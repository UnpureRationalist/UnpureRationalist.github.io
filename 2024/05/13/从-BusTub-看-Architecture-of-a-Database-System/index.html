

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/back.jpg">
  <link rel="icon" href="/img/back.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="arcsin2">
  <meta name="keywords" content="">
  
    <meta name="description" content="CMU 15-445&#x2F;645 课程对应的项目 BusTub 以及数据库领域的经典综述论文 Architecture of a Database System 都可以说是入门数据库的必备材料。BusTub 通过几个 Project，让我们对数据库的缓冲区管理、索引、执行引擎、事务控制等关键模块有相对深入的了解；Architecture of a Database System 则介绍了数据">
<meta property="og:type" content="article">
<meta property="og:title" content="从 BusTub 看 Architecture of a Database System">
<meta property="og:url" content="https://arcsin2.cloud/2024/05/13/%E4%BB%8E-BusTub-%E7%9C%8B-Architecture-of-a-Database-System/index.html">
<meta property="og:site_name" content="arcsin2 的个人博客">
<meta property="og:description" content="CMU 15-445&#x2F;645 课程对应的项目 BusTub 以及数据库领域的经典综述论文 Architecture of a Database System 都可以说是入门数据库的必备材料。BusTub 通过几个 Project，让我们对数据库的缓冲区管理、索引、执行引擎、事务控制等关键模块有相对深入的了解；Architecture of a Database System 则介绍了数据">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://arcsin2.cloud/2024/05/13/%E4%BB%8E-BusTub-%E7%9C%8B-Architecture-of-a-Database-System/image-20240513155926008.png">
<meta property="og:image" content="https://arcsin2.cloud/2024/05/13/%E4%BB%8E-BusTub-%E7%9C%8B-Architecture-of-a-Database-System/image-20240513161300913.png">
<meta property="og:image" content="https://arcsin2.cloud/2024/05/13/%E4%BB%8E-BusTub-%E7%9C%8B-Architecture-of-a-Database-System/image-20240513161614393.png">
<meta property="og:image" content="https://arcsin2.cloud/2024/05/13/%E4%BB%8E-BusTub-%E7%9C%8B-Architecture-of-a-Database-System/image-20240513161833172.png">
<meta property="og:image" content="https://arcsin2.cloud/2024/05/13/%E4%BB%8E-BusTub-%E7%9C%8B-Architecture-of-a-Database-System/image-20240513235256924.png">
<meta property="article:published_time" content="2024-05-13T06:39:37.000Z">
<meta property="article:modified_time" content="2024-05-13T15:56:44.371Z">
<meta property="article:author" content="arcsin2">
<meta property="article:tag" content="bustub">
<meta property="article:tag" content="DBMS">
<meta property="article:tag" content="CMU 15-445&#x2F;645">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://arcsin2.cloud/2024/05/13/%E4%BB%8E-BusTub-%E7%9C%8B-Architecture-of-a-Database-System/image-20240513155926008.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>从 BusTub 看 Architecture of a Database System - arcsin2 的个人博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"arcsin2.cloud","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>arcsin2&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/en/">
                <i class="iconfont icon-icon_English"></i>
                <span>English</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="从 BusTub 看 Architecture of a Database System"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-05-13 14:39" pubdate>
          2024年5月13日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          21k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          72 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">从 BusTub 看 Architecture of a Database System</h1>
            
            
              <div class="markdown-body">
                
                <p>CMU 15-445/645 课程对应的项目 <a
target="_blank" rel="noopener" href="https://github.com/cmu-db/bustub">BusTub</a>
以及数据库领域的经典综述论文 <a
target="_blank" rel="noopener" href="https://www.nowpublishers.com/article/DownloadSummary/DBS-002">Architecture
of a Database System</a> 都可以说是入门数据库的必备材料。BusTub 通过几个
Project，让我们对数据库的缓冲区管理、索引、执行引擎、事务控制等关键模块有相对深入的了解；Architecture
of a Database System
则介绍了数据库系统的整体架构，让我们对数据库系统的每个关键模块都建立概念。BusTub
作为教育目的的数据库，其代码量不大，非常适合结合论文 Architecture of a
Database System 阅读，了解真正的数据库系统是如何设计与组织代码的。本文以
BusTub 作为案例，结合 Architecture of a Database System
一文，看一看真实的数据库是如何组织和实现数据库系统的主要模块的。</p>
<p>下面，我们按 Architecture of a Database System
的章节顺序，依次进行介绍。</p>
<h2 id="introduction">1. Introduction</h2>
<p>本节是论文的引言部分，是全文的总结。这一节中比较关键的点就是了解 DBMS
的主要组件：</p>
<img src="/2024/05/13/%E4%BB%8E-BusTub-%E7%9C%8B-Architecture-of-a-Database-System/image-20240513155926008.png" srcset="/img/loading.gif" lazyload class="" title="image-20240513155926008">
<p>这张图片总结了主流 DBMS
中经常会出现的组件，也指导着我们进行数据库系统的设计与实现。</p>
<p>以 BusTub 为例，进入其 <code>src</code> 源码目录，使用
<code>tree -d</code> 命令，即可查看所有代码子目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree -d</span><br>.<br>├── binder<br>│   └── statement<br>├── buffer<br>├── catalog<br>├── common<br>│   └── util<br>├── concurrency<br>├── container<br>│   ├── disk<br>│   │   └── hash<br>│   └── hash<br>├── execution<br>├── include<br>│   ├── binder<br>│   │   ├── expressions<br>│   │   ├── statement<br>│   │   └── table_ref<br>│   ├── buffer<br>│   ├── catalog<br>│   ├── common<br>│   │   ├── enums<br>│   │   └── util<br>│   ├── concurrency<br>│   ├── container<br>│   │   ├── disk<br>│   │   │   └── hash<br>│   │   └── hash<br>│   ├── execution<br>│   │   ├── executors<br>│   │   ├── expressions<br>│   │   └── plans<br>│   ├── optimizer<br>│   ├── planner<br>│   ├── primer<br>│   ├── recovery<br>│   ├── storage<br>│   │   ├── disk<br>│   │   ├── index<br>│   │   ├── page<br>│   │   └── table<br>│   └── type<br>├── optimizer<br>├── planner<br>├── primer<br>├── recovery<br>├── storage<br>│   ├── disk<br>│   ├── index<br>│   ├── page<br>│   └── table<br>└── type<br><br>51 directories<br></code></pre></td></tr></table></figure>
<p>可以看到 BusTub
的代码组织非常清晰，每个目录的含义基本上一目了然：</p>
<ul>
<li><code>binder</code>：将 PostgreSQL 语法树转换为 BusTub
内部数据结构；</li>
<li><code>buffer</code>：缓冲区管理；</li>
<li><code>catalog</code>：元数据管理；</li>
<li><code>common</code>：一些工具函数，以及组装 BusTub 数据库实例；</li>
<li><code>concurrency</code>：并发控制模块；</li>
<li><code>container</code>：容器，主要是面向内存或磁盘的哈希表；</li>
<li><code>execution</code>：执行引擎，实现各种算子；</li>
<li><code>include</code>：头文件；</li>
<li><code>optimizer</code>：查询优化器模块；</li>
<li><code>planner</code>：把 <code>binder</code>
模块生成的数据结构转换为 BusTub 内部执行计划；</li>
<li><code>recovery</code>：恢复系统，主要用于实现 undo redo log；</li>
<li><code>storage</code>：存储模块，主要实现数据库页面、表、索引等数据结构；</li>
<li><code>type</code>：实现 BusTub 支持的数据类型，如 <code>int</code>
、<code>char</code> 等，以及相关的加减法、比较等运算。</li>
</ul>
<p>根据这些源码组织，我们可以直观的感受 DBMS 的主要组件。</p>
<h2 id="process-models">2. Process Models</h2>
<p>Process Models，或者叫处理模型，是真实 DBMS
中非常重要的部分。因为现代 CPU 是多核的，DBMS
作为重要的系统软件必须能够利用多核 CPU 的能力。</p>
<p>对 Linux 服务端编程稍有了解的同学都知道，服务端程序高效利用多核 CPU
无非两种模式：</p>
<ul>
<li>多进程</li>
<li>多线程</li>
</ul>
<p>具体到 DBMS 也是类似的，有以下三种细分的 process model：</p>
<ul>
<li><p>Process per DBMS Worker：即多进程模型，典型 DBMS
有：PostgreSQL。示意图如下：</p>
<img src="/2024/05/13/%E4%BB%8E-BusTub-%E7%9C%8B-Architecture-of-a-Database-System/image-20240513161300913.png" srcset="/img/loading.gif" lazyload class="" title="image-20240513161300913">
<p>这种模型需要大量使用共享内存等进程间通信技术。由于早期 OS
对线程支持不好，得到了很多早期系统的采用。</p></li>
<li><p>Thread per DBMS Worker：即多线程模型，典型 DBMS 有
MySQL。示意图如下：</p>
<img src="/2024/05/13/%E4%BB%8E-BusTub-%E7%9C%8B-Architecture-of-a-Database-System/image-20240513161614393.png" srcset="/img/loading.gif" lazyload class="" title="image-20240513161614393">
<p>这一模型主要确定是多线程技术本身带来的数据竞争、编码和 debug
难度等。</p></li>
<li><p>Process Pool：即进程池，示意图如下：</p>
<img src="/2024/05/13/%E4%BB%8E-BusTub-%E7%9C%8B-Architecture-of-a-Database-System/image-20240513161833172.png" srcset="/img/loading.gif" lazyload class="" title="image-20240513161833172">
<p>这一模型是多进程的改进。通过池化思想，防止消耗系统大量资源，同时资源预先申请并动态缩扩，提升系统整体性能。</p></li>
<li><p>类似进程池，自然也有线程池这一模型。尽管现代服务器程序使用线程池模型的也很多，但是原论文并未单独介绍这一模式。</p></li>
</ul>
<p>BusTub 源码中似乎并不能看出其使用了哪种 process model。但是在
Project4 的并发控制项目中，性能测试使用的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 省略部分代码...</span><br>  <span class="hljs-keyword">auto</span> bustub = std::<span class="hljs-built_in">make_unique</span>&lt;bustub::BustubInstance&gt;();<br>  <span class="hljs-keyword">auto</span> writer = bustub::<span class="hljs-built_in">SimpleStreamWriter</span>(std::cerr);<br><br>  <span class="hljs-comment">// create schema</span><br>  <span class="hljs-keyword">auto</span> schema = <span class="hljs-string">&quot;CREATE TABLE nft(id int, terrier int);&quot;</span>;<br>  std::cerr &lt;&lt; <span class="hljs-string">&quot;x: create schema&quot;</span> &lt;&lt; std::endl;<br>  bustub-&gt;<span class="hljs-built_in">ExecuteSql</span>(schema, writer);<br><span class="hljs-comment">// 省略部分代码...</span><br>  std::vector&lt;std::thread&gt; threads;<br>  TerrierTotalMetrics total_metrics;<br><br>  total_metrics.<span class="hljs-built_in">Begin</span>();<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> thread_id = <span class="hljs-number">0</span>; thread_id &lt; BUSTUB_TERRIER_THREAD; thread_id++) &#123;<br>    threads.<span class="hljs-built_in">emplace_back</span>(std::<span class="hljs-built_in">thread</span>([thread_id, &amp;bustub, enable_update, duration_ms, &amp;total_metrics] &#123;<br>      <span class="hljs-comment">// lambda 表达式函数体 省略</span><br>    &#125;));<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>可以看出，在进行性能测试时，BusTub 采用的是多线程模型。</p>
<h2 id="parallel-architecture-processes-and-memory-coordination">3.
Parallel Architecture: Processes and Memory Coordination</h2>
<p>本节讨论的是 DBMS 利用现代化并行硬件的主要范式和最佳实践。</p>
<p>主要范式有：</p>
<ul>
<li>Shared Memory：可以理解为现代单机多核 CPU 服务器，即：多个 CPU
核心，甚至多个 CPU，共享内存和磁盘。</li>
<li>Shared-Nothing：可以理解为分布式系统，即：每台机器都有自己的
CPU、内存和磁盘，通过网络构成分布式 DBMS。</li>
<li>Shared-Disk：磁盘共享，CPU 和
内存私有，相当于多台机器共享底层的分布式文件系统，构成一个 DBMS。</li>
<li>NUMA：多个内存，CPU 访问不同地址的内存延迟不同。</li>
</ul>
<p>BusTub
在这方面无特殊设计与实现，且这个主题本身涉及的知识比较专业，本文不做讨论。</p>
<h2 id="relational-query-processor">4. Relational Query Processor</h2>
<p>本节是关系查询处理器，如原文所述：</p>
<blockquote>
<p>The previous sections stressed the macro-architectural design issues
in a DBMS. We now begin a sequence of sections discussing design at a
somewhat ﬁner grain, addressing each of the main DBMS components in
turn.</p>
</blockquote>
<p>前面的章节强调的是 DBMS
的宏观架构设计，而接下来的关注点将更加细粒度，依次研究 DBMS
的主要组件。</p>
<h3 id="query-parsing-and-authorization">4.1 Query Parsing and
Authorization</h3>
<p>SQL 解析器的主要功能如下：</p>
<blockquote>
<p>Given an SQL statement, the main tasks for the SQL Parser are to</p>
<ol type="1">
<li><p>check that the query is correctly speciﬁed,</p></li>
<li><p>resolve names and references,</p></li>
<li><p>convert the query into the internal format used by the optimizer,
and</p></li>
<li><p>verify that the user is authorized to execute the query.</p></li>
</ol>
</blockquote>
<p>即：</p>
<ol type="1">
<li>验证 SQL 语句是否符合语法规范；</li>
<li>解析名字与引用，将名字转换为数据库内部的表、行数据结构；</li>
<li>将语法树转换为内部数据结构，供查询优化器使用；</li>
<li>验证用户是否有权限执行该 SQL 语句。</li>
</ol>
<p>这一步的一般流程是：</p>
<ol type="1">
<li>从 <code>FROM</code> 子句中解析出表名；</li>
<li>调用元数据管理器 <code>Catalog Manager</code>
判断表是否存在系统中，并使用 <code>catalog</code>
保证引用的列名都是正确的；</li>
<li>验证用户是否有执行当前 SQL 语句的权限。</li>
</ol>
<p>在 BusTub 中，不存在授权问题，不予讨论。Query Parsing
主要由两个部分完成：</p>
<ul>
<li><p>BusTub 依赖的第三方库 <code>libpg_query</code>：来源于 DuckDB 的
SQL 语法解析模块，采用与 PostgreSQL 基本相同的语法规则。</p>
<p>进入 <code>third_party/libpg_query</code> 目录，使用
<code>tree -d</code> 命令查看查看代码组织结构：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree -d</span><br>.<br>├── grammar<br>│   ├── keywords<br>│   ├── statements<br>│   └── types<br>└── include<br>    ├── access<br>    ├── catalog<br>    ├── common<br>    ├── datatype<br>    ├── mb<br>    ├── nodes<br>    ├── parser<br>    └── utils<br><br>13 directories<br></code></pre></td></tr></table></figure></li>
<li><p>BusTub 本身的 <code>binder</code> 模块：调用
<code>libpg_query</code> 库提供的接口，将 SQL 语句解析成语法树，并转换为
BusTub 内部的数据结构。</p></li>
</ul>
<p>具体的，以 Project 4 性能测试代码执行流程来追踪这一调用流程。</p>
<ol type="1">
<li><p><code>tools/terrier_bench/terrier.cpp</code>：构造数据库实例，执行
SQL：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (enable_update) &#123;<br>  <span class="hljs-keyword">auto</span> txn = bustub-&gt;txn_manager_-&gt;<span class="hljs-built_in">Begin</span>(<span class="hljs-literal">nullptr</span>, bustub::IsolationLevel::REPEATABLE_READ);<br>  std::string query = fmt::format(<span class="hljs-string">&quot;UPDATE nft SET terrier = &#123;&#125; WHERE id = &#123;&#125;&quot;</span>, terrier_id, nft_id);<br>  <span class="hljs-comment">//   std::cout &lt;&lt; &quot;Update:&quot; &lt;&lt; query &lt;&lt; std::endl;</span><br>  <span class="hljs-keyword">if</span> (!bustub-&gt;<span class="hljs-built_in">ExecuteSqlTxn</span>(query, writer, txn)) &#123;<br>    txn_success = <span class="hljs-literal">false</span>;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>关键是上面的
<code>bustub-&gt;ExecuteSqlTxn(query, writer, txn)</code>
函数调用。</p></li>
<li><p><code>src/common/bustub_instance.cpp</code>：调用
<code>Binder</code> 类提供的函数，解析 SQL 为内部数据结构，并执行
SQL：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> is_successful = <span class="hljs-literal">true</span>;<br>   <br><span class="hljs-function">std::shared_lock&lt;std::shared_mutex&gt; <span class="hljs-title">l</span><span class="hljs-params">(catalog_lock_)</span></span>;<br><span class="hljs-function">bustub::Binder <span class="hljs-title">binder</span><span class="hljs-params">(*catalog_)</span></span>;<br>binder.<span class="hljs-built_in">ParseAndSave</span>(sql);<br>l.<span class="hljs-built_in">unlock</span>();<br>   <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> *stmt : binder.statement_nodes_) &#123;<br>  <span class="hljs-keyword">auto</span> statement = binder.<span class="hljs-built_in">BindStatement</span>(stmt); <span class="hljs-comment">// 转换为内部数据结构</span><br>  <span class="hljs-comment">// 根据 SQL 类型（Create table、index；Insert；Select 等调用对应的函数）</span><br>  <span class="hljs-comment">// 省略部分代码...  </span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面的关键是 <code>bustub::Binder binder(*catalog_)</code> 构造
<code>Binder</code> 对象，以及调用 <code>binder.ParseAndSave(sql)</code>
和
<code>auto statement = binder.BindStatement(stmt)</code>将字符串类型的
SQL 解析为 BusTub 的内部数据结构。</p></li>
<li><p><code>src/binder/binder.cpp</code>：<code>Binder</code>
类的代码逻辑：调用 <code>libpg_query</code> 的接口并转换为语法树：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Binder::ParseAndSave</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;query)</span> </span>&#123;<br>  parser_.<span class="hljs-built_in">Parse</span>(query);<br>  <span class="hljs-keyword">if</span> (!parser_.success) &#123;<br>    <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;Query failed to parse!&quot;</span>);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Exception</span>(fmt::format(<span class="hljs-string">&quot;Query failed to parse: &#123;&#125;&quot;</span>, parser_.error_message));<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (parser_.parse_tree == <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;parser received empty statement&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-built_in">SaveParseTree</span>(parser_.parse_tree);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中的关键是 <code>parser_.Parse(query)</code>。<code>parser_</code>
数据成员的定义是：<code>duckdb::PostgresParser parser_</code>
，可以看出，是调用了 DuckDB 的内部接口。</p></li>
<li><p><code>third_party/libpg_query/postgres_parser.cpp</code>：进入第三方库。这里的主要函数是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PostgresParser::Parse</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;query)</span> </span>&#123;<br>	duckdb_libpgquery::<span class="hljs-built_in">pg_parser_init</span>();<br>	duckdb_libpgquery::parse_result res;<br>	<span class="hljs-built_in">pg_parser_parse</span>(query.<span class="hljs-built_in">c_str</span>(), &amp;res);<br>	success = res.success;<br><br>	<span class="hljs-keyword">if</span> (success) &#123;<br>		parse_tree = res.parse_tree;<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		error_message = <span class="hljs-built_in">string</span>(res.error_message);<br>		error_location = res.error_location;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这是 DuckDB 执行 SQL 解析的接口，传入 SQL
并判断是否合法；若合法，保存语法树。语法分析的细节涉及到编译原理相关知识，本文不详细介绍
SQL 语法解析的流程。</p></li>
<li><p><code>src/binder/transformer.cpp</code>：将 语法解析树转换为
BusTub 内部的 <code>Binder***Statement</code> 数据结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">Binder::BindStatement</span><span class="hljs-params">(duckdb_libpgquery::PGNode *stmt)</span> -&gt; std::unique_ptr&lt;BoundStatement&gt; </span>&#123;<br>  <span class="hljs-keyword">switch</span> (stmt-&gt;type) &#123;<br>    <span class="hljs-keyword">case</span> duckdb_libpgquery::T_PGRawStmt:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">BindStatement</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;duckdb_libpgquery::PGRawStmt *&gt;(stmt)-&gt;stmt);<br>    <span class="hljs-keyword">case</span> duckdb_libpgquery::T_PGCreateStmt:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">BindCreate</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;duckdb_libpgquery::PGCreateStmt *&gt;(stmt));<br>    <span class="hljs-keyword">case</span> duckdb_libpgquery::T_PGInsertStmt:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">BindInsert</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;duckdb_libpgquery::PGInsertStmt *&gt;(stmt));<br>    <span class="hljs-keyword">case</span> duckdb_libpgquery::T_PGSelectStmt:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">BindSelect</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;duckdb_libpgquery::PGSelectStmt *&gt;(stmt));<br>    <span class="hljs-keyword">case</span> duckdb_libpgquery::T_PGExplainStmt:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">BindExplain</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;duckdb_libpgquery::PGExplainStmt *&gt;(stmt));<br>    <span class="hljs-keyword">case</span> duckdb_libpgquery::T_PGDeleteStmt:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">BindDelete</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;duckdb_libpgquery::PGDeleteStmt *&gt;(stmt));<br>    <span class="hljs-keyword">case</span> duckdb_libpgquery::T_PGUpdateStmt:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">BindUpdate</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;duckdb_libpgquery::PGUpdateStmt *&gt;(stmt));<br>    <span class="hljs-keyword">case</span> duckdb_libpgquery::T_PGIndexStmt:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">BindIndex</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;duckdb_libpgquery::PGIndexStmt *&gt;(stmt));<br>    <span class="hljs-keyword">case</span> duckdb_libpgquery::T_PGVariableSetStmt:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">BindVariableSet</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;duckdb_libpgquery::PGVariableSetStmt *&gt;(stmt));<br>    <span class="hljs-keyword">case</span> duckdb_libpgquery::T_PGVariableShowStmt:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">BindVariableShow</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;duckdb_libpgquery::PGVariableShowStmt *&gt;(stmt));<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">NotImplementedException</span>(<span class="hljs-built_in">NodeTagToString</span>(stmt-&gt;type));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里的逻辑就是根据语法树的类型（Create Table、Index、Select
等），构造对应的 BusTub 内部数据结构。</p></li>
<li><p>后续，就进入了具体的不同语法树生成不同内部数据结构的过程，本文不再详细介绍。</p></li>
</ol>
<p>经过上述 <code>binder</code> 模块，BusTub 能够执行涉及元数据的一些
SQL 语句，如：新建表、新建索引、EXPLAIN 命令等，但是还不能执行 SELECT
等类型的 SQL 语句。在 BusTub 中，还需要 <code>planner</code>
模块的继续工作。相关代码如下：</p>
<ol type="1">
<li><p><code>src/common/bustub_instance.cpp</code>：根据
<code>binder</code> 模块返回的数据结构继续调用 <code>planner</code>
模块：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Plan the query.</span><br><span class="hljs-function">bustub::Planner <span class="hljs-title">planner</span><span class="hljs-params">(*catalog_)</span></span>;<br>planner.<span class="hljs-built_in">PlanQuery</span>(*statement);<br>   <br><span class="hljs-comment">// Optimize the query.</span><br><span class="hljs-function">bustub::Optimizer <span class="hljs-title">optimizer</span><span class="hljs-params">(*catalog_, IsForceStarterRule())</span></span>;<br><span class="hljs-keyword">auto</span> optimized_plan = optimizer.<span class="hljs-built_in">Optimize</span>(planner.plan_);<br>   <br>l.<span class="hljs-built_in">unlock</span>();<br>   <br><span class="hljs-comment">// Execute the query.</span><br><span class="hljs-keyword">auto</span> exec_ctx = <span class="hljs-built_in">MakeExecutorContext</span>(txn);<br>std::vector&lt;Tuple&gt; result_set&#123;&#125;;<br>is_successful &amp;= execution_engine_-&gt;<span class="hljs-built_in">Execute</span>(optimized_plan, &amp;result_set, txn, exec_ctx.<span class="hljs-built_in">get</span>());<br></code></pre></td></tr></table></figure></li>
<li><p><code>src/planner/planner.cpp</code>：调用
<code>Planner::PlanQuery</code> 方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Planner::PlanQuery</span><span class="hljs-params">(<span class="hljs-type">const</span> BoundStatement &amp;statement)</span> </span>&#123;<br>  <span class="hljs-keyword">switch</span> (statement.type_) &#123;<br>    <span class="hljs-keyword">case</span> StatementType::SELECT_STATEMENT: &#123;<br>      plan_ = <span class="hljs-built_in">PlanSelect</span>(<span class="hljs-built_in">dynamic_cast</span>&lt;<span class="hljs-type">const</span> SelectStatement &amp;&gt;(statement));<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> StatementType::INSERT_STATEMENT: &#123;<br>      plan_ = <span class="hljs-built_in">PlanInsert</span>(<span class="hljs-built_in">dynamic_cast</span>&lt;<span class="hljs-type">const</span> InsertStatement &amp;&gt;(statement));<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> StatementType::DELETE_STATEMENT: &#123;<br>      plan_ = <span class="hljs-built_in">PlanDelete</span>(<span class="hljs-built_in">dynamic_cast</span>&lt;<span class="hljs-type">const</span> DeleteStatement &amp;&gt;(statement));<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> StatementType::UPDATE_STATEMENT: &#123;<br>      plan_ = <span class="hljs-built_in">PlanUpdate</span>(<span class="hljs-built_in">dynamic_cast</span>&lt;<span class="hljs-type">const</span> UpdateStatement &amp;&gt;(statement));<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Exception</span>(fmt::format(<span class="hljs-string">&quot;the statement &#123;&#125; is not supported in planner yet&quot;</span>, statement.type_));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上述代码中，根据 SQL 语句的不同类型，构造不同的执行
Plan，如：<code>PlanSelect</code> 、<code>PlanInsert</code>
等。</p></li>
<li><p><code>src/planner/plan_insert.cpp</code>：以比较简单的
<code>InsertPlan</code> 为例，查看其构造流程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">Planner::PlanInsert</span><span class="hljs-params">(<span class="hljs-type">const</span> InsertStatement &amp;statement)</span> -&gt; AbstractPlanNodeRef </span>&#123;<br>  <span class="hljs-keyword">auto</span> select = <span class="hljs-built_in">PlanSelect</span>(*statement.select_);<br><br>  <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;table_schema = statement.table_-&gt;schema_.<span class="hljs-built_in">GetColumns</span>();<br>  <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;child_schema = select-&gt;<span class="hljs-built_in">OutputSchema</span>().<span class="hljs-built_in">GetColumns</span>();<br>  <span class="hljs-keyword">if</span> (!std::<span class="hljs-built_in">equal</span>(table_schema.<span class="hljs-built_in">cbegin</span>(), table_schema.<span class="hljs-built_in">cend</span>(), child_schema.<span class="hljs-built_in">cbegin</span>(), child_schema.<span class="hljs-built_in">cend</span>(),<br>                  [](<span class="hljs-keyword">auto</span> &amp;&amp;col1, <span class="hljs-keyword">auto</span> &amp;&amp;col2) &#123; <span class="hljs-keyword">return</span> col1.<span class="hljs-built_in">GetType</span>() == col2.<span class="hljs-built_in">GetType</span>(); &#125;)) &#123;<br>    <span class="hljs-keyword">throw</span> bustub::<span class="hljs-built_in">Exception</span>(<span class="hljs-string">&quot;table schema mismatch&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">auto</span> insert_schema = std::<span class="hljs-built_in">make_shared</span>&lt;Schema&gt;(std::vector&#123;<span class="hljs-built_in">Column</span>(<span class="hljs-string">&quot;__bustub_internal.insert_rows&quot;</span>, TypeId::INTEGER)&#125;);<br><br>  <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_shared</span>&lt;InsertPlanNode&gt;(std::<span class="hljs-built_in">move</span>(insert_schema), std::<span class="hljs-built_in">move</span>(select), statement.table_-&gt;oid_);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<p>至此，BusTub 中 SQL 解析相关模块主要代码介绍完毕。</p>
<h3 id="query-rewrite">4.2 Query Rewrite</h3>
<p>查询重写的原文定义如下：</p>
<blockquote>
<p>The query rewrite module, or rewriter, is responsible for simplifying
and normalizing the query without changing its semantics. It can rely
only on the query and on metadata in the catalog, and cannot access data
in the tables.</p>
</blockquote>
<p>可见，查询重写主要做两件事：</p>
<ul>
<li>简化查询</li>
<li>规范化查询</li>
</ul>
<p>当前，前提是不改变查询语义，且仅依赖于 catalog 中的元数据。</p>
<p>在很多 DBMS
中，查询重写并没有作为单独的模块实现，而是在语法解析或者查询优化中作为一个步骤实现。BusTub
也是类似的思路，其源码中并没有单独实现查询重写。</p>
<p>查询重写主要负责以下任务：</p>
<ul>
<li>视图展开</li>
<li>常量数学表达式计算</li>
<li>谓词的逻辑重写</li>
<li>语义优化</li>
<li>子查询展开和其他启发式重写</li>
</ul>
<p>这些任务很大部分与查询优化重叠，这里不详细介绍。感兴趣可阅读原论文或者查询优化相关论文。</p>
<h3 id="query-optimizer">4.3 Query Optimizer</h3>
<p>查询优化器可以说是 DBMS 中最关键的组件之一，也是公认的 DBMS
中最困难、最有挑战性的部分。</p>
<p>原论文中，本小节主要总结了目前的查询优化相关工作对 System R
的经典论文做了哪些方面的改进，而不涉及具体的优化算法，因此本文也不详细介绍。</p>
<p>BusTub
中有单独的优化器模块进行查询优化，实现了一些基于规则的查询优化策略：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree optimizer</span><br>optimizer<br>├── CMakeLists.txt<br>├── eliminate_true_filter.cpp<br>├── merge_filter_nlj.cpp<br>├── merge_filter_scan.cpp<br>├── merge_projection.cpp<br>├── nlj_as_hash_join.cpp<br>├── nlj_as_index_join.cpp<br>├── optimizer.cpp<br>├── optimizer_custom_rules.cpp<br>├── order_by_index_scan.cpp<br>└── sort_limit_as_topn.cpp<br><br>0 directories, 11 files<br></code></pre></td></tr></table></figure>
<h3 id="query-executor">4.4 Query Executor</h3>
<p>执行引擎在上述 SQL
解析、查询计划生成、查询优化的基础上，根据优化后的查询计划，执行真正的查询。</p>
<p>大多数执行引擎采用火山模型，或者称之为：迭代器模型。每个执行算子拥有类似的接口，以
BusTub 为例，其虚基类定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The AbstractExecutor implements the Volcano tuple-at-a-time iterator model.</span><br><span class="hljs-comment"> * This is the base class from which all executors in the BustTub execution</span><br><span class="hljs-comment"> * engine inherit, and defines the minimal interface that all executors support.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractExecutor</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Construct a new AbstractExecutor instance.</span><br><span class="hljs-comment">   * @param exec_ctx the executor context that the executor runs with</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">AbstractExecutor</span><span class="hljs-params">(ExecutorContext *exec_ctx)</span> : exec_ctx_&#123;</span>exec_ctx&#125; &#123;&#125;<br><br>  <span class="hljs-comment">/** Virtual destructor. */</span><br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">AbstractExecutor</span>() = <span class="hljs-keyword">default</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Initialize the executor.</span><br><span class="hljs-comment">   * @warning This function must be called before Next() is called!</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Yield the next tuple from this executor.</span><br><span class="hljs-comment">   * @param[out] tuple The next tuple produced by this executor</span><br><span class="hljs-comment">   * @param[out] rid The next tuple RID produced by this executor</span><br><span class="hljs-comment">   * @return `true` if a tuple was produced, `false` if there are no more tuples</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">Next</span><span class="hljs-params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="hljs-type">bool</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">/** @return The schema of the tuples that this executor produces */</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">GetOutputSchema</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> -&gt; <span class="hljs-type">const</span> Schema &amp; </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">/** @return The executor context in which this executor runs */</span><br>  <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">GetExecutorContext</span><span class="hljs-params">()</span> -&gt; ExecutorContext * </span>&#123; <span class="hljs-keyword">return</span> exec_ctx_; &#125;<br><br> <span class="hljs-keyword">protected</span>:<br>  <span class="hljs-comment">/** The executor context in which the executor runs */</span><br>  ExecutorContext *exec_ctx_;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>其中，与迭代器模型最相关的就是：<code>Init</code> 方法和
<code>Next</code> 方法。</p>
<p>在 CMU 15-445/645 课程的 Project 3
中，通过实现基本执行算子，我们对迭代器模型会有比较深入的了解。在 BusTub
执行 SQL 语句的过程中，还有一些点需要关注：</p>
<ol type="1">
<li><p><code>src/common/bustub_instance.cpp</code>：执行 SQL 语句</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Execute the query.</span><br><span class="hljs-keyword">auto</span> exec_ctx = <span class="hljs-built_in">MakeExecutorContext</span>(txn);<br>std::vector&lt;Tuple&gt; result_set&#123;&#125;;<br>is_successful &amp;= execution_engine_-&gt;<span class="hljs-built_in">Execute</span>(optimized_plan, &amp;result_set, txn, exec_ctx.<span class="hljs-built_in">get</span>());<br></code></pre></td></tr></table></figure>
<p>其中，<code>ececution_engine_</code> 是 <code>ExecutionEngine</code>
类型的对象，其中封装了迭代器模型实现的算子，作为执行引擎。</p></li>
<li><p><code>src/include/execution/execution_engine.h</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Execute a query plan.</span><br><span class="hljs-comment">   * @param plan The query plan to execute</span><br><span class="hljs-comment">   * @param result_set The set of tuples produced by executing the plan</span><br><span class="hljs-comment">   * @param txn The transaction context in which the query executes</span><br><span class="hljs-comment">   * @param exec_ctx The executor context in which the query executes</span><br><span class="hljs-comment">   * @return `true` if execution of the query plan succeeds, `false` otherwise</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-comment">// NOLINTNEXTLINE</span><br>  <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">Execute</span><span class="hljs-params">(<span class="hljs-type">const</span> AbstractPlanNodeRef &amp;plan, std::vector&lt;Tuple&gt; *result_set, Transaction *txn,</span></span><br><span class="hljs-params"><span class="hljs-function">               ExecutorContext *exec_ctx)</span> -&gt; <span class="hljs-type">bool</span> </span>&#123;<br>    <span class="hljs-built_in">BUSTUB_ASSERT</span>((txn == exec_ctx-&gt;<span class="hljs-built_in">GetTransaction</span>()), <span class="hljs-string">&quot;Broken Invariant&quot;</span>);<br><br>    <span class="hljs-comment">// Construct the executor for the abstract plan node</span><br>    <span class="hljs-keyword">auto</span> executor = ExecutorFactory::<span class="hljs-built_in">CreateExecutor</span>(exec_ctx, plan);<br><br>    <span class="hljs-comment">// Initialize the executor</span><br>    <span class="hljs-keyword">auto</span> executor_succeeded = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>      executor-&gt;<span class="hljs-built_in">Init</span>();<br>      <span class="hljs-built_in">PollExecutor</span>(executor.<span class="hljs-built_in">get</span>(), plan, result_set);<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> ExecutionException &amp;ex) &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> NDEBUG</span><br>      <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;Error Encountered in Executor Execution: %s&quot;</span>, ex.<span class="hljs-built_in">what</span>());<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>      executor_succeeded = <span class="hljs-literal">false</span>;<br>      <span class="hljs-keyword">if</span> (result_set != <span class="hljs-literal">nullptr</span>) &#123;<br>        result_set-&gt;<span class="hljs-built_in">clear</span>();<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> executor_succeeded;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>根据执行计划，真正进行 SQL
语句执行的接口。其函数体内部首先根据执行计划，调用工厂函数
<code>ExecutorFactory::CreateExecutor(exec_ctx, plan)</code>
构造执行算子。</p></li>
<li><p><code>src/execution/executor_factory.cpp</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">ExecutorFactory::CreateExecutor</span><span class="hljs-params">(ExecutorContext *exec_ctx, <span class="hljs-type">const</span> AbstractPlanNodeRef &amp;plan)</span></span><br><span class="hljs-function">    -&gt; std::unique_ptr&lt;AbstractExecutor&gt; </span>&#123;<br>  <span class="hljs-keyword">switch</span> (plan-&gt;<span class="hljs-built_in">GetType</span>()) &#123;<br>    <span class="hljs-comment">// Create a new sequential scan executor</span><br>    <span class="hljs-keyword">case</span> PlanType::SeqScan: &#123;<br>      <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;SeqScanExecutor&gt;(exec_ctx, <span class="hljs-built_in">dynamic_cast</span>&lt;<span class="hljs-type">const</span> SeqScanPlanNode *&gt;(plan.<span class="hljs-built_in">get</span>()));<br>    &#125;<br><br>    <span class="hljs-comment">// Create a new index scan executor</span><br>    <span class="hljs-keyword">case</span> PlanType::IndexScan: &#123;<br>      <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;IndexScanExecutor&gt;(exec_ctx, <span class="hljs-built_in">dynamic_cast</span>&lt;<span class="hljs-type">const</span> IndexScanPlanNode *&gt;(plan.<span class="hljs-built_in">get</span>()));<br>    &#125;<br><br>    <span class="hljs-comment">// Create a new insert executor</span><br>    <span class="hljs-keyword">case</span> PlanType::Insert: &#123;<br>      <span class="hljs-keyword">auto</span> insert_plan = <span class="hljs-built_in">dynamic_cast</span>&lt;<span class="hljs-type">const</span> InsertPlanNode *&gt;(plan.<span class="hljs-built_in">get</span>());<br>      <span class="hljs-keyword">auto</span> child_executor = ExecutorFactory::<span class="hljs-built_in">CreateExecutor</span>(exec_ctx, insert_plan-&gt;<span class="hljs-built_in">GetChildPlan</span>());<br>      <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;InsertExecutor&gt;(exec_ctx, insert_plan, std::<span class="hljs-built_in">move</span>(child_executor));<br>    &#125;<br><br>    <span class="hljs-comment">// Create a new update executor</span><br>    <span class="hljs-keyword">case</span> PlanType::Update: &#123;<br>      <span class="hljs-keyword">auto</span> update_plan = <span class="hljs-built_in">dynamic_cast</span>&lt;<span class="hljs-type">const</span> UpdatePlanNode *&gt;(plan.<span class="hljs-built_in">get</span>());<br>      <span class="hljs-keyword">auto</span> child_executor = ExecutorFactory::<span class="hljs-built_in">CreateExecutor</span>(exec_ctx, update_plan-&gt;<span class="hljs-built_in">GetChildPlan</span>());<br>      <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;UpdateExecutor&gt;(exec_ctx, update_plan, std::<span class="hljs-built_in">move</span>(child_executor));<br>    &#125;<br><br>    <span class="hljs-comment">// Create a new delete executor</span><br>    <span class="hljs-keyword">case</span> PlanType::Delete: &#123;<br>      <span class="hljs-keyword">auto</span> delete_plan = <span class="hljs-built_in">dynamic_cast</span>&lt;<span class="hljs-type">const</span> DeletePlanNode *&gt;(plan.<span class="hljs-built_in">get</span>());<br>      <span class="hljs-keyword">auto</span> child_executor = ExecutorFactory::<span class="hljs-built_in">CreateExecutor</span>(exec_ctx, delete_plan-&gt;<span class="hljs-built_in">GetChildPlan</span>());<br>      <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;DeleteExecutor&gt;(exec_ctx, delete_plan, std::<span class="hljs-built_in">move</span>(child_executor));<br>    &#125;<br><br>    <span class="hljs-comment">// 省略部分代码...</span><br><br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-built_in">UNREACHABLE</span>(<span class="hljs-string">&quot;Unsupported plan type.&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>工厂函数。根据执行计划的类型，递归构造不同的执行算子。</p></li>
<li><p><code>src/include/execution/execution_engine.h</code>：构造生成执行算子后，进行
<code>poll</code> 操作，拉取结果元组：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Poll the executor until exhausted, or exception escapes.</span><br><span class="hljs-comment"> * @param executor The root executor</span><br><span class="hljs-comment"> * @param plan The plan to execute</span><br><span class="hljs-comment"> * @param result_set The tuple result set</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">PollExecutor</span><span class="hljs-params">(AbstractExecutor *executor, <span class="hljs-type">const</span> AbstractPlanNodeRef &amp;plan,</span></span><br><span class="hljs-params"><span class="hljs-function">                         std::vector&lt;Tuple&gt; *result_set)</span> </span>&#123;<br>  RID rid&#123;&#125;;<br>  Tuple tuple&#123;&#125;;<br>  <span class="hljs-keyword">while</span> (executor-&gt;<span class="hljs-built_in">Next</span>(&amp;tuple, &amp;rid)) &#123;<br>    <span class="hljs-keyword">if</span> (result_set != <span class="hljs-literal">nullptr</span>) &#123;<br>      result_set-&gt;<span class="hljs-built_in">push_back</span>(tuple);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="storage-management">5. Storage Management</h2>
<p>DBMS 管理磁盘空间有两种基本方式：</p>
<ul>
<li>DBMS
直接与磁盘的低级块模式设备驱动程序交互(通常称为原始模式访问)：早期系统采用的方式，现在很少使用。</li>
<li>使用操作系统标准文件操作接口：DBMS 创建一个文件，使用
<code>offset</code>
定位数据。文件被视为驻留在磁盘上的页面的线性数组。</li>
</ul>
<p>BusTub
中，磁盘管理采用了后一种方式。其提供的主要接口就是读写页面，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * DiskManager takes care of the allocation and deallocation of pages within a database. It performs the reading and</span><br><span class="hljs-comment"> * writing of pages to and from disk, providing a logical file layer within the context of a database management system.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DiskManager</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Creates a new disk manager that writes to the specified database file.</span><br><span class="hljs-comment">   * @param db_file the file name of the database file to write to</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">DiskManager</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;db_file)</span></span>;<br><br>  <span class="hljs-comment">/** FOR TEST / LEADERBOARD ONLY, used by DiskManagerMemory */</span><br>  <span class="hljs-built_in">DiskManager</span>() = <span class="hljs-keyword">default</span>;<br><br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">DiskManager</span>() = <span class="hljs-keyword">default</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Shut down the disk manager and close all the file resources.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShutDown</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Write a page to the database file.</span><br><span class="hljs-comment">   * @param page_id id of the page</span><br><span class="hljs-comment">   * @param page_data raw page data</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">WritePage</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> page_id, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *page_data)</span></span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Read a page from the database file.</span><br><span class="hljs-comment">   * @param page_id id of the page</span><br><span class="hljs-comment">   * @param[out] page_data output buffer</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ReadPage</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> page_id, <span class="hljs-type">char</span> *page_data)</span></span>;<br><br>  <span class="hljs-comment">// 删除部分代码...</span><br><br> <span class="hljs-keyword">protected</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">GetFileSize</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;file_name)</span> -&gt; <span class="hljs-type">int</span></span>;<br>  <span class="hljs-comment">// stream to write log file</span><br>  std::fstream log_io_;<br>  std::string log_name_;<br>  <span class="hljs-comment">// stream to write db file</span><br>  std::fstream db_io_;<br>  std::string file_name_;<br>  <span class="hljs-type">int</span> num_flushes_&#123;<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-type">int</span> num_writes_&#123;<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-type">bool</span> flush_log_&#123;<span class="hljs-literal">false</span>&#125;;<br>  std::future&lt;<span class="hljs-type">void</span>&gt; *flush_log_f_&#123;<span class="hljs-literal">nullptr</span>&#125;;<br>  <span class="hljs-comment">// With multiple buffer pool instances, need to protect file access</span><br>  std::mutex db_io_latch_;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>由于磁盘相比内存有限的读写速度，buffer pool 提供了内存缓冲，作为 DBMS
与磁盘交互的中间人。缓冲池被组织成一个
<strong>帧数组</strong>，其中每个帧是一个数据库磁盘块大小的内存区域。缓冲池的一个重要数据结构是哈希表，用于将
page_id 映射到 frame_id。buffer pool manager 是 Project 1
的内容，相关代码目录如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree buffer include/buffer container/hash</span><br>buffer<br>├── CMakeLists.txt<br>├── buffer_pool_manager_instance.cpp<br>├── clock_replacer.cpp<br>├── lru_k_replacer.cpp<br>└── lru_replacer.cpp<br>include/buffer<br>├── buffer_pool_manager.h<br>├── buffer_pool_manager_instance.h<br>├── clock_replacer.h<br>├── lru_k_replacer.h<br>├── lru_replacer.h<br>└── replacer.h<br>container/hash<br>├── CMakeLists.txt<br>└── extendible_hash_table.cpp<br><br></code></pre></td></tr></table></figure>
<p>可见，BusTub 中将其分为三个部分来实现：</p>
<ul>
<li>可扩展哈希表：用于将 page_id 映射到 frame_id。</li>
<li>页面替换策略：源码中包括LRU、 LRU-K、CLOCK 等页面替换算法。</li>
<li>buffer pool
manager：组装哈希表、替换策略等数据结构，构成缓冲区管理器。</li>
</ul>
<p>由于这一部分是 Project 1 内容，具体代码这里不介绍。</p>
<h2 id="transactions-concurrency-control-and-recovery">6. Transactions:
Concurrency Control and Recovery</h2>
<p>设计良好的数据库系统能够划分为不同的组件，由不同团队分别进行开发维护，并以文档化的接口交流。但是，数据库管理系统中的事务存储管理器往往作为一个较难划分的整体，它通常包含四个相互交织的组件：</p>
<ul>
<li>用于并发控制的锁管理器</li>
<li>用于恢复的日志管理器</li>
<li>用于暂存数据库 I/O 的缓冲池</li>
<li>在磁盘上组织数据的访问方法</li>
</ul>
<p>这些组件对事务的 ACID 特性提供了不同保证：</p>
<blockquote>
<p>Roughly speaking, modern DBMSs implement isolation via a locking
protocol. Durability is typically implemented via logging and recovery.
Isolation and Atomicity are guaranteed by a combination of locking (to
prevent visibility of transient database states), and logging (to ensure
correctness of data that is visible). Consistency is managed by runtime
checks in the query executor: if a transaction’s actions will violate a
SQL integrity constraint, the transaction is aborted and an error code
returned.</p>
</blockquote>
<p>BusTub
在不同年份设计了不同的并发控制相关实验，其相关代码目录结构如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree concurrency include/concurrency</span><br>concurrency<br>├── CMakeLists.txt<br>├── lock_manager.cpp<br>└── transaction_manager.cpp<br>include/concurrency<br>├── lock_manager.h<br>├── transaction.h<br>└── transaction_manager.h<br><br>0 directories, 3 files<br></code></pre></td></tr></table></figure>
<p>在 Fall 2022 Project 4 中，需要实现 2PL
算法，以及在物理算子中调用相关接口，实现不同的隔离级别。由于没有将并发控制与恢复系统结合起来，很难通过
BusTub 学习到实现完整的事务支持对数据库系统不同组件会带来什么影响。</p>
<p>当然，这一主题本身很复杂，后续深入学习后，有机会再做分享。</p>
<h2 id="shared-components">7. Shared Components</h2>
<h3 id="catalog-manager">7.1 Catalog Manager</h3>
<p>Catalog Manager 作用如下：</p>
<blockquote>
<p>The database catalog holds information about data in the system and
is a form of metadata. The catalog records the names of basic entities
in the system (users, schemas, tables, columns, indexes, etc.) and their
relationships, and is itself stored as a set of tables in the
database.</p>
</blockquote>
<p>BusTub 中，Catalog Manager 相关代码目录组织如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree catalog include/catalog</span><br>catalog<br>├── CMakeLists.txt<br>├── column.cpp<br>├── schema.cpp<br>└── table_generator.cpp<br>include/catalog<br>├── catalog.h<br>├── column.h<br>├── schema.h<br>└── table_generator.h<br></code></pre></td></tr></table></figure>
<p>在 <code>src/include/catalog/catalog.h</code>
中，相关数据结构和接口如下：</p>
<img src="/2024/05/13/%E4%BB%8E-BusTub-%E7%9C%8B-Architecture-of-a-Database-System/image-20240513235256924.png" srcset="/img/loading.gif" lazyload class="" title="image-20240513235256924">
<p><br></p>
<p>这也是我们进行 Project 3 时必须阅读的代码之一。</p>
<p>其它共享组件还有内存分配器、磁盘管理子系统等，这里不再介绍。</p>
<h2 id="conclusion">8. Conclusion</h2>
<p>最后，贴上原论文的 Conclusion 部分，同时也作为本文的总结。</p>
<blockquote>
<p>As should be clear from this paper, modern commercial database
systems are grounded both in academic research and in the experiences of
developing industrial-strength products for high-end customers. The task
of writing and maintaining a high-performance, fully functional
relational DBMS from scratch is an enormous investment in time and
energy. Many of the lessons of relational DBMSs, however, translate over
to new domains. Web services, network-attached storage, text and e-mail
repositories, notiﬁcation services, and network monitors can all beneﬁt
from DBMS research and experience. Data-intensive services are at the
core of computing today, and knowledge of database system design is a
skill that is broadly applicable, both inside and outside the halls of
the main database shops. These new directions raise a number of research
problems in database management as well, and point the way to new
interactions between the database community and other areas of
computing.</p>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="category-chain-item">数据库</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/bustub/">#bustub</a>
      
        <a href="/tags/DBMS/">#DBMS</a>
      
        <a href="/tags/CMU-15-445-645/">#CMU 15-445/645</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>从 BusTub 看 Architecture of a Database System</div>
      <div>https://arcsin2.cloud/2024/05/13/从-BusTub-看-Architecture-of-a-Database-System/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>arcsin2</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年5月13日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="NC - 非商业性使用">
                    <i class="iconfont icon-nc"></i>
                  </span>
                </a>
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - 相同方式共享">
                    <i class="iconfont icon-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/05/24/%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/" title="重学操作系统：内存虚拟化">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">重学操作系统：内存虚拟化</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/05/08/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E5%AE%9A%E6%97%B6%E5%99%A8/" title="信号与定时器">
                        <span class="hidden-mobile">信号与定时器</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
    <!-- 备案信息 ICP for China -->
    <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      苏ICP备2021026429号-1
    </a>
  </span>
  
</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
