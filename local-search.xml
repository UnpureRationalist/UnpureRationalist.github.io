<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>一文读懂 C++ 运算符重载</title>
    <link href="/2023/02/19/%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82-C-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    <url>/2023/02/19/%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82-C-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<p>运算符重载是 C++语言的一个特性，利用运算符重载能够写出更加简洁的代码，对外封装类的实现细节。本文介绍运算符重载相关知识点。</p><p>谈到运算符重载，还需要从 “<strong>函数重载</strong>”说起。函数重载是指函数名相同，但函数参数类型、参数数量不同（返回类型相同）的函数。比如实现某种数据类型向string 类型运算的函数： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 函数重载示例</span><br><span class="hljs-function">string <span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-type">double</span> d)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-type">float</span> d)</span></span>;<br><span class="hljs-comment">// 等等</span><br></code></pre></td></tr></table></figure> 这就是典型的函数重载。</p><p>运算符重载本质上也是函数重载，它们可以看做函数名为<code>operator+</code>、<code>operator-</code>、<code>operator*</code>、<code>operator++</code>、<code>operator&lt;&lt;</code>等等的函数。重载即体现在函数名相同，但函数参数类型不同。当然，一些运算符也允许参数数量不同的重载，典型的就是函数调用运算符<code>operator()</code>的重载。</p><p>利用函数重载可以实现更好的封装，同时提高代码的简洁度。例如，我们要实现一个大整数类，用于支持高精度运算，如果没有运算符重载，我们只能按照如下方式实现：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BigNum</span>&#123;<br>    <span class="hljs-comment">// 相关数据成员声明</span><br>&#125;；<br><span class="hljs-function">BigNum <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">const</span> BigNum &amp;,<span class="hljs-type">const</span> BigNum &amp;)</span></span>;  <span class="hljs-comment">// 加法   </span><br><span class="hljs-function">BigNum <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-type">const</span> BigNum &amp;,<span class="hljs-type">const</span> BigNum &amp;)</span></span>;  <span class="hljs-comment">// 减法   </span><br><span class="hljs-function">BigNum <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-type">const</span> BigNum &amp;,<span class="hljs-type">const</span> BigNum &amp;)</span></span>;  <span class="hljs-comment">// 乘法   </span><br><span class="hljs-function">BigNum <span class="hljs-title">div</span><span class="hljs-params">(<span class="hljs-type">const</span> BigNum &amp;,<span class="hljs-type">const</span> BigNum &amp;)</span></span>;  <span class="hljs-comment">// 除法   </span><br><span class="hljs-function">BigNum <span class="hljs-title">mod</span><span class="hljs-params">(<span class="hljs-type">const</span> BigNum &amp;,<span class="hljs-type">const</span> BigNum &amp;)</span></span>;  <span class="hljs-comment">// 取模   </span><br></code></pre></td></tr></table></figure> 进行函数调用时，则是以下形式： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">BigNum n1, n2, n3;<br>n3 = <span class="hljs-built_in">add</span>(n1, n2);  <span class="hljs-comment">// 显式函数调用</span><br></code></pre></td></tr></table></figure>利用运算符重载，则实现方式如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BigNum</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 相关数据成员</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">friend</span> BigNum <span class="hljs-keyword">operator</span>+ (<span class="hljs-type">const</span> BigNum&amp;, <span class="hljs-type">const</span> BigNum &amp;);    <span class="hljs-comment">// 加法  </span><br>    <span class="hljs-keyword">friend</span> BigNum <span class="hljs-keyword">operator</span>- (<span class="hljs-type">const</span> BigNum&amp;, <span class="hljs-type">const</span> BigNum &amp;);    <span class="hljs-comment">// 减法  </span><br>    <span class="hljs-keyword">friend</span> BigNum <span class="hljs-keyword">operator</span>* (<span class="hljs-type">const</span> BigNum&amp;, <span class="hljs-type">const</span> BigNum &amp;);    <span class="hljs-comment">// 乘法  </span><br>    <span class="hljs-comment">// 略</span><br>&#125;;<br><span class="hljs-comment">// 进行加法运算</span><br>BigNum n1, n2, n3;<br>n3 = n1 + n2;  <span class="hljs-comment">// 直接使用 + 运算符即可，相当于调用 operator+ 函数</span><br></code></pre></td></tr></table></figure>由上面两种实现方式和调用方式，不难看出运算符重载的优点：封装与简洁（对使用者而言的简洁，对类的设计者而言工作量增加）。</p><p>知道了上面的基础知识，我们正式进入 C++运算符重载的主题，重点介绍运算符重载的语法特点和一些需要注意的问题。（下文以<em>TypeName</em> 代表自定义类型名，如上面的 <em>BigNum</em> ）</p><h2 id="重载输出运算符">1. 重载输出运算符 &lt;&lt;</h2><p>输入输出运算符的重载是为了更加方便的输入/输出数据。其语法规则如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 类内声明友元</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 相关成员定义 略</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt; (ostream &amp;, <span class="hljs-type">const</span> TypeName &amp;);    <br>&#125;;<br><span class="hljs-comment">// 类外定义函数</span><br>ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt; (ostream &amp;os, <span class="hljs-type">const</span> TypeName &amp;temp)<br>&#123;<br>    <span class="hljs-comment">// 具体实现 略</span><br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>注意点如下：</p><ol type="1"><li>形参 1 ：<strong>ostream &amp;类型</strong>，非 const 引用</li><li>形参 2 ：<strong>const 引用类型</strong>。const是因为输出运算符一般不应该改变对象的的状态；使用引用类型是处于性能与效率的考虑，减少调用时对象的拷贝，从而提高程序运行效率</li><li>返回类型： <strong>ostream 引用</strong>，这是为了能够连续输出</li><li>一般定义为友元</li></ol><h2 id="重载输入运算符">2. 重载输入运算符 &gt;&gt;</h2><p>输入运算符与输出运算符比较相似，其语法规则如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 类内声明友元与上面输出运算符类似 此处略</span><br><span class="hljs-comment">// 类外实现如下</span><br>istream &amp; <span class="hljs-keyword">operator</span>&gt;&gt; (istream &amp;is, TypeName &amp;temp) <br>&#123;<br>    <span class="hljs-comment">// 具体实现 略</span><br>    <span class="hljs-keyword">return</span> is;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>注意点如下：</p><ol type="1"><li>形参 1 ：<strong>istream &amp;类型</strong>, 同样是非 const引用类型</li><li>形参 2 ：<strong>非 const 引用</strong>，之所以是非 const是因为输入一般要改变对象内部状态；之所以是引用类型是因为要改变形参对象本身</li><li>返回类型：与输出运算符重载类型，返回引用，目的是能够连续输入</li><li>一般定义为友元</li></ol><h2 id="重载算术和关系运算符">3. 重载算术和关系运算符</h2><p>实际上，算术和关系运算符重载有两种实现方法，即重载是定义为成员函数还是定义为非成员函数（友元）。以加法为例说明如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 方法 1 ：非成员函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 类内声明</span><br>    <span class="hljs-keyword">friend</span> TypeName <span class="hljs-keyword">operator</span>+ (<span class="hljs-type">const</span> TypeName &amp;, <span class="hljs-type">const</span> TypeName &amp;);   <br>&#125;;<br><span class="hljs-comment">// 类外定义</span><br>TypeName <span class="hljs-keyword">operator</span>+ (<span class="hljs-type">const</span> TypeName &amp;lop, <span class="hljs-type">const</span> TypeName &amp;rop)<br>&#123;<br>    <span class="hljs-comment">// 略</span><br>&#125;<br><br><span class="hljs-comment">// 方法 2： 成员函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    TypeName <span class="hljs-keyword">operator</span>+ (<span class="hljs-type">const</span> TypeName &amp;rop)<br>    &#123;<br>        <span class="hljs-comment">// 略</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>一般情况下，这两种方式差别不大，但是当类含有一个接收普通类型的构造函数时，第一种实现方法更好，这是因为非成员函数允许对左侧或者右侧的运算对象进行类型转换（即调用构造函数由普通类型构造类的对象）；而成员函数方式只允许对右侧运算对象进行类型转换。按照《C++Primer 第五版》一书的说法，推荐以非成员函数方式实现。</p><h3 id="算术运算符">3.1 算术运算符</h3><p>我们以加法为例介绍算术运算符重载。语法规则如下：(实际上这段代码和上面方法1 代码相同) <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 类内声明</span><br>    <span class="hljs-keyword">friend</span> TypeName <span class="hljs-keyword">operator</span>+ (<span class="hljs-type">const</span> TypeName &amp;, <span class="hljs-type">const</span> TypeName &amp;);   <br>&#125;;<br><span class="hljs-comment">// 类外定义</span><br>TypeName <span class="hljs-keyword">operator</span>+ (<span class="hljs-type">const</span> TypeName &amp;lop, <span class="hljs-type">const</span> TypeName &amp;rop)<br>&#123;<br>    <span class="hljs-comment">// 略</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p>注意点如下：</p><ol type="1"><li>参数类型：两个形参都为 <strong>const &amp;类型</strong>,这是因为算术运算符不改变运算对象本身；同时引用减少拷贝提高效率</li><li>返回值类型：返回一个经算术运算后生成的临时对象</li></ol><h3 id="关系运算符">3.2 关系运算符</h3><p>关系运算符很多，包括：<code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code>共6 种。它们的实现方式同样推荐方法 1，即以非成员函数方式实现。它们的参数类型都是 <strong>const引用类型</strong> ，返回值都是 <strong>bool 类型</strong>。</p><p>这 6种关系运算符实际上存在逻辑上的转换关系，因此在实际编程中，往往采用如下方式实现这些运算符重载：</p><ul><li>首先实现 <code>==</code> 运算符</li><li>利用 <code>==</code> 实现 <code>!=</code> 运算符，即<code>a != b</code> 相当于 <code>!(a == b)</code></li><li>实现 <code>&lt;</code> 运算符</li><li>实现 <code>&gt;</code> 运算符</li><li>利用 <code>&lt;</code> 和 <code>==</code> 实现 <code>&lt;=</code>运算符，即 <code>a &lt;= b</code> 相当于<code>(a &lt; b || a == b)</code> (当然，也可以用<code>!(a &gt; b)</code> 实现)</li><li>利用 <code>&gt;</code> 和 <code>==</code> 实现 <code>&gt;=</code>运算符，即 <code>a &gt;= b</code> 相当于<code>(a &gt; b || a == b)</code> (当然，也可以用<code>!(a &lt; b)</code> 实现)</li></ul><p>实际上，除了上述实现方式也有其他方法，如 <code>a == b</code> 相当于<code>!( (a&gt;b) || (a&lt;b) )</code>，其他运算符也有另外实现方式，只须符合逻辑规则即可，这里不赘述。</p><p>下面以 <code>==</code> 为例给出语法规则： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 类内声明</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>== (<span class="hljs-type">const</span> TypeName &amp;, <span class="hljs-type">const</span> TypeName &amp;);   <br>&#125;;<br><span class="hljs-comment">// 类外定义</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>== (<span class="hljs-type">const</span> TypeName &amp;lop, <span class="hljs-type">const</span> TypeName &amp;rop)<br>&#123;<br>    <span class="hljs-comment">// 略</span><br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="重载赋值运算符">4. 重载赋值运算符</h2><p>赋值运算符分为两种，一为普通的赋值运算符<code>=</code>；二为复合赋值运算符，如<code>+=</code>、<code>-=</code>等。其中，普通赋值运算符又分为拷贝赋值和移动赋值，它们实际上更应该归类与类的拷贝控制。公众号此前写过文章介绍类的拷贝控制，其中包括拷贝赋值和移动赋值运算符介绍：<ahref="https://mp.weixin.qq.com/s/Q80xH9ZlLbgXCpXTmrNUYQ">《浅谈 C++类的拷贝控制》</a>。普通赋值运算符的重载必须为类的成员函数。此外，赋值运算符的也可以重载其它参数类型，如C++ 标准库提供的初始化列表类型<code>initializer_list&lt;TypeName&gt;</code>，不过其不是本文重点，相关资料请自行查阅。</p><p>下面重点介绍复合赋值运算符的重载。复合赋值运算符不是必须定义为类的成员，但是绝大多数情况下，最好定义为类的成员函数。其语法规则如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">TypeName &amp; <span class="hljs-keyword">operator</span>+= (<span class="hljs-type">const</span> TypeName &amp;rop)<br>&#123;<br>    <span class="hljs-comment">// 具体实现 略</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>注意点如下：</p><ol type="1"><li>形参类型：<strong>const 引用类型</strong></li><li>返回值类型：<strong>引用类型</strong>，这是为了与 C++内置与普通数据成员的复合赋值运算符保持一致的特性，即返回引用类型，在代码中体现为<code>return *this</code></li><li>所有复合赋值运算符都应该定义在类内部，作为成员函数</li></ol><h2 id="重载下标运算符">5. 重载下标运算符 [ ]</h2><p>下标运算符必须是成员函数。其语法规则如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 不完全正确版本</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 略</span><br><span class="hljs-keyword">public</span>:<br>    ReturnType &amp; <span class="hljs-keyword">operator</span>[] (<span class="hljs-type">int</span> i)<br>    &#123;<br>        <span class="hljs-comment">// 略</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 代码中<code>ReturnType</code> 代表返回类型，一般取决于类内部数据成员类型。以C++ 提供的 <code>vector</code> 为例，<code>vector&lt;T&gt;</code>类型的下标运算符返回类型为<code>T &amp;</code>。这样我们就可以通过下标运算符修改数据成员。</p><p>注意点如下：</p><ol type="1"><li>参数类型：一般为整型，代表下标</li><li>返回值类型：一般返回<strong>引用类型</strong></li><li>对于 const 类型数据，其下标运算符应该返回 <strong>const引用类型</strong>。因此，在类中应该定义下标运算符的 const 和非 const两个版本重载函数，代码如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 正确版本</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 略</span><br><span class="hljs-keyword">public</span>:<br>    ReturnType &amp; <span class="hljs-keyword">operator</span>[] (<span class="hljs-type">int</span> i)  <span class="hljs-comment">// 非 const  </span><br>    &#123;<br>        <span class="hljs-comment">// 略</span><br>    &#125;<br>    <span class="hljs-comment">// const 类型重载</span><br>    <span class="hljs-type">const</span> ReturnType &amp; <span class="hljs-keyword">operator</span>[] (<span class="hljs-type">int</span> i) <span class="hljs-type">const</span>  <br>    &#123;<br>        <span class="hljs-comment">// 略</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="重载递增和递减运算符---">6. 重载递增和递减运算符 ++ --</h2><p>递增递减运算符分前置和后置两个版本，它们一般应该定义为类的成员。前置与后置版本二者差别较大，下面以<code>++</code> 运算符为例分别介绍。</p><h3 id="前置版本递增递减运算符">6.1 前置版本递增/递减运算符</h3><p>前置版本递增运算符重载语法规则如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    TypeName &amp; <span class="hljs-keyword">operator</span>++ ()<br>    &#123;<br>        <span class="hljs-comment">// 具体实现</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><p>注意点如下：</p><ol type="1"><li>无参函数</li><li>返回值类型：<strong>引用类型</strong>，代码中<code>return *this</code> 体现</li></ol><h3 id="后置版本递增递减运算符">6.2 后置版本递增/递减运算符</h3><p>后置版本递增运算符重载语法规则如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    TypeName <span class="hljs-keyword">operator</span>++ (<span class="hljs-type">int</span>)<br>    &#123;<br>        <span class="hljs-comment">// 具体实现</span><br>        <span class="hljs-keyword">return</span> 自增前的对象;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><p>注意点如下：</p><ol type="1"><li>参数类型： <code>int</code> ，不过，这个 <code>int</code>放在函数形参列表只是为了区分前置与后置， <code>int</code>形参在函数内部不需要用到，因此也不必给出标识符</li><li>返回值类型：<strong>普通类型</strong>，返回递增/递减前保存的临时对象</li><li><strong>后置版本一般利用前置版本实现</strong>，示例代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    TypeName &amp; <span class="hljs-keyword">operator</span>++ ()<br>    &#123;<br>        <span class="hljs-comment">// 具体实现</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <br>    TypeName <span class="hljs-keyword">operator</span>++ (<span class="hljs-type">int</span>)<br>    &#123;<br>        TypeName temp = *<span class="hljs-keyword">this</span>;<br>        ++*<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 调用前置版本++</span><br>        <span class="hljs-keyword">return</span> temp;  <span class="hljs-comment">// 返回递增前保存的临时对象</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h2 id="重载成员访问运算符--">7. 重载成员访问运算符 -&gt; *</h2><p>成员访问运算符包括两个：对于指针的 <code>-&gt;</code> 以及对于对象的<code>*</code> 。<code>-&gt;</code> 必须是类的成员；<code>*</code>通常是类的成员，但并非必须如此。它们的重载函数通常定义为 const的，语法规则如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ReturnType1 <span class="hljs-keyword">operator</span>* () <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-comment">// 具体实现</span><br>        <span class="hljs-comment">// 可返回任意类型</span><br>    &#125;<br>    <br>    ReturnType2 <span class="hljs-keyword">operator</span>-&gt; () <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-comment">// 具体实现</span><br>        <span class="hljs-comment">// 必须返回类的指针或者自定义了箭头运算符的某个类的对象  </span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>成员访问运算符重载一般用的比较少，这里仅做简要介绍。实际中需要用到时，可进一步参考相关资料，并根据类的需求和操作，定义合适的重载方法。</p><h2 id="重载函数调用运算符">8. 重载函数调用运算符 ( )</h2><p>函数调用运算符的重载相对比较特殊。理论上，我们可以重载任意多个函数调用运算符，只要保证这些重载之间不发生冲突即可。函数调用运算符必须是成员函数。定义了函数调用运算符的类的对象称为<strong>函数对象</strong>。举一个例子如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> a &gt; b;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure> 定义了上面的类后，我们可以显式地调用函数： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TypeName obj;<br><span class="hljs-type">bool</span> b = <span class="hljs-built_in">obj</span>(<span class="hljs-number">12</span>, <span class="hljs-number">15</span>);<br></code></pre></td></tr></table></figure>12 比 15 小，因此上述代码中 b 应该为 false。</p><p>不过，函数对象更为常用的是作为函数参数提供给标准库函数，典型的如 sort函数： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">22</span>,<span class="hljs-number">343</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-232</span>,<span class="hljs-number">-23423</span>&#125;;<br><span class="hljs-type">int</span> n = <span class="hljs-built_in">sizeof</span>(a)/<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>);<br><span class="hljs-built_in">sort</span>(a, a+n, <span class="hljs-built_in">TypeName</span>());<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n; ++i)<br>    cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span>;<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure> 将 <code>TypeName()</code>临时对象作为函数参数传递给 <code>sort</code>函数，就能够实现自定义规则排序。上面代码将数组降序排序，而<code>sort</code> 函数默认为升序排序。</p><p>值得一提的是，C++ 中提供的 lambda表达式，实际上都转换为类，这个类重载了函数调用运算符，参数类型即为lambda 表达式的参数类型。这样，调用 lambda表达式就转换为调用函数对象的函数调用运算符。</p><h2 id="重载类型转换运算符">9. 重载类型转换运算符</h2><p>类型转换运算符的重载更为特殊，是类的一种特殊成员函数，其语法规则如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">type</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 具体实现</span><br>&#125;<br></code></pre></td></tr></table></figure> 其中， <code>type</code> 表示目标转换类型。</p><p>类型转换运算符一般很少使用，在实际编程中也应该谨慎使用。若定义不当，可能产生错误或者意料之外的结果。一般而言，类定义向<code>bool</code> 类型的转换规则就足够了，而且该转换函数最好定义为<code>explicit</code> 的。</p><hr /><p>以上就是本文全部内容。不过这些并不是对运算符重载的全面介绍，想了解更深入详细的知识，仍需阅读相关书籍。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>运算符重载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Nginx(GitHub Pages) 与 Hexo 搭建个人博客</title>
    <link href="/2023/02/18/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/02/18/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>本文介绍使用 Nginx（或者 GitHub Pages） 与 Hexo搭建个人博客的主要步骤。</p><p>在正文开始之前，先介绍上面提到的几个工具的功能：</p><ul><li><a href="https://nginx.org/en/">Nginx</a>：充当 Web服务器的角色，在个人博客中，其主要功能是在公网服务器上提供 HTTP 或 HTTPS服务，让用户能够访问你的博客网站。</li><li><a href="https://pages.github.com/">GitHubPages</a>：在没有个人公网服务器时，使用 GitHub Pages同样可以达到搭建个人博客的目的。具体而言，GitHub Pages 就是一个特殊的GitHub 仓库，你可以在这个仓库内放一些 HTML、CSS 和 JS文件等，从而搭建个人网站。</li><li><a href="https://hexo.io/zh-cn/">Hexo</a>：Hexo是一个静态博客框架，使用它可以搭建博客网站，让用户专注于博客内容，而不需要熟悉CSS 和 Javascript等前端内容。使用官方以及许多开源作者提供的主题，即可快速的构建美观的网页，而博客内容使用Markdown 编写即可。</li></ul><p>下面，介绍具体步骤。</p><h2 id="本地安装-node.js">1. 本地安装 Node.js</h2><p>Node.js 官网为：https://nodejs.org/en/download/，打开链接，根据本地环境，选择合适的安装文件下载。Windows 平台与 Mac平台选择二进制 installer 文件，安装时只需要点下一步即可。</p><p>Linux 平台安装稍微复杂些，推荐以下两种安装方式，可任选其一：</p><ul><li>源代码编译安装，无需配置 bash，但是编译耗时，<ahref="https://cloud.tencent.com/developer/article/1938607">参考</a></li><li>二进制文件下载安装，需要配置 bash 环境，<ahref="https://cloud.tencent.com/developer/article/1772306">参考</a></li></ul><p>安装完成后，在命令行输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm -v<br>$ node -v<br></code></pre></td></tr></table></figure><p>若都有输出，说明安装成功。</p><h2 id="本地安装-hexo-并初始化博客环境">2. 本地安装 Hexo并初始化博客环境</h2><p>Hexo 安装命令参考<ahref="https://hexo.io/zh-cn/">官网</a>即可，具体如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install hexo-cli -g<br>$ hexo init blog<br>$ <span class="hljs-built_in">cd</span> blog<br>$ npm install<br>$ hexo server<br></code></pre></td></tr></table></figure><p>关于 Hexo 的更多信息，可参考官方文档：<ahref="https://hexo.io/zh-cn/docs/">文档 | Hexo</a> 。</p><p>为了让你的博客网站更加符合你的审美，可以选择一个合适的主题 <ahref="https://hexo.io/themes/">Themes | Hexo</a> 。本博客网站使用的是Fluid，其 GitHub 仓库地址为：<ahref="https://github.com/fluid-dev/hexo-theme-fluid">fluid-dev/hexo-theme-fluid:一款 Material Design 风格的 Hexo 主题 / An elegant Material-Design themefor Hexo (github.com)</a> ，官方文档地址为：<ahref="https://hexo.fluid-dev.com/docs/guide/">配置指南 | Hexo Fluid用户手册 (fluid-dev.com)</a>。</p><p>仔细阅读 Hexo 官方文档与你选择的主题的官方文档，根据自己的喜好配置好yml 文件，搭建个人博客的路途就走完了一半。</p><p>下面，我们要解决的问题是：如何让互联网上的广大用户能够访问你的博客网站？</p><p>3、4 小节提供了两种方式，可根据自己的具体情况选择。</p><h2 id="建立-github-pages-仓库">3. 建立 GitHub Pages 仓库</h2><p>首先，在 GitHub上建立一个仓库。这个仓库的命名有点讲究，举例说明如下：</p><p>我的 GitHub 个人主页地址为：https://github.com/UnpureRationalist，其中，<code>UnpureRationalist</code> 表示我的用户名。</p><p>打开 GitHub 并选择创建仓库选项，将仓库命名为<code>用户名.github.io</code>，比如我的仓库命名则是：<code>UnpureRationalist.github.io</code>，并设置仓库为公开可见。</p><p>然后，在该仓库上传一个名为 <code>index.html</code>的文件，参考文件内容如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Example<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello World.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在浏览器输入链接 <code>用户名.github.io</code>，如我的博客地址为：<code>UnpureRationalist.github.io</code>，然后，浏览器即可显示 <code>index.html</code>文件的内容（可能需要等待一会）。</p><p>利用此仓库，我们就可以让其他用户访问自己的博客网站。</p><h2 id="服务器安装-nginx">4. 服务器安装 Nginx</h2><p>对于拥有个人云服务器的用户来说，可以直接在个人服务器上安装 Nginx服务，将个人博客搭建在自己的服务器上。</p><p>首先，我们需要在服务器上安装 Nginx，这里以 Ubuntu系统为例，步骤如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo apt update<br>$ sudo apt install nginx<br>$ sudo systemectl <span class="hljs-built_in">enable</span> nginx<span class="hljs-comment"># 设置 nginx 开机启动</span><br>$ sudo systemctl start nginx<span class="hljs-comment"># 启动 nginx 服务</span><br></code></pre></td></tr></table></figure><p>注意，为了让 Nginx 正常工作，需要在服务器的安全组设置中开放 80 or/and443 端口，以让 HTTP or/and HTTPS服务正常工作，具体参考自己使用的服务器提供商。</p><p>如果要使用 HTTPS 服务，则需要对 Nginx进行一定的配置，具体参考链接：https://cloud.tencent.com/document/product/400/35244。</p><h2 id="配置-hexo-实现自动部署">5. 配置 Hexo 实现自动部署</h2><p>经过上面的步骤，我们在本地有了一个存放个人博客的目录；在云端有了公网用户能够访问的目录。因此，我们只需要使用Git 或 scp 等工具，将 Hexo 生成的 public 目录下的所有文件和文件夹上传到GitHub 仓库或者服务器 Web服务根目录下即可。但是，手动进行这些操作有些麻烦，我们可以使用 Hexo提供的功能实现一条命令部署。详情参考链接：<ahref="https://hexo.io/zh-cn/docs/one-command-deployment">部署 | Hexo</a>。</p><p>具体而言，就是在 <code>_config.yml</code>配置文件中进行适当的配置，然后运行如下命令即可将个人博客部署到云端：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo deploy<br></code></pre></td></tr></table></figure><p>不过，在本人实际使用过程中，发现一键部署功能不太好用，GitHub Pages有时由于网络原因无法部署成功；部署到云服务器上则会报错。因此，本人使用Hexo 提供的功能部署到 GitHub Pages；对于服务器，则使用朴实无华的<code>scp</code>命令进行手动同步。如果读者有更好的自动部署方式，欢迎交流讨论。</p>]]></content>
    
    
    
    <tags>
      
      <tag>博客</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/02/18/hello-world/"/>
    <url>/2023/02/18/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h2 id="测试公式">测试公式</h2><p><span class="math display">\[E=mc^2\]</span></p><p><span class="math display">\[\sigma(z_i) = \frac{e^{z_{i}}}{\sum_{j=1}^K e^{z_{j}}} \ \ \ for\i=1,2,\dots,K\]</span></p><p><span class="math display">\[L_{\delta}=    \left\{\begin{matrix}        \frac{1}{2}(y - \hat{y})^{2} &amp; if \left | (y -\hat{y})  \right | &lt; \delta\\        \delta ((y - \hat{y}) - \frac1 2 \delta) &amp; otherwise    \end{matrix}\right.\]</span></p><p><span class="math display">\[\epsilon \sim \mathcal{N}(0, \textbf{I})\]</span></p><p><span class="math display">\[\vec{z} \sim \mathcal{N}(\vec{\mu}, \sigma^2 \textbf{I})\]</span></p><p><span class="math display">\[\sum_{i=1}^{D}|x_i-y_i|\]</span></p><p><span class="math display">\[Accuracy = \frac{TP+TN}{TP+TN+FP+FN}\]</span></p><p><span class="math display">\[Precision = \frac{TP}{TP+FP}\]</span></p><p><span class="math display">\[Recall = \frac{TP}{TP+FN}\]</span></p><p><span class="math display">\[F1 = \frac{2*Precision*Recall}{Precision+Recall} =\frac{2*TP}{2*TP+FP+FN}\]</span></p><h2 id="测试代码">测试代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> net<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> face_alignment <span class="hljs-keyword">import</span> align<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><br>adaface_models = &#123;<br>    <span class="hljs-string">&#x27;ir_50&#x27;</span>:<span class="hljs-string">&quot;pretrained/adaface_ir50_ms1mv2.ckpt&quot;</span>,<br>&#125;<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_pretrained_model</span>(<span class="hljs-params">architecture=<span class="hljs-string">&#x27;ir_50&#x27;</span></span>):<br>    <span class="hljs-comment"># load model and pretrained statedict</span><br>    <span class="hljs-keyword">assert</span> architecture <span class="hljs-keyword">in</span> adaface_models.keys()<br>    model = net.build_model(architecture)<br>    statedict = torch.load(adaface_models[architecture])[<span class="hljs-string">&#x27;state_dict&#x27;</span>]<br>    model_statedict = &#123;key[<span class="hljs-number">6</span>:]:val <span class="hljs-keyword">for</span> key, val <span class="hljs-keyword">in</span> statedict.items() <span class="hljs-keyword">if</span> key.startswith(<span class="hljs-string">&#x27;model.&#x27;</span>)&#125;<br>    model.load_state_dict(model_statedict)<br>    model.<span class="hljs-built_in">eval</span>()<br>    <span class="hljs-keyword">return</span> model<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">to_input</span>(<span class="hljs-params">pil_rgb_image</span>):<br>    np_img = np.array(pil_rgb_image)<br>    brg_img = ((np_img[:,:,::-<span class="hljs-number">1</span>] / <span class="hljs-number">255.</span>) - <span class="hljs-number">0.5</span>) / <span class="hljs-number">0.5</span><br>    tensor = torch.tensor([brg_img.transpose(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)]).<span class="hljs-built_in">float</span>()<br>    <span class="hljs-keyword">return</span> tensor<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br><br>    model = load_pretrained_model(<span class="hljs-string">&#x27;ir_50&#x27;</span>)<br>    feature, norm = model(torch.randn(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">112</span>,<span class="hljs-number">112</span>))<br><br>    test_image_path = <span class="hljs-string">&#x27;face_alignment/test_images&#x27;</span><br>    features = []<br>    <span class="hljs-keyword">for</span> fname <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(os.listdir(test_image_path)):<br>        path = os.path.join(test_image_path, fname)<br>        aligned_rgb_img = align.get_aligned_face(path)<br>        bgr_tensor_input = to_input(aligned_rgb_img)<br>        feature, _ = model(bgr_tensor_input)<br>        features.append(feature)<br><br>    similarity_scores = torch.cat(features) @ torch.cat(features).T<br>    <span class="hljs-built_in">print</span>(similarity_scores)<br>    <br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span><br>&#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode *left;<br>    TreeNode *right;<br>    <span class="hljs-built_in">TreeNode</span>() : <span class="hljs-built_in">val</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x, TreeNode *left, TreeNode *right) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(left), <span class="hljs-built_in">right</span>(right) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode *root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;TreeNode *&gt; s;<br>        TreeNode *p = root;<br>        <span class="hljs-keyword">while</span> (p || !s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span> (p)<br>            &#123;<br>                s.<span class="hljs-built_in">push</span>(p);<br>                p = p-&gt;left;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                TreeNode *temp = s.<span class="hljs-built_in">top</span>();<br>                s.<span class="hljs-built_in">pop</span>();<br>                res.<span class="hljs-built_in">push_back</span>(temp-&gt;val);<br>                p = temp-&gt;right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode *root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;TreeNode *&gt; s;<br>        TreeNode *p = root;<br>        <span class="hljs-keyword">while</span> (p || !s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">while</span> (p)<br>            &#123;<br>                s.<span class="hljs-built_in">push</span>(p);<br>                p = p-&gt;left;<br>            &#125;<br>            TreeNode *temp = s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            res.<span class="hljs-built_in">push_back</span>(temp-&gt;val);<br>            p = temp-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
