<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>GoogleTest 与 Benchmark 库使用：以位图 countOnes 函数为例</title>
    <link href="/2024/06/30/GoogleTest-%E4%B8%8E-Benchmark-%E5%BA%93%E4%BD%BF%E7%94%A8%EF%BC%9A%E4%BB%A5%E4%BD%8D%E5%9B%BE-countOnes-%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BE%8B/"/>
    <url>/2024/06/30/GoogleTest-%E4%B8%8E-Benchmark-%E5%BA%93%E4%BD%BF%E7%94%A8%EF%BC%9A%E4%BB%A5%E4%BD%8D%E5%9B%BE-countOnes-%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<p>单元测试与性能测试都是我们实际进行项目开发中常见的需求，一个优秀的库能够帮助我们高效地完成上述需求，专注于项目本身逻辑的开发，而不是额外花费精力于单元测试库和性能测试库的编写。就C++ 而言，最常用的单元测试和性能测试库应该就是 Google 开源的 GoogleTest和 Benchmark 库了，二者源代码都可在 GitHub 获取。</p><p>本文中，我们以计算一块连续内存中的位 1 的数量为例（也就是实现位图bitmap 的 <code>countOnes</code>函数，这里为了简化，只考虑按字节连续存储的位图），来看看如何使用GoogleTest 库进行单元测试以及如何使用 Benchmark库进行性能测试。本文涉及的源码已经同步到 GitHub：<ahref="https://github.com/UnpureRationalist/SWARBenchmark">UnpureRationalist/SWARBenchmark:Performance comparison of popCount function. (github.com)</a>。</p><p>需要说明的是，本文仅仅是最基础的介绍，主要目的是说明如何使用GoogleTest 和 Benchmark这两个工具，不涉及它们的高级特性。需要使用这两个库高级功能的读者请参阅官方文档。</p><h2 id="目录组织">1. 目录组织</h2><p>使用 <code>tree</code> 命令查看目录组织情况如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree --gitignore</span><br>.<br>├── CMakeLists.txt<br>├── README.md<br>├── src<br>│   ├── benchmark.cpp<br>│   ├── genString.cpp<br>│   ├── genString.h<br>│   ├── swar.cpp<br>│   ├── swar.h<br>│   └── test.cpp<br>└── third_party<br>    └── CMakeLists.txt<br><br>2 directories, 9 files<br></code></pre></td></tr></table></figure><p>其中，<code>third_party</code> 目录是依赖的 GoogleTest 和 Benchmark库所在路径，<code>src</code> 目录是项目源代码。项目使用<code>cmake</code> 进行构建，需要在 <code>CMakeLists.txt</code>文件中指定对 GoogleTest 和 Benchmark 的依赖，具体内容如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>)<br><br><span class="hljs-keyword">project</span>(learnBenchmark<br>        LANGUAGES C CXX<br>)<br><br><span class="hljs-keyword">set</span>(CMAKE_EXPORT_COMPILE_COMMANDS <span class="hljs-keyword">ON</span>)<br><span class="hljs-keyword">set</span>(BUILD_SHARED_LIBS <span class="hljs-keyword">OFF</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="hljs-keyword">ON</span>)<br><br><span class="hljs-keyword">add_subdirectory</span>(third_party)<br><br><span class="hljs-keyword">find_package</span>(OpenMP REQUIRED)<br><br><span class="hljs-keyword">set</span>(SOURCES<br>    src/genString.h<br>    src/genString.cpp<br>    src/swar.h<br>    src/swar.cpp<br>)<br><br><span class="hljs-keyword">add_executable</span>(<span class="hljs-string">&quot;swarBenchmark&quot;</span> <span class="hljs-variable">$&#123;SOURCES&#125;</span> src/benchmark.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(<span class="hljs-string">&quot;swarBenchmark&quot;</span> benchmark::benchmark OpenMP::OpenMP_CXX)<br><br><span class="hljs-keyword">enable_testing</span>()<br><br><span class="hljs-keyword">add_executable</span>(<span class="hljs-string">&quot;swarTest&quot;</span> <span class="hljs-variable">$&#123;SOURCES&#125;</span> src/<span class="hljs-keyword">test</span>.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(<span class="hljs-string">&quot;swarTest&quot;</span> gtest gtest_main OpenMP::OpenMP_CXX)<br></code></pre></td></tr></table></figure><p>项目只会生成两个可执行文件：</p><ul><li><code>swarTest</code>：单元测试可执行文件</li><li><code>swarBenchmark</code>：性能测试可执行文件</li></ul><h2 id="countones-函数实现">2. <code>countOnes</code> 函数实现</h2><p>在本文中，共实现了 5 种 <code>countOnes</code> 函数，其中一个是 Redis源码中采用的 SWAR 算法 + 手动循环展开。Redis中的实现网上已经有很多介绍文章（可参考：<ahref="https://ponder.work/2020/08/01/variable-precision-SWAR-algorithm/">https://ponder.work/2020/08/01/variable-precision-SWAR-algorithm/</a>），这里就简单介绍下朴素的实现算法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">basicPopcount</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *s, <span class="hljs-type">long</span> count)</span> </span>&#123;<br>  <span class="hljs-type">long</span> <span class="hljs-type">long</span> bits = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> i = <span class="hljs-number">0</span>; i &lt; count; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">8</span>; ++j) &#123;<br>      bits += (s[i] &amp; (<span class="hljs-number">1</span> &lt;&lt; j)) &gt; <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> bits;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">bitAndPopcount</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *s, <span class="hljs-type">long</span> count)</span> </span>&#123;<br>  <span class="hljs-type">long</span> <span class="hljs-type">long</span> bits = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> i = <span class="hljs-number">0</span>; i &lt; count; ++i) &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c = s[i];<br>    <span class="hljs-keyword">while</span> (c) &#123;<br>      bits++;<br>      c &amp;= c - <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> bits;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">gccBuildinPopCount</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *s, <span class="hljs-type">long</span> count)</span> </span>&#123;<br>  <span class="hljs-type">long</span> <span class="hljs-type">long</span> bits = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> i = <span class="hljs-number">0</span>; i &lt; count; ++i) &#123;<br>    bits += __builtin_popcount(s[i]);<br>  &#125;<br>  <span class="hljs-keyword">return</span> bits;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">openmpBasicPopCount</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *s, <span class="hljs-type">long</span> count)</span> </span>&#123;<br>  <span class="hljs-type">long</span> <span class="hljs-type">long</span> bits = <span class="hljs-number">0</span>;<br>  <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel for reduction(+:bits) num_threads(2)</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> i = <span class="hljs-number">0</span>; i &lt; count; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">8</span>; ++j) &#123;<br>      bits += (s[i] &amp; (<span class="hljs-number">1</span> &lt;&lt; j)) &gt; <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> bits;<br>&#125;<br></code></pre></td></tr></table></figure><p>给出源码后，其实也没什么好解释的了，内部的实现不同点如下：</p><ul><li><code>bits += (s[i] &amp; (1 &lt;&lt; j)) &gt; 0;</code>：朴素位运算</li><li><code>c &amp;= c - 1;</code>：稍高级的位运算，可参考剑指offer、力扣等了解原理</li><li><code>bits += __builtin_popcount(s[i]);</code>：使用 gcc编译器内置函数</li><li><code>#pragma omp parallel for reduction(+:bits) num_threads(2)</code>：使用OpenMP 多线程加速朴素位运算</li></ul><h2 id="单元测试">3. 单元测试</h2><p>单元测试源码路径为 <code>src/test.cpp</code>，源码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;genString.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;gtest/gtest.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;swar.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;random&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CountOnesTest</span> : <span class="hljs-keyword">public</span> testing::Test &#123;<br> <span class="hljs-keyword">protected</span>:<br>  <span class="hljs-built_in">CountOnesTest</span>() = <span class="hljs-keyword">default</span>;<br><br>  ~<span class="hljs-built_in">CountOnesTest</span>() <span class="hljs-keyword">override</span> = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doCountOnesTest</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>  std::string str = <span class="hljs-built_in">generateRandomString</span>(n);<br>  <span class="hljs-type">long</span> <span class="hljs-type">long</span> redisLen = <span class="hljs-built_in">redisPopcount</span>((<span class="hljs-type">void</span> *)str.<span class="hljs-built_in">c_str</span>(), n);<br>  <span class="hljs-type">long</span> <span class="hljs-type">long</span> basicLen = <span class="hljs-built_in">basicPopcount</span>((<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)str.<span class="hljs-built_in">c_str</span>(), n);<br>  <span class="hljs-type">long</span> <span class="hljs-type">long</span> bitAndLen = <span class="hljs-built_in">bitAndPopcount</span>((<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)str.<span class="hljs-built_in">c_str</span>(), n);<br>  <span class="hljs-type">long</span> <span class="hljs-type">long</span> gccAndLen = <span class="hljs-built_in">gccBuildinPopCount</span>((<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)str.<span class="hljs-built_in">c_str</span>(), n);<br>  <span class="hljs-type">long</span> <span class="hljs-type">long</span> openmpBasicLen = <span class="hljs-built_in">openmpBasicPopCount</span>((<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)str.<span class="hljs-built_in">c_str</span>(), n);<br>  <span class="hljs-built_in">EXPECT_EQ</span>(redisLen, basicLen);<br>  <span class="hljs-built_in">EXPECT_EQ</span>(redisLen, bitAndLen);<br>  <span class="hljs-built_in">EXPECT_EQ</span>(redisLen, gccAndLen);<br>  <span class="hljs-built_in">EXPECT_EQ</span>(redisLen, openmpBasicLen);<br>&#125;<br><br><span class="hljs-built_in">TEST_F</span>(CountOnesTest, BasicTest) &#123;<br>  <span class="hljs-type">int</span> n = <span class="hljs-number">1000000</span>;<br>  <span class="hljs-built_in">doCountOnesTest</span>(n);<br>&#125;<br><br><span class="hljs-built_in">TEST_F</span>(CountOnesTest, StrongTest) &#123;<br>  <span class="hljs-type">int</span> times = <span class="hljs-number">1000</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; times; ++i) &#123;<br>    <span class="hljs-type">int</span> n = (i + <span class="hljs-number">1</span>) * (i + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">doCountOnesTest</span>(n);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>单元测试的编写其实很简单，只需要自定义一个基础自 <code>Test</code>的类：<code>class CountOnesTest : public testing::Test</code>，然后使用宏指定test suite 名和 test case名，并在内部编写单元测试逻辑即可，比如上面的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">TEST_F</span>(CountOnesTest, BasicTest) &#123;<br>  <span class="hljs-type">int</span> n = <span class="hljs-number">1000000</span>;<br>  <span class="hljs-built_in">doCountOnesTest</span>(n);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>CountOnesTest</code> 是我们自定义的类名，<code>BasicTest</code>是我们给测试用例取得名字。在内部调用 <code>doCountOnesTest</code>函数进行单元测试。<code>doCountOnesTest</code> 函数内使用<code>EXPECT_EQ</code> 宏，保证不同的 <code>countOnes</code>实现得到的结果相同。</p><p>运行单元测试，我们能够得到下面的输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./swarTest</span> <br>Running main() from /home/ubuntu/code/learn_benchmark/third_party/googletest/googletest/src/gtest_main.cc<br>[==========] Running 2 tests from 1 test suite.<br>[----------] Global test environment set-up.<br>[----------] 2 tests from CountOnesTest<br>[ RUN      ] CountOnesTest.BasicTest<br>[       OK ] CountOnesTest.BasicTest (30 ms)<br>[ RUN      ] CountOnesTest.StrongTest<br>[       OK ] CountOnesTest.StrongTest (9999 ms)<br>[----------] 2 tests from CountOnesTest (10030 ms total)<br><br>[----------] Global test environment tear-down<br>[==========] 2 tests from 1 test suite ran. (10030 ms total)<br>[  PASSED  ] 2 tests.<br></code></pre></td></tr></table></figure><p>如果单元测试失败，输出会进行提示，我们需要对源码进行修复以通过单元测试。</p><h2 id="性能测试">4. 性能测试</h2><p>性能测试源码路径为 <code>src/benchmark.cpp</code>，具体源码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;genString.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;swar.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;gtest/gtest.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;benchmark/benchmark.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br>std::vector&lt;std::string&gt; inputStrings;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inputInit</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> numStr = <span class="hljs-number">1000</span>;<br>  <span class="hljs-type">int</span> strLen = <span class="hljs-number">10000</span>;<br>  inputStrings.<span class="hljs-built_in">reserve</span>(numStr);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numStr; ++i) &#123;<br>    inputStrings.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">generateRandomString</span>(strLen));<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">BM_RedisPopcount</span><span class="hljs-params">(benchmark::State &amp;state)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> _ : state) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> std::string &amp;str : inputStrings) &#123;<br>      <span class="hljs-built_in">redisPopcount</span>((<span class="hljs-type">void</span> *)str.<span class="hljs-built_in">c_str</span>(), str.<span class="hljs-built_in">size</span>());<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-built_in">BENCHMARK</span>(BM_RedisPopcount);<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">BM_BasicPopCount</span><span class="hljs-params">(benchmark::State &amp;state)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> _ : state) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> std::string &amp;str : inputStrings) &#123;<br>      <span class="hljs-built_in">basicPopcount</span>((<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)str.<span class="hljs-built_in">c_str</span>(), str.<span class="hljs-built_in">size</span>());<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-built_in">BENCHMARK</span>(BM_BasicPopCount);<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">BM_BitAndPopCount</span><span class="hljs-params">(benchmark::State &amp;state)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> _ : state) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> std::string &amp;str : inputStrings) &#123;<br>      <span class="hljs-built_in">bitAndPopcount</span>((<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)str.<span class="hljs-built_in">c_str</span>(), str.<span class="hljs-built_in">size</span>());<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-built_in">BENCHMARK</span>(BM_BitAndPopCount);<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">BM_GccBuiltinPopCount</span><span class="hljs-params">(benchmark::State &amp;state)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> _ : state) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> std::string &amp;str : inputStrings) &#123;<br>      <span class="hljs-built_in">gccBuildinPopCount</span>((<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)str.<span class="hljs-built_in">c_str</span>(), str.<span class="hljs-built_in">size</span>());<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-built_in">BENCHMARK</span>(BM_GccBuiltinPopCount);<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">BM_OpenmpBasicPopCount</span><span class="hljs-params">(benchmark::State &amp;state)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> _ : state) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> std::string &amp;str : inputStrings) &#123;<br>      <span class="hljs-built_in">openmpBasicPopCount</span>((<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)str.<span class="hljs-built_in">c_str</span>(), str.<span class="hljs-built_in">size</span>());<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-built_in">BENCHMARK</span>(BM_OpenmpBasicPopCount);<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-built_in">inputInit</span>();<br><br>  ::benchmark::<span class="hljs-built_in">Initialize</span>(&amp;argc, argv);<br>  ::benchmark::<span class="hljs-built_in">RunSpecifiedBenchmarks</span>();<br>  ::benchmark::<span class="hljs-built_in">Shutdown</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>性能测试的编写也很容易，只需要定义一个函数，输入参数类型为<code>benchmark::State &amp;state</code>，然后在函数体内编写性能测试需要执行的函数，最后进行函数的注册，如上面的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">BM_RedisPopcount</span><span class="hljs-params">(benchmark::State &amp;state)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> _ : state) &#123;<br>    <span class="hljs-comment">// 编写性能测试逻辑</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> std::string &amp;str : inputStrings) &#123;<br>      <span class="hljs-built_in">redisPopcount</span>((<span class="hljs-type">void</span> *)str.<span class="hljs-built_in">c_str</span>(), str.<span class="hljs-built_in">size</span>());<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-built_in">BENCHMARK</span>(BM_RedisPopcount);<span class="hljs-comment">// 注册性能测试函数</span><br></code></pre></td></tr></table></figure><p>性能测试结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./swarBenchmark</span><br>2024-06-30T01:00:01+08:00<br>Running ./swarBenchmark<br>Run on (8 X 2500 MHz CPU s)<br>CPU Caches:<br>  L1 Data 32 KiB (x8)<br>  L1 Instruction 32 KiB (x8)<br>  L2 Unified 4096 KiB (x8)<br>  L3 Unified 28160 KiB (x1)<br>Load Average: 0.10, 0.07, 0.11<br>-----------------------------------------------------------------<br>Benchmark                       Time             CPU   Iterations<br>-----------------------------------------------------------------<br>BM_RedisPopcount          3629826 ns      3629386 ns          192<br>BM_BasicPopCount         25606352 ns     25604317 ns           27<br>BM_BitAndPopCount        98210255 ns     98202993 ns            7<br>BM_GccBuiltinPopCount    36949327 ns     36947015 ns           19<br>BM_OpenmpBasicPopCount   14287040 ns     14286005 ns           49<br></code></pre></td></tr></table></figure><p>可以看出，Redis 的实现要远远快于其他实现，由此我们可以感受到 SWAR算法和循环展开的魅力。而面试中希望面试者给出的解答<code>a &amp; (a - 1)</code>在我们的测试场景下，性能反而不如最朴素的逐位按位与，gcc的内置函数在我们的场景下同样不如朴素算法。使用 OpenMP 2个线程加速朴素位运算算法后，能减少时间开销，但还是与 Redis中的实现有一定差距。</p><h2 id="总结">5. 总结</h2><p>单元测试与性能测试都是实际工作和项目开发中常见的、甚至必须的需求，但是在学校中却较少接触到，导致了知识面的一些欠缺。本文以位图的<code>countOnes</code> 函数的不同实现为例，介绍了 GoogleTest 和Benchmark 的基本使用方法，补全程序员必备工具链的一小环。</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GoogleTest</tag>
      
      <tag>Benchmark</tag>
      
      <tag>bitmap</tag>
      
      <tag>countOnes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LevelDB 源码阅读三：工具函数一览</title>
    <link href="/2024/06/14/LevelDB-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%89%EF%BC%9A%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%E4%B8%80%E8%A7%88/"/>
    <url>/2024/06/14/LevelDB-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%89%EF%BC%9A%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%E4%B8%80%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<p>前面两篇文章，我们分别介绍了 LevelDB 的部分基础数据结构和 LevelDB对操作系统功能的封装，本文我们继续按照自底向上的原则，来看<code>util</code> 目录下的我们尚未阅读的源代码。涉及的源文件包括：</p><ul><li><code>util/arena.h</code> 和 <code>util/arena.cc</code></li><li><code>util/coding.h</code> 和 <code>util/coding.cc</code></li><li><code>util/crc32c.h</code> 和 <code>util/crc32c.cc</code></li><li><code>util/hash.h</code> 和 <code>util/hash.cc</code></li><li><code>util/histogram.h</code> 和 <code>util/histogram.cc</code></li><li><code>util/logging.h</code> 和 <code>util/logging.cc</code></li><li><code>util/no_destructor.h</code></li><li><code>util/random.h</code></li><li><code>include/leveldb/comparator.h</code> 和<code>util/comparator.cc</code></li></ul><p>下面我们按顺序来看相关代码。</p><h2 id="内存分配管理">1. 内存分配管理</h2><p><code>arena.h</code> 源文件中定义了用于管理内存分配的类<code>Arena</code>，其 <code>public</code> 接口和数据成员如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Arena</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// Return a pointer to a newly allocated memory block of &quot;bytes&quot; bytes.</span><br>  <span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">Allocate</span><span class="hljs-params">(<span class="hljs-type">size_t</span> bytes)</span></span>;<br><br>  <span class="hljs-comment">// Allocate memory with the normal alignment guarantees provided by malloc.</span><br>  <span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">AllocateAligned</span><span class="hljs-params">(<span class="hljs-type">size_t</span> bytes)</span></span>;<br><br>  <span class="hljs-comment">// Returns an estimate of the total memory usage of data allocated</span><br>  <span class="hljs-comment">// by the arena.</span><br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">MemoryUsage</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> memory_usage_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// Allocation state</span><br>  <span class="hljs-type">char</span>* alloc_ptr_;<br>  <span class="hljs-type">size_t</span> alloc_bytes_remaining_;<br><br>  <span class="hljs-comment">// Array of new[] allocated memory blocks</span><br>  std::vector&lt;<span class="hljs-type">char</span>*&gt; blocks_;<br><br>  <span class="hljs-comment">// Total memory usage of the arena.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// TODO(costan): This member is accessed via atomics, but the others are</span><br>  <span class="hljs-comment">//               accessed without any locking. Is this OK?</span><br>  std::atomic&lt;<span class="hljs-type">size_t</span>&gt; memory_usage_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>从源码可以看出，<code>Arena</code> 类主要暴露了 3个接口，功能分别为：</p><ul><li><code>char* Allocate(size_t bytes)</code>：分配指定大小的内存</li><li><code>char* AllocateAligned(size_t bytes)</code>：分配对齐的指定大小内存</li><li><code>size_t MemoryUsage() const</code>：返回 <code>Arena</code>类分配的内存总量</li></ul><p><code>Arena</code>类自行进行内存的回收，不需要申请内存的调用者进行内存的回收操作。这一点可以从<code>Arena</code> 类析构函数中看出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Arena::~<span class="hljs-built_in">Arena</span>() &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; blocks_.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    <span class="hljs-keyword">delete</span>[] blocks_[i];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Arena</code> 类在析构时自动进行内存的释放。</p><p>另外，在源码注释中可以看到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// TODO(costan): This member is accessed via atomics, but the others are</span><br><span class="hljs-comment">//               accessed without any locking. Is this OK?</span><br></code></pre></td></tr></table></figure><p>只有数据成员 <code>memory_usage_</code>是原子类型，其他成员是普通类型且没有锁保护，LevelDB作者对于这种实现能否保证并发安全并不确定。查看相关代码，可以发现，多线程并发访问<code>Allocate</code> 接口时，是有可能发生并发访问错误的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">char</span>* <span class="hljs-title">Arena::Allocate</span><span class="hljs-params">(<span class="hljs-type">size_t</span> bytes)</span> </span>&#123;<br>  <span class="hljs-comment">// The semantics of what to return are a bit messy if we allow</span><br>  <span class="hljs-comment">// 0-byte allocations, so we disallow them here (we don&#x27;t need</span><br>  <span class="hljs-comment">// them for our internal use).</span><br>  <span class="hljs-built_in">assert</span>(bytes &gt; <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (bytes &lt;= alloc_bytes_remaining_) &#123;<br>    <span class="hljs-type">char</span>* result = alloc_ptr_;<br>    alloc_ptr_ += bytes;<br>    alloc_bytes_remaining_ -= bytes;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">AllocateFallback</span>(bytes);<br>&#125;<br></code></pre></td></tr></table></figure><p>例如，线程 1 和线程 2 同时调用 <code>Allocate</code> 函数，申请相同<code>bytes</code> 大小的内存，并发进入<code>if (bytes &lt;= alloc_bytes_remaining_)</code> 分支，并同时返回了<code>result</code>指针。这样，两个线程就会持有执行同一个内存区域的指针，后续如果两个线程都对内存进行写入操作，就会导致部分写失效，发生非预期行为。</p><p>我们在 <code>arena_test.cc</code> 中添加以下测试用例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">TEST</span>(ArenaTest, ConcurrencyAllocate) &#123;<br>  Arena arena;<br>  std::vector&lt;<span class="hljs-type">char</span>*&gt; thread1_mem;<br>  std::vector&lt;<span class="hljs-type">char</span>*&gt; thread2_mem;<br>  <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> allocate_times = <span class="hljs-number">1000000</span>;<br>  <span class="hljs-type">size_t</span> bytes = <span class="hljs-number">100</span>;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">([&amp;] &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; allocate_times; ++i) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">      thread1_mem.emplace_back(arena.Allocate(bytes));</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">  &#125;)</span></span>;<br><br>  <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">([&amp;] &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; allocate_times; ++i) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">      thread2_mem.emplace_back(arena.Allocate(bytes));</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">  &#125;)</span></span>;<br><br>  t1.<span class="hljs-built_in">join</span>();<br>  t2.<span class="hljs-built_in">join</span>();<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-type">char</span>* ptr : thread1_mem) &#123;<br>    <span class="hljs-keyword">auto</span> iter = std::<span class="hljs-built_in">find</span>(thread2_mem.<span class="hljs-built_in">begin</span>(), thread2_mem.<span class="hljs-built_in">end</span>(), ptr);<br>    <span class="hljs-built_in">ASSERT_EQ</span>(iter, thread2_mem.<span class="hljs-built_in">end</span>());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重新编译并使用 <code>./leveldb_tests --gtest_filter=Arena*</code>命令运行，多运行几次就可能因为并发申请内存出错：</p><img src="/2024/06/14/LevelDB-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%89%EF%BC%9A%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%E4%B8%80%E8%A7%88/image-20240613000748609.png" class="" title="image-20240613000748609"><p>当然，也可能因为并发访问的原因（double free等）导致测试进程异常退出。</p><p>这一问题的修复在 LevelDB 的官方仓库中已有相关 PR，不过似乎由于LevelDB 缺乏维护，相关 PR 并没有被 merge。在笔者的 GitHub 仓库（<ahref="https://github.com/UnpureRationalist/leveldb">UnpureRationalist/leveldb)</a>）中，利用LevelDB 已有的接口（<code>port/port.h</code> 和<code>util/mutexlock.h</code>）实现了 <code>Arena</code>类的安全并发操作。</p><h2 id="编解码">2. 编解码</h2><p>负责编解码的代码为 <code>util/coding.h</code> 和<code>util/coding.cc</code>。根据源码注释，LevelDB采用了小端编码，支持对固定长度的数据和可变长度的字符串进行编码。对于字符串，先编码字符串的长度，然后存储字符串内容。其提供的部分接口包括：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Standard Put... routines append to a string</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PutFixed32</span><span class="hljs-params">(std::string* dst, <span class="hljs-type">uint32_t</span> value)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PutFixed64</span><span class="hljs-params">(std::string* dst, <span class="hljs-type">uint64_t</span> value)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PutVarint32</span><span class="hljs-params">(std::string* dst, <span class="hljs-type">uint32_t</span> value)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PutVarint64</span><span class="hljs-params">(std::string* dst, <span class="hljs-type">uint64_t</span> value)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PutLengthPrefixedSlice</span><span class="hljs-params">(std::string* dst, <span class="hljs-type">const</span> Slice&amp; value)</span></span>;<br><br><span class="hljs-comment">// Standard Get... routines parse a value from the beginning of a Slice</span><br><span class="hljs-comment">// and advance the slice past the parsed value.</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetVarint32</span><span class="hljs-params">(Slice* input, <span class="hljs-type">uint32_t</span>* value)</span></span>;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetVarint64</span><span class="hljs-params">(Slice* input, <span class="hljs-type">uint64_t</span>* value)</span></span>;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetLengthPrefixedSlice</span><span class="hljs-params">(Slice* input, Slice* result)</span></span>;<br><br><span class="hljs-comment">// Pointer-based variants of GetVarint...  These either store a value</span><br><span class="hljs-comment">// in *v and return a pointer just past the parsed value, or return</span><br><span class="hljs-comment">// nullptr on error.  These routines only look at bytes in the range</span><br><span class="hljs-comment">// [p..limit-1]</span><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">GetVarint32Ptr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* p, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* limit, <span class="hljs-type">uint32_t</span>* v)</span></span>;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">GetVarint64Ptr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* p, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* limit, <span class="hljs-type">uint64_t</span>* v)</span></span>;<br><br><span class="hljs-comment">// Returns the length of the varint32 or varint64 encoding of &quot;v&quot;</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">VarintLength</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> v)</span></span>;<br></code></pre></td></tr></table></figure><p>这些函数实现了对不同长度数据的编解码。需要注意的是，LevelDB 实现了对<code>uint32_t</code> 和 <code>uint64_t</code>类型的变长编码以节省存储空间，具体的编码方式为：每个字节的低 7位表示具体的数位，最高位表示是否有后续。具体的实现细节涉及一些位运算操作，本文不详细解释，感兴趣的读者请自行阅读相关代码。</p><h2 id="循环冗余校验">3. 循环冗余校验</h2><p><code>util/crc32c.h</code> 和 <code>util/crc32c.cc</code>源文件实现了 CRC32C循环冗余校验算法，用于数据完整性校验。这部分最重要的就是用于计算一段数据CRC32C 校验值的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Return the crc32c of data[0,n-1]</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">uint32_t</span> <span class="hljs-title">Value</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* data, <span class="hljs-type">size_t</span> n)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Extend</span>(<span class="hljs-number">0</span>, data, n); &#125;<br></code></pre></td></tr></table></figure><p>CRC32C 的具体实现代码本文不介绍。</p><h2 id="哈希函数">4. 哈希函数</h2><p><code>util/hash.h</code> 和 <code>util/hash.cc</code>源文件定义并实现了对变长数据的哈希值计算。接口如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">Hash</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* data, <span class="hljs-type">size_t</span> n, <span class="hljs-type">uint32_t</span> seed)</span></span>;<br></code></pre></td></tr></table></figure><p>哈希函数对长度为 <code>n</code>的输入数据的每个字节进行运算，得到一个哈希值。</p><h2 id="直方图统计数据">5. 直方图统计数据</h2><p>实现这一功能的是 <code>util/histogram.h</code> 和<code>util/histogram.cc</code> 源文件。接口定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Histogram</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Histogram</span>() &#123;&#125;<br>  ~<span class="hljs-built_in">Histogram</span>() &#123;&#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Clear</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">double</span> value)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Merge</span><span class="hljs-params">(<span class="hljs-type">const</span> Histogram&amp; other)</span></span>;<br><br>  <span class="hljs-function">std::string <span class="hljs-title">ToString</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">enum</span> &#123; kNumBuckets = <span class="hljs-number">154</span> &#125;;<br><br>  <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Median</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Percentile</span><span class="hljs-params">(<span class="hljs-type">double</span> p)</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Average</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">StandardDeviation</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">double</span> kBucketLimit[kNumBuckets];<br><br>  <span class="hljs-type">double</span> min_;<br>  <span class="hljs-type">double</span> max_;<br>  <span class="hljs-type">double</span> num_;<br>  <span class="hljs-type">double</span> sum_;<br>  <span class="hljs-type">double</span> sum_squares_;<br><br>  <span class="hljs-type">double</span> buckets_[kNumBuckets];<br>&#125;;<br></code></pre></td></tr></table></figure><p>这一类用于维护中位数等一些统计信息，实现代码只涉及到一些数学知识。</p><h2 id="日志">6. 日志</h2><p>负责日志的源文件为 <code>util/logging.h</code> 和<code>util/logging.cc</code> 。<code>logging.h</code>头文件中声明的接口有：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Append a human-readable printout of &quot;num&quot; to *str</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AppendNumberTo</span><span class="hljs-params">(std::string* str, <span class="hljs-type">uint64_t</span> num)</span></span>;<br><br><span class="hljs-comment">// Append a human-readable printout of &quot;value&quot; to *str.</span><br><span class="hljs-comment">// Escapes any non-printable characters found in &quot;value&quot;.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AppendEscapedStringTo</span><span class="hljs-params">(std::string* str, <span class="hljs-type">const</span> Slice&amp; value)</span></span>;<br><br><span class="hljs-comment">// Return a human-readable printout of &quot;num&quot;</span><br><span class="hljs-function">std::string <span class="hljs-title">NumberToString</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> num)</span></span>;<br><br><span class="hljs-comment">// Return a human-readable version of &quot;value&quot;.</span><br><span class="hljs-comment">// Escapes any non-printable characters found in &quot;value&quot;.</span><br><span class="hljs-function">std::string <span class="hljs-title">EscapeString</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; value)</span></span>;<br><br><span class="hljs-comment">// Parse a human-readable number from &quot;*in&quot; into *value.  On success,</span><br><span class="hljs-comment">// advances &quot;*in&quot; past the consumed number and sets &quot;*val&quot; to the</span><br><span class="hljs-comment">// numeric value.  Otherwise, returns false and leaves *in in an</span><br><span class="hljs-comment">// unspecified state.</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ConsumeDecimalNumber</span><span class="hljs-params">(Slice* in, <span class="hljs-type">uint64_t</span>* val)</span></span>;<br></code></pre></td></tr></table></figure><p>这些函数用于将数组、字符串等转换为人类可读的形式，并写入结果字符串。</p><h2 id="不析构类模板">7. 不析构类模板</h2><p>这一类模板（<code>util/no_destructor.h</code>）与之前介绍过的 <ahref="/2024/06/03/LevelDB-源码阅读二：操作系统接口封装/#singletonenv-单例模板类">SingletonEnv单例模板类</a>有点类似，也是实现了对象在预先分配的内存上构造，并不允许调用析构函数。具体代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Wraps an instance whose destructor is never called.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// This is intended for use with function-level static variables.</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> InstanceType&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NoDestructor</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... ConstructorArgTypes&gt;<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">NoDestructor</span><span class="hljs-params">(ConstructorArgTypes&amp;&amp;... constructor_args)</span> </span>&#123;<br>    <span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">sizeof</span>(instance_storage_) &gt;= <span class="hljs-built_in">sizeof</span>(InstanceType),<br>                  <span class="hljs-string">&quot;instance_storage_ is not large enough to hold the instance&quot;</span>);<br>    <span class="hljs-built_in">static_assert</span>(<br>        <span class="hljs-built_in">alignof</span>(<span class="hljs-keyword">decltype</span>(instance_storage_)) &gt;= <span class="hljs-built_in">alignof</span>(InstanceType),<br>        <span class="hljs-string">&quot;instance_storage_ does not meet the instance&#x27;s alignment requirement&quot;</span>);<br>    <span class="hljs-keyword">new</span> (&amp;instance_storage_)<br>        <span class="hljs-built_in">InstanceType</span>(std::forward&lt;ConstructorArgTypes&gt;(constructor_args)...);<br>  &#125;<br><br>  ~<span class="hljs-built_in">NoDestructor</span>() = <span class="hljs-keyword">default</span>;<br><br>  <span class="hljs-built_in">NoDestructor</span>(<span class="hljs-type">const</span> NoDestructor&amp;) = <span class="hljs-keyword">delete</span>;<br>  NoDestructor&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> NoDestructor&amp;) = <span class="hljs-keyword">delete</span>;<br><br>  <span class="hljs-function">InstanceType* <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;InstanceType*&gt;(&amp;instance_storage_);<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">typename</span> std::aligned_storage&lt;<span class="hljs-built_in">sizeof</span>(InstanceType),<br>                                <span class="hljs-built_in">alignof</span>(InstanceType)&gt;::type instance_storage_;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="随机数生成">8. 随机数生成</h2><p><code>util/random.h</code> 源文件中实现了一个生成随机数的类<code>Random</code>，部分代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// A very simple random number generator.  Not especially good at</span><br><span class="hljs-comment">// generating truly random bits, but good enough for our needs in this</span><br><span class="hljs-comment">// package.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Random</span> &#123;<br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">uint32_t</span> seed_;<br><br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Random</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> s)</span> : seed_(s &amp; <span class="hljs-number">0x7fffffff</span>u) &#123;</span><br>    <span class="hljs-comment">// Avoid bad seeds.</span><br>    <span class="hljs-keyword">if</span> (seed_ == <span class="hljs-number">0</span> || seed_ == <span class="hljs-number">2147483647L</span>) &#123;<br>      seed_ = <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">Next</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 具体实现省略</span><br>  &#125;<br>  <span class="hljs-comment">// Returns a uniformly distributed value in the range [0..n-1]</span><br>  <span class="hljs-comment">// REQUIRES: n &gt; 0</span><br>  <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">Uniform</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Next</span>() % n; &#125;<br><br>  <span class="hljs-comment">// Randomly returns true ~&quot;1/n&quot; of the time, and false otherwise.</span><br>  <span class="hljs-comment">// REQUIRES: n &gt; 0</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">OneIn</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123; <span class="hljs-keyword">return</span> (<span class="hljs-built_in">Next</span>() % n) == <span class="hljs-number">0</span>; &#125;<br><br>  <span class="hljs-comment">// Skewed: pick &quot;base&quot; uniformly from range [0,max_log] and then</span><br>  <span class="hljs-comment">// return &quot;base&quot; random bits.  The effect is to pick a number in the</span><br>  <span class="hljs-comment">// range [0,2^max_log-1] with exponential bias towards smaller numbers.</span><br>  <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">Skewed</span><span class="hljs-params">(<span class="hljs-type">int</span> max_log)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Uniform</span>(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">Uniform</span>(max_log + <span class="hljs-number">1</span>)); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中，最重要的就是 <code>uint32_t Next()</code>函数，用于生成下一个随机数。</p><h2 id="比较接口">9. 比较接口</h2><p><code>include/leveldb/comparator.h</code> 和<code>util/comparator.cc</code> 源文件实现 LevelDB中排序操作所需的比较操作的接口抽象和实现。由于 <code>Slice</code> 是LevelDB 中最关键的数据结构，<code>Key</code> 和 <code>Value</code> 都以<code>Slice</code> 类型表示，因此 <code>Compare</code>接口针对的类型就是 <code>Slice</code>，部分代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// A Comparator object provides a total order across slices that are</span><br><span class="hljs-comment">// used as keys in an sstable or a database.  A Comparator implementation</span><br><span class="hljs-comment">// must be thread-safe since leveldb may invoke its methods concurrently</span><br><span class="hljs-comment">// from multiple threads.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LEVELDB_EXPORT</span> Comparator &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Comparator</span>();<br><br>  <span class="hljs-comment">// 三路比较运算，大等小分别返回 1，0，-1</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">Compare</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; a, <span class="hljs-type">const</span> Slice&amp; b)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 返回比较器名称</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">Name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Advanced functions: these are used to reduce the space requirements</span><br>  <span class="hljs-comment">// for internal data structures like index blocks.</span><br><br>  <span class="hljs-comment">// If *start &lt; limit, changes *start to a short string in [start,limit).</span><br>  <span class="hljs-comment">// Simple comparator implementations may return with *start unchanged,</span><br>  <span class="hljs-comment">// i.e., an implementation of this method that does nothing is correct.</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">FindShortestSeparator</span><span class="hljs-params">(std::string* start,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">const</span> Slice&amp; limit)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Changes *key to a short string &gt;= *key.</span><br>  <span class="hljs-comment">// Simple comparator implementations may return with *key unchanged,</span><br>  <span class="hljs-comment">// i.e., an implementation of this method that does nothing is correct.</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">FindShortSuccessor</span><span class="hljs-params">(std::string* key)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在 <code>util/comparator.cc</code>源文件中，<code>BytewiseComparatorImpl</code> 类实现了上述接口，进行byte wise 的比较。其内部实现调用了 <code>Slice</code> 类型的<code>compare</code> 函数，相关代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BytewiseComparatorImpl</span> : <span class="hljs-keyword">public</span> Comparator &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">BytewiseComparatorImpl</span>() = <span class="hljs-keyword">default</span>;<br><br>  <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">Name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;leveldb.BytewiseComparator&quot;</span>; &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Compare</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; a, <span class="hljs-type">const</span> Slice&amp; b)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">compare</span>(b);<span class="hljs-comment">// 调用 Slice 类成员函数，进行逐字节比较</span><br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FindShortestSeparator</span><span class="hljs-params">(std::string* start,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">const</span> Slice&amp; limit)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    <span class="hljs-comment">// 省略</span><br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FindShortSuccessor</span><span class="hljs-params">(std::string* key)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    <span class="hljs-comment">// 省略</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>此外，该源文件中还用到了上文介绍的 <code>NoDestructor</code>类模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">const</span> Comparator* <span class="hljs-title">BytewiseComparator</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">static</span> NoDestructor&lt;BytewiseComparatorImpl&gt; singleton;<br>  <span class="hljs-keyword">return</span> singleton.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>用于返回全局唯一的逐字节比较器。</p><h2 id="总结">10. 总结</h2><p>以上就是对 LevelDB 中 <code>util</code>目录下部分源代码的介绍，涉及到的代码和功能较为繁杂。除了本文罗列的相关源文件，<code>util</code>目录下实际上还有一些我们之前已经介绍过的代码，如：<code>Env</code>、<code>Status</code>等；此外，还有少量源文件，因为篇幅限制，且其代码稍长或者比较重要，会在本系列的后续文章中进行介绍。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>读源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LevelDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LevelDB 源码阅读二：操作系统接口封装</title>
    <link href="/2024/06/03/LevelDB-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%BA%8C%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3%E5%B0%81%E8%A3%85/"/>
    <url>/2024/06/03/LevelDB-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%BA%8C%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3%E5%B0%81%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p>本文继续介绍 LevelDB 源码，重点是 LevelDB中对操作系统相关接口的封装，也即 <code>Env</code>接口及相关实现类。本文涉及的相关源码路径如下：</p><ul><li><code>include/leveldb/env.h</code></li><li><code>util/env.cc</code></li><li><code>util/posix_logger.h</code></li><li><code>util/env_posix.cc</code></li></ul><h2 id="env.h">1 env.h</h2><p>在 <code>include/leveldb/env.h</code>源文件中，定义了若干接口，用于对操作系统提供的功能进行接口的统一。这一点从源代码的注释可以看出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// An Env is an interface used by the leveldb implementation to access</span><br><span class="hljs-comment">// operating system functionality like the filesystem etc.  Callers</span><br><span class="hljs-comment">// may wish to provide a custom Env object when opening a database to</span><br><span class="hljs-comment">// get fine gain control; e.g., to rate limit file system operations.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// All Env implementations are safe for concurrent access from</span><br><span class="hljs-comment">// multiple threads without any external synchronization.</span><br></code></pre></td></tr></table></figure><p>在源文件中，最重要的类是虚基类 <code>Env</code>，它声明了提供以下功能的函数：</p><ul><li>创建不同类型的文件</li><li>判断文件是否存在</li><li>获取目录的所有文件名</li><li>删除文件</li><li>创建/删除目录</li><li>获取文件大小</li><li>重命名文件</li><li>获取/释放文件锁</li><li>线程/调度相关操作</li><li>创建日志文件</li><li>……</li></ul><p>除了 <code>Env</code>类，该源文件实际上还声明了一些表示不同类型文件的类，如：</p><ul><li><code>SequentialFile</code>：用于顺序读取文件的文件抽象。</li><li><code>RandomAccessFile</code>：用于随机读取文件内容的文件抽象。</li><li><code>WritableFile</code>：用于顺序写入的文件抽象。实现必须提供缓冲，因为调用者可以一次将小片段附加到文件中。</li><li><code>Logger</code>：用于写入日志消息的接口。</li></ul><p>不同类型的文件提供了不同的接口，这里不详细解释，后面会再次提及。</p><p>另外，还有用于多进程并发访问的文件锁 <code>FileLock</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Identifies a locked file.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LEVELDB_EXPORT</span> FileLock &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">FileLock</span>() = <span class="hljs-keyword">default</span>;<br><br>  <span class="hljs-built_in">FileLock</span>(<span class="hljs-type">const</span> FileLock&amp;) = <span class="hljs-keyword">delete</span>;<br>  FileLock&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> FileLock&amp;) = <span class="hljs-keyword">delete</span>;<br><br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">FileLock</span>();<br>&#125;;<br></code></pre></td></tr></table></figure><p>此外，该头文件中还声明了一些实用函数，包括：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Log the specified data to *info_log if info_log is non-null.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Log</span><span class="hljs-params">(Logger* info_log, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* format, ...)</span></span><br><span class="hljs-function"><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(__GNUC__) || defined(__clang__)</span></span><br><span class="hljs-function">    __<span class="hljs-title">attribute__</span><span class="hljs-params">((__format__(__printf__, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)))</span></span><br><span class="hljs-function"><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></span><br><span class="hljs-function">    </span>;<br><br><span class="hljs-comment">// A utility routine: write &quot;data&quot; to the named file.</span><br><span class="hljs-function">LEVELDB_EXPORT Status <span class="hljs-title">WriteStringToFile</span><span class="hljs-params">(Env* env, <span class="hljs-type">const</span> Slice&amp; data,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        <span class="hljs-type">const</span> std::string&amp; fname)</span></span>;<br><br><span class="hljs-comment">// A utility routine: read contents of named file into *data</span><br><span class="hljs-function">LEVELDB_EXPORT Status <span class="hljs-title">ReadFileToString</span><span class="hljs-params">(Env* env, <span class="hljs-type">const</span> std::string&amp; fname,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       std::string* data)</span></span>;<br></code></pre></td></tr></table></figure><p>它们分别用于写日志、写数据到文件和读文件到字符串。</p><p>最后，还有一个对 <code>Env</code> 类进行包装的<code>EnvWrapper</code> 类，提供给仅需要重写 <code>Env</code>部分接口的用户使用。其数据成员只包括一个执行某个 <code>Env</code>实现类的指针，部分代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// An implementation of Env that forwards all calls to another Env.</span><br><span class="hljs-comment">// May be useful to clients who wish to override just part of the</span><br><span class="hljs-comment">// functionality of another Env.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LEVELDB_EXPORT</span> EnvWrapper : <span class="hljs-keyword">public</span> Env &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// Initialize an EnvWrapper that delegates all calls to *t.</span><br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">EnvWrapper</span><span class="hljs-params">(Env* t)</span> : target_(t) &#123;</span>&#125;<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">EnvWrapper</span>();<br><br>  <span class="hljs-comment">// Return the target to which this Env forwards all calls.</span><br>  <span class="hljs-function">Env* <span class="hljs-title">target</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> target_; &#125;<br><br>  <span class="hljs-comment">// The following text is boilerplate that forwards all methods to target().</span><br>  <span class="hljs-function">Status <span class="hljs-title">NewSequentialFile</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; f, SequentialFile** r)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> target_-&gt;<span class="hljs-built_in">NewSequentialFile</span>(f, r);<br>  &#125;<br>  <span class="hljs-comment">// 其他接口都是类似的逻辑，调用 target_ 成员的对应函数</span><br><br> <span class="hljs-keyword">private</span>:<br>  Env* target_;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="env.cc">2. env.cc</h2><p><code>env.cc</code> 具体路径为 <code>util/env.cc</code>，其中对<code>env.h</code>源文件中部分声明（一些类的构造函数、析构函数、实用函数等）提供了定义。例如，前文提到的用于写日志、写数据到文件和读文件到字符串的函数，在此源文件中进行了实现，部分代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Log</span><span class="hljs-params">(Logger* info_log, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* format, ...)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (info_log != <span class="hljs-literal">nullptr</span>) &#123;<br>    std::va_list ap;<br>    <span class="hljs-built_in">va_start</span>(ap, format);<br>    info_log-&gt;<span class="hljs-built_in">Logv</span>(format, ap);<br>    <span class="hljs-built_in">va_end</span>(ap);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="posix_logger.h">3. posix_logger.h</h2><p>此源文件位于 <code>util/posix_logger.h</code>，用于实现 Posix环境下的 <code>Logger</code>接口。具体而言，该源文件中声明并实现了继承自 <code>Logger</code> 接口的<code>PosixLogger</code> 类。文件头的注释如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Logger implementation that can be shared by all environments</span><br><span class="hljs-comment">// where enough posix functionality is available.</span><br></code></pre></td></tr></table></figure><p><code>PosixLogger</code> 类的数据成员为一个 <code>std::FILE</code>类型的指针，通过调用 <code>std::FILE</code> 相关函数，实现了<code>Logger</code> 接口的 <code>Logv</code>函数。日志记录的信息包括：</p><ul><li>时间戳</li><li>线程 <code>id</code></li><li>日志信息</li></ul><p>一个示例输出如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">2024</span>/<span class="hljs-number">06</span>/<span class="hljs-number">03</span><span class="hljs-number">-17</span>:<span class="hljs-number">03</span>:<span class="hljs-number">49.672877</span> <span class="hljs-number">140472843178944</span> Just <span class="hljs-keyword">for</span> test log<br></code></pre></td></tr></table></figure><h2 id="env_posix.cc">4. env_posix.cc</h2><p>该源文件路径为 <code>util/env_posix.cc</code>，是 Posix 环境下对<code>Env</code>相关接口的实现。下面我们来看其涉及到的相关类或函数。</p><h3 id="limiter-类">4.1 Limiter 类</h3><p><code>Limiter</code> 是用于控制资源（只读文件描述符和<code>mmap</code>文件）使用数量的辅助类，以防止文件描述符或虚拟内存用尽，如注释所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Helper class to limit resource usage to avoid exhaustion.</span><br><span class="hljs-comment">// Currently used to limit read-only file descriptors and mmap file usage</span><br><span class="hljs-comment">// so that we do not run out of file descriptors or virtual memory, or run into</span><br><span class="hljs-comment">// kernel performance problems for very large databases.</span><br></code></pre></td></tr></table></figure><p>该类有一个成员变量，表示允许的最大资源数。有两个返回值类型为<code>bool</code> 的成员函数 <code>Acquire</code> 和<code>Release</code> 分别表示获取和释放资源。</p><h3 id="相关文件实现">4.2 相关文件实现</h3><p>前文提到，<code>env.h</code>头文件中声明了若干表示不同类型文件的接口。这一小节介绍 Posix环境下对这些接口的实现类。涉及到的具体实现类有：</p><ul><li><p><code>PosixSequentialFile</code>：使用 <code>read()</code>实现对文件的顺序读访问。其数据成员包括文件描述符和文件名。其使用 Linux下的系统调用 <code>::read(fd_, scratch, n)</code> 实现<code>SequentialFile</code> 定义的接口。</p></li><li><p><code>PosixRandomAccessFile</code>：使用 <code>pread()</code>实现对文件的随机读访问。其包含的数据成员和实现的接口如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PosixRandomAccessFile</span> <span class="hljs-keyword">final</span> : <span class="hljs-keyword">public</span> RandomAccessFile &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// The new instance takes ownership of |fd|. |fd_limiter| must outlive this</span><br>  <span class="hljs-comment">// instance, and will be used to determine if .</span><br>  <span class="hljs-built_in">PosixRandomAccessFile</span>(std::string filename, <span class="hljs-type">int</span> fd, Limiter* fd_limiter)<br>      : <span class="hljs-built_in">has_permanent_fd_</span>(fd_limiter-&gt;<span class="hljs-built_in">Acquire</span>()),<br>        <span class="hljs-built_in">fd_</span>(has_permanent_fd_ ? fd : <span class="hljs-number">-1</span>),<br>        <span class="hljs-built_in">fd_limiter_</span>(fd_limiter),<br>        <span class="hljs-built_in">filename_</span>(std::<span class="hljs-built_in">move</span>(filename)) &#123;<br>    <span class="hljs-comment">// 省略</span><br>  &#125;<br><br>  ~<span class="hljs-built_in">PosixRandomAccessFile</span>() <span class="hljs-keyword">override</span> &#123;<br>    <span class="hljs-comment">// 省略</span><br>  &#125;<br><br>  <span class="hljs-function">Status <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> offset, <span class="hljs-type">size_t</span> n, Slice* result,</span></span><br><span class="hljs-params"><span class="hljs-function">              <span class="hljs-type">char</span>* scratch)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    <span class="hljs-comment">// 省略</span><br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">const</span> <span class="hljs-type">bool</span> has_permanent_fd_;  <span class="hljs-comment">// If false, the file is opened on every read.</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> fd_;                 <span class="hljs-comment">// -1 if has_permanent_fd_ is false.</span><br>  Limiter* <span class="hljs-type">const</span> fd_limiter_;<br>  <span class="hljs-type">const</span> std::string filename_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在 <code>Read</code> 接口中，调用 Linux 系统调用<code>::pread(fd, scratch, n, static_cast&lt;off_t&gt;(offset))</code>完成对数据的随机读取。</p></li><li><p><code>PosixMmapReadableFile</code>：使用 <code>mmap()</code>实现对文件的随机读访问。该类也是对 <code>RandomAccessFile</code>接口的实现。其数据成员和函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PosixMmapReadableFile</span> <span class="hljs-keyword">final</span> : <span class="hljs-keyword">public</span> RandomAccessFile &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// mmap_base[0, length-1] points to the memory-mapped contents of the file. It</span><br>  <span class="hljs-comment">// must be the result of a successful call to mmap(). This instances takes</span><br>  <span class="hljs-comment">// over the ownership of the region.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// |mmap_limiter| must outlive this instance. The caller must have already</span><br>  <span class="hljs-comment">// acquired the right to use one mmap region, which will be released when this</span><br>  <span class="hljs-comment">// instance is destroyed.</span><br>  <span class="hljs-built_in">PosixMmapReadableFile</span>(std::string filename, <span class="hljs-type">char</span>* mmap_base, <span class="hljs-type">size_t</span> length,<br>                        Limiter* mmap_limiter)<br>      : <span class="hljs-built_in">mmap_base_</span>(mmap_base),<br>        <span class="hljs-built_in">length_</span>(length),<br>        <span class="hljs-built_in">mmap_limiter_</span>(mmap_limiter),<br>        <span class="hljs-built_in">filename_</span>(std::<span class="hljs-built_in">move</span>(filename)) &#123;&#125;<br><br>  ~<span class="hljs-built_in">PosixMmapReadableFile</span>() <span class="hljs-keyword">override</span> &#123;<br>    <span class="hljs-comment">// 省略 需释放 mmap 映射的内存</span><br>  &#125;<br><br>  <span class="hljs-function">Status <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> offset, <span class="hljs-type">size_t</span> n, Slice* result,</span></span><br><span class="hljs-params"><span class="hljs-function">              <span class="hljs-type">char</span>* scratch)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    <span class="hljs-comment">// 省略</span><br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">char</span>* <span class="hljs-type">const</span> mmap_base_;<span class="hljs-comment">// 指向通过 mmap() 映射的文件内容的基地址</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> length_;<span class="hljs-comment">// 映射区域的长度</span><br>  Limiter* <span class="hljs-type">const</span> mmap_limiter_;<br>  <span class="hljs-type">const</span> std::string filename_;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><code>PosixWritableFile</code>：实现了 <code>WritableFile</code>可写文件接口。其相关数据成员和函数定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PosixWritableFile</span> <span class="hljs-keyword">final</span> : <span class="hljs-keyword">public</span> WritableFile &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">PosixWritableFile</span>(std::string filename, <span class="hljs-type">int</span> fd)<br>      : <span class="hljs-built_in">pos_</span>(<span class="hljs-number">0</span>),<br>        <span class="hljs-built_in">fd_</span>(fd),<br>        <span class="hljs-built_in">is_manifest_</span>(<span class="hljs-built_in">IsManifest</span>(filename)),<br>        <span class="hljs-built_in">filename_</span>(std::<span class="hljs-built_in">move</span>(filename)),<br>        <span class="hljs-built_in">dirname_</span>(<span class="hljs-built_in">Dirname</span>(filename_)) &#123;&#125;<br><br>  ~<span class="hljs-built_in">PosixWritableFile</span>() <span class="hljs-keyword">override</span> &#123;<br>    <span class="hljs-comment">// 省略</span><br>  &#125;<br><br>  <span class="hljs-function">Status <span class="hljs-title">Append</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; data)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    <span class="hljs-comment">// 省略</span><br>  &#125;<br><br>  <span class="hljs-function">Status <span class="hljs-title">Close</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    <span class="hljs-comment">// 省略</span><br>  &#125;<br><br>  <span class="hljs-function">Status <span class="hljs-title">Flush</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">FlushBuffer</span>(); &#125;<br><br>  <span class="hljs-function">Status <span class="hljs-title">Sync</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    <span class="hljs-comment">// 省略</span><br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// 省略部分成员函数</span><br><br>  <span class="hljs-comment">// buf_[0, pos_ - 1] contains data to be written to fd_.</span><br>  <span class="hljs-type">char</span> buf_[kWritableFileBufferSize];<br>  <span class="hljs-type">size_t</span> pos_;<br>  <span class="hljs-type">int</span> fd_;<br><br>  <span class="hljs-type">const</span> <span class="hljs-type">bool</span> is_manifest_;  <span class="hljs-comment">// True if the file&#x27;s name starts with MANIFEST.</span><br>  <span class="hljs-type">const</span> std::string filename_;<br>  <span class="hljs-type">const</span> std::string dirname_;  <span class="hljs-comment">// The directory of filename_.</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个类在内部调用 Linux 的 <code>read</code>、<code>write</code>等系统调用，实现了可写文件接口。</p></li></ul><h3 id="posixfilelock-类">4.3 PosixFileLock 类</h3><p>这一类实现了 <code>FileLock</code> 接口，其代码比较简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Instances are thread-safe because they are immutable.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PosixFileLock</span> : <span class="hljs-keyword">public</span> FileLock &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">PosixFileLock</span>(<span class="hljs-type">int</span> fd, std::string filename)<br>      : <span class="hljs-built_in">fd_</span>(fd), <span class="hljs-built_in">filename_</span>(std::<span class="hljs-built_in">move</span>(filename)) &#123;&#125;<br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fd</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> fd_; &#125;<br>  <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">filename</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> filename_; &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> fd_;<br>  <span class="hljs-type">const</span> std::string filename_;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="posixlocktable-类">4.4 PosixLockTable 类</h3><p><code>PosixLockTable</code> 类也非常简单：使用一个 <code>set</code>追踪文件释放被 <code>LockFile</code> 加锁，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Tracks the files locked by PosixEnv::LockFile().</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// We maintain a separate set instead of relying on fcntl(F_SETLK) because</span><br><span class="hljs-comment">// fcntl(F_SETLK) does not provide any protection against multiple uses from the</span><br><span class="hljs-comment">// same process.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Instances are thread-safe because all member data is guarded by a mutex.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PosixLockTable</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; fname)</span> <span class="hljs-title">LOCKS_EXCLUDED</span><span class="hljs-params">(mu_)</span> </span>&#123;<br>    mu_.<span class="hljs-built_in">Lock</span>();<br>    <span class="hljs-type">bool</span> succeeded = locked_files_.<span class="hljs-built_in">insert</span>(fname).second;<br>    mu_.<span class="hljs-built_in">Unlock</span>();<br>    <span class="hljs-keyword">return</span> succeeded;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Remove</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; fname)</span> <span class="hljs-title">LOCKS_EXCLUDED</span><span class="hljs-params">(mu_)</span> </span>&#123;<br>    mu_.<span class="hljs-built_in">Lock</span>();<br>    locked_files_.<span class="hljs-built_in">erase</span>(fname);<br>    mu_.<span class="hljs-built_in">Unlock</span>();<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  port::Mutex mu_;<br>  <span class="hljs-function">std::set&lt;std::string&gt; locked_files_ <span class="hljs-title">GUARDED_BY</span><span class="hljs-params">(mu_)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="posixenv-类">4.5 PosixEnv 类</h3><p>这个类实现了 <code>Env</code> 接口。部分代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PosixEnv</span> : <span class="hljs-keyword">public</span> Env &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">PosixEnv</span>();<br>  ~<span class="hljs-built_in">PosixEnv</span>() <span class="hljs-keyword">override</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> msg[] =<br>        <span class="hljs-string">&quot;PosixEnv singleton destroyed. Unsupported behavior!\n&quot;</span>;<br>    std::<span class="hljs-built_in">fwrite</span>(msg, <span class="hljs-number">1</span>, <span class="hljs-built_in">sizeof</span>(msg), stderr);<br>    std::<span class="hljs-built_in">abort</span>();<span class="hljs-comment">// 析构函数有定义，但是不允许调用</span><br>  &#125;<br><br>  <span class="hljs-function">Status <span class="hljs-title">NewSequentialFile</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; filename,</span></span><br><span class="hljs-params"><span class="hljs-function">                           SequentialFile** result)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    <span class="hljs-type">int</span> fd = ::<span class="hljs-built_in">open</span>(filename.<span class="hljs-built_in">c_str</span>(), O_RDONLY | kOpenBaseFlags);<span class="hljs-comment">// 打开文件</span><br>    <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) &#123;<br>      *result = <span class="hljs-literal">nullptr</span>;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">PosixError</span>(filename, errno);<br>    &#125;<br><br>    *result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">PosixSequentialFile</span>(filename, fd);<span class="hljs-comment">// 构造 PosixSequentialFile</span><br>    <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">OK</span>();<br>  &#125;<br><br>  <span class="hljs-function">Status <span class="hljs-title">NewRandomAccessFile</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; filename,</span></span><br><span class="hljs-params"><span class="hljs-function">                             RandomAccessFile** result)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>   <span class="hljs-comment">// 省略</span><br>  &#125;<br><br>  <span class="hljs-function">Status <span class="hljs-title">NewWritableFile</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; filename,</span></span><br><span class="hljs-params"><span class="hljs-function">                         WritableFile** result)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    <span class="hljs-comment">// 省略</span><br>  &#125;<br><br>  <span class="hljs-function">Status <span class="hljs-title">NewAppendableFile</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; filename,</span></span><br><span class="hljs-params"><span class="hljs-function">                           WritableFile** result)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    <span class="hljs-comment">// 省略</span><br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">FileExists</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; filename)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">access</span>(filename.<span class="hljs-built_in">c_str</span>(), F_OK) == <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-function">Status <span class="hljs-title">GetChildren</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; directory_path,</span></span><br><span class="hljs-params"><span class="hljs-function">                     std::vector&lt;std::string&gt;* result)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    <span class="hljs-comment">// 省略</span><br>  &#125;<br><br>  <span class="hljs-function">Status <span class="hljs-title">RemoveFile</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; filename)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    <span class="hljs-comment">// 省略</span><br>  &#125;<br><br>  <span class="hljs-function">Status <span class="hljs-title">CreateDir</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; dirname)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    <span class="hljs-comment">// 省略</span><br>  &#125;<br><br>  <span class="hljs-function">Status <span class="hljs-title">RemoveDir</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; dirname)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (::<span class="hljs-built_in">rmdir</span>(dirname.<span class="hljs-built_in">c_str</span>()) != <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">PosixError</span>(dirname, errno);<br>    &#125;<br>    <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">OK</span>();<br>  &#125;<br><br>  <span class="hljs-function">Status <span class="hljs-title">GetFileSize</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; filename, <span class="hljs-type">uint64_t</span>* size)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    <span class="hljs-comment">// 省略</span><br>  &#125;<br><br>  <span class="hljs-function">Status <span class="hljs-title">RenameFile</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; from, <span class="hljs-type">const</span> std::string&amp; to)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    <span class="hljs-comment">// 省略</span><br>  &#125;<br><br>  <span class="hljs-function">Status <span class="hljs-title">LockFile</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; filename, FileLock** lock)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    *lock = <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-type">int</span> fd = ::<span class="hljs-built_in">open</span>(filename.<span class="hljs-built_in">c_str</span>(), O_RDWR | O_CREAT | kOpenBaseFlags, <span class="hljs-number">0644</span>);<br>    <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">PosixError</span>(filename, errno);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!locks_.<span class="hljs-built_in">Insert</span>(filename)) &#123;<br>      ::<span class="hljs-built_in">close</span>(fd);<br>      <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">IOError</span>(<span class="hljs-string">&quot;lock &quot;</span> + filename, <span class="hljs-string">&quot;already held by process&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">LockOrUnlock</span>(fd, <span class="hljs-literal">true</span>) == <span class="hljs-number">-1</span>) &#123;<br>      <span class="hljs-type">int</span> lock_errno = errno;<br>      ::<span class="hljs-built_in">close</span>(fd);<br>      locks_.<span class="hljs-built_in">Remove</span>(filename);<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">PosixError</span>(<span class="hljs-string">&quot;lock &quot;</span> + filename, lock_errno);<br>    &#125;<br><br>    *lock = <span class="hljs-keyword">new</span> <span class="hljs-built_in">PosixFileLock</span>(fd, filename);<br>    <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">OK</span>();<br>  &#125;<br><br>  <span class="hljs-function">Status <span class="hljs-title">UnlockFile</span><span class="hljs-params">(FileLock* lock)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    <span class="hljs-comment">// 省略</span><br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Schedule</span><span class="hljs-params">(<span class="hljs-type">void</span> (*background_work_function)(<span class="hljs-type">void</span>* background_work_arg),</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-type">void</span>* background_work_arg)</span> <span class="hljs-keyword">override</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StartThread</span><span class="hljs-params">(<span class="hljs-type">void</span> (*thread_main)(<span class="hljs-type">void</span>* thread_main_arg),</span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-type">void</span>* thread_main_arg)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">new_thread</span><span class="hljs-params">(thread_main, thread_main_arg)</span></span>;<br>    new_thread.<span class="hljs-built_in">detach</span>();<br>  &#125;<br><br>  <span class="hljs-function">Status <span class="hljs-title">GetTestDirectory</span><span class="hljs-params">(std::string* result)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    <span class="hljs-comment">// 省略</span><br>  &#125;<br><br>  <span class="hljs-function">Status <span class="hljs-title">NewLogger</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; filename, Logger** result)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    <span class="hljs-comment">// 省略</span><br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">NowMicros</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    <span class="hljs-comment">// 省略</span><br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SleepForMicroseconds</span><span class="hljs-params">(<span class="hljs-type">int</span> micros)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">microseconds</span>(micros));<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// 省略部分私有成员函数</span><br><br>  port::Mutex background_work_mutex_;<br>  <span class="hljs-function">port::CondVar background_work_cv_ <span class="hljs-title">GUARDED_BY</span><span class="hljs-params">(background_work_mutex_)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">bool</span> started_background_thread_ <span class="hljs-title">GUARDED_BY</span><span class="hljs-params">(background_work_mutex_)</span></span>;<br><br>  <span class="hljs-function">std::queue&lt;BackgroundWorkItem&gt; background_work_queue_</span><br><span class="hljs-function">      <span class="hljs-title">GUARDED_BY</span><span class="hljs-params">(background_work_mutex_)</span></span>;<span class="hljs-comment">// 后台任务队列</span><br><br>  PosixLockTable locks_;  <span class="hljs-comment">// Thread-safe.</span><br>  Limiter mmap_limiter_;  <span class="hljs-comment">// Thread-safe.</span><br>  Limiter fd_limiter_;    <span class="hljs-comment">// Thread-safe.</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>PosixEnv</code> 类中的 <code>NewxxxFile</code>函数中，调用前文介绍的 <code>PosixxxxFile</code>创建相应类型的文件。其他的文件/目录相关操作，通过调用 Linux系统提供的接口实现。</p><p>需要注意的是 <code>LockFile</code> 和 <code>UnlockFile</code>函数中，调用了 <code>LockOrUnlock</code>函数进行加锁或解锁，函数定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LockOrUnlock</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">bool</span> lock)</span> </span>&#123;<br>  errno = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">struct</span> ::flock file_lock_info;<br>  std::<span class="hljs-built_in">memset</span>(&amp;file_lock_info, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(file_lock_info));<br>  file_lock_info.l_type = (lock ? F_WRLCK : F_UNLCK);<span class="hljs-comment">// 加锁 (F_WRLCK) 或解锁 (F_UNLCK)</span><br>  file_lock_info.l_whence = SEEK_SET;<br>  file_lock_info.l_start = <span class="hljs-number">0</span>;<br>  file_lock_info.l_len = <span class="hljs-number">0</span>;  <span class="hljs-comment">// Lock/unlock entire file.</span><br>  <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">fcntl</span>(fd, F_SETLK, &amp;file_lock_info);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，通过 <code>fcntl</code>系统调用，设置文件锁。<code>struct ::flock</code>成员的相关设置含义如下：</p><ul><li><code>l_whence</code> 设置为<code>SEEK_SET</code>，表示锁操作的起始位置为文件的开头。</li><li><code>l_start</code> 设置为<code>0</code>，表示从文件开头位置开始加锁或解锁。</li><li><code>l_len</code> 设置为 <code>0</code>，表示锁定整个文件。</li></ul><p>在 <code>PosixEnv</code>类中，还有一些相关成员函数用于执行后台任务，相关函数包括：</p><ul><li><code>void PosixEnv::BackgroundThreadMain()</code></li><li><code>void PosixEnv::Schedule(void (*background_work_function)(void* background_work_arg), void* background_work_arg)</code></li></ul><p>具体代码这里不详细介绍。</p><h3 id="singletonenv-单例模板类">4.6 SingletonEnv 单例模板类</h3><p>对操作系统环境的封装在整个项目中仅需要一个对象，因此这里利用单例模式来实现，利用模板类包装<code>Env</code> 实现类的唯一对象。相关代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Wraps an Env instance whose destructor is never created.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Intended usage:</span><br><span class="hljs-comment">//   using PlatformSingletonEnv = SingletonEnv&lt;PlatformEnv&gt;;</span><br><span class="hljs-comment">//   void ConfigurePosixEnv(int param) &#123;</span><br><span class="hljs-comment">//     PlatformSingletonEnv::AssertEnvNotInitialized();</span><br><span class="hljs-comment">//     // set global configuration flags.</span><br><span class="hljs-comment">//   &#125;</span><br><span class="hljs-comment">//   Env* Env::Default() &#123;</span><br><span class="hljs-comment">//     static PlatformSingletonEnv default_env;</span><br><span class="hljs-comment">//     return default_env.env();</span><br><span class="hljs-comment">//   &#125;</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> EnvType&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonEnv</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">SingletonEnv</span>() &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(NDEBUG)</span><br>    env_initialized_.<span class="hljs-built_in">store</span>(<span class="hljs-literal">true</span>, std::memory_order_relaxed);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">// !defined(NDEBUG)</span></span><br>    <span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">sizeof</span>(env_storage_) &gt;= <span class="hljs-built_in">sizeof</span>(EnvType),<br>                  <span class="hljs-string">&quot;env_storage_ will not fit the Env&quot;</span>);<br>    <span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">alignof</span>(<span class="hljs-keyword">decltype</span>(env_storage_)) &gt;= <span class="hljs-built_in">alignof</span>(EnvType),<br>                  <span class="hljs-string">&quot;env_storage_ does not meet the Env&#x27;s alignment needs&quot;</span>);<br>    <span class="hljs-keyword">new</span> (&amp;env_storage_) <span class="hljs-built_in">EnvType</span>();<span class="hljs-comment">// inplace new，原地调用构造函数</span><br>  &#125;<br>  ~<span class="hljs-built_in">SingletonEnv</span>() = <span class="hljs-keyword">default</span>;<br><br>  <span class="hljs-built_in">SingletonEnv</span>(<span class="hljs-type">const</span> SingletonEnv&amp;) = <span class="hljs-keyword">delete</span>;<br>  SingletonEnv&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> SingletonEnv&amp;) = <span class="hljs-keyword">delete</span>;<span class="hljs-comment">// 显式不允许拷贝</span><br><br>  <span class="hljs-function">Env* <span class="hljs-title">env</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;Env*&gt;(&amp;env_storage_); &#125;<span class="hljs-comment">// 强制类型转换获取 Env 对象</span><br><br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">AssertEnvNotInitialized</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(NDEBUG)</span><br>    <span class="hljs-built_in">assert</span>(!env_initialized_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed));<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">// !defined(NDEBUG)</span></span><br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">typename</span> std::aligned_storage&lt;<span class="hljs-built_in">sizeof</span>(EnvType), <span class="hljs-built_in">alignof</span>(EnvType)&gt;::type<br>      env_storage_;<span class="hljs-comment">// 存储 Env 实现类对象的内存空间</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(NDEBUG)</span><br>  <span class="hljs-type">static</span> std::atomic&lt;<span class="hljs-type">bool</span>&gt; env_initialized_;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">// !defined(NDEBUG)</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><p>利用这个单例模板类，实现了 <code>env.h</code>头文件中的静态接口，获取 LevelDB 默认的环境对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Env* <span class="hljs-title">Env::Default</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">static</span> PosixDefaultEnv env_container;<br>  <span class="hljs-keyword">return</span> env_container.<span class="hljs-built_in">env</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结">5. 总结</h2><p>本文介绍了 LevelDB 对操作系统接口提供封装涉及的相关代码。通过<code>env.h</code> 头文件定义了相关接口，在 <code>env_posix.cc</code>源文件中，实现类对 Posix 系统的 API 进行封装，转换为 <code>env.h</code>中定义的接口，供 LevelDB其余部分使用。为了包装系统环境的一致性，使用单例模式，保证运行时仅有一个<code>Env</code> 依赖。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>读源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LevelDB</tag>
      
      <tag>单例模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LevelDB 源码阅读一：基础数据结构</title>
    <link href="/2024/05/29/LevelDB-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2024/05/29/LevelDB-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>继上文搭建完 LevelDB 调试环境后，我们开始阅读源码。本文介绍 LevelDB中最基础的一些数据结构，按照源文件组织的层次结构，自底向上阅读源码。本文涉及的主要源代码包括以下文件：</p><ul><li><code>include/leveldb/export.h</code></li><li><code>include/leveldb/slice.h</code></li><li><code>port/thread_annotations.h</code></li><li><code>port/port_stdcxx.h</code></li><li><code>port/port.h</code></li><li><code>include/leveldb/status.h</code> 和<code>util/status.cc</code></li></ul><h2 id="export.h">1. export.h</h2><p><code>include/leveldb/export.h</code> 头文件用于 LevelDB中控制编译导出符号。在 <code>include/leveldb</code>文件夹下的头文件中，许多函数/类的声明中都添加了<code>LEVELDB_EXPORT</code> 宏，这个宏在 <code>CMakeLists.txt</code>文件中有相关的定义与使用。通过编译时的宏定义，<code>LEVELDB_EXPORT</code>宏在不同的编译器下有不同的定义，如：Linux 下的<code>__attribute__((visibility("default")))</code> 和 Windows MSVC 下的<code>__declspec(dllexport)</code>。</p><p>搞明白这一点后，后续阅读代码遇到类似下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LEVELDB_EXPORT</span> Slice;<br></code></pre></td></tr></table></figure><p>就可以简单的忽略其中的宏<code>LEVELDB_EXPORT</code>，它不影响代码的逻辑。</p><h2 id="slice.h">2. slice.h</h2><p><code>Slice</code> 类（<code>include/leveldb/slice.h</code>）是LevelDB 中重要的基础数据结构，很多数据库的操作，如插入、删除等接口，都以<code>Slice</code> 类型作为参数。</p><p><code>Slice</code>类含义如其命名一样：切片，它是对底层字符串的索引，仅存储字符串的起点指针和长度，而不控制字符串的生命期。因此，使用者必须保证<code>Slice</code> 引用的字符串的生命期长于 <code>Slice</code>对象的生命期，否则可能引发难以排查的 bug。</p><p><code>Slice</code> 提供了以下接口：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LEVELDB_EXPORT</span> Slice &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Slice</span>() : <span class="hljs-built_in">data_</span>(<span class="hljs-string">&quot;&quot;</span>), <span class="hljs-built_in">size_</span>(<span class="hljs-number">0</span>) &#123;&#125;<br><br>  <span class="hljs-built_in">Slice</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* d, <span class="hljs-type">size_t</span> n) : <span class="hljs-built_in">data_</span>(d), <span class="hljs-built_in">size_</span>(n) &#123;&#125;<br><br>  <span class="hljs-built_in">Slice</span>(<span class="hljs-type">const</span> std::string&amp; s) : <span class="hljs-built_in">data_</span>(s.<span class="hljs-built_in">data</span>()), <span class="hljs-built_in">size_</span>(s.<span class="hljs-built_in">size</span>()) &#123;&#125;<br><br>  <span class="hljs-built_in">Slice</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s) : <span class="hljs-built_in">data_</span>(s), <span class="hljs-built_in">size_</span>(<span class="hljs-built_in">strlen</span>(s)) &#123;&#125;<br><br>  <span class="hljs-comment">// Intentionally copyable.</span><br>  <span class="hljs-built_in">Slice</span>(<span class="hljs-type">const</span> Slice&amp;) = <span class="hljs-keyword">default</span>;<br>  Slice&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Slice&amp;) = <span class="hljs-keyword">default</span>;<br><br>  <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">data</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data_; &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> size_; &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> size_ == <span class="hljs-number">0</span>; &#125;<br><br>  <span class="hljs-type">char</span> <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> n) <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-built_in">assert</span>(n &lt; <span class="hljs-built_in">size</span>());<br>    <span class="hljs-keyword">return</span> data_[n];<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;<br>    data_ = <span class="hljs-string">&quot;&quot;</span>;<br>    size_ = <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Drop the first &quot;n&quot; bytes from this slice.</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove_prefix</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n)</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(n &lt;= <span class="hljs-built_in">size</span>());<br>    data_ += n;<br>    size_ -= n;<br>  &#125;<br><br>  <span class="hljs-comment">// Return a string that contains the copy of the referenced data.</span><br>  <span class="hljs-function">std::string <span class="hljs-title">ToString</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">string</span>(data_, size_); &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; b)</span> <span class="hljs-type">const</span></span>;<br><br>  <span class="hljs-comment">// Return true iff &quot;x&quot; is a prefix of &quot;*this&quot;</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">starts_with</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; x)</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ((size_ &gt;= x.size_) &amp;&amp; (<span class="hljs-built_in">memcmp</span>(data_, x.data_, x.size_) == <span class="hljs-number">0</span>));<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* data_;<br>  <span class="hljs-type">size_t</span> size_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看出，<code>Slice</code> 提供了多种构造函数，可以从标准 C字符串和 C++ string 构造 <code>Slice</code>对象，并且显式地允许了拷贝构造和拷贝赋值操作。除了构造函数，<code>Slice</code>提供的接口绝大多数是只读的，即带了 <code>const</code> 声明。</p><h2 id="thread_annotations.h">3. thread_annotations.h</h2><p>该头文件所在路径为 <code>port/thread_annotations.h</code>。这一头文件的用途在注释中已经说明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Use Clang&#x27;s thread safety analysis annotations when available. In other</span><br><span class="hljs-comment">// environments, the macros receive empty definitions.</span><br><span class="hljs-comment">// Usage documentation: https://clang.llvm.org/docs/ThreadSafetyAnalysis.html</span><br></code></pre></td></tr></table></figure><p>注释中的链接放在这里：<ahref="https://clang.llvm.org/docs/ThreadSafetyAnalysis.html">https://clang.llvm.org/docs/ThreadSafetyAnalysis.html</a>。简而言之，这个头文件的作用就是在 <code>clang</code> 编译环境下，启用<code>clang</code>提供的线程安全静态分析功能；而在其他编译环境下，宏定义为空，无任何操作。关于Thread Safety Analysis 的使用方法，可参考上面链接，这里不详细介绍。</p><h2 id="port_stdcxx.h">4. port_stdcxx.h</h2><p>本头文件路径为<code>port/port_stdcxx.h</code>。实际上，<code>port</code>目录下所有源代码的目的已经在 <code>README.md</code> 文件中说明：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">This directory contains interfaces and implementations that isolate the<br>rest of the package from platform details.<br><br>Code in the rest of the package includes &quot;port.h&quot; from this directory.<br>&quot;port.h&quot; in turn includes a platform specific &quot;port<span class="hljs-emphasis">_<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">platform</span>&gt;</span></span>.h&quot; file</span><br><span class="hljs-emphasis">that provides the platform specific implementation.</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">See port_</span>stdcxx.h for an example of what must be provided in a platform<br>specific header file.<br></code></pre></td></tr></table></figure><p>这个目录中定义的接口是为了隔离 LevelDB中其余代码与具体平台。<code>port_stdcxx.h</code>头文件就是一个示例代码，说明了 LevelDB剩余部分需要依赖哪些与平台相关的接口。</p><p>在 <code>port_stdcxx.h</code>源代码中，首先根据编译环境是否包含某些包，决定是否包含相应的头文件，如下面的<code>zstd</code> 压缩相关的包：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZSTD_STATIC_LINKING_ONLY  <span class="hljs-comment">// For ZSTD_compressionParameters.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;zstd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">// HAVE_ZSTD</span></span><br></code></pre></td></tr></table></figure><p>然后，对 C++ 标准库提供的一些组件进行封装，如对 <code>mutex</code>封装：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Thinly wraps std::mutex.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LOCKABLE</span> Mutex &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Mutex</span>() = <span class="hljs-keyword">default</span>;<br>  ~<span class="hljs-built_in">Mutex</span>() = <span class="hljs-keyword">default</span>;<br><br>  <span class="hljs-built_in">Mutex</span>(<span class="hljs-type">const</span> Mutex&amp;) = <span class="hljs-keyword">delete</span>;<br>  Mutex&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Mutex&amp;) = <span class="hljs-keyword">delete</span>;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Lock</span><span class="hljs-params">()</span> <span class="hljs-title">EXCLUSIVE_LOCK_FUNCTION</span><span class="hljs-params">()</span> </span>&#123; mu_.<span class="hljs-built_in">lock</span>(); &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Unlock</span><span class="hljs-params">()</span> <span class="hljs-title">UNLOCK_FUNCTION</span><span class="hljs-params">()</span> </span>&#123; mu_.<span class="hljs-built_in">unlock</span>(); &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AssertHeld</span><span class="hljs-params">()</span> <span class="hljs-title">ASSERT_EXCLUSIVE_LOCK</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CondVar</span>;<br>  std::mutex mu_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>类似地，<code>CondVar</code> 对条件变量进行封装。</p><p>下面，则是对一些依赖包的接口进行封装，如压缩相关的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">Snappy_Compress</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* input, <span class="hljs-type">size_t</span> length,</span></span><br><span class="hljs-params"><span class="hljs-function">                            std::string* output)</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> HAVE_SNAPPY</span><br>  output-&gt;<span class="hljs-built_in">resize</span>(snappy::<span class="hljs-built_in">MaxCompressedLength</span>(length));<br>  <span class="hljs-type">size_t</span> outlen;<br>  snappy::<span class="hljs-built_in">RawCompress</span>(input, length, &amp;(*output)[<span class="hljs-number">0</span>], &amp;outlen);<br>  output-&gt;<span class="hljs-built_in">resize</span>(outlen);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  <span class="hljs-comment">// Silence compiler warnings about unused arguments.</span><br>  (<span class="hljs-type">void</span>)input;<br>  (<span class="hljs-type">void</span>)length;<br>  (<span class="hljs-type">void</span>)output;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">// HAVE_SNAPPY</span></span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据编译环境是否有对应的包，条件编译生成不同的代码。</p><h2 id="port.h">5. port.h</h2><p><code>port.h</code> 头文件是 LevelDB其余部分真正进行包含的头文件，其源码非常简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> STORAGE_LEVELDB_PORT_PORT_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STORAGE_LEVELDB_PORT_PORT_H_</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-comment">// Include the appropriate platform specific file below.  If you are</span><br><span class="hljs-comment">// porting to a new platform, see &quot;port_example.h&quot; for documentation</span><br><span class="hljs-comment">// of what the new port_&lt;platform&gt;.h file must provide.</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(LEVELDB_PLATFORM_POSIX) || defined(LEVELDB_PLATFORM_WINDOWS)</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;port/port_stdcxx.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(LEVELDB_PLATFORM_CHROMIUM)</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;port/port_chromium.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">// STORAGE_LEVELDB_PORT_PORT_H_</span></span><br></code></pre></td></tr></table></figure><p>可见，这个头文件就是为了封装可能变化的具体平台，提供统一的接口供LevelDB 剩余部分使用。在 Linux 和 Windows 中，LevelDB都默认使用上面介绍的 <code>port_stdcxx.h</code> 头文件中的具体实现。</p><h2 id="status.h-和-status.cc">6. status.h 和 status.cc</h2><p>LevelDB 中的很多接口都以 <code>Status</code>类型作为返回值类型。其相关源码位于 <code>include/leveldb/status.h</code>和 <code>util/status.cc</code> 。下面我们来看 <code>Status</code>类的具体实现。</p><p><code>Status</code> 类的数据成员只有一个，即<code>const char *state_</code> ，精简后的 <code>Status</code>类代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LEVELDB_EXPORT</span> Status &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// Create a success status.</span><br>  <span class="hljs-built_in">Status</span>() <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">state_</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>  ~<span class="hljs-built_in">Status</span>() &#123; <span class="hljs-keyword">delete</span>[] state_; &#125;<br><br>  <span class="hljs-comment">// 省略部分构造函数</span><br><br>  <span class="hljs-comment">// 类静态方法，创建对应类型的 Status 对象</span><br>  <span class="hljs-comment">// Return a success status.</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> Status <span class="hljs-title">OK</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Status</span>(); &#125;<br><br>  <span class="hljs-comment">// Return error status of an appropriate type.</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> Status <span class="hljs-title">NotFound</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; msg, <span class="hljs-type">const</span> Slice&amp; msg2 = Slice())</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Status</span>(kNotFound, msg, msg2);<br>  &#125;<br>  <span class="hljs-comment">// 省略其他创建错误状态的函数</span><br><br>  <span class="hljs-comment">// Returns true iff the status indicates success.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ok</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> (state_ == <span class="hljs-literal">nullptr</span>); &#125;<br><br>  <span class="hljs-comment">// 省略其他判断错误类型的函数</span><br><br>  <span class="hljs-comment">// Return a string representation of this status suitable for printing.</span><br>  <span class="hljs-comment">// Returns the string &quot;OK&quot; for success.</span><br>  <span class="hljs-function">std::string <span class="hljs-title">ToString</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Code</span> &#123;<br>    kOk = <span class="hljs-number">0</span>,<br>    kNotFound = <span class="hljs-number">1</span>,<br>    kCorruption = <span class="hljs-number">2</span>,<br>    kNotSupported = <span class="hljs-number">3</span>,<br>    kInvalidArgument = <span class="hljs-number">4</span>,<br>    kIOError = <span class="hljs-number">5</span><br>  &#125;;<br><br>  <span class="hljs-function">Code <span class="hljs-title">code</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (state_ == <span class="hljs-literal">nullptr</span>) ? kOk : <span class="hljs-built_in">static_cast</span>&lt;Code&gt;(state_[<span class="hljs-number">4</span>]);<br>  &#125;<br><br>  <span class="hljs-built_in">Status</span>(Code code, <span class="hljs-type">const</span> Slice&amp; msg, <span class="hljs-type">const</span> Slice&amp; msg2);<br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">CopyState</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s)</span></span>;<br><br>  <span class="hljs-comment">// OK status has a null state_.  Otherwise, state_ is a new[] array</span><br>  <span class="hljs-comment">// of the following form:</span><br>  <span class="hljs-comment">//    state_[0..3] == length of message</span><br>  <span class="hljs-comment">//    state_[4]    == code</span><br>  <span class="hljs-comment">//    state_[5..]  == message</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* state_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>根据注释和源码可以看出，<code>Status</code> 的具体状态由枚举类型<code>Status::Code</code> 定义，包括 1 种正确状态和 5种错误状态。<code>state_</code> 成员格式在注释中已经指明：前 4个字节表示 <code>message</code> 字符串长度；第 5 个字节表示<code>Code</code> ；后续字节表示 <code>message</code> 字符串。</p><p>由于 <code>Status</code> 类需要管理 <code>state_</code>成员进行内存的分配和回收，代码中也显式重写了拷贝构造、拷贝赋值、移动构造等拷贝控制相关函数。</p><p>另外，<code>Status</code>类提供了静态方法，用于创建不同类型的错误状态；以及 <code>ToString</code>方法，用于将 <code>Status</code> 对象转换为可读的字符串。</p><h2 id="总结">7. 总结</h2><p>以上就是 LevelDB源码阅读系列的第一篇，介绍了最基础的一些头文件和数据结构。从上面的相关代码中，个人体会比较深刻的有两点：</p><ul><li><p><strong>良好的设计一定要封装隔离变化</strong></p><p>这一点可以从上文的很多地方看出，比如：</p><ul><li><code>export.h</code> 头文件通过宏应对编译环境（GNU orMSVC）的变化；</li><li><code>thread_annotations.h</code> 头文件通过自定义宏，将<code>clang</code>的特性封装在一个源文件中，而不是扩散到整个项目的代码中；</li><li><code>port.h</code> 头文件通过宏进行条件编译，隔离 LevelDB其余部分代码依赖的平台相关接口，同时允许不同平台的不同实现，如利用 C++标准库的 <code>port_stdcxx.h</code> 头文件。</li></ul><p>实际上，LevelDB中利用这一思想进行设计与实现的例子还有很多，后面遇到时也会再进行介绍。</p><p>上面的相关代码似乎只是对部分接口进行了简单的封装，但是却蕴含了很深刻的软件设计、设计模型相关的思想。这里，本人作为设计模式学习新手，也只能稍微体会到这么一丢丢。于是，我问了ChatGPT 一个问题：</p><blockquote><p>良好的设计一定要封装隔离变化这一点可以从上文的很多地方看出，比如：</p><ul><li><p><code>export.h</code> 头文件通过宏应对编译环境（GNU orMSVC）的变化</p></li><li><p><code>thread_annotations.h</code> 头文件通过自定义宏，将<code>clang</code>的特性封装在一个源文件中，而不是扩散到整个项目的代码中；</p></li><li><p><code>port.h</code> 头文件通过宏进行条件编译，隔离 LevelDB其余部分代码依赖的平台相关接口，同时允许不同平台的不同实现，如利用 C++标准库的 <code>port_stdcxx.h</code> 头文件。</p><p>上面内容符合设计模式中哪些原则和具体的设计模式？</p></li></ul></blockquote><p>下面是 ChatGPT 的回答，个人认为没有大问题，供读者参考：</p><blockquote><p>上面的内容符合多个设计原则和具体的设计模式，主要包括<strong>单一职责原则（SRP）</strong>、<strong>开闭原则（OCP）</strong>、<strong>依赖倒置原则（DIP）</strong>以及<strong>适配器模式（AdapterPattern）</strong>和<strong>策略模式（Strategy Pattern）</strong>。</p><h3 id="设计原则">设计原则</h3><ol type="1"><li><strong>单一职责原则（SRP）</strong><ul><li>每个模块或类应该只有一个改变的原因，即它们应该只有一个职责。通过使用不同的头文件来处理不同的功能，代码更加模块化和可维护。</li><li>例如，<code>thread_annotations.h</code>只负责封装线程安全注释的逻辑，<code>export.h</code>只负责处理编译环境的差异，<code>port.h</code>负责隔离平台相关的接口。</li></ul></li><li><strong>开闭原则（OCP）</strong><ul><li>软件实体（类、模块、函数等）应该可以扩展，但是不应该修改。通过使用宏和条件编译来处理不同的平台和编译器特性，可以扩展支持新的平台或编译器，而无需修改现有代码。</li><li>例如，<code>export.h</code> 和 <code>port.h</code>通过宏来应对不同编译器和平台的变化，使得代码可以在新增平台和编译器时通过增加新的宏定义来适应，而不是修改已有代码。</li></ul></li><li><strong>依赖倒置原则（DIP）</strong><ul><li>高层模块不应该依赖低层模块，两者都应该依赖于抽象；抽象不应该依赖细节，细节应该依赖抽象。通过头文件和宏进行封装，实现了不同平台和编译器的隔离，使得高层代码无需直接依赖底层实现细节。</li><li>例如，<code>port.h</code>通过条件编译隔离了平台相关的实现，使得高层的 LevelDB代码不直接依赖于特定平台的实现细节。</li></ul></li></ol><h3 id="设计模式">设计模式</h3><ol type="1"><li><strong>适配器模式（Adapter Pattern）</strong><ul><li>适配器模式使得原本由于接口不兼容而不能一起工作的类可以一起工作。通过使用宏和条件编译，将不同平台和编译器特性适配为统一的接口。</li><li>例如，<code>export.h</code>通过宏适配不同编译器的导出符号语法，<code>thread_annotations.h</code> 将Clang 特定的线程安全注释适配为统一的宏接口。</li></ul></li><li><strong>策略模式（Strategy Pattern）</strong><ul><li>策略模式定义了一系列算法，并将每一个算法封装起来，使它们可以互换。本质上是将行为抽象出来，使得可以动态地选择不同的行为实现。</li><li>例如，<code>port.h</code> 通过条件编译选择不同的平台实现（如使用<code>port_stdcxx.h</code>），这种方式允许在不同平台上动态选择不同的实现策略，而不改变客户端代码。</li></ul></li></ol><h3 id="具体示例解释">具体示例解释</h3><ul><li><strong><code>export.h</code> 头文件通过宏应对编译环境（GNU orMSVC）的变化</strong>：<ul><li><strong>设计模式</strong>：适配器模式</li><li><strong>设计原则</strong>：开闭原则、单一职责原则</li><li>通过定义宏来适配不同的编译器，实现了对不同编译环境的封装和隔离。</li></ul></li><li><strong><code>thread_annotations.h</code> 头文件通过自定义宏，将<code>clang</code> 的特性封装在一个源文件中</strong>：<ul><li><strong>设计模式</strong>：适配器模式</li><li><strong>设计原则</strong>：单一职责原则、开闭原则</li><li>将 Clang的线程安全注释功能封装成统一的宏接口，使得整个项目可以方便地使用这些特性而无需关注编译器的具体实现。</li></ul></li><li><strong><code>port.h</code> 头文件通过宏进行条件编译，隔离 LevelDB其余部分代码依赖的平台相关接口</strong>：<ul><li><strong>设计模式</strong>：策略模式</li><li><strong>设计原则</strong>：依赖倒置原则、开闭原则、单一职责原则</li><li>通过条件编译选择不同的平台实现，使得代码可以在不同平台上运行而无需修改高层代码，实现了对平台差异的封装和隔离。</li></ul></li></ul><h3 id="总结-1">总结</h3><p>上述设计符合良好的设计原则和模式，通过封装和隔离变化，增强了代码的可维护性、可扩展性和可移植性。这种设计不仅使得代码更易于理解和修改，还能够更好地应对未来的变化。</p></blockquote></li><li><p><strong>知名的项目也并非完美无缺</strong></p><p>LevelDB 使用的 C++ 标准是 C++ 11。在 C++ 11中，<code>enum class</code> 语法已经得到了支持，它解决了原有的<code>enum</code> 作用域泄漏的问题。在 <code>status.h</code>源文件中，<code>Code</code> 相关代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Code</span> &#123;<br>    kOk = <span class="hljs-number">0</span>,<br>    kNotFound = <span class="hljs-number">1</span>,<br>    kCorruption = <span class="hljs-number">2</span>,<br>    kNotSupported = <span class="hljs-number">3</span>,<br>    kInvalidArgument = <span class="hljs-number">4</span>,<br>    kIOError = <span class="hljs-number">5</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>显然，这里使用 <code>enum class Code&#123;...&#125;;</code>更合适，因为它能避免作用域泄漏、隐式类型转换等问题。而 LevelDB却并没有使用新的 C++ 11 标准。或许当时的编译器还不支持；或许 LevelDB的作者认为没有必要。其中原因，作为普通使用者很难揣测。不过，这一点已经足够证明：知名的项目也并非完美无缺。阅读开源项目源码是学习进步的必不可少的途径，但是完全信奉知名项目的代码，而没有自己的思考和判断，则显然是本末倒置了。这也和：<strong>尽信书，不如无书</strong>是一个道理。</p><p>愿我们带着自己的思考和判断，阅读源码，即使是知名项目的源码。以此共勉。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>读源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LevelDB</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LevelDB 调试环境搭建</title>
    <link href="/2024/05/25/LevelDB-%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2024/05/25/LevelDB-%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>LevelDB 是知名的 C++/数据库/K-V 存储/LSM Tree 相关的项目，由 Google的 Jeffrey Dean等知名大牛编写。阅读源码是学习提升的必经之路，这条道路上的第一个障碍就是如何把代码跑起来，并自己上手运行、调试。本文以LevelDB 为例，介绍如何搭建 LevelDB的调试环境，为后续阅读源码做好铺垫工作。</p><p>本文的环境为 Linux + VS Code，LevelDB 官方仓库为：<ahref="https://github.com/google/leveldb">google/leveldb: LevelDB is afast key-value storage library written at Google that provides anordered mapping from string keys to string values. (github.com)</a>。</p><h2 id="必要插件安装">1. 必要插件安装</h2><p>使用 VS Code阅读代码时，选择合适的插件能提升效率。之前在网上看到很多推荐 clangd +CodeLLDB 家族的插件，而本人之前也一直使用微软的 IntelliSense 等官方C/C++ 开发环境插件。因此，借这次机会尝试下新事物。</p><p>插件的安装流程本文就详细介绍了，网上能够搜索很多相关的文章，这里贴几个供参考：</p><ul><li><p><ahref="https://zhangjk98.xyz/vscode-c-and-cpp-develop-and-debug-setting/">VSCodeC/C++ 开发环境和调试配置：Clangd+Codelldb | 止息'幻想乡(zhangjk98.xyz)</a></p></li><li><p><ahref="https://zhuanlan.zhihu.com/p/566365173">几乎无痛的VSCode+clangd+lldb+cmake配置C/C++开发环境指南- 知乎 (zhihu.com)</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/583201222">VSCode -使用Clangd搭建C++开发环境 - 知乎 (zhihu.com)</a></p></li><li><p><ahref="https://juejin.cn/post/7126880493668139021">为vscode配置clangd -掘金 (juejin.cn)</a></p></li><li><p><ahref="https://blog.csdn.net/callinglove/article/details/132539448">VisualstudioCode的clangd插件一篇通，上乘的C/C++开发环境配置-CSDN博客</a></p></li></ul><p>可以选择一个博客，按照步骤安装插件。要注意的是 clangd和微软的插件只可以安装一个，防止冲突。</p><h2 id="克隆仓库">2. 克隆仓库</h2><p>安装完插件后，我们来拉取代码。当然可以使用谷歌官方的代码仓库：<ahref="https://github.com/google/leveldb">LevelDB</a>，不过笔者也克隆了一个仓库，并提供了可进行 Debug 的入口文件，并更改了CmakeLists.txt 文件，想省点事可以克隆如下仓库：<ahref="https://github.com/UnpureRationalist/leveldb">UnpureRationalist/leveldb:LevelDB is a fast key-value storage library written at Google thatprovides an ordered mapping from string keys to string values.(github.com)</a> 。</p><p>具体的命令直接参考代码仓库的 README 就行了，注意使用 git clone的时候要加上 <code>--recurse-submodules</code> 选项。</p><h2 id="编译调试">3. 编译调试</h2><p>下载完成代码后进入项目根目录，执行下面的命令进行编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p build &amp;&amp; cd build<br>cmake -DCMAKE_BUILD_TYPE=Debug .. &amp;&amp; cmake --build .<br></code></pre></td></tr></table></figure><p>编译完成后，使用 <code>ls</code> 命令查看输出，具体如下：</p><img src="/2024/05/25/LevelDB-%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20240525220600755.png" class="" title="image-20240525220600755"><p><br></p><p>这里使用的是本人克隆并稍作修改的仓库，多了一个可执行文件：<code>test_entry</code>，用于进行调试。这一可执行文件对应的源代码位于<code>benchmarks</code> 目录下，文件名为<code>test.cc</code>，具体代码（摘自 LevelDB 官方文档中）如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;leveldb/db.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;leveldb/options.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;leveldb/slice.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  leveldb::DB* db;<br>  leveldb::Options options;<br>  options.create_if_missing = <span class="hljs-literal">true</span>;<br>  leveldb::Status status = leveldb::DB::<span class="hljs-built_in">Open</span>(options, <span class="hljs-string">&quot;/tmp/testdb&quot;</span>, &amp;db);<br>  <span class="hljs-built_in">assert</span>(status.<span class="hljs-built_in">ok</span>());<br><br>  leveldb::WriteOptions write_options;<br>  leveldb::ReadOptions read_options;<br>  leveldb::Slice key&#123;<span class="hljs-string">&quot;1&quot;</span>&#125;;<br>  leveldb::Slice value&#123;<span class="hljs-string">&quot;666&quot;</span>&#125;;<br>  db-&gt;<span class="hljs-built_in">Put</span>(write_options, key, value);<br>  std::string result;<br>  db-&gt;<span class="hljs-built_in">Get</span>(read_options, key, &amp;result);<br><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;key: &quot;</span> &lt;&lt; key.<span class="hljs-built_in">data</span>() &lt;&lt; <span class="hljs-string">&quot;, value: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br><br>  <span class="hljs-comment">// iterator</span><br>  leveldb::Iterator* it = db-&gt;<span class="hljs-built_in">NewIterator</span>(read_options);<br>  <span class="hljs-keyword">for</span> (it-&gt;<span class="hljs-built_in">SeekToFirst</span>(); it-&gt;<span class="hljs-built_in">Valid</span>(); it-&gt;<span class="hljs-built_in">Next</span>()) &#123;<br>    std::cout &lt;&lt; it-&gt;<span class="hljs-built_in">key</span>().<span class="hljs-built_in">ToString</span>() &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; it-&gt;<span class="hljs-built_in">value</span>().<span class="hljs-built_in">ToString</span>()<br>              &lt;&lt; std::endl;<br>  &#125;<br>  <span class="hljs-built_in">assert</span>(it-&gt;<span class="hljs-built_in">status</span>().<span class="hljs-built_in">ok</span>());  <span class="hljs-comment">// Check for any errors found during the scan</span><br>  <span class="hljs-keyword">delete</span> it;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在 VS Code 页面按 <code>Ctrl + Shift + D</code>按键，左边出现以下界面：</p><center><img src="/2024/05/25/LevelDB-%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20240525221350689.png" class="" title="image-20240525221350689"></center><p><br></p><p>点击图中红色框内的<code>create a launch.json file</code>，创建文件，复制粘贴内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-comment">// Use IntelliSense to learn about possible attributes.</span><br>    <span class="hljs-comment">// Hover to view descriptions of existing attributes.</span><br>    <span class="hljs-comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.2.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;lldb&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;launch&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Debug&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;program&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/build/test_entry&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>其实主要就是改动<code>"program": "$&#123;workspaceFolder&#125;/build/test_entry"</code>这个配置，以找到 Debug 入口文件。</p><p>然后在 <code>test.cc</code> 文件中随便添加一个断点，点击<code>F5</code> 按键，开始愉快的 Debug：</p><img src="/2024/05/25/LevelDB-%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20240525221721414.png" class="" title="image-20240525221721414"><p><br></p><p>至此，就可以在图形化界面中进行Debug，追踪代码执行流程，阅读源码。</p><p>当然，喜欢 <code>gdb</code>命令行的话就不需要这一通操作了，直接命令行 <code>gdb</code> 启动进行Debug 即可。</p><h2 id="总结">4. 总结</h2><p>以上就是在 VS Code 中搭建 LevelDB调试环境的大致流程，如果中途遇到问题，针对性地进行搜索解决即可。成功运行代码，开启调试后，就可以开始阅读源码了，后续见。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>工具</category>
      
      <category>读源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LevelDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重学操作系统：内存虚拟化</title>
    <link href="/2024/05/24/%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    <url>/2024/05/24/%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>内存是操作系统需要管理的另一重要资源。同管理 CPU类似，操作系统在管理物理内存时想要达到以下目的：</p><ul><li>共享：多个进程可以同时使用物理内存，每个进程都感觉自己在独占内存空间。</li><li>安全：共享带来的另一个问题就是安全，操作系统要隔离不同进程的内存访问，确保它们访问的是属于进程本身的物理内存，而不可以随意读写其它进程的内存空间。</li><li>高效：尽可能减少时间空间资源的占用，以更高效的方式管理内存。</li></ul><p>为了达成以上目的，需要在物理内存上提供一层虚拟（或者叫抽象），进程在访问地址空间内某个内存单元时，进程感觉自己在独占地址空间，而感觉不到物理内存上还运行着操作系统和其它进程。这个抽象叫<strong>地址空间</strong>，是进程看到的系统中的内存。最简单的地址空间可以分为4 类：</p><ul><li>代码区</li><li>栈</li><li>堆</li><li>未分配</li></ul><p>进程运行时生成的地址称为<strong>虚拟地址</strong>，而物理内存的地址称为<strong>物理地址</strong>。显然，想要为进程提供地址空间的抽象，必须在进程运行时将虚拟地址转换为物理地址，以访问真正的物理内存。这一机制称为：<strong>地址转换</strong>。地址转换一般需要硬件的参与，因此也称为：基于硬件的地址转换。</p><h2 id="地址转换">1. 地址转换</h2><p>现代 CPU和操作系统的地址转换机制比较复杂，但是我们从最简单的假设开始，即：进程地址空间固定且小于物理内存。在这种情况下，硬件需要提供以下功能以为进程提供虚拟地址空间：</p><ul><li>CPU 需要有特权模式和用户模式。</li><li>CPU 的内存管理单元需要提供两个寄存器：<strong>基址寄存器</strong> 和<strong>界限寄存器</strong>。</li><li>CPU 提供修改基址/界限寄存器的特权指令。</li></ul><p>操作系统同样也需要额外的工作，以为进程提供地址空间的抽象：</p><ul><li>创建进程时，OS要为进程的地址空间分配实际的空闲物理内存，并在基址/界限寄存器记录。</li><li>进程终止时，OS 要回收进程占据的物理内存，加入空闲列表。</li><li>进程控制块中额外记录进程的基址/界限寄存器值，用于上下文切换。</li><li>OS 提供异常处理程序，处理进程越界访问内存。</li></ul><p>有了改基址/界限寄存器后，物理地址可以由以下方式计算出： <spanclass="math display">\[\text{physical address} = \text{base register} + \text{virtual address}\]</span> 在 <em>进程地址空间固定且小于物理内存</em>这种最简单的假设下，上述硬件机制和 OS提供的功能即可为进程提供虚拟的地址空间。但是，由于进程空间大小固定，每次OS 都要为进程分配固定大小的物理内存空间，会导致<strong>内部碎片</strong>（具体来说：堆和栈直接可能存在大量未使用区域）。下面对这种一对基址/界限寄存器的机制进行泛化，得到分段机制，以改善这个问题。</p><h2 id="分段">2. 分段</h2><p>分段就是泛化的基址/界限。这一机制在 CPU的内存管理单元（MMU）中引入多个基址/寄存器对，表示地址空间内的每个逻辑段（代码段、栈、堆）。</p><p>引入分段机制后，对于给定的虚拟地址，我们首先要根据虚拟地址的高若干位，确定属于哪个段，进而去访问对应的基址/界限寄存器。</p><p>另外，由于不同段的地址增长方向不一样，MMU中还需要额外的位来标记地址增长方向。为了<strong>共享代码</strong>，还需要额外的位标识每个段的读、写、执行权限。</p><p>不过，由于不同段的大小不同，OS 在分配段空间管理物理内存时，很容易导致<strong>外部碎片</strong>（内存被划分为很多小的空闲区域，无法满足一次大的内存分配申请）。</p><h2 id="空闲空间管理">3. 空闲空间管理</h2><p>在堆上管理空闲空间的数据结构通常称为<strong>空闲列表</strong>。具体而言，可以通过链表形式的数据结构，链表每个节点记录连续空闲空间的起始位置和大小。</p><p>分配内存空间的一个重要问题就是：选择哪个空闲区域进行分配，具体有以下策略：</p><ul><li>最优匹配</li><li>最差匹配</li><li>首次匹配</li><li>下次匹配：不从列表开始查找，而是从上一次查找结束的位置开始查找</li></ul><p>除了上述方式，还有其它的内存分配方式：</p><ul><li>分离空闲列表：如果程序经常申请一种或几种固定大小的内存空间，就用一个独立的列表只管理这样大小的对象；其它大小的请求都交给更通用的内存分配程序。</li><li>伙伴系统：Linux 采用。</li></ul><h2 id="分页">4. 分页</h2><p>分页的核心思想是：将物理内存划分为固定大小，称为：页帧（pageframe）。进程的虚拟内存空间同样划分为固定大小的页，并将虚拟页放在某个物理页帧中。为了记录地址空间的每个虚拟页放在物理内存中的位置，OS通常为 <strong>每个进程</strong>保存一个数据结构，称为：<strong>页表</strong>（pagetable），用于将虚拟地址空间的虚拟页转换为物理内存的页帧。</p><p>将虚拟地址转换为物理地址过程如下：</p><ul><li>将虚拟地址分为两部分：高位的虚拟页面号（Virtual PageNumber，VPN）和低位的页内偏移量（offset）；</li><li>在页表中检索（为了找到页表在物理内存中位置，硬件还需要提供一个<strong>页表基址寄存器</strong>），找到虚拟页面号对应的物理页号（PhysicalPage Number，PPN）；</li><li>用 PPN 替代 VPN，生成物理地址。</li></ul><p>页表的最简单存储方式就是利用一个连续的数组，每个数组的下标<code>idx</code> 就表示虚拟页面号 VPN，数组存储的内容就是物理页号PPN。以典型的 32 位虚拟地址空间，页面大小为 4 KB，每个页表项（Page TableEntry，PTE）假设为 4 字节，则存储每个进程的页表需要占用 <spanclass="math inline">\(2^{20}\times 4 \text{ Byte} = 4 \text{MB}\)</span>。如果系统内运行着 100个进程，则仅仅存储这些进程的页表就需要 400MB，导致占用大量的物理内存。当采用此种连续数组方式存储页表时，进程访问内存实际过程如下伪码描述：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT<br>PTEAddr = PageTableBaseRegister + (VPN * sizeof(PTE))<br>PTE = AccessMemory(PTEAddr)<br>offset = VirtualAddress &amp; OFFSET_MASK<br>PhyAddr = (PTE.PPN &lt;&lt; PPN_SHIFT) | offset<br>Register = AccessMemory(PhyAddr)<br></code></pre></td></tr></table></figure><p>可见，由于引入了进程地址空间这一虚拟层，进程执行时如果要访问一个内存位置，必须经过两次物理内存访问，这会导致进程执行速度变慢。为了解决这一问题，引入地址转换旁路缓存存储器（TranslationLookaside Buffer，TLB）。</p><h2 id="快速地址转换tlb">5. 快速地址转换：TLB</h2><p>TLB 类似于 CPU 中的缓存，只不过 CPU 缓存的是指令或数据，而 TLB缓存的是页表项，以减少虚拟地址转换为物理地址的开销。我们希望通过TLB，让绝大多数的地址转换都能够命中 TLB缓存，在极快的时间内获得虚拟地址对应的物理地址，从而提升进程运行效率；而不是通过访问页表获取物理地址，导致多了一次内存访问开销。</p><p>由于是缓存，自然就引出了一个问题：如何处理 TLB未命中的情况？可以由硬件自动处理或者操作系统通过异常处理程序进行处理。处理的具体操作自然就是从页表中读取虚拟地址对应的物理地址，并插入TLB 中，然后重试导致 TLB 未命中的指令。</p><p>TLB 存储的每项记录形式如下： <span class="math display">\[\text{VPN } | \text{ PFN } | \text{ 其他位}\]</span> 其他位中通常包括有效位，用于表示该项是否为有效的地址映射。</p><p>引入 TLB 后，在进行进程的上下文切换时，必须对 TLB内容标记无效，也就是进行清空 TLB 操作。当然，也可以在 TLB中记录进程标识符 pid，即可在不同进程间共享 TLB。</p><h2 id="减小页表空间">6. 减小页表空间</h2><p>前文提到，分页的引入带来了两个问题：</p><ul><li>页表过大，占用过多物理内存。</li><li>导致两次访问内存，降低执行效率。</li></ul><p>第二个问题通过 TLB 可以极大改善，现在我们着手解决第一个问题。</p><p>这里，我们就忽略比较简单的增大页面大小、分段分页结合的方法，它们虽然都能改善页表过大的问题，但是也会引入内部碎片、外部碎片等问题。我们直接来看多级页表这一解决方案。</p><p>多级页表的核心思想是：将页表也按照页大小进行划分，如果整页的页表项（PTE）无效，就完全不分配该页的页表。为了追踪页表的页是否有效（以及如果有效，它在内存中的位置），需要使用名为页目录（pagedirectory）的新结构，这一新结构可以看作二级页表。在二级页表中，页目录为每页页表包含了一项。它由多个页目录项（PageDirectory Entry，PDE）组成。PDE 至少拥有有效位和页帧号。PDE中的有效位指的是该项指向的页表中是否至少有一个页是有效的。</p><p>和二级页表思想类似，可以引入三级页表等。多级页表形成了一个树结构。</p><h2 id="物理内存与硬盘的交换">7. 物理内存与硬盘的交换</h2><p>当物理内存不够时，OS可以利用硬盘上的一部分空间（交换空间），用于物理页的移入和移出（verysimilar to buffer pool in DBMS）。为了进行正确的移入移出操作，OS必须能够记录给定页在硬盘中存放的地址。</p><p>为了能够将页换入硬盘，必须在页表项中添加一个位，用于判断页是否在物理内存中，称为<strong>存在位</strong>。如果进程指向时发现某个页存在位为0，说明该页在硬盘中，产生一个页错误，需要操作系统接管处理。操作系统需要知道这一页面存储在硬盘的哪里？这一信息通常记录在页表中。OS通过页表项获取页面在磁盘的位置，进行 IO 操作。IO 操作完成后，OS将存在位更改为 1，并在更新页表项的 PFN字段以记录新获取页在物理内存中的位置，并重试指令。</p><p>当物理内存满了时，需要选取页面交换到硬盘内，这叫做页面替换策略。可能的页面替换策略有以下几种：</p><ul><li>最优替换策略：需要事先知道页面访问序列，由于很难实现，实际很少采用，仅作为最佳策略和其他方法对比。</li><li>FIFO（先入先出策略）</li><li>随机</li><li>LRU（最近最少使用，Least RecentlyUsed）：替换最近使用最少的页。</li><li>LFU（最不经常使用，Least FrequentlyUsed）：替换最不经常使用的页。</li><li>时钟算法：系统中所有页放在一个循环列表中，时钟指针初始指向某个页。当必须进行页替换时，OS检查当前时钟指针指向的页的使用位是 1 还是 0。如果是1，则说明当前页面最近被使用过，因此不适合被替换。因此将当前页使用位设置为0，指针后移。直到找到第一个使用位为 0 的页，进行换出。</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存虚拟化</tag>
      
      <tag>内存管理</tag>
      
      <tag>LRU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从 BusTub 看 Architecture of a Database System</title>
    <link href="/2024/05/13/%E4%BB%8E-BusTub-%E7%9C%8B-Architecture-of-a-Database-System/"/>
    <url>/2024/05/13/%E4%BB%8E-BusTub-%E7%9C%8B-Architecture-of-a-Database-System/</url>
    
    <content type="html"><![CDATA[<p>CMU 15-445/645 课程对应的项目 <ahref="https://github.com/cmu-db/bustub">BusTub</a>以及数据库领域的经典综述论文 <ahref="https://www.nowpublishers.com/article/DownloadSummary/DBS-002">Architectureof a Database System</a> 都可以说是入门数据库的必备材料。BusTub 通过几个Project，让我们对数据库的缓冲区管理、索引、执行引擎、事务控制等关键模块有相对深入的了解；Architectureof a Database System则介绍了数据库系统的整体架构，让我们对数据库系统的每个关键模块都建立概念。BusTub作为教育目的的数据库，其代码量不大，非常适合结合论文 Architecture of aDatabase System 阅读，了解真正的数据库系统是如何设计与组织代码的。本文以BusTub 作为案例，结合 Architecture of a Database System一文，看一看真实的数据库是如何组织和实现数据库系统的主要模块的。</p><p>下面，我们按 Architecture of a Database System的章节顺序，依次进行介绍。</p><h2 id="introduction">1. Introduction</h2><p>本节是论文的引言部分，是全文的总结。这一节中比较关键的点就是了解 DBMS的主要组件：</p><img src="/2024/05/13/%E4%BB%8E-BusTub-%E7%9C%8B-Architecture-of-a-Database-System/image-20240513155926008.png" class="" title="image-20240513155926008"><p>这张图片总结了主流 DBMS中经常会出现的组件，也指导着我们进行数据库系统的设计与实现。</p><p>以 BusTub 为例，进入其 <code>src</code> 源码目录，使用<code>tree -d</code> 命令，即可查看所有代码子目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree -d</span><br>.<br>├── binder<br>│   └── statement<br>├── buffer<br>├── catalog<br>├── common<br>│   └── util<br>├── concurrency<br>├── container<br>│   ├── disk<br>│   │   └── hash<br>│   └── hash<br>├── execution<br>├── include<br>│   ├── binder<br>│   │   ├── expressions<br>│   │   ├── statement<br>│   │   └── table_ref<br>│   ├── buffer<br>│   ├── catalog<br>│   ├── common<br>│   │   ├── enums<br>│   │   └── util<br>│   ├── concurrency<br>│   ├── container<br>│   │   ├── disk<br>│   │   │   └── hash<br>│   │   └── hash<br>│   ├── execution<br>│   │   ├── executors<br>│   │   ├── expressions<br>│   │   └── plans<br>│   ├── optimizer<br>│   ├── planner<br>│   ├── primer<br>│   ├── recovery<br>│   ├── storage<br>│   │   ├── disk<br>│   │   ├── index<br>│   │   ├── page<br>│   │   └── table<br>│   └── type<br>├── optimizer<br>├── planner<br>├── primer<br>├── recovery<br>├── storage<br>│   ├── disk<br>│   ├── index<br>│   ├── page<br>│   └── table<br>└── type<br><br>51 directories<br></code></pre></td></tr></table></figure><p>可以看到 BusTub的代码组织非常清晰，每个目录的含义基本上一目了然：</p><ul><li><code>binder</code>：将 PostgreSQL 语法树转换为 BusTub内部数据结构；</li><li><code>buffer</code>：缓冲区管理；</li><li><code>catalog</code>：元数据管理；</li><li><code>common</code>：一些工具函数，以及组装 BusTub 数据库实例；</li><li><code>concurrency</code>：并发控制模块；</li><li><code>container</code>：容器，主要是面向内存或磁盘的哈希表；</li><li><code>execution</code>：执行引擎，实现各种算子；</li><li><code>include</code>：头文件；</li><li><code>optimizer</code>：查询优化器模块；</li><li><code>planner</code>：把 <code>binder</code>模块生成的数据结构转换为 BusTub 内部执行计划；</li><li><code>recovery</code>：恢复系统，主要用于实现 undo redo log；</li><li><code>storage</code>：存储模块，主要实现数据库页面、表、索引等数据结构；</li><li><code>type</code>：实现 BusTub 支持的数据类型，如 <code>int</code>、<code>char</code> 等，以及相关的加减法、比较等运算。</li></ul><p>根据这些源码组织，我们可以直观的感受 DBMS 的主要组件。</p><h2 id="process-models">2. Process Models</h2><p>Process Models，或者叫处理模型，是真实 DBMS中非常重要的部分。因为现代 CPU 是多核的，DBMS作为重要的系统软件必须能够利用多核 CPU 的能力。</p><p>对 Linux 服务端编程稍有了解的同学都知道，服务端程序高效利用多核 CPU无非两种模式：</p><ul><li>多进程</li><li>多线程</li></ul><p>具体到 DBMS 也是类似的，有以下三种细分的 process model：</p><ul><li><p>Process per DBMS Worker：即多进程模型，典型 DBMS有：PostgreSQL。示意图如下：</p><img src="/2024/05/13/%E4%BB%8E-BusTub-%E7%9C%8B-Architecture-of-a-Database-System/image-20240513161300913.png" class="" title="image-20240513161300913"><p>这种模型需要大量使用共享内存等进程间通信技术。由于早期 OS对线程支持不好，得到了很多早期系统的采用。</p></li><li><p>Thread per DBMS Worker：即多线程模型，典型 DBMS 有MySQL。示意图如下：</p><img src="/2024/05/13/%E4%BB%8E-BusTub-%E7%9C%8B-Architecture-of-a-Database-System/image-20240513161614393.png" class="" title="image-20240513161614393"><p>这一模型主要确定是多线程技术本身带来的数据竞争、编码和 debug难度等。</p></li><li><p>Process Pool：即进程池，示意图如下：</p><img src="/2024/05/13/%E4%BB%8E-BusTub-%E7%9C%8B-Architecture-of-a-Database-System/image-20240513161833172.png" class="" title="image-20240513161833172"><p>这一模型是多进程的改进。通过池化思想，防止消耗系统大量资源，同时资源预先申请并动态缩扩，提升系统整体性能。</p></li><li><p>类似进程池，自然也有线程池这一模型。尽管现代服务器程序使用线程池模型的也很多，但是原论文并未单独介绍这一模式。</p></li></ul><p>BusTub 源码中似乎并不能看出其使用了哪种 process model。但是在Project4 的并发控制项目中，性能测试使用的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 省略部分代码...</span><br>  <span class="hljs-keyword">auto</span> bustub = std::<span class="hljs-built_in">make_unique</span>&lt;bustub::BustubInstance&gt;();<br>  <span class="hljs-keyword">auto</span> writer = bustub::<span class="hljs-built_in">SimpleStreamWriter</span>(std::cerr);<br><br>  <span class="hljs-comment">// create schema</span><br>  <span class="hljs-keyword">auto</span> schema = <span class="hljs-string">&quot;CREATE TABLE nft(id int, terrier int);&quot;</span>;<br>  std::cerr &lt;&lt; <span class="hljs-string">&quot;x: create schema&quot;</span> &lt;&lt; std::endl;<br>  bustub-&gt;<span class="hljs-built_in">ExecuteSql</span>(schema, writer);<br><span class="hljs-comment">// 省略部分代码...</span><br>  std::vector&lt;std::thread&gt; threads;<br>  TerrierTotalMetrics total_metrics;<br><br>  total_metrics.<span class="hljs-built_in">Begin</span>();<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> thread_id = <span class="hljs-number">0</span>; thread_id &lt; BUSTUB_TERRIER_THREAD; thread_id++) &#123;<br>    threads.<span class="hljs-built_in">emplace_back</span>(std::<span class="hljs-built_in">thread</span>([thread_id, &amp;bustub, enable_update, duration_ms, &amp;total_metrics] &#123;<br>      <span class="hljs-comment">// lambda 表达式函数体 省略</span><br>    &#125;));<br>  &#125;<br></code></pre></td></tr></table></figure><p>可以看出，在进行性能测试时，BusTub 采用的是多线程模型。</p><h2 id="parallel-architecture-processes-and-memory-coordination">3.Parallel Architecture: Processes and Memory Coordination</h2><p>本节讨论的是 DBMS 利用现代化并行硬件的主要范式和最佳实践。</p><p>主要范式有：</p><ul><li>Shared Memory：可以理解为现代单机多核 CPU 服务器，即：多个 CPU核心，甚至多个 CPU，共享内存和磁盘。</li><li>Shared-Nothing：可以理解为分布式系统，即：每台机器都有自己的CPU、内存和磁盘，通过网络构成分布式 DBMS。</li><li>Shared-Disk：磁盘共享，CPU 和内存私有，相当于多台机器共享底层的分布式文件系统，构成一个 DBMS。</li><li>NUMA：多个内存，CPU 访问不同地址的内存延迟不同。</li></ul><p>BusTub在这方面无特殊设计与实现，且这个主题本身涉及的知识比较专业，本文不做讨论。</p><h2 id="relational-query-processor">4. Relational Query Processor</h2><p>本节是关系查询处理器，如原文所述：</p><blockquote><p>The previous sections stressed the macro-architectural design issuesin a DBMS. We now begin a sequence of sections discussing design at asomewhat ﬁner grain, addressing each of the main DBMS components inturn.</p></blockquote><p>前面的章节强调的是 DBMS的宏观架构设计，而接下来的关注点将更加细粒度，依次研究 DBMS的主要组件。</p><h3 id="query-parsing-and-authorization">4.1 Query Parsing andAuthorization</h3><p>SQL 解析器的主要功能如下：</p><blockquote><p>Given an SQL statement, the main tasks for the SQL Parser are to</p><ol type="1"><li><p>check that the query is correctly speciﬁed,</p></li><li><p>resolve names and references,</p></li><li><p>convert the query into the internal format used by the optimizer,and</p></li><li><p>verify that the user is authorized to execute the query.</p></li></ol></blockquote><p>即：</p><ol type="1"><li>验证 SQL 语句是否符合语法规范；</li><li>解析名字与引用，将名字转换为数据库内部的表、行数据结构；</li><li>将语法树转换为内部数据结构，供查询优化器使用；</li><li>验证用户是否有权限执行该 SQL 语句。</li></ol><p>这一步的一般流程是：</p><ol type="1"><li>从 <code>FROM</code> 子句中解析出表名；</li><li>调用元数据管理器 <code>Catalog Manager</code>判断表是否存在系统中，并使用 <code>catalog</code>保证引用的列名都是正确的；</li><li>验证用户是否有执行当前 SQL 语句的权限。</li></ol><p>在 BusTub 中，不存在授权问题，不予讨论。Query Parsing主要由两个部分完成：</p><ul><li><p>BusTub 依赖的第三方库 <code>libpg_query</code>：来源于 DuckDB 的SQL 语法解析模块，采用与 PostgreSQL 基本相同的语法规则。</p><p>进入 <code>third_party/libpg_query</code> 目录，使用<code>tree -d</code> 命令查看查看代码组织结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree -d</span><br>.<br>├── grammar<br>│   ├── keywords<br>│   ├── statements<br>│   └── types<br>└── include<br>    ├── access<br>    ├── catalog<br>    ├── common<br>    ├── datatype<br>    ├── mb<br>    ├── nodes<br>    ├── parser<br>    └── utils<br><br>13 directories<br></code></pre></td></tr></table></figure></li><li><p>BusTub 本身的 <code>binder</code> 模块：调用<code>libpg_query</code> 库提供的接口，将 SQL 语句解析成语法树，并转换为BusTub 内部的数据结构。</p></li></ul><p>具体的，以 Project 4 性能测试代码执行流程来追踪这一调用流程。</p><ol type="1"><li><p><code>tools/terrier_bench/terrier.cpp</code>：构造数据库实例，执行SQL：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (enable_update) &#123;<br>  <span class="hljs-keyword">auto</span> txn = bustub-&gt;txn_manager_-&gt;<span class="hljs-built_in">Begin</span>(<span class="hljs-literal">nullptr</span>, bustub::IsolationLevel::REPEATABLE_READ);<br>  std::string query = fmt::format(<span class="hljs-string">&quot;UPDATE nft SET terrier = &#123;&#125; WHERE id = &#123;&#125;&quot;</span>, terrier_id, nft_id);<br>  <span class="hljs-comment">//   std::cout &lt;&lt; &quot;Update:&quot; &lt;&lt; query &lt;&lt; std::endl;</span><br>  <span class="hljs-keyword">if</span> (!bustub-&gt;<span class="hljs-built_in">ExecuteSqlTxn</span>(query, writer, txn)) &#123;<br>    txn_success = <span class="hljs-literal">false</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>关键是上面的<code>bustub-&gt;ExecuteSqlTxn(query, writer, txn)</code>函数调用。</p></li><li><p><code>src/common/bustub_instance.cpp</code>：调用<code>Binder</code> 类提供的函数，解析 SQL 为内部数据结构，并执行SQL：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> is_successful = <span class="hljs-literal">true</span>;<br>   <br><span class="hljs-function">std::shared_lock&lt;std::shared_mutex&gt; <span class="hljs-title">l</span><span class="hljs-params">(catalog_lock_)</span></span>;<br><span class="hljs-function">bustub::Binder <span class="hljs-title">binder</span><span class="hljs-params">(*catalog_)</span></span>;<br>binder.<span class="hljs-built_in">ParseAndSave</span>(sql);<br>l.<span class="hljs-built_in">unlock</span>();<br>   <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> *stmt : binder.statement_nodes_) &#123;<br>  <span class="hljs-keyword">auto</span> statement = binder.<span class="hljs-built_in">BindStatement</span>(stmt); <span class="hljs-comment">// 转换为内部数据结构</span><br>  <span class="hljs-comment">// 根据 SQL 类型（Create table、index；Insert；Select 等调用对应的函数）</span><br>  <span class="hljs-comment">// 省略部分代码...  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面的关键是 <code>bustub::Binder binder(*catalog_)</code> 构造<code>Binder</code> 对象，以及调用 <code>binder.ParseAndSave(sql)</code>和<code>auto statement = binder.BindStatement(stmt)</code>将字符串类型的SQL 解析为 BusTub 的内部数据结构。</p></li><li><p><code>src/binder/binder.cpp</code>：<code>Binder</code>类的代码逻辑：调用 <code>libpg_query</code> 的接口并转换为语法树：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Binder::ParseAndSave</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;query)</span> </span>&#123;<br>  parser_.<span class="hljs-built_in">Parse</span>(query);<br>  <span class="hljs-keyword">if</span> (!parser_.success) &#123;<br>    <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;Query failed to parse!&quot;</span>);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Exception</span>(fmt::format(<span class="hljs-string">&quot;Query failed to parse: &#123;&#125;&quot;</span>, parser_.error_message));<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (parser_.parse_tree == <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;parser received empty statement&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-built_in">SaveParseTree</span>(parser_.parse_tree);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中的关键是 <code>parser_.Parse(query)</code>。<code>parser_</code>数据成员的定义是：<code>duckdb::PostgresParser parser_</code>，可以看出，是调用了 DuckDB 的内部接口。</p></li><li><p><code>third_party/libpg_query/postgres_parser.cpp</code>：进入第三方库。这里的主要函数是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PostgresParser::Parse</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;query)</span> </span>&#123;<br>duckdb_libpgquery::<span class="hljs-built_in">pg_parser_init</span>();<br>duckdb_libpgquery::parse_result res;<br><span class="hljs-built_in">pg_parser_parse</span>(query.<span class="hljs-built_in">c_str</span>(), &amp;res);<br>success = res.success;<br><br><span class="hljs-keyword">if</span> (success) &#123;<br>parse_tree = res.parse_tree;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>error_message = <span class="hljs-built_in">string</span>(res.error_message);<br>error_location = res.error_location;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是 DuckDB 执行 SQL 解析的接口，传入 SQL并判断是否合法；若合法，保存语法树。语法分析的细节涉及到编译原理相关知识，本文不详细介绍SQL 语法解析的流程。</p></li><li><p><code>src/binder/transformer.cpp</code>：将 语法解析树转换为BusTub 内部的 <code>Binder***Statement</code> 数据结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">Binder::BindStatement</span><span class="hljs-params">(duckdb_libpgquery::PGNode *stmt)</span> -&gt; std::unique_ptr&lt;BoundStatement&gt; </span>&#123;<br>  <span class="hljs-keyword">switch</span> (stmt-&gt;type) &#123;<br>    <span class="hljs-keyword">case</span> duckdb_libpgquery::T_PGRawStmt:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">BindStatement</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;duckdb_libpgquery::PGRawStmt *&gt;(stmt)-&gt;stmt);<br>    <span class="hljs-keyword">case</span> duckdb_libpgquery::T_PGCreateStmt:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">BindCreate</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;duckdb_libpgquery::PGCreateStmt *&gt;(stmt));<br>    <span class="hljs-keyword">case</span> duckdb_libpgquery::T_PGInsertStmt:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">BindInsert</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;duckdb_libpgquery::PGInsertStmt *&gt;(stmt));<br>    <span class="hljs-keyword">case</span> duckdb_libpgquery::T_PGSelectStmt:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">BindSelect</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;duckdb_libpgquery::PGSelectStmt *&gt;(stmt));<br>    <span class="hljs-keyword">case</span> duckdb_libpgquery::T_PGExplainStmt:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">BindExplain</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;duckdb_libpgquery::PGExplainStmt *&gt;(stmt));<br>    <span class="hljs-keyword">case</span> duckdb_libpgquery::T_PGDeleteStmt:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">BindDelete</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;duckdb_libpgquery::PGDeleteStmt *&gt;(stmt));<br>    <span class="hljs-keyword">case</span> duckdb_libpgquery::T_PGUpdateStmt:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">BindUpdate</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;duckdb_libpgquery::PGUpdateStmt *&gt;(stmt));<br>    <span class="hljs-keyword">case</span> duckdb_libpgquery::T_PGIndexStmt:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">BindIndex</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;duckdb_libpgquery::PGIndexStmt *&gt;(stmt));<br>    <span class="hljs-keyword">case</span> duckdb_libpgquery::T_PGVariableSetStmt:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">BindVariableSet</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;duckdb_libpgquery::PGVariableSetStmt *&gt;(stmt));<br>    <span class="hljs-keyword">case</span> duckdb_libpgquery::T_PGVariableShowStmt:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">BindVariableShow</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;duckdb_libpgquery::PGVariableShowStmt *&gt;(stmt));<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">NotImplementedException</span>(<span class="hljs-built_in">NodeTagToString</span>(stmt-&gt;type));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的逻辑就是根据语法树的类型（Create Table、Index、Select等），构造对应的 BusTub 内部数据结构。</p></li><li><p>后续，就进入了具体的不同语法树生成不同内部数据结构的过程，本文不再详细介绍。</p></li></ol><p>经过上述 <code>binder</code> 模块，BusTub 能够执行涉及元数据的一些SQL 语句，如：新建表、新建索引、EXPLAIN 命令等，但是还不能执行 SELECT等类型的 SQL 语句。在 BusTub 中，还需要 <code>planner</code>模块的继续工作。相关代码如下：</p><ol type="1"><li><p><code>src/common/bustub_instance.cpp</code>：根据<code>binder</code> 模块返回的数据结构继续调用 <code>planner</code>模块：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Plan the query.</span><br><span class="hljs-function">bustub::Planner <span class="hljs-title">planner</span><span class="hljs-params">(*catalog_)</span></span>;<br>planner.<span class="hljs-built_in">PlanQuery</span>(*statement);<br>   <br><span class="hljs-comment">// Optimize the query.</span><br><span class="hljs-function">bustub::Optimizer <span class="hljs-title">optimizer</span><span class="hljs-params">(*catalog_, IsForceStarterRule())</span></span>;<br><span class="hljs-keyword">auto</span> optimized_plan = optimizer.<span class="hljs-built_in">Optimize</span>(planner.plan_);<br>   <br>l.<span class="hljs-built_in">unlock</span>();<br>   <br><span class="hljs-comment">// Execute the query.</span><br><span class="hljs-keyword">auto</span> exec_ctx = <span class="hljs-built_in">MakeExecutorContext</span>(txn);<br>std::vector&lt;Tuple&gt; result_set&#123;&#125;;<br>is_successful &amp;= execution_engine_-&gt;<span class="hljs-built_in">Execute</span>(optimized_plan, &amp;result_set, txn, exec_ctx.<span class="hljs-built_in">get</span>());<br></code></pre></td></tr></table></figure></li><li><p><code>src/planner/planner.cpp</code>：调用<code>Planner::PlanQuery</code> 方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Planner::PlanQuery</span><span class="hljs-params">(<span class="hljs-type">const</span> BoundStatement &amp;statement)</span> </span>&#123;<br>  <span class="hljs-keyword">switch</span> (statement.type_) &#123;<br>    <span class="hljs-keyword">case</span> StatementType::SELECT_STATEMENT: &#123;<br>      plan_ = <span class="hljs-built_in">PlanSelect</span>(<span class="hljs-built_in">dynamic_cast</span>&lt;<span class="hljs-type">const</span> SelectStatement &amp;&gt;(statement));<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> StatementType::INSERT_STATEMENT: &#123;<br>      plan_ = <span class="hljs-built_in">PlanInsert</span>(<span class="hljs-built_in">dynamic_cast</span>&lt;<span class="hljs-type">const</span> InsertStatement &amp;&gt;(statement));<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> StatementType::DELETE_STATEMENT: &#123;<br>      plan_ = <span class="hljs-built_in">PlanDelete</span>(<span class="hljs-built_in">dynamic_cast</span>&lt;<span class="hljs-type">const</span> DeleteStatement &amp;&gt;(statement));<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> StatementType::UPDATE_STATEMENT: &#123;<br>      plan_ = <span class="hljs-built_in">PlanUpdate</span>(<span class="hljs-built_in">dynamic_cast</span>&lt;<span class="hljs-type">const</span> UpdateStatement &amp;&gt;(statement));<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Exception</span>(fmt::format(<span class="hljs-string">&quot;the statement &#123;&#125; is not supported in planner yet&quot;</span>, statement.type_));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，根据 SQL 语句的不同类型，构造不同的执行Plan，如：<code>PlanSelect</code> 、<code>PlanInsert</code>等。</p></li><li><p><code>src/planner/plan_insert.cpp</code>：以比较简单的<code>InsertPlan</code> 为例，查看其构造流程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">Planner::PlanInsert</span><span class="hljs-params">(<span class="hljs-type">const</span> InsertStatement &amp;statement)</span> -&gt; AbstractPlanNodeRef </span>&#123;<br>  <span class="hljs-keyword">auto</span> select = <span class="hljs-built_in">PlanSelect</span>(*statement.select_);<br><br>  <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;table_schema = statement.table_-&gt;schema_.<span class="hljs-built_in">GetColumns</span>();<br>  <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;child_schema = select-&gt;<span class="hljs-built_in">OutputSchema</span>().<span class="hljs-built_in">GetColumns</span>();<br>  <span class="hljs-keyword">if</span> (!std::<span class="hljs-built_in">equal</span>(table_schema.<span class="hljs-built_in">cbegin</span>(), table_schema.<span class="hljs-built_in">cend</span>(), child_schema.<span class="hljs-built_in">cbegin</span>(), child_schema.<span class="hljs-built_in">cend</span>(),<br>                  [](<span class="hljs-keyword">auto</span> &amp;&amp;col1, <span class="hljs-keyword">auto</span> &amp;&amp;col2) &#123; <span class="hljs-keyword">return</span> col1.<span class="hljs-built_in">GetType</span>() == col2.<span class="hljs-built_in">GetType</span>(); &#125;)) &#123;<br>    <span class="hljs-keyword">throw</span> bustub::<span class="hljs-built_in">Exception</span>(<span class="hljs-string">&quot;table schema mismatch&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">auto</span> insert_schema = std::<span class="hljs-built_in">make_shared</span>&lt;Schema&gt;(std::vector&#123;<span class="hljs-built_in">Column</span>(<span class="hljs-string">&quot;__bustub_internal.insert_rows&quot;</span>, TypeId::INTEGER)&#125;);<br><br>  <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_shared</span>&lt;InsertPlanNode&gt;(std::<span class="hljs-built_in">move</span>(insert_schema), std::<span class="hljs-built_in">move</span>(select), statement.table_-&gt;oid_);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>至此，BusTub 中 SQL 解析相关模块主要代码介绍完毕。</p><h3 id="query-rewrite">4.2 Query Rewrite</h3><p>查询重写的原文定义如下：</p><blockquote><p>The query rewrite module, or rewriter, is responsible for simplifyingand normalizing the query without changing its semantics. It can relyonly on the query and on metadata in the catalog, and cannot access datain the tables.</p></blockquote><p>可见，查询重写主要做两件事：</p><ul><li>简化查询</li><li>规范化查询</li></ul><p>当前，前提是不改变查询语义，且仅依赖于 catalog 中的元数据。</p><p>在很多 DBMS中，查询重写并没有作为单独的模块实现，而是在语法解析或者查询优化中作为一个步骤实现。BusTub也是类似的思路，其源码中并没有单独实现查询重写。</p><p>查询重写主要负责以下任务：</p><ul><li>视图展开</li><li>常量数学表达式计算</li><li>谓词的逻辑重写</li><li>语义优化</li><li>子查询展开和其他启发式重写</li></ul><p>这些任务很大部分与查询优化重叠，这里不详细介绍。感兴趣可阅读原论文或者查询优化相关论文。</p><h3 id="query-optimizer">4.3 Query Optimizer</h3><p>查询优化器可以说是 DBMS 中最关键的组件之一，也是公认的 DBMS中最困难、最有挑战性的部分。</p><p>原论文中，本小节主要总结了目前的查询优化相关工作对 System R的经典论文做了哪些方面的改进，而不涉及具体的优化算法，因此本文也不详细介绍。</p><p>BusTub中有单独的优化器模块进行查询优化，实现了一些基于规则的查询优化策略：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree optimizer</span><br>optimizer<br>├── CMakeLists.txt<br>├── eliminate_true_filter.cpp<br>├── merge_filter_nlj.cpp<br>├── merge_filter_scan.cpp<br>├── merge_projection.cpp<br>├── nlj_as_hash_join.cpp<br>├── nlj_as_index_join.cpp<br>├── optimizer.cpp<br>├── optimizer_custom_rules.cpp<br>├── order_by_index_scan.cpp<br>└── sort_limit_as_topn.cpp<br><br>0 directories, 11 files<br></code></pre></td></tr></table></figure><h3 id="query-executor">4.4 Query Executor</h3><p>执行引擎在上述 SQL解析、查询计划生成、查询优化的基础上，根据优化后的查询计划，执行真正的查询。</p><p>大多数执行引擎采用火山模型，或者称之为：迭代器模型。每个执行算子拥有类似的接口，以BusTub 为例，其虚基类定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The AbstractExecutor implements the Volcano tuple-at-a-time iterator model.</span><br><span class="hljs-comment"> * This is the base class from which all executors in the BustTub execution</span><br><span class="hljs-comment"> * engine inherit, and defines the minimal interface that all executors support.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractExecutor</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Construct a new AbstractExecutor instance.</span><br><span class="hljs-comment">   * @param exec_ctx the executor context that the executor runs with</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">AbstractExecutor</span><span class="hljs-params">(ExecutorContext *exec_ctx)</span> : exec_ctx_&#123;</span>exec_ctx&#125; &#123;&#125;<br><br>  <span class="hljs-comment">/** Virtual destructor. */</span><br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">AbstractExecutor</span>() = <span class="hljs-keyword">default</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Initialize the executor.</span><br><span class="hljs-comment">   * @warning This function must be called before Next() is called!</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Yield the next tuple from this executor.</span><br><span class="hljs-comment">   * @param[out] tuple The next tuple produced by this executor</span><br><span class="hljs-comment">   * @param[out] rid The next tuple RID produced by this executor</span><br><span class="hljs-comment">   * @return `true` if a tuple was produced, `false` if there are no more tuples</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">Next</span><span class="hljs-params">(Tuple *tuple, RID *rid)</span> -&gt; <span class="hljs-type">bool</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">/** @return The schema of the tuples that this executor produces */</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">GetOutputSchema</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> -&gt; <span class="hljs-type">const</span> Schema &amp; </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">/** @return The executor context in which this executor runs */</span><br>  <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">GetExecutorContext</span><span class="hljs-params">()</span> -&gt; ExecutorContext * </span>&#123; <span class="hljs-keyword">return</span> exec_ctx_; &#125;<br><br> <span class="hljs-keyword">protected</span>:<br>  <span class="hljs-comment">/** The executor context in which the executor runs */</span><br>  ExecutorContext *exec_ctx_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中，与迭代器模型最相关的就是：<code>Init</code> 方法和<code>Next</code> 方法。</p><p>在 CMU 15-445/645 课程的 Project 3中，通过实现基本执行算子，我们对迭代器模型会有比较深入的了解。在 BusTub执行 SQL 语句的过程中，还有一些点需要关注：</p><ol type="1"><li><p><code>src/common/bustub_instance.cpp</code>：执行 SQL 语句</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Execute the query.</span><br><span class="hljs-keyword">auto</span> exec_ctx = <span class="hljs-built_in">MakeExecutorContext</span>(txn);<br>std::vector&lt;Tuple&gt; result_set&#123;&#125;;<br>is_successful &amp;= execution_engine_-&gt;<span class="hljs-built_in">Execute</span>(optimized_plan, &amp;result_set, txn, exec_ctx.<span class="hljs-built_in">get</span>());<br></code></pre></td></tr></table></figure><p>其中，<code>ececution_engine_</code> 是 <code>ExecutionEngine</code>类型的对象，其中封装了迭代器模型实现的算子，作为执行引擎。</p></li><li><p><code>src/include/execution/execution_engine.h</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Execute a query plan.</span><br><span class="hljs-comment">   * @param plan The query plan to execute</span><br><span class="hljs-comment">   * @param result_set The set of tuples produced by executing the plan</span><br><span class="hljs-comment">   * @param txn The transaction context in which the query executes</span><br><span class="hljs-comment">   * @param exec_ctx The executor context in which the query executes</span><br><span class="hljs-comment">   * @return `true` if execution of the query plan succeeds, `false` otherwise</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-comment">// NOLINTNEXTLINE</span><br>  <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">Execute</span><span class="hljs-params">(<span class="hljs-type">const</span> AbstractPlanNodeRef &amp;plan, std::vector&lt;Tuple&gt; *result_set, Transaction *txn,</span></span><br><span class="hljs-params"><span class="hljs-function">               ExecutorContext *exec_ctx)</span> -&gt; <span class="hljs-type">bool</span> </span>&#123;<br>    <span class="hljs-built_in">BUSTUB_ASSERT</span>((txn == exec_ctx-&gt;<span class="hljs-built_in">GetTransaction</span>()), <span class="hljs-string">&quot;Broken Invariant&quot;</span>);<br><br>    <span class="hljs-comment">// Construct the executor for the abstract plan node</span><br>    <span class="hljs-keyword">auto</span> executor = ExecutorFactory::<span class="hljs-built_in">CreateExecutor</span>(exec_ctx, plan);<br><br>    <span class="hljs-comment">// Initialize the executor</span><br>    <span class="hljs-keyword">auto</span> executor_succeeded = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>      executor-&gt;<span class="hljs-built_in">Init</span>();<br>      <span class="hljs-built_in">PollExecutor</span>(executor.<span class="hljs-built_in">get</span>(), plan, result_set);<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> ExecutionException &amp;ex) &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> NDEBUG</span><br>      <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;Error Encountered in Executor Execution: %s&quot;</span>, ex.<span class="hljs-built_in">what</span>());<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>      executor_succeeded = <span class="hljs-literal">false</span>;<br>      <span class="hljs-keyword">if</span> (result_set != <span class="hljs-literal">nullptr</span>) &#123;<br>        result_set-&gt;<span class="hljs-built_in">clear</span>();<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> executor_succeeded;<br>  &#125;<br></code></pre></td></tr></table></figure><p>根据执行计划，真正进行 SQL语句执行的接口。其函数体内部首先根据执行计划，调用工厂函数<code>ExecutorFactory::CreateExecutor(exec_ctx, plan)</code>构造执行算子。</p></li><li><p><code>src/execution/executor_factory.cpp</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">ExecutorFactory::CreateExecutor</span><span class="hljs-params">(ExecutorContext *exec_ctx, <span class="hljs-type">const</span> AbstractPlanNodeRef &amp;plan)</span></span><br><span class="hljs-function">    -&gt; std::unique_ptr&lt;AbstractExecutor&gt; </span>&#123;<br>  <span class="hljs-keyword">switch</span> (plan-&gt;<span class="hljs-built_in">GetType</span>()) &#123;<br>    <span class="hljs-comment">// Create a new sequential scan executor</span><br>    <span class="hljs-keyword">case</span> PlanType::SeqScan: &#123;<br>      <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;SeqScanExecutor&gt;(exec_ctx, <span class="hljs-built_in">dynamic_cast</span>&lt;<span class="hljs-type">const</span> SeqScanPlanNode *&gt;(plan.<span class="hljs-built_in">get</span>()));<br>    &#125;<br><br>    <span class="hljs-comment">// Create a new index scan executor</span><br>    <span class="hljs-keyword">case</span> PlanType::IndexScan: &#123;<br>      <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;IndexScanExecutor&gt;(exec_ctx, <span class="hljs-built_in">dynamic_cast</span>&lt;<span class="hljs-type">const</span> IndexScanPlanNode *&gt;(plan.<span class="hljs-built_in">get</span>()));<br>    &#125;<br><br>    <span class="hljs-comment">// Create a new insert executor</span><br>    <span class="hljs-keyword">case</span> PlanType::Insert: &#123;<br>      <span class="hljs-keyword">auto</span> insert_plan = <span class="hljs-built_in">dynamic_cast</span>&lt;<span class="hljs-type">const</span> InsertPlanNode *&gt;(plan.<span class="hljs-built_in">get</span>());<br>      <span class="hljs-keyword">auto</span> child_executor = ExecutorFactory::<span class="hljs-built_in">CreateExecutor</span>(exec_ctx, insert_plan-&gt;<span class="hljs-built_in">GetChildPlan</span>());<br>      <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;InsertExecutor&gt;(exec_ctx, insert_plan, std::<span class="hljs-built_in">move</span>(child_executor));<br>    &#125;<br><br>    <span class="hljs-comment">// Create a new update executor</span><br>    <span class="hljs-keyword">case</span> PlanType::Update: &#123;<br>      <span class="hljs-keyword">auto</span> update_plan = <span class="hljs-built_in">dynamic_cast</span>&lt;<span class="hljs-type">const</span> UpdatePlanNode *&gt;(plan.<span class="hljs-built_in">get</span>());<br>      <span class="hljs-keyword">auto</span> child_executor = ExecutorFactory::<span class="hljs-built_in">CreateExecutor</span>(exec_ctx, update_plan-&gt;<span class="hljs-built_in">GetChildPlan</span>());<br>      <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;UpdateExecutor&gt;(exec_ctx, update_plan, std::<span class="hljs-built_in">move</span>(child_executor));<br>    &#125;<br><br>    <span class="hljs-comment">// Create a new delete executor</span><br>    <span class="hljs-keyword">case</span> PlanType::Delete: &#123;<br>      <span class="hljs-keyword">auto</span> delete_plan = <span class="hljs-built_in">dynamic_cast</span>&lt;<span class="hljs-type">const</span> DeletePlanNode *&gt;(plan.<span class="hljs-built_in">get</span>());<br>      <span class="hljs-keyword">auto</span> child_executor = ExecutorFactory::<span class="hljs-built_in">CreateExecutor</span>(exec_ctx, delete_plan-&gt;<span class="hljs-built_in">GetChildPlan</span>());<br>      <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;DeleteExecutor&gt;(exec_ctx, delete_plan, std::<span class="hljs-built_in">move</span>(child_executor));<br>    &#125;<br><br>    <span class="hljs-comment">// 省略部分代码...</span><br><br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-built_in">UNREACHABLE</span>(<span class="hljs-string">&quot;Unsupported plan type.&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>工厂函数。根据执行计划的类型，递归构造不同的执行算子。</p></li><li><p><code>src/include/execution/execution_engine.h</code>：构造生成执行算子后，进行<code>poll</code> 操作，拉取结果元组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Poll the executor until exhausted, or exception escapes.</span><br><span class="hljs-comment"> * @param executor The root executor</span><br><span class="hljs-comment"> * @param plan The plan to execute</span><br><span class="hljs-comment"> * @param result_set The tuple result set</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">PollExecutor</span><span class="hljs-params">(AbstractExecutor *executor, <span class="hljs-type">const</span> AbstractPlanNodeRef &amp;plan,</span></span><br><span class="hljs-params"><span class="hljs-function">                         std::vector&lt;Tuple&gt; *result_set)</span> </span>&#123;<br>  RID rid&#123;&#125;;<br>  Tuple tuple&#123;&#125;;<br>  <span class="hljs-keyword">while</span> (executor-&gt;<span class="hljs-built_in">Next</span>(&amp;tuple, &amp;rid)) &#123;<br>    <span class="hljs-keyword">if</span> (result_set != <span class="hljs-literal">nullptr</span>) &#123;<br>      result_set-&gt;<span class="hljs-built_in">push_back</span>(tuple);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="storage-management">5. Storage Management</h2><p>DBMS 管理磁盘空间有两种基本方式：</p><ul><li>DBMS直接与磁盘的低级块模式设备驱动程序交互(通常称为原始模式访问)：早期系统采用的方式，现在很少使用。</li><li>使用操作系统标准文件操作接口：DBMS 创建一个文件，使用<code>offset</code>定位数据。文件被视为驻留在磁盘上的页面的线性数组。</li></ul><p>BusTub中，磁盘管理采用了后一种方式。其提供的主要接口就是读写页面，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * DiskManager takes care of the allocation and deallocation of pages within a database. It performs the reading and</span><br><span class="hljs-comment"> * writing of pages to and from disk, providing a logical file layer within the context of a database management system.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DiskManager</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Creates a new disk manager that writes to the specified database file.</span><br><span class="hljs-comment">   * @param db_file the file name of the database file to write to</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">DiskManager</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;db_file)</span></span>;<br><br>  <span class="hljs-comment">/** FOR TEST / LEADERBOARD ONLY, used by DiskManagerMemory */</span><br>  <span class="hljs-built_in">DiskManager</span>() = <span class="hljs-keyword">default</span>;<br><br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">DiskManager</span>() = <span class="hljs-keyword">default</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Shut down the disk manager and close all the file resources.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShutDown</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Write a page to the database file.</span><br><span class="hljs-comment">   * @param page_id id of the page</span><br><span class="hljs-comment">   * @param page_data raw page data</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">WritePage</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> page_id, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *page_data)</span></span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Read a page from the database file.</span><br><span class="hljs-comment">   * @param page_id id of the page</span><br><span class="hljs-comment">   * @param[out] page_data output buffer</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ReadPage</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> page_id, <span class="hljs-type">char</span> *page_data)</span></span>;<br><br>  <span class="hljs-comment">// 删除部分代码...</span><br><br> <span class="hljs-keyword">protected</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">GetFileSize</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;file_name)</span> -&gt; <span class="hljs-type">int</span></span>;<br>  <span class="hljs-comment">// stream to write log file</span><br>  std::fstream log_io_;<br>  std::string log_name_;<br>  <span class="hljs-comment">// stream to write db file</span><br>  std::fstream db_io_;<br>  std::string file_name_;<br>  <span class="hljs-type">int</span> num_flushes_&#123;<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-type">int</span> num_writes_&#123;<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-type">bool</span> flush_log_&#123;<span class="hljs-literal">false</span>&#125;;<br>  std::future&lt;<span class="hljs-type">void</span>&gt; *flush_log_f_&#123;<span class="hljs-literal">nullptr</span>&#125;;<br>  <span class="hljs-comment">// With multiple buffer pool instances, need to protect file access</span><br>  std::mutex db_io_latch_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>由于磁盘相比内存有限的读写速度，buffer pool 提供了内存缓冲，作为 DBMS与磁盘交互的中间人。缓冲池被组织成一个<strong>帧数组</strong>，其中每个帧是一个数据库磁盘块大小的内存区域。缓冲池的一个重要数据结构是哈希表，用于将page_id 映射到 frame_id。buffer pool manager 是 Project 1的内容，相关代码目录如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree buffer include/buffer container/hash</span><br>buffer<br>├── CMakeLists.txt<br>├── buffer_pool_manager_instance.cpp<br>├── clock_replacer.cpp<br>├── lru_k_replacer.cpp<br>└── lru_replacer.cpp<br>include/buffer<br>├── buffer_pool_manager.h<br>├── buffer_pool_manager_instance.h<br>├── clock_replacer.h<br>├── lru_k_replacer.h<br>├── lru_replacer.h<br>└── replacer.h<br>container/hash<br>├── CMakeLists.txt<br>└── extendible_hash_table.cpp<br><br></code></pre></td></tr></table></figure><p>可见，BusTub 中将其分为三个部分来实现：</p><ul><li>可扩展哈希表：用于将 page_id 映射到 frame_id。</li><li>页面替换策略：源码中包括LRU、 LRU-K、CLOCK 等页面替换算法。</li><li>buffer poolmanager：组装哈希表、替换策略等数据结构，构成缓冲区管理器。</li></ul><p>由于这一部分是 Project 1 内容，具体代码这里不介绍。</p><h2 id="transactions-concurrency-control-and-recovery">6. Transactions:Concurrency Control and Recovery</h2><p>设计良好的数据库系统能够划分为不同的组件，由不同团队分别进行开发维护，并以文档化的接口交流。但是，数据库管理系统中的事务存储管理器往往作为一个较难划分的整体，它通常包含四个相互交织的组件：</p><ul><li>用于并发控制的锁管理器</li><li>用于恢复的日志管理器</li><li>用于暂存数据库 I/O 的缓冲池</li><li>在磁盘上组织数据的访问方法</li></ul><p>这些组件对事务的 ACID 特性提供了不同保证：</p><blockquote><p>Roughly speaking, modern DBMSs implement isolation via a lockingprotocol. Durability is typically implemented via logging and recovery.Isolation and Atomicity are guaranteed by a combination of locking (toprevent visibility of transient database states), and logging (to ensurecorrectness of data that is visible). Consistency is managed by runtimechecks in the query executor: if a transaction’s actions will violate aSQL integrity constraint, the transaction is aborted and an error codereturned.</p></blockquote><p>BusTub在不同年份设计了不同的并发控制相关实验，其相关代码目录结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree concurrency include/concurrency</span><br>concurrency<br>├── CMakeLists.txt<br>├── lock_manager.cpp<br>└── transaction_manager.cpp<br>include/concurrency<br>├── lock_manager.h<br>├── transaction.h<br>└── transaction_manager.h<br><br>0 directories, 3 files<br></code></pre></td></tr></table></figure><p>在 Fall 2022 Project 4 中，需要实现 2PL算法，以及在物理算子中调用相关接口，实现不同的隔离级别。由于没有将并发控制与恢复系统结合起来，很难通过BusTub 学习到实现完整的事务支持对数据库系统不同组件会带来什么影响。</p><p>当然，这一主题本身很复杂，后续深入学习后，有机会再做分享。</p><h2 id="shared-components">7. Shared Components</h2><h3 id="catalog-manager">7.1 Catalog Manager</h3><p>Catalog Manager 作用如下：</p><blockquote><p>The database catalog holds information about data in the system andis a form of metadata. The catalog records the names of basic entitiesin the system (users, schemas, tables, columns, indexes, etc.) and theirrelationships, and is itself stored as a set of tables in thedatabase.</p></blockquote><p>BusTub 中，Catalog Manager 相关代码目录组织如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree catalog include/catalog</span><br>catalog<br>├── CMakeLists.txt<br>├── column.cpp<br>├── schema.cpp<br>└── table_generator.cpp<br>include/catalog<br>├── catalog.h<br>├── column.h<br>├── schema.h<br>└── table_generator.h<br></code></pre></td></tr></table></figure><p>在 <code>src/include/catalog/catalog.h</code>中，相关数据结构和接口如下：</p><img src="/2024/05/13/%E4%BB%8E-BusTub-%E7%9C%8B-Architecture-of-a-Database-System/image-20240513235256924.png" class="" title="image-20240513235256924"><p><br></p><p>这也是我们进行 Project 3 时必须阅读的代码之一。</p><p>其它共享组件还有内存分配器、磁盘管理子系统等，这里不再介绍。</p><h2 id="conclusion">8. Conclusion</h2><p>最后，贴上原论文的 Conclusion 部分，同时也作为本文的总结。</p><blockquote><p>As should be clear from this paper, modern commercial databasesystems are grounded both in academic research and in the experiences ofdeveloping industrial-strength products for high-end customers. The taskof writing and maintaining a high-performance, fully functionalrelational DBMS from scratch is an enormous investment in time andenergy. Many of the lessons of relational DBMSs, however, translate overto new domains. Web services, network-attached storage, text and e-mailrepositories, notiﬁcation services, and network monitors can all beneﬁtfrom DBMS research and experience. Data-intensive services are at thecore of computing today, and knowledge of database system design is askill that is broadly applicable, both inside and outside the halls ofthe main database shops. These new directions raise a number of researchproblems in database management as well, and point the way to newinteractions between the database community and other areas ofcomputing.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bustub</tag>
      
      <tag>DBMS</tag>
      
      <tag>CMU 15-445/645</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信号与定时器</title>
    <link href="/2024/05/08/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    <url>/2024/05/08/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文是《Linux高性能服务器编程》阅读记录，供以后查阅参考。推荐阅读原书。</p><p>所有函数未标明需要包含什么头文件，可使用 <code>man</code>命令自行查询。</p></blockquote><h2 id="信号">1. 信号</h2><p>信号是由用户、系统或者进程发送给目标进程的信息，以通知目标进程某个状态的改变或系统异常。服务器程序必须处理（或至少忽略）一些常见的信号，以免异常终止。</p><h3 id="linux-信号相关-api">1.1 Linux 信号相关 API</h3><h4 id="发送信号">1.1.1 发送信号</h4><p>使用 <code>kill</code> 函数发送信号给某个进程，函数接口如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Send signal SIG to process number PID.  If PID is zero,</span><br><span class="hljs-comment">   send SIG to all processes in the current process&#x27;s process group.</span><br><span class="hljs-comment">   If PID is &lt; -1, send SIG to all processes in process group - PID.  */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kill</span> <span class="hljs-params">(<span class="hljs-type">__pid_t</span> __pid, <span class="hljs-type">int</span> __sig)</span>;<br></code></pre></td></tr></table></figure><p><code>pid</code> 的取值会影响 <code>kill</code>函数的行为，具体如下：</p><img src="/2024/05/08/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E5%AE%9A%E6%97%B6%E5%99%A8/image-20240506192626096.png" class="" title="image-20240506192626096"><p><code>sig</code> 表示信号。Linux 定义的信号值都大于 0，如果<code>sig</code> 取值为 0，则 <code>kill</code> 函数不发送任何信号。</p><h4 id="信号处理方式">1.1.2 信号处理方式</h4><p>目标进程在收到信号时，需要定义一个接收函数来处理之。信号处理函数的声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Type of a signal handler.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*<span class="hljs-type">__sighandler_t</span>)</span> <span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<br></code></pre></td></tr></table></figure><p>信号处理函数参数为 <code>int</code>类型，指示信号类型。信号处理函数必须是可重入的，不能调用一些不安全的函数。</p><p>用户可以自定义信号处理函数，也可以使用系统提供的一些可选的默认处理方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span>SIG_DFL ((__sighandler_t)  0)<span class="hljs-comment">/* Default action.  */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>SIG_IGN ((__sighandler_t)  1)<span class="hljs-comment">/* Ignore signal.  */</span></span><br></code></pre></td></tr></table></figure><p>默认处理方式包括：：结束进程（Term）、忽略信号（Ign）、结束进程并生成核心转储文件（Core）、暂停进程（Stop），以及继续进程（Cont）。</p><h4 id="linux-信号">1.1.3 Linux 信号</h4><p>Linux 系统中定义的信号可使用 <code>kill -l</code> 命令查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">kill</span> -l</span><br> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP<br> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1<br>11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM<br>16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP<br>21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ<br>26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR<br>31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3<br>38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8<br>43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13<br>48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12<br>53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7<br>58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2<br>63) SIGRTMAX-1  64) SIGRTMAX<br></code></pre></td></tr></table></figure><p>其中，标准信号含义及系统默认处理行为如下：</p><img src="/2024/05/08/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E5%AE%9A%E6%97%B6%E5%99%A8/image-20240506194220807.png" class="" title="image-20240506194220807"><img src="/2024/05/08/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E5%AE%9A%E6%97%B6%E5%99%A8/image-20240506194306926.png" class="" title="image-20240506194306926"><p>我们并不需要在代码中处理所有这些信号。其中与网络编程关系紧密的信号有：<code>SIGHUP</code>、<code>SIGPIPE</code>和<code>SIGURG</code>。以及定时器相关的信号：<code>SIGALRM</code>、<code>SIGCHLD</code>等。</p><h3 id="信号函数">1.2 信号函数</h3><h4 id="signal">1.2.1 signal</h4><p><code>signal</code> 函数用于为一个信号设置处理函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Set the handler for the signal SIG to HANDLER, returning the old</span><br><span class="hljs-comment">   handler, or SIG_ERR on error.</span><br><span class="hljs-comment">   By default `signal&#x27; has the BSD semantic.  */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">__sighandler_t</span> <span class="hljs-title function_">signal</span> <span class="hljs-params">(<span class="hljs-type">int</span> __sig, <span class="hljs-type">__sighandler_t</span> __handler)</span>;<br></code></pre></td></tr></table></figure><h4 id="sigaction">1.2.2 sigaction</h4><p><code>sigaction</code> 是设置信号处理函数的更健壮的接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Get and/or set the action for signal SIG.  */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sigaction</span> <span class="hljs-params">(<span class="hljs-type">int</span> __sig, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sigaction *__restrict __act,</span><br><span class="hljs-params">      <span class="hljs-keyword">struct</span> sigaction *__restrict __oact)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>sig</code>：指定要捕获的信号类型</li><li><code>act</code>：指定新的信号处理方式</li><li><code>oact</code>：用于输出信号之前的处理方式</li></ul><p><code>sigaction</code> 结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Structure describing the action to be taken when a signal arrives.  */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span></span><br><span class="hljs-class">  &#123;</span><br>    <span class="hljs-comment">/* Signal handler.  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined __USE_POSIX199309 || defined __USE_XOPEN_EXTENDED</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span></span><br><span class="hljs-class">      &#123;</span><br><span class="hljs-comment">/* Used if SA_SIGINFO is not set.  */</span><br><span class="hljs-type">__sighandler_t</span> sa_handler;<br><span class="hljs-comment">/* Used if SA_SIGINFO is set.  */</span><br><span class="hljs-type">void</span> (*sa_sigaction) (<span class="hljs-type">int</span>, <span class="hljs-type">siginfo_t</span> *, <span class="hljs-type">void</span> *);<br>      &#125;<br>    __sigaction_handler;<br><span class="hljs-meta"># <span class="hljs-keyword">define</span> sa_handler__sigaction_handler.sa_handler</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> sa_sigaction__sigaction_handler.sa_sigaction</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-type">__sighandler_t</span> sa_handler;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* Additional set of signals to be blocked.  */</span><br>    <span class="hljs-type">__sigset_t</span> sa_mask;<br><br>    <span class="hljs-comment">/* Special flags.  */</span><br>    <span class="hljs-type">int</span> sa_flags;<br><br>    <span class="hljs-comment">/* Restore handler.  */</span><br>    <span class="hljs-type">void</span> (*sa_restorer) (<span class="hljs-type">void</span>);<br>  &#125;;<br></code></pre></td></tr></table></figure><ul><li><p><code>sa_hander</code>：指定信号处理函数。</p></li><li><p><code>sa_mask</code>：设置进程的信号掩码（确切地说是在进程原有信号掩码的基础上增加信号掩码），以指定哪些信号不能发送给本进程。</p></li><li><p><code>sa_flags</code>：用于设置程序收到信号时的行为，可选值如下：</p><img src="/2024/05/08/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E5%AE%9A%E6%97%B6%E5%99%A8/image-20240506200258149.png" class="" title="image-20240506200258149"></li></ul><h3 id="信号集">1.3 信号集</h3><h4 id="信号集函数">1.3.1 信号集函数</h4><p>Linux 使用数据结构 <code>sigset_t</code>来表示一组信号，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _SIGSET_NWORDS (1024 / (8 * sizeof (unsigned long int)))</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> __val[_SIGSET_NWORDS];<br>&#125; <span class="hljs-type">__sigset_t</span>;<br></code></pre></td></tr></table></figure><p><code>sigset_t</code>实际上是一个长整型数组，数组的每个元素的每个位表示一个信号。这种定义方式和文件描述符集<code>fd_set</code> 类似。Linux提供了如下一组函数来设置、修改、删除和查询信号集：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Clear all signals from SET.  */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sigemptyset</span> <span class="hljs-params">(<span class="hljs-type">sigset_t</span> *__set)</span> __THROW __<span class="hljs-title function_">nonnull</span> <span class="hljs-params">((<span class="hljs-number">1</span>))</span>;<br><br><span class="hljs-comment">/* Set all signals in SET.  */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sigfillset</span> <span class="hljs-params">(<span class="hljs-type">sigset_t</span> *__set)</span> __THROW __<span class="hljs-title function_">nonnull</span> <span class="hljs-params">((<span class="hljs-number">1</span>))</span>;<br><br><span class="hljs-comment">/* Add SIGNO to SET.  */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sigaddset</span> <span class="hljs-params">(<span class="hljs-type">sigset_t</span> *__set, <span class="hljs-type">int</span> __signo)</span> __THROW __<span class="hljs-title function_">nonnull</span> <span class="hljs-params">((<span class="hljs-number">1</span>))</span>;<br><br><span class="hljs-comment">/* Remove SIGNO from SET.  */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sigdelset</span> <span class="hljs-params">(<span class="hljs-type">sigset_t</span> *__set, <span class="hljs-type">int</span> __signo)</span> __THROW __<span class="hljs-title function_">nonnull</span> <span class="hljs-params">((<span class="hljs-number">1</span>))</span>;<br><br><span class="hljs-comment">/* Return 1 if SIGNO is in SET, 0 if not.  */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sigismember</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *__set, <span class="hljs-type">int</span> __signo)</span><br>     __THROW __<span class="hljs-title function_">nonnull</span> <span class="hljs-params">((<span class="hljs-number">1</span>))</span>;<br></code></pre></td></tr></table></figure><h4 id="进程信号掩码">1.3.2 进程信号掩码</h4><p>除了 <code>sigaction</code> 结构体的 <code>sa_mask</code>成员可以用来设置进程的信号掩码，<code>sigprocmask</code>函数也可用于设置或查看进程的信号掩码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Get and/or change the set of blocked signals.  */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sigprocmask</span> <span class="hljs-params">(<span class="hljs-type">int</span> __how, <span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *__restrict __set,</span><br><span class="hljs-params"><span class="hljs-type">sigset_t</span> *__restrict __oset)</span> __THROW;<br></code></pre></td></tr></table></figure><ul><li><p><code>set</code>：指定新的信号掩码。</p></li><li><p><code>oset</code>：若不为<code>NULL</code>，用于输出原来的信号掩码。</p></li><li><p><code>set</code>：若不为<code>NULL</code>，指定设置进程信号掩码的方式，可选值如下表所示：</p><img src="/2024/05/08/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E5%AE%9A%E6%97%B6%E5%99%A8/image-20240506201325249.png" class="" title="image-20240506201325249"></li></ul><p>若 <code>set</code> 为<code>NULL</code>，信号掩码不变，<code>oset</code>用于获取进程当前的信号掩码。</p><h4 id="被挂起的信号">1.3.3 被挂起的信号</h4><p>设置进程信号掩码后，被屏蔽的信号将不能被进程接收。如果给进程发送一个被屏蔽的信号，则操作系统将该信号设置为进程的一个被挂起的信号。如果我们取消对被挂起信号的屏蔽，则它能立即被进程接收到。如下函数可以获得进程当前被挂起的信号集：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Put in SET all signals that are blocked and waiting to be delivered.  */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sigpending</span> <span class="hljs-params">(<span class="hljs-type">sigset_t</span> *__set)</span> __THROW __<span class="hljs-title function_">nonnull</span> <span class="hljs-params">((<span class="hljs-number">1</span>))</span>;<br></code></pre></td></tr></table></figure><p>在多进程、多线程环境中，我们要以进程、线程为单位来处理信号和信号掩码。我们不能设想新创建的进程、线程具有和父进程、主线程完全相同的信号特征。比如，<code>fork</code>调用产生的子进程将继承父进程的信号掩码，但具有一个空的挂起信号集。</p><h3 id="统一事件源">1.4 统一事件源</h3><p>信号是一种异步事件：信号处理函数和程序的主循环是两条不同的执行路线。信号处理函数需要尽可能快地执行完毕，以确保该信号不被屏蔽（前面提到过，为了避免一些竞态条件，信号在处理期间，系统不会再次触发它）太久。</p><p>一种典型的解决方案是：把信号的主要处理逻辑放到程序的主循环中，当信号处理函数被触发时，它只是简单地通知主循环程序接收到信号，并把信号值传递给主循环，主循环再根据接收到的信号值执行目标信号对应的逻辑代码。信号处理函数通常使用管道来将信号“传递”给主循环：信号处理函数往管道的写端写入信号值，主循环则从管道的读端读出该信号值。那么主循环怎么知道管道上何时有数据可读呢？这很简单，我们只需要使用I/O复用系统调用来监听管道的读端文件描述符上的可读事件。如此一来，信号事件就能和其他I/O 事件一样被处理，即统一事件源。核心代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_EVENT_NUMBER 1024</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>];  <span class="hljs-comment">// 管道</span><br><br><span class="hljs-comment">// 信号处理函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sig_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span> </span>&#123;<br>  <span class="hljs-type">int</span> save_errno = errno;<br>  <span class="hljs-type">int</span> msg = sig;<br>  <span class="hljs-built_in">send</span>(pipefd[<span class="hljs-number">1</span>], (<span class="hljs-type">char</span> *)&amp;msg, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 向管道写入信号</span><br>  errno = save_errno;<br>&#125;<br><br><span class="hljs-comment">// 主函数关键逻辑</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>  <span class="hljs-comment">// 省略部分代码 ......</span><br>  epoll_event events[MAX_EVENT_NUMBER];<br>  <span class="hljs-type">int</span> epollfd = <span class="hljs-built_in">epoll_create</span>(<span class="hljs-number">5</span>);<br>  <span class="hljs-built_in">assert</span>(epollfd != <span class="hljs-number">-1</span>);<br>  <span class="hljs-built_in">addfd</span>(epollfd, listenfd);<br><br>  ret = <span class="hljs-built_in">socketpair</span>(PF_UNIX, SOCK_STREAM, <span class="hljs-number">0</span>, pipefd);<br>  <span class="hljs-built_in">assert</span>(ret != <span class="hljs-number">-1</span>);<br>  <span class="hljs-built_in">setnonblocking</span>(pipefd[<span class="hljs-number">1</span>]);<br>  <span class="hljs-built_in">addfd</span>(epollfd, pipefd[<span class="hljs-number">0</span>]);<span class="hljs-comment">// 监听管道文件描述符</span><br><br>  <span class="hljs-comment">// 注册感兴趣信号的信号处理函数</span><br>  <span class="hljs-built_in">addsig</span>(SIGHUP);<br>  <span class="hljs-built_in">addsig</span>(SIGCHLD);<br>  <span class="hljs-built_in">addsig</span>(SIGTERM);<br>  <span class="hljs-built_in">addsig</span>(SIGINT);<br><br>  <span class="hljs-type">bool</span> stop_server = <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-keyword">while</span> (!stop_server) &#123;<br>    <span class="hljs-type">int</span> number = <span class="hljs-built_in">epoll_wait</span>(epollfd, events, MAX_EVENT_NUMBER, <span class="hljs-number">-1</span>);<br>    <span class="hljs-comment">// 省略部分代码 ......</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; number; i++) &#123;<br>      <span class="hljs-type">int</span> sockfd = events[i].data.fd;<br>      <span class="hljs-keyword">if</span> (sockfd == listenfd) &#123;<br>        <span class="hljs-comment">// 省略部分代码 ......</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((sockfd == pipefd[<span class="hljs-number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;<br>        <span class="hljs-type">int</span> sig;<br>        <span class="hljs-type">char</span> signals[<span class="hljs-number">1024</span>];<br>        ret = <span class="hljs-built_in">recv</span>(pipefd[<span class="hljs-number">0</span>], signals, <span class="hljs-built_in">sizeof</span>(signals), <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>          <span class="hljs-keyword">continue</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">continue</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 处理信号</span><br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ret; ++i) &#123;<br>            <span class="hljs-comment">// printf( &quot;I caugh the signal %d\n&quot;, signals[i] );</span><br>            <span class="hljs-keyword">switch</span> (signals[i]) &#123;<br>              <span class="hljs-keyword">case</span> SIGCHLD:<br>              <span class="hljs-keyword">case</span> SIGHUP: &#123;<br>                <span class="hljs-keyword">continue</span>;<br>              &#125;<br>              <span class="hljs-keyword">case</span> SIGTERM:<br>              <span class="hljs-keyword">case</span> SIGINT: &#123;<br>                stop_server = <span class="hljs-literal">true</span>;<br>              &#125;<br>            &#125;<br>          &#125;<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 省略关闭文件描述符等操作 ......</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="网络编程相关信号">1.5 网络编程相关信号</h3><h4 id="sighup">1.5.1 SIGHUP</h4><p>当挂起进程的控制终端时，<code>SIGHUP</code>信号将被触发。对于没有控制终端的网络后台程序而言，它们通常利用<code>SIGHUP</code> 信号来强制服务器<strong>重读配置文件</strong>。</p><h4 id="sigpipe">1.5.2 SIGPIPE</h4><p>默认情况下，往一个读端关闭的管道或 <code>socket</code>连接中写数据将引发 <code>SIGPIPE</code>信号。我们需要在代码中捕获并处理该信号，或者至少忽略它，因为程序接收到<code>SIGPIPE</code>信号的默认行为是结束进程，而我们绝对不希望因为错误的写操作而导致程序退出。引起<code>SIGPIPE</code> 信号的写操作将设置 <code>errno</code> 为<code>EPIPE</code>。</p><h4 id="sigurg">1.5.3 SIGURG</h4><p>在 Linux 环境下，内核通知应用程序带外数据到达主要有两种方法：一种是I/O 复用技术，<code>select</code>等系统调用在接收到带外数据时将返回，并向应用程序报告 <code>socket</code>上的异常事件；另外一种方法就是使用 <code>SIGURG</code> 信号：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sig_urg</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span> </span>&#123;<br>  <span class="hljs-type">int</span> save_errno = errno;<br><br>  <span class="hljs-type">char</span> buffer[BUF_SIZE];<br>  <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-string">&#x27;\0&#x27;</span>, BUF_SIZE);<br>  <span class="hljs-type">int</span> ret = <span class="hljs-built_in">recv</span>(connfd, buffer, BUF_SIZE - <span class="hljs-number">1</span>, MSG_OOB);  <span class="hljs-comment">// 接收带外数据</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;got %d bytes of oob data &#x27;%s&#x27;\n&quot;</span>, ret, buffer);<br><br>  errno = save_errno;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="定时器">2. 定时器</h2><h3 id="socket-选项-so_rcvtimeo-和-so_sndtimeo">2.1 socket 选项SO_RCVTIMEO 和 SO_SNDTIMEO</h3><p><code>socket</code> 选项 <code>so_RCVTIMEO</code> 和<code>SO_SNDTIMEO</code> 用于设置 <code>socket</code>接收数据超时时间和发送数据超时时间。这两个选项仅对 <code>socket</code>相关的专用系统调用有效，具体影响如下：</p><img src="/2024/05/08/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E5%AE%9A%E6%97%B6%E5%99%A8/image-20240508151901318.png" class="" title="image-20240508151901318"><p>使用 <code>setsocketopt</code> 设置 <code>socket</code>定时属性示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> sockfd = <span class="hljs-built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">assert</span>(sockfd &gt;= <span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">timeval</span> timeout;<br>timeout.tv_sec = time;<br>timeout.tv_usec = <span class="hljs-number">0</span>;<br><span class="hljs-type">socklen_t</span> len = <span class="hljs-built_in">sizeof</span>(timeout);<br>ret = <span class="hljs-built_in">setsockopt</span>(sockfd, SOL_SOCKET, SO_SNDTIMEO, &amp;timeout, len);  <span class="hljs-comment">// 设置发送数据定时时间</span><br><span class="hljs-built_in">assert</span>(ret != <span class="hljs-number">-1</span>);<br></code></pre></td></tr></table></figure><h3 id="sigalrm-信号">2.2 SIGALRM 信号</h3><p>可以使用 <code>alarm</code> 和 <code>setitimer</code>函数设置定时闹钟，超时时将触发 <code>SIGALRM</code>信号，可以利用该信号的信号处理函数来处理任务。</p><h4 id="基于升序链表的定时器">2.2.1 基于升序链表的定时器</h4><p>定时器通常至少要包含两个成员：一个<strong>超时时间（相对时间或者绝对时间）</strong>和一个<strong>任务回调函数</strong>。有的时候还可能包含回调函数被执行时需要传入的参数，以及是否重启定时器等信息。使用链表时，还需要维护指针信息。可以使用升序列表维护一些定时器，当收到<code>SIGALRM</code>信号后，执行回调函数，以执行定时任务。部分关键代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_SIZE 64</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">util_timer</span>;<br><br><span class="hljs-comment">// 用户数据结构</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">client_data</span> &#123;<br>  sockaddr_in address;    <span class="hljs-comment">// 客户端 socket 地址</span><br>  <span class="hljs-type">int</span> sockfd;             <span class="hljs-comment">// socket 文件描述符</span><br>  <span class="hljs-type">char</span> buf[BUFFER_SIZE];  <span class="hljs-comment">// 读缓存</span><br>  util_timer *timer;      <span class="hljs-comment">// 定时器</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">util_timer</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">util_timer</span>() : <span class="hljs-built_in">prev</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br><br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-type">time_t</span> expire;                   <span class="hljs-comment">// 任务的超时时间 绝对时间</span><br>  <span class="hljs-built_in">void</span> (*cb_func)(client_data *);  <span class="hljs-comment">// 任务回调函数</span><br>  client_data *user_data;          <span class="hljs-comment">// 回调函数处理的客户数据，由定时器的执行者传递给回调函数</span><br>  util_timer *prev;<br>  util_timer *next;<br>&#125;;<br><br><span class="hljs-comment">// 定时器链表：升序双向链表</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sort_timer_lst</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// 添加定时器</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_timer</span><span class="hljs-params">(util_timer *timer)</span> </span>&#123;<br>   <br>  &#125;<br><br>  <span class="hljs-comment">// 当某个定时任务发生变化时（expire 属性增加）， 调整定时器在链表中位置</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">adjust_timer</span><span class="hljs-params">(util_timer *timer)</span> </span>&#123;<br>    <br>  &#125;<br><br>  <span class="hljs-comment">// 删除指定定时器</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del_timer</span><span class="hljs-params">(util_timer *timer)</span> </span>&#123;<br>    <br>  &#125;<br><br>  <span class="hljs-comment">// SIGALRM 信号每次被触发时，就在其信号处理函数（如果使用统一时间源，则是主函数）中执行一次 tick</span><br>  <span class="hljs-comment">// 函数，以处理链表上的到期任务</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tick</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!head) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;timer tick\n&quot;</span>);<br>    <span class="hljs-type">time_t</span> cur = <span class="hljs-built_in">time</span>(<span class="hljs-literal">nullptr</span>);  <span class="hljs-comment">// 获得系统当前时间</span><br>    util_timer *tmp = head;<br><br>    <span class="hljs-comment">// 从头结点开始依次处理每个定时器，直到遇到一个尚未到期的定时器，这就是定时器的核心逻辑</span><br>    <span class="hljs-keyword">while</span> (tmp) &#123;<br>      <span class="hljs-comment">// 因为每个定时器都使用绝对时间作为超时值，所以我们可以把定时器的超时值和系统当前时间，比较以判断定时器是否到期</span><br>      <span class="hljs-keyword">if</span> (cur &lt; tmp-&gt;expire) &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      tmp-&gt;<span class="hljs-built_in">cb_func</span>(tmp-&gt;user_data);  <span class="hljs-comment">// 调用回调函数</span><br>      <span class="hljs-comment">// 执行完定时器中的定时任务之后，就将它从链表中删除，并重置链表头结点</span><br>      head = tmp-&gt;next;<br>      <span class="hljs-keyword">if</span> (head) &#123;<br>        head-&gt;prev = <span class="hljs-literal">nullptr</span>;<br>      &#125;<br>      <span class="hljs-keyword">delete</span> tmp;<br>      tmp = head;<br>    &#125;<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  util_timer *head;<br>  util_timer *tail;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="处理非活动连接">2.2.2 处理非活动连接</h4><p>定时任务可用于处理非活动连接。服务器程序通常要定期处理非活动连接：给客户端发一个重连请求，或者关闭该连接，或者其他。Linux在内核中提供了对连接是否处于活动状态的定期检查机制，我们可以通过<code>socket</code> 选项 <code>KEEPALIVE</code>来激活它。不过使用这种方式将使得应用程序对连接的管理变得复杂。因此，我们可以考虑在应用层实现类似于<code>KEEPALIVE</code>的机制，以管理所有长时间处于非活动状态的连接。具体来说，可以利用<code>alarm</code> 函数周期性地触发 <code>SIGALRM</code>信号，该信号的信号处理函数利用管道通知主循环执行定时器链表上的定时任务，处理非活动连接。部分关键代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">timer_handler</span><span class="hljs-params">()</span> </span>&#123;<br>  timer_lst.<span class="hljs-built_in">tick</span>();<br>  <span class="hljs-comment">// 一次 alarm 调用之和产生一次 SIGALRM 信号，因此这里要重新启动定时器</span><br>  <span class="hljs-built_in">alarm</span>(TIMESLOT);  <span class="hljs-comment">// 重新启动计时器</span><br>&#125;<br><br><span class="hljs-comment">// 回调函数：删除 epoll 注册 并 关闭客户连接</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cb_func</span><span class="hljs-params">(client_data *user_data)</span> </span>&#123;<br>  <span class="hljs-built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_DEL, user_data-&gt;sockfd, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">assert</span>(user_data);<br>  <span class="hljs-built_in">close</span>(user_data-&gt;sockfd);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;close fd %d\n&quot;</span>, user_data-&gt;sockfd);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>  <span class="hljs-type">int</span> listenfd = <span class="hljs-built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br><br>  ret = <span class="hljs-built_in">bind</span>(listenfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;address, <span class="hljs-built_in">sizeof</span>(address));<br><br>  ret = <span class="hljs-built_in">listen</span>(listenfd, <span class="hljs-number">5</span>);<br><br>  epoll_event events[MAX_EVENT_NUMBER];<br>  <span class="hljs-type">int</span> epollfd = <span class="hljs-built_in">epoll_create</span>(<span class="hljs-number">5</span>);  <span class="hljs-comment">// epoll</span><br>  <span class="hljs-built_in">assert</span>(epollfd != <span class="hljs-number">-1</span>);<br>  <span class="hljs-built_in">addfd</span>(epollfd, listenfd);  <span class="hljs-comment">// 监听 listenfd</span><br><br>  ret = <span class="hljs-built_in">socketpair</span>(PF_UNIX, SOCK_STREAM, <span class="hljs-number">0</span>, pipefd);  <span class="hljs-comment">// 创建管道</span><br>  <span class="hljs-built_in">assert</span>(ret != <span class="hljs-number">-1</span>);<br>  <span class="hljs-built_in">setnonblocking</span>(pipefd[<span class="hljs-number">1</span>]);<br>  <span class="hljs-built_in">addfd</span>(epollfd, pipefd[<span class="hljs-number">0</span>]);  <span class="hljs-comment">// 监听管道读取端</span><br><br>  <span class="hljs-comment">// add all the interesting signals here</span><br>  <span class="hljs-built_in">addsig</span>(SIGALRM);<br>  <span class="hljs-built_in">addsig</span>(SIGTERM);  <span class="hljs-comment">// 信号</span><br>  <span class="hljs-type">bool</span> stop_server = <span class="hljs-literal">false</span>;<br><br>  client_data *users = <span class="hljs-keyword">new</span> client_data[FD_LIMIT];<br>  <span class="hljs-type">bool</span> timeout = <span class="hljs-literal">false</span>;<br>  <span class="hljs-built_in">alarm</span>(TIMESLOT);  <span class="hljs-comment">// TIMESLOT 秒后，触发 SIGALRM 信号</span><br><br>  <span class="hljs-keyword">while</span> (!stop_server) &#123;<br>    <span class="hljs-type">int</span> number = <span class="hljs-built_in">epoll_wait</span>(epollfd, events, MAX_EVENT_NUMBER, <span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; number; i++) &#123;<br>      <span class="hljs-type">int</span> sockfd = events[i].data.fd;<br>      <span class="hljs-keyword">if</span> (sockfd == listenfd) &#123;  <span class="hljs-comment">// 处理新连接</span><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> client_address;<br>        <span class="hljs-type">socklen_t</span> client_addrlength = <span class="hljs-built_in">sizeof</span>(client_address);<br>        <span class="hljs-type">int</span> connfd = <span class="hljs-built_in">accept</span>(listenfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;client_address, &amp;client_addrlength);<br>        <span class="hljs-built_in">addfd</span>(epollfd, connfd);<br>        users[connfd].address = client_address;<br>        users[connfd].sockfd = connfd;<br>        util_timer *timer = <span class="hljs-keyword">new</span> util_timer;<br>        timer-&gt;user_data = &amp;users[connfd];<br>        timer-&gt;cb_func = cb_func;<br>        <span class="hljs-type">time_t</span> cur = <span class="hljs-built_in">time</span>(<span class="hljs-literal">nullptr</span>);<br>        timer-&gt;expire = cur + <span class="hljs-number">3</span> * TIMESLOT;<br>        users[connfd].timer = timer;<br>        timer_lst.<span class="hljs-built_in">add_timer</span>(timer);                                        <span class="hljs-comment">// 生成定时任务并加入 sorted_list</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((sockfd == pipefd[<span class="hljs-number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;  <span class="hljs-comment">// 处理信号</span><br>        <span class="hljs-type">int</span> sig;<br>        <span class="hljs-type">char</span> signals[<span class="hljs-number">1024</span>];<br>        ret = <span class="hljs-built_in">recv</span>(pipefd[<span class="hljs-number">0</span>], signals, <span class="hljs-built_in">sizeof</span>(signals), <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>          <span class="hljs-comment">// handle the error</span><br>          <span class="hljs-keyword">continue</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">continue</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ret; ++i) &#123;<br>            <span class="hljs-keyword">switch</span> (signals[i]) &#123;<br>              <span class="hljs-keyword">case</span> SIGALRM: &#123;  <span class="hljs-comment">// SIGALRM</span><br>                timeout = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>              &#125;<br>              <span class="hljs-keyword">case</span> SIGTERM: &#123;<br>                stop_server = <span class="hljs-literal">true</span>;<br>              &#125;<br>            &#125;<br>          &#125;<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;<br>        <span class="hljs-built_in">memset</span>(users[sockfd].buf, <span class="hljs-string">&#x27;\0&#x27;</span>, BUFFER_SIZE);<br>        ret = <span class="hljs-built_in">recv</span>(sockfd, users[sockfd].buf, BUFFER_SIZE - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get %d bytes of client data %s from %d\n&quot;</span>, ret, users[sockfd].buf, sockfd);<br>        util_timer *timer = users[sockfd].timer;<br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">if</span> (errno != EAGAIN) &#123;<br>            <span class="hljs-built_in">cb_func</span>(&amp;users[sockfd]);<br>            <span class="hljs-keyword">if</span> (timer) &#123;<br>              timer_lst.<span class="hljs-built_in">del_timer</span>(timer);<br>            &#125;<br>          &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-built_in">cb_func</span>(&amp;users[sockfd]);<br>          <span class="hljs-keyword">if</span> (timer) &#123;<br>            timer_lst.<span class="hljs-built_in">del_timer</span>(timer);<br>          &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// send( sockfd, users[sockfd].buf, BUFFER_SIZE-1, 0 );</span><br>          <span class="hljs-comment">// 如果某个客户连接上有数据可读，则我们要调整该连接对应的定时器，以延迟该连接被关闭的时间</span><br>          <span class="hljs-keyword">if</span> (timer) &#123;<br>            <span class="hljs-type">time_t</span> cur = <span class="hljs-built_in">time</span>(<span class="hljs-literal">nullptr</span>);<br>            timer-&gt;expire = cur + <span class="hljs-number">3</span> * TIMESLOT;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;adjust timer once\n&quot;</span>);<br>            timer_lst.<span class="hljs-built_in">adjust_timer</span>(timer);<br>          &#125;<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// others</span><br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (timeout) &#123;  <span class="hljs-comment">// SIGALRM 信号</span><br>      <span class="hljs-built_in">timer_handler</span>();<br>      timeout = <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="io-复用系统调用的超时参数">2.3 I/O 复用系统调用的超时参数</h3><p>Linux下的 3 组 I/O复用系统调用都带有超时参数，因此它们不仅能统一处理信号和 I/O事件，也能统一处理定时事件。但是由于 I/O复用系统调用可能在超时时间到期之前就返回（有 I/O事件发生），所以如果我们要利用它们来定时，就需要不断更新定时参数以反映剩余的时间。示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TIMEOUT 5000</span><br><br><span class="hljs-type">int</span> timeout = TIMEOUT;<br><span class="hljs-type">time_t</span> start = <span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>);<br><span class="hljs-type">time_t</span> end = <span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>);<br><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the timeout is now%d mil-seconds\n&quot;</span>, timeout);<br>  start = <span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>);<br><br>  <span class="hljs-type">int</span> number = <span class="hljs-built_in">epoll_wait</span>(epollfd, events, MAX_EVENT_NUMBER, timeout);<br>  <span class="hljs-keyword">if</span> ((number &lt; <span class="hljs-number">0</span>) &amp;&amp; (errno != EINTR)) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;epoll failure\n&quot;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-comment">// 如果 epoll_wait 成功返回 0，则说明超时时间到，此时便可处理定时任务，并重置定时时间</span><br>  <span class="hljs-keyword">if</span> (number == <span class="hljs-number">0</span>) &#123;<br>    timeout = TIMEOUT;<br>    <span class="hljs-keyword">continue</span>;<br>  &#125;<br>  end = <span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>);<br>  <span class="hljs-comment">// 如果 epoll_wait 的返回值大于 0，则本次 epoll_wait 调用持续的时间是 (end - start)*1000</span><br>  <span class="hljs-comment">// ms，我们需要将定时时间 timeout 减去这段时间，以获得下次 epoll_wait 调用的超时参数</span><br>  timeout -= (end - start) * <span class="hljs-number">1000</span>;<br>  <span class="hljs-comment">// 重新计算之后的 timeout 值有可能等于0，说明本次 epoll_wait</span><br>  <span class="hljs-comment">// 调用返回时，不仅有文件描述符就绪，而且其超时时间也刚好到达，此时我们也要处理定时任务，并重置定时时间</span><br>  <span class="hljs-keyword">if</span> (timeout &lt; = <span class="hljs-number">0</span>) &#123;<br>    timeout = TIMEOUT;<br>  &#125;<br>  <span class="hljs-comment">// handle connections</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高性能定时器">2.4 高性能定时器</h3><h4 id="时间轮">2.4.1 时间轮</h4><p>基于排序链表的定时器存在一个问题：添加定时器的效率偏低。一种改进方案是时间轮，如下图所示：</p><img src="/2024/05/08/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E5%AE%9A%E6%97%B6%E5%99%A8/image-20240508164125263.png" class="" title="image-20240508164125263"><p>其核心思想是：指针每隔 si （slot interval，槽间隔）时间转动一步，顺时针移动到下一个 slot。共有 N 个slot，则旋转一周时间为 <span class="math inline">\(N * si\)</span>。每个 slot 指向一个定时器链表，每条链表上的定时器的定时时间相差 <spanclass="math inline">\(N*si\)</span>​的整数倍，时间轮利用这个关系将定时器散列到不同的链表中。</p><p>加上指针目前指向下标 <span class="math inline">\(cs\)</span>处，需要添加的定时器定时时间为 <spanclass="math inline">\(ti\)</span>，则该定时间将被插入下标 <spanclass="math inline">\(ts\)</span> 位置的链表中： <spanclass="math display">\[ts = (cs + \frac{ti}{si} ) \% N\]</span> 对时间轮而言，要提高定时精度，就要使 <spanclass="math inline">\(si\)</span> 值足够小；要提高执行效率，则要求 <spanclass="math inline">\(N\)</span>​ 值足够大。</p><p>上图描述的是一种简单的时间轮，因为它只有一个轮子。而复杂的时间轮可能有多个轮子，不同的轮子拥有不同的粒度。相邻的两个轮子，精度高的转一圈，精度低的仅往前移动一槽，</p><h4 id="时间堆">2.4.2 时间堆</h4><p>前面两种方法以固定的频率调用心搏函数<code>tick</code>，并在其中依次检测到期的定时器，然后执行到期定时器上的回调函数。设计定时器的另外一种思路是：将所有定时器中超时时间最小的一个定时器的超时值作为心搏间隔。这样，一旦心搏函数<code>tick</code> 被调用，超时时间最小的定时器必然到期，我们就可以在<code>tick</code>函数中处理该定时器。然后，<strong>再次从剩余的定时器中找出超时时间最小的一个，并将这段最小时间设置为下一次心搏间隔。如此反复，就实现了较为精确的定时。</strong>可以使用最小堆实现这一方案。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信号</tag>
      
      <tag>定时器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>I/O 复用</title>
    <link href="/2024/05/04/I-O-%E5%A4%8D%E7%94%A8/"/>
    <url>/2024/05/04/I-O-%E5%A4%8D%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文是《Linux高性能服务器编程》阅读记录，供以后查阅参考。推荐阅读原书。</p><p>所有函数未标明需要包含什么头文件，可使用 <code>man</code>命令自行查询。</p></blockquote><h2 id="select">1. select</h2><p><code>select</code>系统调用用于：在一段指定的时间内，监听用户感兴趣的文件描述符上的可读、可写和异常等事件。</p><h3 id="select-api">1.1 select API</h3><p><code>select</code> 函数原型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* Check the first NFDS descriptors each in READFDS (if not NULL) for read</span><br><span class="hljs-comment">   readiness, in WRITEFDS (if not NULL) for write readiness, and in EXCEPTFDS</span><br><span class="hljs-comment">   (if not NULL) for exceptional conditions.  If TIMEOUT is not NULL, time out</span><br><span class="hljs-comment">   after waiting the interval specified therein.  Returns the number of ready</span><br><span class="hljs-comment">   descriptors, or -1 for errors.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   This function is a cancellation point and therefore not marked with</span><br><span class="hljs-comment">   __THROW.  */</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title">select</span> <span class="hljs-params">(<span class="hljs-type">int</span> __nfds, fd_set *__restrict __readfds,</span></span><br><span class="hljs-params"><span class="hljs-function">   fd_set *__restrict __writefds,</span></span><br><span class="hljs-params"><span class="hljs-function">   fd_set *__restrict __exceptfds,</span></span><br><span class="hljs-params"><span class="hljs-function">   <span class="hljs-keyword">struct</span> timeval *__restrict __timeout)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p><code>nfds</code>：指定被监听的文件描述符的总数。通常设置为<code>select</code> 监听的所有文件描述符中的最大值 + 1，因为文件描述符从0 开始计数。</p></li><li><p><code>readfs</code>：指向可读事件对应的文件描述符集合；</p></li><li><p><code>writefs</code>：可写；</p></li><li><p><code>exceptfs</code>：异常；<code>select</code>调用返回时，系统将修改这些文件描述符来通知应用程序哪些文件描述符已就绪。<code>fd_set</code> 结构体类型定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* The fd_set member is required to be an array of longs.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> __fd_mask;<br><br><span class="hljs-comment">/* Some versions of &lt;linux/posix_types.h&gt; define this macros.  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span>__NFDBITS</span><br><span class="hljs-comment">/* It&#x27;s easier to assume 8-bit bytes than to get CHAR_BIT.  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NFDBITS(8 * (int) sizeof (__fd_mask))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>__FD_ELT(d)((d) / __NFDBITS)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>__FD_MASK(d)((__fd_mask) (1UL &lt;&lt; ((d) % __NFDBITS)))</span><br><br><span class="hljs-comment">/* fd_set for select and pselect.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">  &#123;</span><br>    <span class="hljs-comment">/* XPG4.2 requires this member name.  Otherwise avoid the name</span><br><span class="hljs-comment">       from the global namespace.  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __USE_XOPEN</span><br>    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];<br><span class="hljs-meta"># <span class="hljs-keyword">define</span> __FDS_BITS(set) ((set)-&gt;fds_bits)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];<br><span class="hljs-meta"># <span class="hljs-keyword">define</span> __FDS_BITS(set) ((set)-&gt;__fds_bits)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  &#125; fd_set;<br></code></pre></td></tr></table></figure><p>即：<code>fd_set</code>结构体成员仅包含一个整型数组，数组每个元素的每一位（bit）标记一个文件描述符。<code>fd_set</code>能容纳的文件描述符数量由 <code>FD_SETSIZE</code> 指定，这限制了<code>select</code> 能同时处理的文件描述符总量。</p><p>系统提供了以下宏，以便于用户读写 <code>fd_set</code> 中的 bit：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span><br><br>FD_ZERO(fd_set *fdset);<span class="hljs-comment">// 清除 fd_set 所有位</span><br>FD_SET(<span class="hljs-type">int</span> fd, fd_set *fdset);<span class="hljs-comment">// 设置 fd_set 位 fd</span><br>FD_CLR(<span class="hljs-type">int</span> fd, fd_set *fdset);<span class="hljs-comment">// 清除 fd_set 位 fd</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">FD_ISSET</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, fd_set *fdset)</span>;<span class="hljs-comment">// 测试 fd_set 的位 fd 是否被设置</span><br></code></pre></td></tr></table></figure></li><li><p><code>timeout</code>：设置 <code>select</code>函数的超时时间，类型是 <code>tomeval</code> 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* A time value that is accurate to the nearest</span><br><span class="hljs-comment">   microsecond but also has a range of years.  */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">long</span> tv_sec;<span class="hljs-comment">/* Seconds.  */</span><br>  <span class="hljs-type">long</span> tv_usec;<span class="hljs-comment">/* Microseconds.  */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>如果传递给 <code>timeout</code> <code>NULL</code> 指针，则<code>select</code> 将阻塞，直到某个文件描述符就绪。</p></li><li><p>返回值：成功时返回就绪（可读、可写和异常）文件描述符的总数。如果超时后没有任何文件描述符就绪，返回0。失败时返回 -1 并设置 <code>errno</code>。如果在 <code>select</code>等待期间，程序收到信号，则 <code>select</code> 立即返回 -1，并设置<code>errno</code> 为 <code>EINTR</code>。</p></li></ul><h3 id="文件描述符就绪条件">1.2 文件描述符就绪条件</h3><ul><li><p><code>socket</code> <strong>可读</strong>情况：</p><ul><li><p><code>socket</code>内核接收缓冲区中的字节数大于或等于其低水位标记<code>SO_RCVLOWAT</code>。此时我们可以无阻塞的读该 <code>socket</code>且返回的字节数大于 0。</p></li><li><p><code>socket</code> 通信的对方关闭连接。此时读取<code>socket</code> 返回 0。</p></li><li><p>监听 <code>socket</code> 上有新的连接请求。</p></li><li><p><code>socket</code> 上有未处理的错误。此时我们可以使用<code>getsocketopt</code> 来读取和清楚该错误。</p></li></ul></li><li><p><code>socket</code> <strong>可写</strong>情况：</p><ul><li><code>socket</code> 内核发送缓冲区中的字节数大于或等于其低水位标记<code>SO_SNDLOWAT</code>。此时我们可以无阻塞的写该 <code>socket</code>且返回的字节数大于 0。</li><li><code>socket</code> 的写操作被关闭。对写操作被关闭的<code>socket</code> 执行写操作将触发一个 <code>SIGPIPE</code>信号。</li><li><code>socket</code> 使用非阻塞 <code>connect</code>连接成功或者失败（超时）之后。</li><li><code>socket</code> 上有未处理的错误。此时我们可以使用<code>getsocketopt</code> 来读取和清楚该错误。</li></ul></li><li><p><code>socket</code> <strong>异常</strong>情况：</p><ul><li><code>select</code> 能处理的异常情况只有一种：<code>socket</code>接收到带外数据。</li></ul></li></ul><h2 id="poll">2. poll</h2><p><code>poll</code> 函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Poll the file descriptors described by the NFDS structures starting at</span><br><span class="hljs-comment">   FDS.  If TIMEOUT is nonzero and not -1, allow TIMEOUT milliseconds for</span><br><span class="hljs-comment">   an event to occur; if TIMEOUT is -1, block until an event occurs.</span><br><span class="hljs-comment">   Returns the number of file descriptors with events, zero if timed out,</span><br><span class="hljs-comment">   or -1 for errors.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   This function is a cancellation point and therefore not marked with</span><br><span class="hljs-comment">   __THROW.  */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">poll</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> pollfd *__fds, <span class="hljs-type">nfds_t</span> __nfds, <span class="hljs-type">int</span> __timeout)</span>;<br></code></pre></td></tr></table></figure><ul><li><p><code>fds</code>：一个 <code>pollfd</code>结构体类型数组，结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Data structure describing a polling request.  */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span></span><br><span class="hljs-class">  &#123;</span><br>    <span class="hljs-type">int</span> fd;<span class="hljs-comment">/* File descriptor to poll.  */</span><br>    <span class="hljs-type">short</span> <span class="hljs-type">int</span> events;<span class="hljs-comment">/* Types of events poller cares about.  */</span><br>    <span class="hljs-type">short</span> <span class="hljs-type">int</span> revents;<span class="hljs-comment">/* Types of events that actually occurred.  */</span><br>  &#125;;<br></code></pre></td></tr></table></figure><p>其中，<code>fd</code> 成员指定文件描述符；<code>events</code>成员告诉系统监听 <code>fd</code>上的哪些事件，是一系列事件的按位或；<code>revents</code>成员由内核修改，通知应用程序 <code>fd</code>实际上发生了哪些事件。<code>poll</code> 支持的事件类型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Event types that can be polled for.  These bits may be set in `events&#x27;</span><br><span class="hljs-comment">   to indicate the interesting event types; they will appear in `revents&#x27;</span><br><span class="hljs-comment">   to indicate the status of the file descriptor.  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POLLIN0x001<span class="hljs-comment">/* There is data to read.  */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POLLPRI0x002<span class="hljs-comment">/* There is urgent data to read.  */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POLLOUT0x004<span class="hljs-comment">/* Writing now will not block.  */</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined __USE_XOPEN || defined __USE_XOPEN2K8</span><br><span class="hljs-comment">/* These values are defined in XPG4.2.  */</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> POLLRDNORM0x040<span class="hljs-comment">/* Normal data may be read.  */</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> POLLRDBAND0x080<span class="hljs-comment">/* Priority data may be read.  */</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> POLLWRNORM0x100<span class="hljs-comment">/* Writing now will not block.  */</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> POLLWRBAND0x200<span class="hljs-comment">/* Priority data may be written.  */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __USE_GNU</span><br><span class="hljs-comment">/* These are extensions for Linux.  */</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> POLLMSG0x400</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> POLLREMOVE0x1000</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> POLLRDHUP0x2000</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">/* Event types always implicitly polled for.  These bits need not be set in</span><br><span class="hljs-comment">   `events&#x27;, but they will appear in `revents&#x27; to indicate the status of</span><br><span class="hljs-comment">   the file descriptor.  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POLLERR0x008<span class="hljs-comment">/* Error condition.  */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POLLHUP0x010<span class="hljs-comment">/* Hung up.  */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POLLNVAL0x020<span class="hljs-comment">/* Invalid polling request.  */</span></span><br></code></pre></td></tr></table></figure></li><li><p><code>nfds</code>：指定被监听事件集合 <code>fds</code>的大小，其类型定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Type used for the number of file descriptors.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-type">nfds_t</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>timeout</code>：指定超时值，<code>int</code>类型，单位毫秒。-1 表示 <code>poll</code> 调用将阻塞直到某个事件发生；0调用立即返回。</p></li><li><p>返回值：含义与 <code>select</code> 相同。</p></li></ul><h2 id="epoll">3. epoll</h2><h3 id="内核事件表">3.1 内核事件表</h3><p><code>epoll</code> 是 Linux 特有的 I/O 复用函数。它在实现和使用上与<code>select</code>、<code>poll</code>有很大差异。首先，<code>epoll</code>使用一组函数来完成任务，而不是单个函数。其次，<code>epoll</code>把用户关心的文件描述符上的事件放在内核里的一个事件表中，从而无须像<code>select</code> 和 <code>poll</code>那样每次调用都要重复传入文件描述符集或事件集。但 <code>epoll</code>需要使用一个额外的文件描述符，来唯一标识内核中的这个事件表。这个文件描述符使用<code>epoll_create</code> 函数创建：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Creates an epoll instance.  Returns an fd for the new instance.</span><br><span class="hljs-comment">   The &quot;size&quot; parameter is a hint specifying the number of file</span><br><span class="hljs-comment">   descriptors to be associated with the new instance.  The fd</span><br><span class="hljs-comment">   returned by epoll_create() should be closed with close().  */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">epoll_create</span> <span class="hljs-params">(<span class="hljs-type">int</span> __size)</span> __THROW;<br></code></pre></td></tr></table></figure><p>函数返回的文件描述符将用于后续 <code>epoll</code>相关函数的第一个参数，以指定要访问的内核事件表。</p><p>操作 <code>epoll</code> 内核事件表的函数 <code>epoll_ctl</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Manipulate an epoll instance &quot;epfd&quot;. Returns 0 in case of success,</span><br><span class="hljs-comment">   -1 in case of error ( the &quot;errno&quot; variable will contain the</span><br><span class="hljs-comment">   specific error code ) The &quot;op&quot; parameter is one of the EPOLL_CTL_*</span><br><span class="hljs-comment">   constants defined above. The &quot;fd&quot; parameter is the target of the</span><br><span class="hljs-comment">   operation. The &quot;event&quot; parameter describes which events the caller</span><br><span class="hljs-comment">   is interested in and any associated user data.  */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">epoll_ctl</span> <span class="hljs-params">(<span class="hljs-type">int</span> __epfd, <span class="hljs-type">int</span> __op, <span class="hljs-type">int</span> __fd,</span><br><span class="hljs-params">      <span class="hljs-keyword">struct</span> epoll_event *__event)</span> __THROW;<br></code></pre></td></tr></table></figure><ul><li><p><code>op</code>：指定操作类型，有以下三种：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Valid opcodes ( &quot;op&quot; parameter ) to issue to epoll_ctl().  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EPOLL_CTL_ADD 1<span class="hljs-comment">/* Add a file descriptor to the interface.  */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EPOLL_CTL_DEL 2<span class="hljs-comment">/* Remove a file descriptor from the interface.  */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EPOLL_CTL_MOD 3<span class="hljs-comment">/* Change file descriptor epoll_event structure.  */</span></span><br></code></pre></td></tr></table></figure><p>分别表示：往事件表注册 <code>fd</code> 上的事件；删除 <code>fd</code>上注册的事件；修改 <code>fd</code> 上注册的事件</p></li><li><p><code>fd</code>：要操作的文件描述符</p></li><li><p><code>event</code>：指定事件类型，是 <code>epoll_event</code>结构体类型的指针，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">epoll_data</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">void</span> *ptr;<br>  <span class="hljs-type">int</span> fd;<br>  <span class="hljs-type">uint32_t</span> u32;<br>  <span class="hljs-type">uint64_t</span> u64;<br>&#125; <span class="hljs-type">epoll_data_t</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">uint32_t</span> events;<span class="hljs-comment">/* Epoll events */</span><br>  <span class="hljs-type">epoll_data_t</span> data;<span class="hljs-comment">/* User data variable */</span><br>&#125; __EPOLL_PACKED;<br></code></pre></td></tr></table></figure><p>其中，<code>events</code> 成员表示事件类型。<code>epoll</code>支持的事件类型和 <code>poll</code> 基本相同。表示 <code>epoll</code>事件类型的宏是在 <code>poll</code> 对应的宏前加上 “E”，具体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">EPOLL_EVENTS</span></span><br><span class="hljs-class">  &#123;</span><br>    EPOLLIN = <span class="hljs-number">0x001</span>,<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EPOLLIN EPOLLIN</span><br>    EPOLLPRI = <span class="hljs-number">0x002</span>,<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EPOLLPRI EPOLLPRI</span><br>    EPOLLOUT = <span class="hljs-number">0x004</span>,<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EPOLLOUT EPOLLOUT</span><br>    EPOLLRDNORM = <span class="hljs-number">0x040</span>,<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EPOLLRDNORM EPOLLRDNORM</span><br>    EPOLLRDBAND = <span class="hljs-number">0x080</span>,<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EPOLLRDBAND EPOLLRDBAND</span><br>    EPOLLWRNORM = <span class="hljs-number">0x100</span>,<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EPOLLWRNORM EPOLLWRNORM</span><br>    EPOLLWRBAND = <span class="hljs-number">0x200</span>,<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EPOLLWRBAND EPOLLWRBAND</span><br>    EPOLLMSG = <span class="hljs-number">0x400</span>,<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EPOLLMSG EPOLLMSG</span><br>    EPOLLERR = <span class="hljs-number">0x008</span>,<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EPOLLERR EPOLLERR</span><br>    EPOLLHUP = <span class="hljs-number">0x010</span>,<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EPOLLHUP EPOLLHUP</span><br>    EPOLLRDHUP = <span class="hljs-number">0x2000</span>,<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EPOLLRDHUP EPOLLRDHUP</span><br>    EPOLLEXCLUSIVE = <span class="hljs-number">1u</span> &lt;&lt; <span class="hljs-number">28</span>,<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EPOLLEXCLUSIVE EPOLLEXCLUSIVE</span><br>    EPOLLWAKEUP = <span class="hljs-number">1u</span> &lt;&lt; <span class="hljs-number">29</span>,<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EPOLLWAKEUP EPOLLWAKEUP</span><br>    EPOLLONESHOT = <span class="hljs-number">1u</span> &lt;&lt; <span class="hljs-number">30</span>,<span class="hljs-comment">// epoll 特有</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EPOLLONESHOT EPOLLONESHOT</span><br>    EPOLLET = <span class="hljs-number">1u</span> &lt;&lt; <span class="hljs-number">31</span><span class="hljs-comment">// epoll 特有</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EPOLLET EPOLLET</span><br>  &#125;;<br></code></pre></td></tr></table></figure></li><li><p>返回值：成功时返回 0；失败返回 -1 并设置<code>errno</code>。</p></li></ul><h3 id="epoll_wait">3.2 epoll_wait</h3><p><code>epoll_wait</code>函数在一段超时时间内等待一组文件描述符上的事件，其原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Wait for events on an epoll instance &quot;epfd&quot;. Returns the number of</span><br><span class="hljs-comment">   triggered events returned in &quot;events&quot; buffer. Or -1 in case of</span><br><span class="hljs-comment">   error with the &quot;errno&quot; variable set to the specific error code. The</span><br><span class="hljs-comment">   &quot;events&quot; parameter is a buffer that will contain triggered</span><br><span class="hljs-comment">   events. The &quot;maxevents&quot; is the maximum number of events to be</span><br><span class="hljs-comment">   returned ( usually size of &quot;events&quot; ). The &quot;timeout&quot; parameter</span><br><span class="hljs-comment">   specifies the maximum wait time in milliseconds (-1 == infinite).</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   This function is a cancellation point and therefore not marked with</span><br><span class="hljs-comment">   __THROW.  */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">epoll_wait</span> <span class="hljs-params">(<span class="hljs-type">int</span> __epfd, <span class="hljs-keyword">struct</span> epoll_event *__events,</span><br><span class="hljs-params">       <span class="hljs-type">int</span> __maxevents, <span class="hljs-type">int</span> __timeout)</span>;<br></code></pre></td></tr></table></figure><ul><li>返回值：成功时返回就绪的文件描述符数量；失败时返回 -1 并设置<code>errno</code>。</li><li><code>timeout</code>：与 <code>poll</code> 函数中意义相同。</li><li><code>maxevents</code>：指定最多监听多少个事件，必须大于 0。</li><li><code>events</code>：<code>epoll_wait</code>函数如果检测到事件，就将所有就绪的事件从内核事件表（由 <code>epfd</code>参数指定）中复制到它的第二个参数 <code>events</code>指向的数组中。这个数组只用于输出 <code>epoll_wait</code>检测到的就绪事件，而不像 <code>select</code> 和 <code>poll</code>的数组参数那样既用于传入用户注册的事件，又用于输出内核检测到的就绪事件。这就极大地提高了应用程序索引就绪文件描述符的效率。</li></ul><p><code>poll</code> 与 <code>epoll</code>索引就绪文件描述符示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">poll_and_epoll</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// 索引 poll 返回的就绪文件描述符</span><br>  <span class="hljs-type">int</span> ret = <span class="hljs-built_in">poll</span>(fds, MAX_EVENT_NUMBER, <span class="hljs-number">-1</span>);<br>  <span class="hljs-comment">// 必须遍历所有已注册文件描述符并找到其中的就绪者（当然，可以利用 ret 来稍做优化）</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_EVENT_NUMBER; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (fds[i].revents &amp; POLLIN)  <span class="hljs-comment">// 判断第 i 个文件描述符是否就绪</span><br>    &#123;<br>      <span class="hljs-type">int</span> sockfd = fds[i].fd;<br>      <span class="hljs-comment">// 处理 sockfd</span><br>    &#125;<br>  &#125;<br><br><br>  <span class="hljs-comment">// 索引 epoll 返回的就绪文件描述符</span><br>  <span class="hljs-type">int</span> ret = <span class="hljs-built_in">epoll_wait</span>(epollfd, events, MAX_EVENT_NUMBER, <span class="hljs-number">-1</span>);<br>  <span class="hljs-comment">// 仅遍历就绪的 ret 个文件描述符</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ret; i++) &#123;<br>    <span class="hljs-type">int</span> sockfd = events[i].data.fd;<br>    <span class="hljs-comment">// sockfd 肯定就绪，直接处理</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从中可以看出 <code>epoll</code> 对比 <code>poll</code>的性能提升（需要遍历的文件描述符数变少了）。</p><h3 id="lt-和-et-模式">3.3 LT 和 ET 模式</h3><p><code>epoll</code> 对文件描述符的操作有两种模式：LT（LevelTrigger，电平触发）模式和ET（Edge Trigger，边沿触发）模式。LT模式是默认的工作模式，这种模式下 <code>epoll</code> 相当于一个效率较高的<code>poll</code>。当往 <code>epoll</code>内核事件表中注册一个文件描述符上的 <code>EPOLLET</code>事件时，<code>epoll</code> 将以 ET 模式来操作该文件描述符。<strong>ET模式是 <code>epoll</code> 的高效工作模式</strong>。</p><p>对于采用 LT 工作模式的文件描述符，当 <code>epoll_wait</code>检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事件。这样，当应用程序下一次调用<code>epoll_wait</code> 时，<code>epoll_wait</code>还会再次向应用程序通告此事件，直到该事件被处理。而对于采用 ET工作模式的文件描述符，当 <code>epoll_wait</code>检测到其上有事件发生并将此事件通知应用程序后，应用程序必须立即处理该事件，因为后续的<code>epoll_wait</code> 调用将不再向应用程序通知这一事件。<strong>ET模式在很大程度上降低了同一个 <code>epoll</code>事件被重复触发的次数，因此效率要比 LT 模式高。</strong></p><p>注意：<strong><em>每个使用 ET模式的文件描述符都应该是非阻塞的</em></strong>。如果文件描述符是阻塞的，那么读或写操作将会因为没有后续的事件而一直处于阻塞状态（饥渴状态）。</p><h3 id="epolloneshot-事件">3.4 EPOLLONESHOT 事件</h3><p>为了防止多个线程并发读取 <code>socket</code>，可以使用<code>epoll</code> 的 <code>EPOLLONESHOT</code> 事件。</p><p>对于注册了 <code>EPOLLONESHOT</code>事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次，除非我们使用<code>epoll_ctl</code> 函数重置该文件描述符上注册的<code>EPOLLONESHOT</code> 事件。这样，当一个线程在处理某个<code>socket</code> 时，其他线程是不可能有机会操作该 <code>socket</code>的。但反过来思考，注册了 <code>EPOLLONESHOT</code> 事件的<code>socket</code>一旦被某个线程处理完毕，该线程就应该立即重置这个<code>socket</code> 上的<code>EPOLLONESHOT</code> 事件，以确保这个 <code>socket</code>下一次可读时，其 <code>EPOLLIN</code>事件能被触发，进而让其他工作线程有机会继续处理这个<code>socket</code>。</p><h2 id="三组-io-多路复用函数的比较">4. 三组 I/O 多路复用函数的比较</h2><img src="/2024/05/04/I-O-%E5%A4%8D%E7%94%A8/image-20240504222700859.png" class="" title="image-20240504222700859">]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>select</tag>
      
      <tag>poll</tag>
      
      <tag>epoll</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高级 I/O 函数</title>
    <link href="/2024/05/02/%E9%AB%98%E7%BA%A7-I-O-%E5%87%BD%E6%95%B0/"/>
    <url>/2024/05/02/%E9%AB%98%E7%BA%A7-I-O-%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文是《Linux高性能服务器编程》阅读记录，供以后查阅参考。推荐阅读原书。</p><p>所有函数未标明需要包含什么头文件，可使用 <code>man</code>命令自行查询。</p></blockquote><h2 id="pipe">1. pipe</h2><p>函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* Create a one-way communication channel (pipe).</span><br><span class="hljs-comment">   If successful, two file descriptors are stored in PIPEDES;</span><br><span class="hljs-comment">   bytes written on PIPEDES[1] can be read from PIPEDES[0].</span><br><span class="hljs-comment">   Returns 0 if successful, -1 if not.  */</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title">pipe</span> <span class="hljs-params">(<span class="hljs-type">int</span> __pipedes[<span class="hljs-number">2</span>])</span> __THROW __wur</span>;<br></code></pre></td></tr></table></figure><p><code>fd[1]</code> 用于 <strong>写入</strong>数据；<code>fd[0]</code> 用于 <strong>读取</strong>数据。且管道为单向通信，只能一端写入，另一端读取。需要双向通信时，可创建两个管道。管道默认为阻塞的，也即调用<code>read</code> 函数读数据时，若管道内无数据写入，<code>read</code>调用会阻塞，直到有数据可读。<code>write</code>调用当管道已满时，也会阻塞，直到管道有足够的空闲空间可供写入数据。</p><p>如果写入端引用计数为 0，调用 <code>read</code> 会返回 0，表示EOF（End Of File）；如果读取端引用计数为 0，调用 <code>write</code>将失败，并引发 <code>SIGPIPE</code> 信号。</p><p>另外，可使用 <code>sockerpair</code>函数创建双向通信的管道，即：两端都可以读写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* Create two new sockets, of type TYPE in domain DOMAIN and using</span><br><span class="hljs-comment">   protocol PROTOCOL, which are connected to each other, and put file</span><br><span class="hljs-comment">   descriptors for them in FDS[0] and FDS[1].  If PROTOCOL is zero,</span><br><span class="hljs-comment">   one will be chosen automatically.  Returns 0 on success, -1 for errors.  */</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title">socketpair</span> <span class="hljs-params">(<span class="hljs-type">int</span> __domain, <span class="hljs-type">int</span> __type, <span class="hljs-type">int</span> __protocol,</span></span><br><span class="hljs-params"><span class="hljs-function">       <span class="hljs-type">int</span> __fds[<span class="hljs-number">2</span>])</span> __THROW</span>;<br></code></pre></td></tr></table></figure><h2 id="dup-和-dup2">2. dup 和 dup2</h2><p>函数原型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* Duplicate FD, returning a new file descriptor on the same file.  */</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title">dup</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fd)</span> __THROW __wur</span>;<br><br><br><span class="hljs-comment">/* Duplicate FD to FD2, closing FD2 and making it open on the same file.  */</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title">dup2</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fd, <span class="hljs-type">int</span> __fd2)</span> __THROW</span>;<br></code></pre></td></tr></table></figure><p><code>dup</code>函数用于创建一个新的指向同一个文件、管道或网络连接的文件描述符。<code>dup2</code>关闭 <code>fd2</code>，并且将 <code>fd2</code> 指向 <code>fd</code>表示的文件。</p><h2 id="readv-和-writev">3. readv 和 writev</h2><p><code>readv</code>函数将数据从文件描述符读到分散的内存块中，即：分散读；<code>writev</code>函数则将多块分散的内存数据一并写入一个文件描述符，即：集中写。函数声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* Read data from file descriptor FD, and put the result in the</span><br><span class="hljs-comment">   buffers described by IOVEC, which is a vector of COUNT &#x27;struct iovec&#x27;s.</span><br><span class="hljs-comment">   The buffers are filled in the order specified.</span><br><span class="hljs-comment">   Operates just like &#x27;read&#x27; (see &lt;unistd.h&gt;) except that data are</span><br><span class="hljs-comment">   put in IOVEC instead of a contiguous buffer.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   This function is a cancellation point and therefore not marked with</span><br><span class="hljs-comment">   __THROW.  */</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title">readv</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> iovec *__iovec, <span class="hljs-type">int</span> __count)</span></span>;<br><br><br><span class="hljs-comment">/* Write data pointed by the buffers described by IOVEC, which</span><br><span class="hljs-comment">   is a vector of COUNT &#x27;struct iovec&#x27;s, to file descriptor FD.</span><br><span class="hljs-comment">   The data is written in the order specified.</span><br><span class="hljs-comment">   Operates just like &#x27;write&#x27; (see &lt;unistd.h&gt;) except that the data</span><br><span class="hljs-comment">   are taken from IOVEC instead of a contiguous buffer.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   This function is a cancellation point and therefore not marked with</span><br><span class="hljs-comment">   __THROW.  */</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title">writev</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> iovec *__iovec, <span class="hljs-type">int</span> __count)</span></span>;<br></code></pre></td></tr></table></figure><p>成功时返回读取的字节数；失败返回 -1。</p><p><code>writev</code> 函数的一个可能的使用场景是：响应 HTTP请求时，header 和 body 分别存储在两个缓冲区里。可以利用<code>writev</code> 函数一次写两个缓冲区。</p><h2 id="sendfile">4. sendfile</h2><p><code>sendfile</code>函数用于在两个文件描述符之间直接传递数据，从而避免了内核缓冲区和用户缓冲区之间的数据拷贝，称之为零拷贝。函数声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* Send up to COUNT bytes from file associated with IN_FD starting at</span><br><span class="hljs-comment">   *OFFSET to descriptor OUT_FD.  Set *OFFSET to the IN_FD&#x27;s file position</span><br><span class="hljs-comment">   following the read bytes.  If OFFSET is a null pointer, use the normal</span><br><span class="hljs-comment">   file position instead.  Return the number of written bytes, or -1 in</span><br><span class="hljs-comment">   case of error.  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __USE_FILE_OFFSET64</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title">sendfile</span> <span class="hljs-params">(<span class="hljs-type">int</span> __out_fd, <span class="hljs-type">int</span> __in_fd, <span class="hljs-type">off_t</span> *__offset,</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-type">size_t</span> __count)</span> __THROW</span>;<br></code></pre></td></tr></table></figure><ul><li><code>in_fd</code>：待读出内容的文件描述符，必须时支持类似<code>mmap</code> 函数的文件描述符，即它必须指向真实的文件，不能是socket 和管道</li><li><code>out_fd</code>：待写入内容的文件描述符，必须是一个 socket</li><li><code>offset</code>：指定从读入文件描述符的哪个位置开始读；空表示从默认起始位置开始读</li><li><code>count</code>：指定传输的字节数</li><li>调用成功返回传输的字节数，-1 表示出错</li></ul><h2 id="mmap-和-munmap">5. mmap 和 munmap</h2><p><code>mmap</code> 函数用于申请一段内存空间。<code>munmap</code>函数则释放由 <code>mmap</code> 函数创建的这段内存空间。声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* Map addresses starting near ADDR and extending for LEN bytes.  from</span><br><span class="hljs-comment">   OFFSET into the file FD describes according to PROT and FLAGS.  If ADDR</span><br><span class="hljs-comment">   is nonzero, it is the desired mapping address.  If the MAP_FIXED bit is</span><br><span class="hljs-comment">   set in FLAGS, the mapping will be at ADDR exactly (which must be</span><br><span class="hljs-comment">   page-aligned); otherwise the system chooses a convenient nearby address.</span><br><span class="hljs-comment">   The return value is the actual mapping address chosen or MAP_FAILED</span><br><span class="hljs-comment">   for errors (in which case `errno&#x27; is set).  A successful `mmap&#x27; call</span><br><span class="hljs-comment">   deallocates any previous mapping for the affected region.  */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __USE_FILE_OFFSET64</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> *<span class="hljs-title">mmap</span> <span class="hljs-params">(<span class="hljs-type">void</span> *__addr, <span class="hljs-type">size_t</span> __len, <span class="hljs-type">int</span> __prot,</span></span><br><span class="hljs-params"><span class="hljs-function">   <span class="hljs-type">int</span> __flags, <span class="hljs-type">int</span> __fd, <span class="hljs-type">__off_t</span> __offset)</span> __THROW</span>;<br><br><br><span class="hljs-comment">/* Deallocate any mapping for the region starting at ADDR and extending LEN</span><br><span class="hljs-comment">   bytes.  Returns 0 if successful, -1 for errors (and sets errno).  */</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title">munmap</span> <span class="hljs-params">(<span class="hljs-type">void</span> *__addr, <span class="hljs-type">size_t</span> __len)</span> __THROW</span>;<br></code></pre></td></tr></table></figure><ul><li><code>start</code>：允许用户使用某个特定地址作为内存的起始地址，设置为<code>NULL</code> 表示系统自动分配一个地址</li><li><code>len</code>：指定内存端的长度</li><li><code>prot</code>：设置内存端的访问权限，包括可读、可写、可执行和不能被访问</li><li><code>flags</code>：控制内存段内容被修改后程序的行为</li><li><code>fd</code>：被映射文件对应的文件描述符</li><li><code>offset</code>：设置文件从何处开始映射</li></ul><h2 id="splice">6. splice</h2><p><code>splice</code>函数用于在两个文件描述符之间移动数据，也是零拷贝操作。函数声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* Splice two files together.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   This function is a possible cancellation point and therefore not</span><br><span class="hljs-comment">   marked with __THROW.  */</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">__ssize_t</span> <span class="hljs-title">splice</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fdin, <span class="hljs-type">__off64_t</span> *__offin, <span class="hljs-type">int</span> __fdout,</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-type">__off64_t</span> *__offout, <span class="hljs-type">size_t</span> __len,</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> __flags)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>fd_in</code>：待输入数据的文件描述符</li><li><code>off_in</code>：如果 <code>fd_in</code>是管道文件描述符，则必须设置为<code>NULL</code>；否则表示从输入数据流的何处开始读数据，为<code>NULL</code> 表示从输入流的当前偏移位置读入</li><li><code>fd_out</code>：使用 <code>splice</code> 时，<code>fd_in</code>和 <code>fd_out</code> 必须至少有一个为管道文件描述符</li><li><code>off_out</code>：和 <code>in</code>相同，不过表示写入数据流</li><li><code>len</code> ：表示移动数据的长度</li><li><code>flags</code>：控制数据如何移动</li></ul><h2 id="tee">7. tee</h2><p><code>tee</code>函数用于在两个管道文件描述符之间复制数据，也是零拷贝操作。它不消耗数据，因此源文件描述符上的数据仍然可以用于后续的读操作。函数声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* In-kernel implementation of tee for pipe buffers.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   This function is a possible cancellation point and therefore not</span><br><span class="hljs-comment">   marked with __THROW.  */</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">__ssize_t</span> <span class="hljs-title">tee</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fdin, <span class="hljs-type">int</span> __fdout, <span class="hljs-type">size_t</span> __len,</span></span><br><span class="hljs-params"><span class="hljs-function">      <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> __flags)</span></span>;<br></code></pre></td></tr></table></figure><p>函数参数含义与 <code>splice</code> 相同，但是 <code>fd_in</code> 和<code>fd_out</code> 都必须是管道文件描述符。</p><h2 id="fcntl">8. fcntl</h2><p><code>fcntl</code> （filecontrol）函数提供了对文件描述符的各种控制操作。另外一个能够控制文件描述符属性和行为的系统调用是<code>ioctl</code>，能够比 <code>fcntl</code>执行更多的控制。<code>fcntl</code> 函数声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* Do the file control operation described by CMD on FD.</span><br><span class="hljs-comment">   The remaining arguments are interpreted depending on CMD.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   This function is a cancellation point and therefore not marked with</span><br><span class="hljs-comment">   __THROW.  */</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title">fcntl</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fd, <span class="hljs-type">int</span> __cmd, ...)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>fd</code>：被操作的文件描述符</li><li><code>cmd</code>：指定执行何种类型的操作</li><li><code>arg</code>：可选参数</li></ul><p>网络编程中，<code>fcntl</code>函数常用于将文件描述符设置未非阻塞的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">setNonBlocking</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span> </span>&#123;<br>  <span class="hljs-type">int</span> old_option = <span class="hljs-built_in">fcntl</span>(fd, F_GETFL);  <span class="hljs-comment">// 获取文件描述符旧的状态标志</span><br>  <span class="hljs-type">int</span> new_option = old_option | O_NONBLOCK;<br>  <span class="hljs-built_in">fcntl</span>(fd, F_SETFL, new_option);  <span class="hljs-comment">// 设置非阻塞</span><br>  <span class="hljs-keyword">return</span> old_option;               <span class="hljs-comment">// 返回文件描述符旧的状态标志，可供恢复</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 并发编程入门</title>
    <link href="/2024/04/19/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    <url>/2024/04/19/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>本文介绍 Modern C++标准库提供的关于多线程编程的工具。如标题所示，本文定位是入门，不讨论内存序、无锁编程等并发编程的高级主题。本文内容主要参考《C++并发编程实战（第二版）》一书，对并发编程感兴趣推荐阅读原书。</p><h2 id="线程">1. 线程</h2><p>C++ 中使用线程的方式非常简单，只需要包含 <code>thread</code>头文件，然后向 <code>thread</code>构造函数传入可调用函数和实参即可。一些示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Hello Concurrent World!\n&quot;</span>; &#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">HelloThread</span> &#123;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Hello Thread!&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bind_sample</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; + &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; a + b &lt;&lt; std::endl; &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">increase</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;i)</span> </span>&#123; ++i; &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddTen</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123; std::cout &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot; + &quot;</span> &lt;&lt; ten &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; value + ten &lt;&lt; std::endl; &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> ten&#123;<span class="hljs-number">10</span>&#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(hello)</span></span>;  <span class="hljs-comment">// 无参函数</span><br>  t1.<span class="hljs-built_in">join</span>();<br><br>  <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(HelloThread&#123;&#125;)</span></span>;  <span class="hljs-comment">// 可调用对象</span><br>  t2.<span class="hljs-built_in">join</span>();<br><br>  <span class="hljs-function">std::thread <span class="hljs-title">t3</span><span class="hljs-params">([]() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Hello Lambda!&quot;</span> &lt;&lt; std::endl; &#125;)</span></span>;  <span class="hljs-comment">// lambda 表达式</span><br>  t3.<span class="hljs-built_in">join</span>();<br><br>  <span class="hljs-function">std::thread <span class="hljs-title">t4</span><span class="hljs-params">(bind_sample, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;  <span class="hljs-comment">// 有参函数</span><br>  t4.<span class="hljs-built_in">join</span>();<br><br>  <span class="hljs-keyword">auto</span> f = std::<span class="hljs-built_in">bind</span>(bind_sample, std::placeholders::_1, <span class="hljs-number">4</span>);<br>  <span class="hljs-function">std::thread <span class="hljs-title">t5</span><span class="hljs-params">(f, <span class="hljs-number">5</span>)</span></span>;  <span class="hljs-comment">// bind</span><br>  t5.<span class="hljs-built_in">join</span>();<br><br>  <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t6</span><span class="hljs-params">(increase, std::ref(i))</span></span>;  <span class="hljs-comment">// 传入引用类型参数</span><br>  t6.<span class="hljs-built_in">join</span>();<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; std::endl;<br><br>  AddTen obj;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t7</span><span class="hljs-params">(&amp;AddTen::add, &amp;obj, <span class="hljs-number">1</span>)</span></span>;  <span class="hljs-comment">// 传入对象调用指定函数</span><br>  t7.<span class="hljs-built_in">join</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">Hello Concurrent World!<br>Hello Thread!<br>Hello Lambda!<br>1 + 2 = 3<br>5 + 4 = 9<br>i = 1<br>1 + 10 = 11<br></code></pre></td></tr></table></figure><p>上面的代码示例了如何传入各种类型的函数、可调用对象等构造<code>thread</code>，以在单独的线程中运行任务。需要注意的是，传入的参数默认是进行拷贝的，因此，如果函数形参类型是引用，需要使用<code>std::ref()</code> 以指定引用语义，如上述代码 <code>41</code>行所示。</p><p>线程构造完成后，即自动在新线程中运行指定的任务。此时需要使用<code>t.join()</code> 进行汇合，表示等待线程执行完成。也可以使用<code>t.detach()</code> 表示不等待线程执行完成。同时 <code>thread</code>对象是不可拷贝的，只具有移动语义。可以使用 <code>vector</code>等容器管理线程对象。</p><h2 id="锁">2. 锁</h2><p>当多个线程并发读写某个数据时，可能会出现错误。示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> total = <span class="hljs-number">100000</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; total; ++i) &#123;<br>    ++n;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(add)</span></span>;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(add)</span></span>;<br>  t1.<span class="hljs-built_in">join</span>();<br>  t2.<span class="hljs-built_in">join</span>();<br><br>  std::cout &lt;&lt; n &lt;&lt; std::endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>g++ xxx.cpp</code>编译上述源文件（不使用任何编译优化选项）并多次运行可执行文件，可以发现每次程序的输出都不确定：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./a.out</span> <br>112924<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./a.out</span> <br>188328<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./a.out</span> <br>135646<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./a.out</span> <br>131277<br></code></pre></td></tr></table></figure><p>输出并不是预期的 <code>200000</code>，而似乎是随机数。这是因为多个线程并发读写同一个变量（数据竞争），导致了不合理的数据状态。解决这一问题的最简单方法就是加锁。</p><p>C++ 中锁的使用非常简单，只需要包含 <code>mutex</code>头文件，然后在进入临界区之前调用 <code>lock</code>函数；在离开临界区时调用 <code>unlock</code> 函数，示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>std::mutex m;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> total = <span class="hljs-number">100000</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; total; ++i) &#123;<br>    m.<span class="hljs-built_in">lock</span>();  <span class="hljs-comment">// 进入临界区</span><br>    ++n;<br>    m.<span class="hljs-built_in">unlock</span>();  <span class="hljs-comment">// 离开临界区</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了 <code>mutex</code> 类外，C++ 还提供了<code>shared_mutex</code>，也即读写锁，可用于读多写少的场景，以提高并发度。</p><p>上述基于锁的写法虽然解决了数据竞争的问题，但是必须保证对<code>lock</code> 和 <code>unlock</code>方法配对调用，否则就会导致锁一直被某个线程占用，阻塞其它线程。C++中提倡的写法是基于 RAII 的锁管理，包括 <code>lock_guard</code>、<code>unique_lock</code>、<code>shared_lock</code>。这些类是一个包装类，可以指定这些类在构造函数中调用<code>lock</code> 方法，在析构函数中自动调用 <code>unlock</code>方法对锁进行管理。这样，程序员就不需要在每个可能的退出分支中调用<code>unlock</code> 函数，降低出现 bug 的概率。示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>std::mutex m;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> total = <span class="hljs-number">100000</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; total; ++i) &#123;<br>    <span class="hljs-function">std::lock_guard <span class="hljs-title">lock</span><span class="hljs-params">(m)</span></span>;  <span class="hljs-comment">// RAII 管理锁</span><br>    <span class="hljs-comment">// 或者 std::unique_lock lock(m);</span><br>    <span class="hljs-comment">// 或者 std::scoped_lock lock(m);</span><br>    ++n;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当需要对多个锁进行加锁时，为了防止死锁，需要按照相同的顺序进行加锁。C++提供了 <code>std::lock</code> 函数以解决这一问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>std::mutex m1;<br>std::mutex m2;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> total = <span class="hljs-number">100000</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; total; ++i) &#123;<br>    <span class="hljs-function">std::unique_lock <span class="hljs-title">lock1</span><span class="hljs-params">(m1, std::defer_lock)</span></span>;  <span class="hljs-comment">// std::defer_lock 表示推迟上锁</span><br>    <span class="hljs-function">std::unique_lock <span class="hljs-title">lock2</span><span class="hljs-params">(m2, std::defer_lock)</span></span>;<br>    std::<span class="hljs-built_in">lock</span>(lock1, lock2);  <span class="hljs-comment">// 按固定顺序上锁 避免死锁</span><br>    ++n;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="call_once">3. call_once</h2><p>在实际项目中有一个常见的需求：某个对象只需要构造一次，但是其消耗的资源较大，我们希望只有在真的需要用到它时在进行构造。这一需求类似于线程安全的单例模式。在此我们不考虑其究竟有几种并发安全的写法，而只介绍一种实用的、C++语言也支持的写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heavyInit</span><span class="hljs-params">()</span> </span>&#123;<br>  std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Resource prepared!&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br>std::once_flag work_once_flag;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>  std::<span class="hljs-built_in">call_once</span>(work_once_flag, heavyInit);  <span class="hljs-comment">// 保证 heavyInit 函数只被调用一次</span><br>  <span class="hljs-comment">// do work using the prepared resource</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> workers = <span class="hljs-number">10</span>;<br>  std::vector&lt;std::thread&gt; threads;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; workers; ++i) &#123;<br>    threads.<span class="hljs-built_in">emplace_back</span>(work);<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;t : threads) &#123;<br>    t.<span class="hljs-built_in">join</span>();<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码非常简单，只需要包含 <code>mutex</code> 头文件，定义<code>std::call_once_flag</code> 类型变量，并使用<code>std::call_once</code> 方法，传入对应的<code>std::call_once_flag</code>和方法名和参数，即可保证某方法只被多个线程调用一次，且保证并发安全。</p><h2 id="条件变量">4. 条件变量</h2><p>在实际编程中，我们经常遇到一种情况：一个线程准备数据；另一个线程等待数据，待数据准备好后对其进行处理。如果仅使用上述已经介绍的知识，我们可以写出类似下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-type">bool</span> ok = <span class="hljs-literal">false</span>;<br>std::mutex m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">provide</span><span class="hljs-params">()</span> </span>&#123;<br>  std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">500</span>));  <span class="hljs-comment">// prepare data</span><br>  <span class="hljs-function">std::unique_lock <span class="hljs-title">lock</span><span class="hljs-params">(m)</span></span>;                                     <span class="hljs-comment">// 加锁以保证写 ok 的并发安全性</span><br>  ok = <span class="hljs-literal">true</span>;<br>  lock.<span class="hljs-built_in">unlock</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">consume</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-function">std::unique_lock <span class="hljs-title">lock</span><span class="hljs-params">(m)</span></span>;  <span class="hljs-comment">// 加锁以保证读取到正确的 ok 值</span><br>    <span class="hljs-keyword">if</span> (ok) &#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    lock.<span class="hljs-built_in">unlock</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;comsume thread waked without data...&quot;</span> &lt;&lt; std::endl;<br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">100</span>));<br>  &#125;<br>  <span class="hljs-comment">// data prepared now, handle it</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(provide)</span></span>;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(consume)</span></span>;<br>  t1.<span class="hljs-built_in">join</span>();<br>  t2.<span class="hljs-built_in">join</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>核心思路是：使用一个标记变量，和一个保护该变量的锁。生产数据的线程完成数据生产后，将标记变量赋值为<code>true</code>；消费线程使用轮询+休眠策略，直到标记变量变为<code>true</code> 后，进行数据处理。</p><p>这么写虽然能够解决问题，但是不够优雅：消费线程不应该使用轮询+休眠策略，而是应该一直处于休眠中，待生产线程准备好数据后，通知消费进程即可，消费线程唤醒进行数据处理工作。实际上，条件变量就是为了解决这个问题，示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br>std::condition_variable cv;<br><span class="hljs-type">bool</span> ok = <span class="hljs-literal">false</span>;<br>std::mutex m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">provide</span><span class="hljs-params">()</span> </span>&#123;<br>  std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">500</span>));  <span class="hljs-comment">// prepare data</span><br>  <span class="hljs-function">std::unique_lock <span class="hljs-title">lock</span><span class="hljs-params">(m)</span></span>;                                     <span class="hljs-comment">// 加锁以保证写 ok 的并发安全性</span><br>  ok = <span class="hljs-literal">true</span>;<br>  cv.<span class="hljs-built_in">notify_one</span>();  <span class="hljs-comment">// 通知 consume 线程数据已准备好</span><br>  lock.<span class="hljs-built_in">unlock</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">consume</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function">std::unique_lock <span class="hljs-title">lock</span><span class="hljs-params">(m)</span></span>;  <span class="hljs-comment">// 加锁以保证读取到正确的 ok 值</span><br>  cv.<span class="hljs-built_in">wait</span>(lock, [&amp;]() &#123;  <span class="hljs-comment">// wait 函数传入 lambda 表达式，表示等待 lambda 表达式条件满足时，唤醒线程</span><br>    <span class="hljs-keyword">if</span> (!ok) &#123;<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;comsume thread waked without data...&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ok;<br>  &#125;);<br>  <span class="hljs-comment">// data prepared now, handle it</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(provide)</span></span>;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(consume)</span></span>;<br>  t1.<span class="hljs-built_in">join</span>();<br>  t2.<span class="hljs-built_in">join</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用条件变量时，仍需要锁对临界区进行保护。<code>cv.wait</code>函数传入锁和线程等待的条件，以避免假唤醒。此外，条件变量还有<code>wait_for</code> 、<code>wait_until</code>等接口，能够实现线程的限时等待。示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::chrono_literals;<br><br><span class="hljs-keyword">auto</span> one_day = <span class="hljs-number">24</span>h;<br><span class="hljs-keyword">auto</span> half_an_hour = <span class="hljs-number">30</span>min;<br><span class="hljs-keyword">auto</span> max_time_between_messages = <span class="hljs-number">30</span>ms;<br><br>std::condition_variable cv;<br><span class="hljs-type">bool</span> done;<br>std::mutex m;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">wait_loop</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> <span class="hljs-type">const</span> timeout = std::chrono::steady_clock::<span class="hljs-built_in">now</span>() + std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">500</span>);<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;timer begin...&quot;</span> &lt;&lt; std::endl;<br>  <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(m)</span></span>;<br>  <span class="hljs-keyword">while</span> (!done) &#123;<br>    <span class="hljs-keyword">if</span> (cv.<span class="hljs-built_in">wait_until</span>(lk, timeout) == std::cv_status::timeout) &#123;  <span class="hljs-comment">// 指定等待时间</span><br>      <span class="hljs-keyword">break</span>;                                                      <span class="hljs-comment">// 超时 退出循环</span><br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;wake up while timer not out...&quot;</span> &lt;&lt; std::endl;<br>  &#125;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;done = &quot;</span> &lt;&lt; done &lt;&lt; std::endl;<br>  <span class="hljs-keyword">return</span> done;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">notify</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>    cv.<span class="hljs-built_in">notify_one</span>();<br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">10</span>));<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>  <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(notify)</span></span>;<br>  <span class="hljs-built_in">wait_loop</span>();<br>  t.<span class="hljs-built_in">join</span>();<br>  <span class="hljs-keyword">auto</span> stop = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;do_something() took &quot;</span> &lt;&lt; std::chrono::<span class="hljs-built_in">duration</span>&lt;<span class="hljs-type">double</span>&gt;(stop - start).<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot; seconds&quot;</span> &lt;&lt; std::endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./a.out</span> <br>timer begin...<br>wake up while timer not out...<br>wake up while timer not out...<br>wake up while timer not out...<br>wake up while timer not out...<br>wake up while timer not out...<br>wake up while timer not out...<br>wake up while timer not out...<br>wake up while timer not out...<br>wake up while timer not out...<br>wake up while timer not out...<br>done = 0<br>do_something() took 0.500422 seconds<br></code></pre></td></tr></table></figure><p>使用条件变量，我们还可以实现并发安全的队列（本段代码主要来自《C++并发编程实战（第二版）》一书）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-comment">// 线程安全的队列</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">threadsafe_queue</span> &#123;<br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">mutable</span> std::mutex mut;<br>  std::queue&lt;T&gt; data_queue;<br>  std::condition_variable data_cond;  <span class="hljs-comment">// 条件变量</span><br><br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">threadsafe_queue</span>() &#123;&#125;<br><br>  <span class="hljs-built_in">threadsafe_queue</span>(threadsafe_queue <span class="hljs-type">const</span> &amp;other) &#123;<br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(other.mut)</span></span>;  <span class="hljs-comment">// 拷贝构造函数，对数据源加锁</span><br>    data_queue = other.data_queue;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T new_value)</span> </span>&#123;<br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(mut)</span></span>;  <span class="hljs-comment">// 加锁，保证对 data_queue 访问的安全性</span><br>    data_queue.<span class="hljs-built_in">push</span>(new_value);<br>    data_cond.<span class="hljs-built_in">notify_one</span>();  <span class="hljs-comment">// 通知调用 wait_and_pop 的线程</span><br>  &#125;<br><br>  <span class="hljs-comment">// 阻塞方法</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wait_and_pop</span><span class="hljs-params">(T &amp;value)</span> </span>&#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(mut)</span></span>;<br>    data_cond.<span class="hljs-built_in">wait</span>(lk, [<span class="hljs-keyword">this</span>] &#123; <span class="hljs-keyword">return</span> !data_queue.<span class="hljs-built_in">empty</span>(); &#125;);  <span class="hljs-comment">// 等待期待的条件：队列非空</span><br>    value = data_queue.<span class="hljs-built_in">front</span>();<br>    data_queue.<span class="hljs-built_in">pop</span>();<br>  &#125;<br><br>  <span class="hljs-comment">// 阻塞方法</span><br>  <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">wait_and_pop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(mut)</span></span>;<br>    data_cond.<span class="hljs-built_in">wait</span>(lk, [<span class="hljs-keyword">this</span>] &#123; <span class="hljs-keyword">return</span> !data_queue.<span class="hljs-built_in">empty</span>(); &#125;);  <span class="hljs-comment">// 等待期待的条件：队列非空</span><br>    <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">res</span><span class="hljs-params">(std::make_shared&lt;T&gt;(data_queue.front()))</span></span>;<br>    data_queue.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br><br>  <span class="hljs-comment">// 非阻塞方法</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">try_pop</span><span class="hljs-params">(T &amp;value)</span> </span>&#123;<br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(mut)</span></span>;<br>    <span class="hljs-keyword">if</span> (data_queue.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 队列空，返回 false</span><br>    value = data_queue.<span class="hljs-built_in">front</span>();<br>    data_queue.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 非阻塞方法</span><br>  <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">try_pop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(mut)</span></span>;<br>    <span class="hljs-keyword">if</span> (data_queue.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">shared_ptr</span>&lt;T&gt;();  <span class="hljs-comment">// 队列空，返回空指针</span><br>    <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">res</span><span class="hljs-params">(std::make_shared&lt;T&gt;(data_queue.front()))</span></span>;<br>    data_queue.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(mut)</span></span>;<br>    <span class="hljs-keyword">return</span> data_queue.<span class="hljs-built_in">empty</span>();<br>  &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  std::mutex cout_mutex;<br><br>  threadsafe_queue&lt;<span class="hljs-type">int</span>&gt; q;<br>  std::vector&lt;std::thread&gt; threads;<br>  <span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>      threads.<span class="hljs-built_in">emplace_back</span>(std::<span class="hljs-built_in">thread</span>([&amp;]() &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>          q.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>      &#125;));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      threads.<span class="hljs-built_in">emplace_back</span>(std::<span class="hljs-built_in">thread</span>([&amp;]() &#123;<br>        <span class="hljs-type">int</span> value;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>          q.<span class="hljs-built_in">wait_and_pop</span>(value);<br>        &#125;<br>      &#125;));<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;t : threads) &#123;<br>    t.<span class="hljs-built_in">join</span>();<br>  &#125;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;q.empty() = &quot;</span> &lt;&lt; q.<span class="hljs-built_in">empty</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="异步任务">5. 异步任务</h2><p>除了上述提供的较为低级的并发编程工具，C++也提供了一些较为高级的接口，能让我们迅速的使用多线程技术以充分利用多核CPU 的能力。</p><p>C++ 的 <code>future</code> 头文件中提供了 <code>std::async</code>方法，能够直接让系统开启一个线程执行指定的任务：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find_the_answer_to_ltuae</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_other_stuff</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  std::future&lt;<span class="hljs-type">int</span>&gt; the_answer = std::<span class="hljs-built_in">async</span>(find_the_answer_to_ltuae);<br>  <span class="hljs-built_in">do_other_stuff</span>();<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;The answer is &quot;</span> &lt;&lt; the_answer.<span class="hljs-built_in">get</span>() &lt;&lt; std::endl;<span class="hljs-comment">// get 方法获取异步任务返回的结果</span><br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./a.out</span> <br>The answer is 42<br></code></pre></td></tr></table></figure><p><code>async</code> 可以看作时 <code>thread</code>的封装，提供了更简单的使用方法供用户使用。因此，调用 <code>async</code>方法时，和 <code>thread</code>的构造函数类似，参数传递为拷贝语义，具体说明见下面代码（本段代码主要来自《C++并发编程实战（第二版）》一书）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> &#123;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>, std::string <span class="hljs-type">const</span> &amp;)</span></span>;<br><br>  <span class="hljs-function">std::string <span class="hljs-title">bar</span><span class="hljs-params">(std::string <span class="hljs-type">const</span> &amp;)</span></span>;<br>&#125;;<br><br>X x;<br><span class="hljs-keyword">auto</span> f1 = std::<span class="hljs-built_in">async</span>(&amp;X::foo, &amp;x, <span class="hljs-number">42</span>, <span class="hljs-string">&quot;hello&quot;</span>);  <span class="hljs-comment">// 调用 p-&gt;foo(42, &quot;hello&quot;)，p 是指向 x 的指针</span><br><span class="hljs-keyword">auto</span> f2 = std::<span class="hljs-built_in">async</span>(&amp;X::bar, x, <span class="hljs-string">&quot;goodbye&quot;</span>);     <span class="hljs-comment">// 调用 tmpx.bar(&quot;goodbye&quot;)， tmpx 是 x 的拷贝副本</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Y</span> &#123;<br>  <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span></span>;<br>&#125;;<br><br>Y y;<br><span class="hljs-keyword">auto</span> f3 = std::<span class="hljs-built_in">async</span>(<span class="hljs-built_in">Y</span>(), <span class="hljs-number">3.141</span>);          <span class="hljs-comment">// 调用 tmpy(3.141)，tmpy 通过 Y 的移动构造函数得到</span><br><span class="hljs-keyword">auto</span> f4 = std::<span class="hljs-built_in">async</span>(std::<span class="hljs-built_in">ref</span>(y), <span class="hljs-number">2.718</span>);  <span class="hljs-comment">// 调用 y(2.718)</span><br><br><span class="hljs-function">X <span class="hljs-title">baz</span><span class="hljs-params">(X &amp;)</span></span>;<br><span class="hljs-keyword">auto</span> f6 = std::<span class="hljs-built_in">async</span>(baz, std::<span class="hljs-built_in">ref</span>(x));  <span class="hljs-comment">// 调用 baz(x)</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">move_only</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">move_only</span>();<br>  <span class="hljs-built_in">move_only</span>(move_only &amp;&amp;);<br>  <span class="hljs-built_in">move_only</span>(move_only <span class="hljs-type">const</span> &amp;) = <span class="hljs-keyword">delete</span>;<br>  move_only &amp;<span class="hljs-keyword">operator</span>=(move_only &amp;&amp;);<br>  move_only &amp;<span class="hljs-keyword">operator</span>=(move_only <span class="hljs-type">const</span> &amp;) = <span class="hljs-keyword">delete</span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">auto</span> f5 = std::<span class="hljs-built_in">async</span>(<span class="hljs-built_in">move_only</span>());  <span class="hljs-comment">// 调用 tmp()，tmp 是通过 std::move(move_only()) 构造得到</span><br></code></pre></td></tr></table></figure><p>利用 <code>async</code>接口，我们能够方便地实现一个多线程版本的快速排序算法（本段代码主要来自《C++并发编程实战（第二版）》一书）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">std::list&lt;T&gt; <span class="hljs-title">parallel_quick_sort</span><span class="hljs-params">(std::list&lt;T&gt; input)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (input.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> input;<br>  &#125;<br>  std::list&lt;T&gt; result;<br>  result.<span class="hljs-built_in">splice</span>(result.<span class="hljs-built_in">begin</span>(), input, input.<span class="hljs-built_in">begin</span>());<br>  T <span class="hljs-type">const</span> &amp;pivot = *result.<span class="hljs-built_in">begin</span>();<br>  <span class="hljs-keyword">auto</span> divide_point = std::<span class="hljs-built_in">partition</span>(input.<span class="hljs-built_in">begin</span>(), input.<span class="hljs-built_in">end</span>(), [&amp;](T <span class="hljs-type">const</span> &amp;t) &#123; <span class="hljs-keyword">return</span> t &lt; pivot; &#125;);<br>  std::list&lt;T&gt; lower_part;<br>  lower_part.<span class="hljs-built_in">splice</span>(lower_part.<span class="hljs-built_in">end</span>(), input, input.<span class="hljs-built_in">begin</span>(), divide_point);<br>  std::future&lt;std::list&lt;T&gt; &gt; <span class="hljs-built_in">new_lower</span>(std::<span class="hljs-built_in">async</span>(&amp;parallel_quick_sort&lt;T&gt;, std::<span class="hljs-built_in">move</span>(lower_part)));  <span class="hljs-comment">// 开辟另一线程</span><br>  <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">new_higher</span><span class="hljs-params">(parallel_quick_sort(std::move(input)))</span></span>;<br>  result.<span class="hljs-built_in">splice</span>(result.<span class="hljs-built_in">end</span>(), new_higher);<br>  result.<span class="hljs-built_in">splice</span>(result.<span class="hljs-built_in">begin</span>(), new_lower.<span class="hljs-built_in">get</span>());<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  std::list&lt;<span class="hljs-type">int</span>&gt; lst&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">12</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">32</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-9</span>&#125;;<br>  <span class="hljs-keyword">auto</span> sorted_lst = <span class="hljs-built_in">parallel_quick_sort</span>(lst);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;elem : sorted_lst) &#123;<br>    std::cout &lt;&lt; elem &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>  &#125;<br>  std::cout &lt;&lt; std::endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了 <code>async</code> ，<code>future</code> 头文件还提供了<code>std::promise</code> 、<code>std::packaged_task</code>等高级编程接口，这里不具体介绍，可参考 <ahref="https://zh.cppreference.com/w/cpp/thread#future">https://zh.cppreference.com/w/cpp/thread#future</a>。</p><h2 id="原子类型">6. 原子类型</h2><p>除了上述工具，C++还提供了相对而言轻量级、高性能的原子类型。对应本文开始的代码，使用原子类型能够在基本不改变原有代码的情况下得到预期的结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br>std::atomic&lt;<span class="hljs-type">int</span>&gt; n = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 原子类型</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> total = <span class="hljs-number">100000</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; total; ++i) &#123;<br>    ++n;  <span class="hljs-comment">// 并发读写安全</span><br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(add)</span></span>;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(add)</span></span>;<br>  t1.<span class="hljs-built_in">join</span>();<br>  t2.<span class="hljs-built_in">join</span>();<br><br>  std::cout &lt;&lt; n &lt;&lt; std::endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./a.out</span> <br>200000<br></code></pre></td></tr></table></figure><p>使用原子类型，也可以方便地解决前文提到的生产者消费者问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br>std::vector&lt;<span class="hljs-type">int</span>&gt; data;<br><span class="hljs-function">std::atomic_bool <span class="hljs-title">data_ready</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>;<span class="hljs-comment">// 原子类型</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reader_thread</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (!data_ready.<span class="hljs-built_in">load</span>()) &#123;<span class="hljs-comment">// 并发安全读</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;not prepared yet&quot;</span> &lt;&lt; std::endl;<br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">1</span>));<br>  &#125;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;The answer=&quot;</span> &lt;&lt; data[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">writer_thread</span><span class="hljs-params">()</span> </span>&#123;<br>  data.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">42</span>);<br>  data_ready = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 并发安全写</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(reader_thread)</span></span>;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(writer_thread)</span></span>;<br>  t1.<span class="hljs-built_in">join</span>();<br>  t2.<span class="hljs-built_in">join</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于原子类型更多信息可参考 <ahref="https://zh.cppreference.com/w/cpp/atomic/atomic">https://zh.cppreference.com/w/cpp/atomic/atomic</a>。</p><h2 id="总结">7. 总结</h2><p>本文仅仅是关于 C++ 并发编程的最简单介绍，介绍了线程、锁、RAII管理锁、条件变量、原子类型、异步任务等的使用方法。内存模型、内存序、并行算法库等内容将在以后介绍。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
      <tag>多线程</tag>
      
      <tag>RAII</tag>
      
      <tag>锁</tag>
      
      <tag>条件变量</tag>
      
      <tag>原子类型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DBMS for ANNS 一览</title>
    <link href="/2024/03/26/DBMS-for-ANNS-%E4%B8%80%E8%A7%88/"/>
    <url>/2024/03/26/DBMS-for-ANNS-%E4%B8%80%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<p>自 2023 年 ChatGPT带动的大语言模型热以来，向量相似度检索得到了很多数据库系统的支持。实际上，早在2023 年之前，就已经有很多 DBMS支持了向量数据存储、索引、查询优化等功能。其中，最重要的功能就是提供支持近似最近邻检索（ANNS）的索引结构。在<a href="https://github.com/erikbern/ann-benchmarks">ANN Benchmark</a>中，列出了许多支持 ANNS 的库或者DBMS，并在主要的数据集上进行了性能测试。本文简要的介绍几个支持 ANNS的数据库系统。</p><h2 id="vearch">1. Vearch</h2><p>论文见：<ahref="https://arxiv.org/ftp/arxiv/papers/1908/1908.07389.pdf">The Designand Implementation of a Real Time Visual Search System on JD E-commercePlatform</a></p><p>GitHub：<a href="https://github.com/vearch/vearch">vearch/vearch:Distributed vector search for AI-native applications(github.com)</a></p><p>Vearch 算是最早的提供 ANNS功能的数据库系统，来自京东，用于其内部的商品图像检索。更早期的系统大多服务于基于内容的图片检索，不能称得上真正的DBMS。Vearch 提供了 Restful API 、实时索引更新、一些语言的 SDK 以及DDL/DML/DQL 接口等功能，所以可以算是 DBMS。Vearch 架构图：</p><center><img src="/2024/03/26/DBMS-for-ANNS-%E4%B8%80%E8%A7%88/image-20240326202017972.png" class="" title="image-20240326202017972"></center><p>以现在观点看，当时（论文发表时）的 Vearch 还是比较 naive的，但是其的却算是开创性的支持 ANNS 的DBMS。且在后续发展中，也逐渐支持了属性过滤等相对高级的功能。</p><p>另外，尽管开源了且最近都在更新，但是其文档似乎做的不是特别好，页面不是很详细，让人担心使用时会遇到问题。</p><h2 id="analyticdb">2. AnalyticDB</h2><p>论文：<ahref="https://www.vldb.org/pvldb/vol12/p2059-zhan.pdf">AnalyticDB:Real-time OLAP Database System at Alibaba Cloud</a></p><p>未开源，阿里云提供云服务版</p><p>如论文标题所示，AnalyticDB 是 OLAP系统。不过根据论文，其在当时已经支持了向量数据存储及索引功能。其为所有列创建索引，以加速OLAP 场景复杂查询的响应速度。在论文发表时，其支持了 PQ 和 ProximityGraph (k-NNG) 两种 ANN索引结构。对于走索引的查询，其设计了一些不错的优化策略，具体可参考原论文4.2.1 Index Filtering 小节。附架构图：</p><center><img src="/2024/03/26/DBMS-for-ANNS-%E4%B8%80%E8%A7%88/image-20240326203815139.png" class="" title="image-20240326203815139"></center><h2 id="analyticdb-v">3. AnalyticDB-V</h2><p>论文：<ahref="https://vldb.org/pvldb/vol13/p3152-wei.pdf">AnalyticDB-V: A HybridAnalytical Engine Towards Query Fusion for Structured and UnstructuredData</a></p><p>未开源</p><p>如题目所示，AnalyticDB-V 显然是 AnalyticDB 针对V（vector）的优化版本。AnalyticDB-V主要贡献是针对同时包含结构化数据的布尔条件过滤和向量相似度的混合查询进行了系统的优化。混合查询示意图如下：</p><center><img src="/2024/03/26/DBMS-for-ANNS-%E4%B8%80%E8%A7%88/image-20240326204502178.png" class="" title="image-20240326204502178"></center><p>系统架构图如下：</p><center><img src="/2024/03/26/DBMS-for-ANNS-%E4%B8%80%E8%A7%88/image-20240326204552655.png" class="" title="image-20240326204552655"></center><p>AnalyticDB-V 实现了 4中针对混合查询的物理执行计划，并设计了基于代价的查询优化算法，让系统选择代价最低的执行计划。具体参见论文5. HYBRID QUERY OPTIMIZATION 小节。</p><p>个人认为，AnalyticDB-V是很不错的工作。针对工业界的现实需求：标量向量数据混合查询，设计并实现一系列优化算法，以实现高效查询。同时也算是挖了个坑，混合查询优化这个方向值得进一步探索与研究。</p><h2 id="pase">4. PASE</h2><p>论文：<ahref="https://dl.acm.org/doi/pdf/10.1145/3318464.3386131">PASE:PostgreSQL Ultra-High-Dimensional Approximate Nearest Neighbor SearchExtension</a></p><p>GitHub：<ahref="https://github.com/alipay/PASE">https://github.com/alipay/PASE</a></p><p>连续第三篇阿里的工作。不同于前两个 DBMS，PASE 是 PostgreSQL的插件，实现了向量数据存储和索引功能，支持 PQ 和 HNSW 两种索引结构。</p><p>本文是学习如何为 PG 编写插件的不错案例，论文中介绍了 PG页面结构，如何自定义索引，如何设计页面存储格式等问题。例如：PQ 和 HNSW的页面格式分别设计如下：</p><center><img src="/2024/03/26/DBMS-for-ANNS-%E4%B8%80%E8%A7%88/image-20240326205647387.png" class="" title="image-20240326205647387"><img src="/2024/03/26/DBMS-for-ANNS-%E4%B8%80%E8%A7%88/image-20240326205709314.png" class="" title="image-20240326205709314"></center><p>对如何为 PG 编写插件感兴趣的，值得参考本论文和对应的 GitHub仓库。</p><p>根据 GitHub 仓库，PASE似乎提交后就没有后续的更新和维护了。不过类似的工作还有： <ahref="https://github.com/pgvector/pgvector">pgvector/pgvector:Open-source vector similarity search for Postgres (github.com)</a>，pgvector 是一个开源社区编写的 PG 插件，同样用于 ANNS，实现了 PQ 和HNSW 索引，且还在更新维护中。</p><h2 id="milvus">5. Milvus</h2><p>论文：<ahref="https://dl.acm.org/doi/pdf/10.1145/3448016.3457550">Milvus: APurpose-Built Vector Data Management System</a></p><p>GitHub：<ahref="https://github.com/milvus-io/milvus">milvus-io/milvus: Acloud-native vector database, storage for next generation AIapplications (github.com)</a></p><p>Milvus 是一个开源的、商业级、专为向量数据设计的DBMS，算是当今全球比较成功的 VDBMS，同样是国内企业开发。Milvus 提供了GPU 加速、SIMD指令优化、多向量相似度检索等高级特性。个人认为文档与社区也建设的不错，算是国内一众数据库厂商中发展的很不错的了。Milvus架构图如下：</p><center><img src="/2024/03/26/DBMS-for-ANNS-%E4%B8%80%E8%A7%88/image-20240326210514433.png" class="" title="image-20240326210514433"></center><p>同时，还有个 Manu （<a href="https://arxiv.org/pdf/2206.13843">Manu:A Cloud Native Vector Database ManagementSystem</a>），是同一家公司的云原生VDBMS，感兴趣参考论文，这里不多介绍。</p><p>另外，谈到商业 VDBMS，国外的 <ahref="https://www.pinecone.io/">Pinecone</a> 也是知名的 VDBMS创业公司，且其文档也做得特别好，不过其未开源也没有相关的论文。</p><h2 id="traditional-dbms-for-anns">6. Traditional DBMS for ANNS</h2><p>早些年时，一些传统的数据库，包括 PG、ES等，其实也有相关插件，实现了向量检索功能。2023 年 GhatGPT、LLMs等概念大火以来，许多传统数据库陆续官方宣布支持了向量数据存储及 ANNS功能，包括 Elasticsearch、ClickHouse、Redis 等等。可见，未来 vector大概率会成为类似 int、char 的基础数据类型，得到 DBMS的广泛支持。不过，在与传统 DBMS 结合时，必然也会产生新的问题和需求，比如AnalyticDB-V首次探索的混合查询优化等等。后续会如何发展，值得我们拭目以待。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>向量数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ANN</tag>
      
      <tag>数据库</tag>
      
      <tag>向量数据库</tag>
      
      <tag>Vector Database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重学操作系统：CPU 虚拟化与进程</title>
    <link href="/2024/03/09/%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9ACPU-%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B8%8E%E8%BF%9B%E7%A8%8B/"/>
    <url>/2024/03/09/%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9ACPU-%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B8%8E%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>操作系统是每名程序员必须掌握的内容。回想大学时学习操作系统时，总是陷于一些算法方面的细节，习题则多为计算不同算法的性能指标，而忽略了从更高层面来看待和理解操作系统。因此，最近开始阅读备受好评的操作系统书籍：《操作系统导论》（英文版名称为：OperatingSystems: Three Easy Pieces，OSTEP）。</p><p>OSTEP从虚拟化、并发、持久化三大方面展开对操作系统的介绍，通过提出问题、介绍简单的解决方案、逐渐放宽假设从而引出现代操作系统中真正使用的复杂算法，循序渐进地展开对操作系统的介绍。同时，我认为本书最好的一点就是：对操作系统要解决的关键问题用单独的排版特别标出。抓住这些问题，就抓住了学习操作系统的主线任务和主要矛盾，而不会再局限于算法细节，真正从更高的角度理解操作系统。</p><p>本文内容基于《操作系统导论》CPU虚拟化部分的内容，并按照自己的理解重新组织了内容。需要注意的是：本文的基本假设是单核CPU 以及多进程，不考虑现代多核 CPU 所带来的进程调度等问题。</p><h2 id="什么是操作系统">1. 什么是操作系统</h2><p>在正式开始之前，我们首先要搞清楚一个问题：什么是操作系统？</p><p>首先，我们要对操作系统有一个直观的概念。这里用之前在知乎冲浪时看到的内容概括：操作系统就是躺在内存里面，等着中断到来进行处理的代码。（原文参见：<ahref="https://www.zhihu.com/question/23561375/answer/25345790">Linux内核的操作系统是不是得一直运行着？ - 高鹏的回答 - 知乎</a>）</p><p>现在我们知道了操作系统不是魔法，它也是程序，只不过它的功能比较特殊，同时它的权限也比普通程序更高，也就是要区分CPU 的内核模式和用户模式。</p><p>对操作系统有了直观的概念后，还需要知道操作系统究竟是用来干什么的，它有什么样的功能？同样一句话概括：操作系统是系统资源（CPU时间、内存、IO设备等）的管理者。资源往往是稀少的，而需求（即不同进程都有对资源的需求）又是很多的。因此，操作系统作为资源管理者，有以下主要设计目标：</p><ul><li>共享：当资源有限时，如何满足众多需求，实现资源的共享；</li><li>高效：操作系统作为资源的管理者，其本身占用的CPU、内存等资源要尽可能少，且尽量不让资源空闲，以实现高效的资源共享；</li><li>公平：在分配资源时，尽可能公平，不能让某个进程一直独占系统资源；</li><li>安全：操作系统要保证资源的安全性，防止资源遭到破坏以及不同进程之间互相影响。</li></ul><p>实现这些目标的一个重要方法是：虚拟化，即：制造一个假象，让用户程序以为自己在独占资源。</p><p>对于 CPU 时间资源而言，进程便是为了解决 CPU的共享问题而引出的概念，下一小节详细介绍。</p><h2 id="如何共享-cpu进程">2. 如何共享 CPU：进程</h2><p>为了共享 CPU 实现运行多道程序，首先要知道 CPU是用来干什么的？程序又是什么？</p><p>这里我们只需要知道 CPU就是一个不断执行指令的器件，每个时钟周期其都在不断地进行：取指令、分析指令、执行指令的操作。而程序就是一个指令序列，正在执行中的程序称为进程。在某一时刻进程运行到的指令（PC，程序计数器）及进程的所有数据（包括寄存器和内存）共同构成了一个状态。在CPU 的下一个时钟周期，CPU 将根据 PC指针地址取指令，并分析执行，从而得到进程的下一个状态。</p><p>为了让 CPU资源能够被共享，一个简单的想法就是：将时间划分为时间片，例如 1 秒钟。第1 秒执行第 1 个进程；第 2 秒执行第 2个进程；以此类推……这种方式称为：时分共享。同时，在切换执行的进程时，需要保存必要的进程状态（保存在内核栈中），包括：PC（程序计数器）、SP（栈指针）等寄存器，以能够在后面恢复程序的运行状态并继续执行（上下文切换）。操作系统要用数据结构维护系统内所有的进程信息，称为：进程列表。为了保证安全性，操作系统运行于CPU内核模式下，而进程运行于用户模式下。同时，采用时间中断方式让操作系统能够周期性地获取执行权限。</p><h2 id="如何高效公平地共享-cpu进程调度">3. 如何高效公平地共享CPU：进程调度</h2><p>当有多个进程在系统内运行时，我们要考虑让 CPU执行哪个进程，这就是进程调度问题。同时，操作系统也要尽可能地保证高效地调度，及不浪费CPU资源；同时也要保证公平，不能出现饥饿现象（即有进程一直得不到执行）。</p><h3 id="先进先出first-in-first-outfifo">3.1 先进先出（First In FirstOut，FIFO）</h3><p>FIFO 算法也被称为先到先服务（First Come First Served，FCFS）。</p><p>这是最简单的进程调度算法，根据名字就可以知道含义：先到达的进程先占用CPU，直到运行结束（假设进程不存在 IO 操作）。</p><h3 id="最短任务优化shortest-job-firstsjf">3.2 最短任务优化（ShortestJob First，SJF）</h3><p>该调度策略含义为：先运行耗时最短的任务，然后次短任务，以此类推。</p><p>不过，由于现实世界往往不知道进程的执行耗时，因此该算法并不现实。</p><h3 id="最短完成时间优化shortest-time-to-completion-firststcf">3.3最短完成时间优化（Shortest Time-to-Completion First，STCF）</h3><p>该调度策略也称为：抢占式最短作业优先（Preemptive Shortest JobFirst，PSJF）。</p><p>该调度算法运行进行抢占式调度（SJF是非抢占式的），每当有新任务加入系统时，选择剩余工作和新工作中剩余时间最少的，执行该任务。</p><p>前三种调度算法都是为了优化周转时间（完成时间减去到达时间）。</p><h3 id="轮转round-robinrr">3.4 轮转（Round-Robin，RR）</h3><p>对于交互式程序，响应时间（即：首次运行时刻减去到达时刻）非常重要，于是提出了RR 调度策略。</p><p>RR基本思想是：在一个时间片内运行一个任务，然后切换到运行队列的下一个任务，而不是运行一个任务直到结束。反复执行，直到所有任务都运行结束。时间片长度必须是时钟中断周期的倍数。</p><h3 id="多级反馈队列multi-level-feedback-queuemlfq">3.5多级反馈队列（Multi-level Feedback Queue，MLFQ）</h3><p>前面 3.1 到 3.4小节中的调度算法只能优化周转时间或响应时间中的一个。本小节介绍现代操作系统中真正使用的进程调度算法：多级反馈队列，其能够同时优化周转时间和响应时间。</p><p>MLFQ调度算法有多个独立的队列，每个队列有不同的优先级。任何时刻一个任务只能存放在一个队列中。MLFQ总是优先执行较高优先级的工作。同一优先级队列内的任务采用轮转调度。为了兼顾周转时间和响应时间，MLFQ遵循以下规则：</p><ul><li>如果 A 优先级大于 B 优先级，运行 A；</li><li>如果 A 优先级等于 B 优先级，轮转运行 A 和 B；</li><li>工作进入系统时，放在最高优先级队列；（优化响应时间）</li><li>一旦工作用完了其在某一层的时间配额（无论中间主动放弃了多少次CPU），就降低其优先级；（公平性，优先级越高的队列时间配额越短）</li><li>每经过一段时间 <span class="math inline">\(S\)</span>，就将系统内所有工作重新加入最高优先级队列。（防止 CPU密集型任务饥饿）</li></ul><h2 id="总结">4. 总结</h2><p>本文主要参考了 《操作系统导论》 1 到 11 章的内容，介绍了 CPU虚拟化部分的主要内容，包括：进程概念、上下文切换、进程调度等。原书部分章节本文并未涉及，如：比例配额调度和多核处理器调度等，推荐阅读原书。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPU 虚拟化</tag>
      
      <tag>进程调度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 对象模型</title>
    <link href="/2024/02/19/C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    <url>/2024/02/19/C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>最近在看《深度探索 C++ 对象模型》一书，收获颇丰。如果你对 C++底层机制感兴趣、想知道编译器对我们的代码动了什么“手脚”，推荐阅读该书。</p><p>本文不打算整理或复述《深度探索 C++对象模型》一书的内容，因为这本书需要花费一定的时间心力阅读，一篇文章恐难覆盖全书内容。因此，本文仅展示部分代码及运行结果，加以必要的注释、解释等，以阐明C++ 对象模型的部分知识点。代码在 64 位 WSL（Ubuntu 22.04）系统运行，使用g++ 编译器。系统及编译器信息展示如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">uname</span> -a</span><br>Linux arcsin2-pc 5.15.133.1-microsoft-standard-WSL2 #1 SMP Thu Oct 5 21:02:42 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">g++ --version</span><br>g++ (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0<br>Copyright (C) 2021 Free Software Foundation, Inc.<br>This is free software; see the source for copying conditions.  There is NO<br>warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.<br></code></pre></td></tr></table></figure><p>由于部分代码涉及到裸指针操作和强制类型转换等，且 C++对象模型在不同编译器中的实现存在区别，本文代码并不保证跨平台运行，也不保证输出结果确定。本文的分析和解释仅针对上述系统和编译器。</p><h2 id="多态与虚函数表">0. 多态与虚函数表</h2><p>在开始之前，实现要对 C++多态实现机制：虚函数表有了解。下面代码展示了如何通过强制类型转换，通过<code>vptr</code> 访问虚函数表从而调用虚函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;f called&quot;</span> &lt;&lt; endl; &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;g called&quot;</span> &lt;&lt; endl; &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;h called&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  Object obj;<br>  <span class="hljs-keyword">auto</span> vptr = *<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-built_in">void</span> (***)(Object *)&gt;(&amp;obj);<br>  vptr[<span class="hljs-number">0</span>](&amp;obj);<br>  vptr[<span class="hljs-number">1</span>](&amp;obj);<br>  vptr[<span class="hljs-number">2</span>](&amp;obj);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">g++ virtual_function.cpp &amp;&amp; ./a.out</span> <br>f called<br>g called<br>h called<br></code></pre></td></tr></table></figure><p>通过 <code>vptr</code> 访问虚函数表的不同 <code>slot</code>即可实现调用不同的虚函数。</p><h2 id="new-与-malloc-的区别">1. new 与 malloc 的区别</h2><p>首先给出代码及运行结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base&quot;</span> &lt;&lt; endl; &#125;<br><br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() = <span class="hljs-keyword">default</span>;<br><br>  <span class="hljs-comment">//  private:</span><br>  <span class="hljs-type">int</span> data_;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derive</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive&quot;</span> &lt;&lt; endl; &#125;<br><br>  <span class="hljs-comment">//  private:</span><br>  <span class="hljs-type">int</span> age_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Base) &lt;&lt; endl;<br>  cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Derive) &lt;&lt; endl;<br><br>  Base b;<br>  b.<span class="hljs-built_in">show</span>();<br><br>  Derive d;<br>  d.<span class="hljs-built_in">show</span>();<br><br>  cout &lt;&lt; &amp;d &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; &amp;d.data_ &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; &amp;d.age_ &lt;&lt; endl;<br>  cout &lt;&lt; &amp;b &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; &amp;b.data_ &lt;&lt; endl;<br><br>  Derive *p = <span class="hljs-built_in">reinterpret_cast</span>&lt;Derive *&gt;(<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Derive)));<br>  <span class="hljs-keyword">auto</span> pd = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">double</span> *&gt;(p);<br>  *pd = *<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">double</span> *&gt;(&amp;d);<br>  p-&gt;<span class="hljs-built_in">show</span>(); <span class="hljs-comment">// Derive</span><br><br>  *pd = *<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">double</span> *&gt;(&amp;b);<br>  p-&gt;<span class="hljs-built_in">show</span>(); <span class="hljs-comment">// Base</span><br><br>  p = <span class="hljs-built_in">new</span> (pd) Derive; <span class="hljs-comment">// placement operator new</span><br>  p-&gt;<span class="hljs-built_in">show</span>();           <span class="hljs-comment">// Derive</span><br><br>  <span class="hljs-keyword">auto</span> ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br>  ptr-&gt;<span class="hljs-built_in">show</span>(); <span class="hljs-comment">// Derive</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">g++ new_and_malloc.cpp &amp;&amp; ./a.out</span> <br>16<br>16<br>Base<br>Derive<br>0x7ffcdc4153b0  0x7ffcdc4153b8  0x7ffcdc4153bc<br>0x7ffcdc4153a0  0x7ffcdc4153a8<br>Derive<br>Base<br>Derive<br>Derive<br></code></pre></td></tr></table></figure><p>这段代码旨在说明面试中的一个常见问题：<code>new</code> 与<code>malloc</code>有什么区别？当然答案其实很简单，就是前者不仅分配内存，而且调用了构造函数；而后者仅进行内存分配。我们结合代码分析。</p><p>在代码第 <code>35</code> 行，通过 <code>malloc</code>在堆内存申请足够空间以放置 <code>Derive</code>类的对象。然后通过指针操作，将分配的内存区域的 <code>vptr</code>，即：虚函数表指针分布赋予 <code>Base</code> 类和 <code>Derive</code>类的虚函数表地址，于是代码 <code>38</code> 行和 <code>41</code>行分别输出 <code>Base</code> 和 <code>Derive</code>，实现了手动指定<code>vptr</code> 指针以调用不同的虚函数。这对理解 C++多态的实现机制：虚函数表有一定帮助。</p><p>代码 <code>43</code> 行，通过一个<code>placement operator new</code>，调用了 <code>Derive</code>类的构造函数，从而代码 <code>44</code> 行输出 <code>Derive</code>。</p><p>代码 <code>46</code> 和 <code>47</code> 行则通过 <code>new</code>来构造对象，编译器负责帮我们分配内存即指定 <code>vptr</code>，我们能够输出 <code>Derive</code>。</p><h2 id="c-class-与-c-struct-的转换">2. C++ class 与 C struct 的转换</h2><p>本小节通过代码来直观感受：如何用 C 语言提供的机制来实现 C++的语义和运行时特征。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// C++ object</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">X</span>() = <span class="hljs-keyword">default</span>;<br><br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">X</span>() = <span class="hljs-keyword">default</span>;<br><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;foo&quot;</span> &lt;&lt; endl; &#125;<br><br>  <span class="hljs-built_in">X</span>(<span class="hljs-type">const</span> X &amp;x) = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-function">X <span class="hljs-title">foobar</span><span class="hljs-params">()</span> </span>&#123;<br>  X xx;<br>  X *px = <span class="hljs-keyword">new</span> X&#123;&#125;;<br><br>  xx.<span class="hljs-built_in">foo</span>();<br>  px-&gt;<span class="hljs-built_in">foo</span>();<br><br>  <span class="hljs-keyword">delete</span> px;<br>  <span class="hljs-keyword">return</span> xx;<br>&#125;<br><br><span class="hljs-comment">// C struct</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">c_X</span> &#123;<br>  <span class="hljs-type">int</span> **vptr;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">c_X_destructor</span><span class="hljs-params">(c_X *ptr)</span> </span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">c_X_foo</span><span class="hljs-params">(c_X *ptr)</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;c_X_foo&quot;</span> &lt;&lt; endl; &#125;<br><br><span class="hljs-type">int</span> *virtual_function_table[] = &#123;<br>    <span class="hljs-literal">nullptr</span>,                <span class="hljs-comment">// type info struct (not used here)</span><br>    (<span class="hljs-type">int</span> *)c_X_destructor,  <span class="hljs-comment">// virtual destructor</span><br>    (<span class="hljs-type">int</span> *)c_X_foo          <span class="hljs-comment">// virtual function foo</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">c_X_constructor</span><span class="hljs-params">(c_X *ptr)</span> </span>&#123; ptr-&gt;vptr = virtual_function_table; &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">c_X_copy</span><span class="hljs-params">(c_X *ptr, c_X src)</span> </span>&#123; ptr-&gt;vptr = src.vptr; &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foobar</span><span class="hljs-params">(c_X &amp;_result)</span> </span>&#123;<br>  <span class="hljs-built_in">c_X_constructor</span>(&amp;_result);<br><br>  c_X *px = (c_X *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(c_X));<br>  <span class="hljs-keyword">if</span> (px != <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-built_in">c_X_constructor</span>(px);<br>  &#125;<br><br>  <span class="hljs-built_in">c_X_foo</span>(&amp;_result);  <span class="hljs-comment">// call foo directly</span><br><br>  ((<span class="hljs-built_in">void</span> (*)(c_X *))(px-&gt;vptr[<span class="hljs-number">2</span>]))(px);  <span class="hljs-comment">// call foo by vptr</span><br><br>  <span class="hljs-keyword">if</span> (px != <span class="hljs-literal">nullptr</span>) &#123;<br>    ((<span class="hljs-built_in">void</span> (*)(c_X *))(px-&gt;vptr[<span class="hljs-number">1</span>]))(px);  <span class="hljs-comment">// call destructor by vptr</span><br>    <span class="hljs-built_in">free</span>(px);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// NRVO</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  cout &lt;&lt; <span class="hljs-string">&quot;C++ style: &quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">foobar</span>();<br><br>  cout &lt;&lt; <span class="hljs-string">&quot;\nC style: &quot;</span> &lt;&lt; endl;<br>  c_X obj;<br>  <span class="hljs-built_in">foobar</span>(obj);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">g++ object_model.cpp &amp;&amp; ./a.out</span> <br>C++ style: <br>foo<br>foo<br><br>C style: <br>c_X_foo<br>c_X_foo<br></code></pre></td></tr></table></figure><p>上述代码展示了如何用 C语言机制实现构造函数、析构函数、拷贝构造函数等。其中的关键是虚函数表以及结构体内指向虚函数表的<code>vptr</code> 指针。同时，转换的 C语言代码还应用了编译器常用的优化策略：NRVO（Named Return ValueOptimization），即：在函数参数内添加一个参数以传递返回值，从而消除拷贝构造函数的调用，提高程序性能。</p><h2 id="成员初始化顺序">3. 成员初始化顺序</h2><p>C++ 构造函数中的初始化列表的书写顺序并不代表成员的实际初始化顺序。C++标准规定，类成员的初始化顺序和声明顺序相同，而和构造函数的初始化列表无关。下面的代码展示了可能的错误和正确的写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">X</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> : j(val), i(j) &#123;</span>&#125; <span class="hljs-comment">// 错误 按成员声明顺序依次初始化 应改为： i(val), j(val)</span><br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; j = &quot;</span> &lt;&lt; j &lt;&lt; endl; &#125;<br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-type">int</span> j;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Y</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Y</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> : i(val), j(i) &#123;</span>&#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; j = &quot;</span> &lt;&lt; j &lt;&lt; endl; &#125;<br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-type">int</span> j;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  X x&#123;<span class="hljs-number">10</span>&#125;;<br>  x.<span class="hljs-built_in">show</span>(); <span class="hljs-comment">// i = random , j = 10</span><br><br>  Y y&#123;<span class="hljs-number">10</span>&#125;;<br>  y.<span class="hljs-built_in">show</span>(); <span class="hljs-comment">// i = 10 , j = 10</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下（多次运行以说明类 <code>X</code> 的数据成员<code>i</code> 并没有被正确初始化）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">g++ init_order.cpp &amp;&amp; ./a.out</span> <br>i = 32624 j = 10<br>i = 10 j = 10<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">g++ init_order.cpp &amp;&amp; ./a.out</span> <br>i = 32757 j = 10<br>i = 10 j = 10<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">g++ init_order.cpp &amp;&amp; ./a.out</span> <br>i = 32637 j = 10<br>i = 10 j = 10<br></code></pre></td></tr></table></figure><p>正确的做法是：在初始化列表内按照成员的声明顺序依次初始化，不可随意改变顺序。</p><h2 id="类成员指针">4. 类成员指针</h2><p>本小节仅为说明一个很少用的用法，即：如何通过指针获取类成员函数并通过类成员函数指针进行函数调用。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;func called with value = &quot;</span> &lt;&lt; value &lt;&lt; endl; &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> add)</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;func called with value + add = &quot;</span> &lt;&lt; value + add &lt;&lt; endl; &#125;<br><br>  <span class="hljs-type">int</span> value&#123;<span class="hljs-number">10</span>&#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  Object obj;<br>  <span class="hljs-keyword">auto</span> func_ptr = &amp;Object::func;<br>  (obj.*func_ptr)();<br><br>  obj.value = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">auto</span> func_ptr2 = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-built_in">void</span> (*)(Object *, <span class="hljs-type">int</span>)&gt;(&amp;Object::func2); <span class="hljs-comment">// warning</span><br>  <span class="hljs-built_in">func_ptr2</span>(&amp;obj, <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下（编译器会发出警告，下列运行结果保留编译器输出信息）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">g++ member_pointer.cpp &amp;&amp; ./a.out</span> <br>member_pointer.cpp: In function ‘int main()’:<br>member_pointer.cpp:19:76: warning: converting from ‘void (Object::*)(int)’ to ‘void (*)(Object*, int)’ [-Wpmf-conversions]<br>   19 |   auto func_ptr2 = reinterpret_cast&lt;void (*)(Object *, int)&gt;(&amp;Object::func2); // warning<br>      |                                                                            ^<br>func called with value = 10<br>func called with value + add = 2<br></code></pre></td></tr></table></figure><p>代码 <code>15</code> 和 <code>16</code>行展示了成员函数指针的用法；<code>19</code> 和 <code>20</code>行展示了如何通过强制类型转换和 <code>this</code>指针进行类成员函数调用。可以看出，程序运行结果与我们预期相同。不过，编译器对<code>19</code> 行代码发出了警告，实际项目中不可使用此方式编码。</p><h2 id="虚拟继承的对象布局">5. 虚拟继承的对象布局</h2><p>虚拟继承是避免菱形继承中子类含有多个基类对象的方法。本小节解释虚拟继承是如何实现的？其对对象的内存布局会产生什么影响？见以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point2d</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-type">float</span> _x&#123;<span class="hljs-number">1.0f</span>&#125;;<br>  <span class="hljs-type">float</span> _y&#123;<span class="hljs-number">2.0f</span>&#125;;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * offset : member</span><br><span class="hljs-comment"> * 0      : vptr</span><br><span class="hljs-comment"> * 8      : next</span><br><span class="hljs-comment"> * 16     : _x</span><br><span class="hljs-comment"> * 20     : _y</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vertex</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> Point2d &#123;<br> <span class="hljs-keyword">public</span>:<br>  Vertex *next;  <span class="hljs-comment">// 虚基类的数据成员 _x _y 在 Vertex 类尾部</span><br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * offset : member</span><br><span class="hljs-comment"> * 0      : vptr</span><br><span class="hljs-comment"> * 8      : _z</span><br><span class="hljs-comment"> * 12     : _x</span><br><span class="hljs-comment"> * 16     : _y</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point3d</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> Point2d &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-type">float</span> _z;  <span class="hljs-comment">// 虚基类的数据成员 _x _y 在 Vertex 类尾部</span><br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * offset : member</span><br><span class="hljs-comment"> * 0      : vptr</span><br><span class="hljs-comment"> * 8      : next    // class Vertex</span><br><span class="hljs-comment"> * 16     : vptr</span><br><span class="hljs-comment"> * 24     : _z      // class Point2d</span><br><span class="hljs-comment"> * 28     : mumble  // data member of class Vertex3d</span><br><span class="hljs-comment"> * 32     : _x</span><br><span class="hljs-comment"> * 36     : _y      // class Point2d</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vertex3d</span> : <span class="hljs-keyword">public</span> Vertex, <span class="hljs-keyword">public</span> Point3d &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-type">float</span> mumble;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Point2d) &lt;&lt; endl;<br>  cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Vertex) &lt;&lt; endl;<br>  cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Point3d) &lt;&lt; endl;<br>  cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Vertex3d) &lt;&lt; endl;<br><br>  Point2d p2d;<br>  cout &lt;&lt; &amp;p2d &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; &amp;p2d._x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; &amp;p2d._y &lt;&lt; endl;<br><br>  Vertex ver;<br>  cout &lt;&lt; &amp;ver &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; &amp;ver._x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; &amp;ver._y &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; &amp;ver.next &lt;&lt; endl;<br><br>  Point3d p3d;<br>  cout &lt;&lt; &amp;p3d &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; &amp;p3d._x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; &amp;p3d._y &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; &amp;p3d._z &lt;&lt; endl;<br><br>  Vertex3d ver3d;<br>  cout &lt;&lt; &amp;ver3d &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; &amp;ver3d._x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; &amp;ver3d._y &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; &amp;ver3d._z<br>       &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; &amp;ver3d.next &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; &amp;ver3d.mumble &lt;&lt; endl;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">g++ virtual_inheritance.cpp &amp;&amp; ./a.out</span> <br>8<br>24<br>24<br>40<br>0x7ffce4dad0d8 0x7ffce4dad0d8 0x7ffce4dad0dc<br>0x7ffce4dad0e0 0x7ffce4dad0f0 0x7ffce4dad0f4 0x7ffce4dad0e8<br>0x7ffce4dad100 0x7ffce4dad10c 0x7ffce4dad110 0x7ffce4dad108<br>0x7ffce4dad120 0x7ffce4dad140 0x7ffce4dad144 0x7ffce4dad138 0x7ffce4dad128 0x7ffce4dad13c<br></code></pre></td></tr></table></figure><p>这段代码的输出结果并不那么重要，关键是代码中每个类前面的注释，注释展示了对象的内存布局。以菱形继承的最低层子类<code>Vertex3d</code> 为例，由于其直接基类 <code>Vertex</code> 和<code>Point3d</code> 都是虚拟继承自类 <code>Point2d</code>，因此，其内存布局和普通的继承有很大区别。注释阐明了一种可能实现方式的内存布局，<code>vptr</code>指针在这里不仅仅指向虚函数表，也需要在某个 <code>slot</code>内指明虚基类 <code>Point2d</code> 的地址与 <code>this</code>指针的偏移量。这样，就能够在运行时通过该偏移量动态访问到虚拟基类，并调用正确的函数。</p><h2 id="构造函数析构函数与虚函数">6. 构造函数析构函数与虚函数</h2><p>假如我们在构造函数中调用一个虚函数，会发生什么呢？调用的究竟是基类的实现还是子类改写的实现呢？以下面代码为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point2d</span> &#123;<br>  <span class="hljs-type">double</span> x_, y_;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Point2d</span>() &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;this = &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Point2d size = &quot;</span> &lt;&lt; <span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">sizeof</span>(Point2d); &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Constructor 内调用的 virtual 函数并不具备多态行为，而是调用当前类的函数</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-built_in">Point2d</span>() &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;this = &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Point2d size = &quot;</span> &lt;&lt; <span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point3d</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> Point2d &#123;<br>  <span class="hljs-type">double</span> y_;<br><br><span class="hljs-keyword">public</span>:<br>  ~<span class="hljs-built_in">Point3d</span>() &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;this = &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Point3d size = &quot;</span> &lt;&lt; <span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">sizeof</span>(Point3d); &#125;<br><br>  <span class="hljs-built_in">Point3d</span>() &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;this = &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Point3d size = &quot;</span> &lt;&lt; <span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vertex</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> Point2d &#123;<br><span class="hljs-keyword">public</span>:<br>  ~<span class="hljs-built_in">Vertex</span>() &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;this = &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Vertex size = &quot;</span> &lt;&lt; <span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">sizeof</span>(Vertex); &#125;<br><br>  <span class="hljs-built_in">Vertex</span>() &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;this = &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Vertex size = &quot;</span> &lt;&lt; <span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vertex3d</span> : <span class="hljs-keyword">public</span> Point3d, <span class="hljs-keyword">public</span> Vertex &#123;<br><span class="hljs-keyword">public</span>:<br>  ~<span class="hljs-built_in">Vertex3d</span>() &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;this = &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Vertex3d size = &quot;</span> &lt;&lt; <span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">sizeof</span>(Vertex3d); &#125;<br><br>  <span class="hljs-built_in">Vertex3d</span>() &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;this = &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Vertex3d size = &quot;</span> &lt;&lt; <span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PVertex3d</span> : <span class="hljs-keyword">public</span> Vertex3d &#123;<br>  <span class="hljs-type">double</span> d_;<br><br><span class="hljs-keyword">public</span>:<br>  ~<span class="hljs-built_in">PVertex3d</span>() &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;this = &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;PVertex3d size = &quot;</span> &lt;&lt; <span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">sizeof</span>(PVertex3d); &#125;<br><br>  <span class="hljs-built_in">PVertex3d</span>() &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;this = &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;PVertex3d size = &quot;</span> &lt;&lt; <span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>  &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Point2d) &lt;&lt; endl;<br>  cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Point3d) &lt;&lt; endl;<br>  cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Vertex) &lt;&lt; endl;<br>  cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Vertex3d) &lt;&lt; endl;<br>  cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(PVertex3d) &lt;&lt; endl;<br><br>  &#123;<br>    Vertex3d obj;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Destructor:&quot;</span> &lt;&lt; endl;<br>  &#125;<br><br>  cout &lt;&lt; <span class="hljs-string">&quot;------------------------------------&quot;</span> &lt;&lt; endl;<br><br>  &#123;<br>    PVertex3d pv3d;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Destructor:&quot;</span> &lt;&lt; endl;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">g++ virtual_func_in_constructor.cpp &amp;&amp; ./a.out</span> <br>24<br>40<br>32<br>48<br>56<br>this = 0x7ffd70141fa8   Point2d size = 24<br>this = 0x7ffd70141f90   Point3d size = 40<br>this = 0x7ffd70141fa0   Vertex size = 32<br>this = 0x7ffd70141f90   Vertex3d size = 48<br>Destructor:<br>this = 0x7ffd70141f90   Vertex3d size = 48<br>this = 0x7ffd70141fa0   Vertex size = 32<br>this = 0x7ffd70141f90   Point3d size = 40<br>this = 0x7ffd70141fa8   Point2d size = 24<br>------------------------------------<br>this = 0x7ffd70141fb0   Point2d size = 24<br>this = 0x7ffd70141f90   Point3d size = 40<br>this = 0x7ffd70141fa0   Vertex size = 32<br>this = 0x7ffd70141f90   Vertex3d size = 48<br>this = 0x7ffd70141f90   PVertex3d size = 56<br>Destructor:<br>this = 0x7ffd70141f90   PVertex3d size = 56<br>this = 0x7ffd70141f90   Vertex3d size = 48<br>this = 0x7ffd70141fa0   Vertex size = 32<br>this = 0x7ffd70141f90   Point3d size = 40<br>this = 0x7ffd70141fb0   Point2d size = 24<br></code></pre></td></tr></table></figure><p>输出展示了构造函数与析构函数的调用顺序与继承关系的关联。同时，运行结果也说明了：构造函数内调用的virtual 函数并不具备多态行为，而是调用当前类的实现。这是因为 C++语言在进行当前类的构造前，首先把 <code>vptr</code>指针指向当前类的虚函数表。在指向基类的构造函数时，<code>vptr</code>指向基类的虚函数表，调用的自然就是基类的实现。只有当子类的构造函数全部完成（所有基类和成员的构造函数此时必定已执行完成），<code>vptr</code>指向子类的虚函数表，子类也就展现出属于子类的多态行为。析构函数中调用虚函数有类似的效果。</p><h2 id="模板实例化与静态变量">7. 模板实例化与静态变量</h2><p>首先看代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T t)</span> </span>&#123;<br>  <span class="hljs-type">static</span> <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>  cout &lt;&lt; <span class="hljs-string">&quot;count = &quot;</span> &lt;&lt; count &lt;&lt; endl;<br>  ++count;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-type">static</span> <span class="hljs-type">int</span> count;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Derive</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;count = &quot;</span> &lt;&lt; count &lt;&lt; endl;<br>    ++count;<br>  &#125;<br>&#125;;<br><br><span class="hljs-type">int</span> Base::count = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">func</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 0</span><br>  <span class="hljs-built_in">func</span>(<span class="hljs-number">1.0</span>);  <span class="hljs-comment">// 0</span><br>  <span class="hljs-built_in">func</span>(<span class="hljs-number">2</span>);    <span class="hljs-comment">// 1</span><br>  <span class="hljs-built_in">func</span>(<span class="hljs-number">1.0f</span>); <span class="hljs-comment">// 0</span><br>  cout &lt;&lt; <span class="hljs-string">&quot;-------------&quot;</span> &lt;&lt; endl;<br>  Derive&lt;<span class="hljs-type">int</span>&gt; di;<br>  di.<span class="hljs-built_in">show</span>(); <span class="hljs-comment">// 0</span><br>  Derive&lt;<span class="hljs-type">double</span>&gt; dd;<br>  dd.<span class="hljs-built_in">show</span>(); <span class="hljs-comment">// 1</span><br>  Derive&lt;<span class="hljs-type">char</span>&gt; dc;<br>  dc.<span class="hljs-built_in">show</span>(); <span class="hljs-comment">// 2</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">g++ template_function.cpp &amp;&amp; ./a.out</span> <br>count = 0<br>count = 0<br>count = 1<br>count = 0<br>-------------<br>count = 0<br>count = 1<br>count = 2<br></code></pre></td></tr></table></figure><p>这段代码说明了一个结论：模板的不同实例内的静态变量是不同的，如代码<code>26</code> 到 <code>29</code>行的输出所示。如果想让某个模板类的所有类型实例共享一个静态变量，应该按照代码<code>10</code> 到<code>21</code>行实现，即：在基类中声明一个静态变量，模板类继承自该基类。这样即可实现模板的所有类型实例都共享一个静态变量。</p><h2 id="总结">8. 总结</h2><p>本文通过代码和运行结果辅以适当解释说明了 C++对象模型的部分关键知识点。全文内容基于《深度探索 C++对象模型》一书，推荐想进一步了解 C++ 对象模型的读者阅读本书。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>对象模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DB 论文阅读：Product Quantization for Nearest Neighbor Search</title>
    <link href="/2024/01/29/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AProduct-Quantization-for-Nearest-Neighbor-Search/"/>
    <url>/2024/01/29/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AProduct-Quantization-for-Nearest-Neighbor-Search/</url>
    
    <content type="html"><![CDATA[<p>本文介绍论文《<ahref="https://inria.hal.science/inria-00514462/file/jegou_pq_postprint.pdf">ProductQuantization for Nearest Neighbor Search</a>》，即 ANN中乘积量化（Product Quantization，PQ）算法的主要内容。</p><h2 id="背景介绍">1. 背景介绍</h2><p>PQ 论文在 2011 年发表于 TPAMI，是针对欧式距离设计的一种 ANN算法。当时，基于图的算法尚未提出，主流的算法包括：EuclideanLocality-Sensitive Hashing (E2LSH)、randomized KD-trees、hierarchicalk-means等。但是，这些算法往往需要大量的内存才能运行，甚至索引结构所需要的内存超过了向量所需的内存。针对这一问题，提出了PQ 算法。</p><h2 id="量化与乘积量化">2. 量化与乘积量化</h2><h3 id="向量量化">2.1 向量量化</h3><p>量化可视作信息压缩的过程。在向量量化场景下，给定量化器 <spanclass="math inline">\(q\)</span>，其将 <spanclass="math inline">\(D\)</span> 维向量 <span class="math inline">\(x\in \mathbb{R}^{D}\)</span> 映射到一个向量 <spanclass="math inline">\(q(x) \in \mathcal{C} = \{ c_i, i \in \mathcal{I}\}\)</span> ，其中索引下标集合是有限的：<spanclass="math inline">\(\mathcal{I} = 0,…,k-1\)</span> ，<spanclass="math inline">\(c_i\)</span> 是中心点，<spanclass="math inline">\(\mathcal{C}\)</span> 是大小为 <spanclass="math inline">\(k\)</span> 的码本。被映射到同一个下标 <spanclass="math inline">\(i\)</span> 的向量集合 <spanclass="math inline">\(\mathcal{V}_i\)</span> 称为沃罗诺伊单元（Voronoicell）。码本 <span class="math inline">\(\mathcal{C}\)</span> 通常通过k-means 算法计算得到。</p><h3 id="乘积量化">2.2 乘积量化</h3><p>给定一个 128 维的向量，如果使用上面的向量量化方法，假设 <spanclass="math inline">\(k = 2^{64}\)</span> ，这样每个向量只需要一个 64比特的索引即可表示。但是，由于聚类中心过多，k-means算法时间复杂度不可接受，且存储这么多的聚类中心向量同样不现实。</p><p>解决这个问题的方法是乘积量化。给定向量 <spanclass="math inline">\(x\)</span> ，将其等划分为子向量 <spanclass="math inline">\(u_j, 1 \leq j \leq m\)</span> ，<spanclass="math inline">\(u_j\)</span> 维度为 <spanclass="math inline">\(D^* = D / m\)</span> ，其中 <spanclass="math inline">\(D\)</span> 为 <spanclass="math inline">\(m\)</span> 的倍数。然后，使用 <spanclass="math inline">\(m\)</span> 个量化器分别对子向量进行量化，于是向量<span class="math inline">\(x\)</span> 映射为： <spanclass="math display">\[\underbrace{x_1, \ldots, x_{D^*}}_{u_1(x)}, \ldots,\underbrace{x_{D-D^*+1}, \ldots, x_D}_{u_m(x)} \rightarrowq_1\left(u_1(x)\right), \ldots, q_m\left(u_m(x)\right) ,\]</span> 其中，<span class="math inline">\(q_j\)</span> 是对应第 <spanclass="math inline">\(j\)</span> 个子向量的低复杂度量化器。通过子量化器<span class="math inline">\(q_j\)</span> ，我们将下标集合 <spanclass="math inline">\(\mathcal{I}_j\)</span> 、码本 <spanclass="math inline">\(\mathcal{C}_j\)</span> 和对应的重构值 <spanclass="math inline">\(c_{j,i}\)</span> 联系起来。</p><p>乘积量化器的重构值可以由集合 <span class="math inline">\(\mathcal{I}= \mathcal{I}_1 \times … \times \mathcal{I}_m\)</span>中的一个元素表示。码本也可由笛卡尔积表示： <span class="math display">\[\mathcal{C} = \mathcal{C}_1 \times … \times \mathcal{C}_m ,\]</span> 集合的中心由 <span class="math inline">\(m\)</span>个子量化器的中心拼接得到。假设每个子量化器都有有限个（<spanclass="math inline">\(k^*\)</span>）重构值，于是总的中心数量为： <spanclass="math display">\[k = (k^{*})^m .\]</span> 对比 k-means、HKM 和 乘积量化码本占用的内存和任务复杂度：</p><img src="/2024/01/29/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AProduct-Quantization-for-Nearest-Neighbor-Search/image-20240129163623471.png" class="" title="image-20240129163623471"><p>可以看出，只有乘积量化适用于 <span class="math inline">\(k\)</span>非常大的情况。</p><p><span class="math inline">\(k^*\)</span> 和 <spanclass="math inline">\(m\)</span>的取值会影响计算复杂度和量化效果，推荐的取值为：<spanclass="math inline">\(k^* = 256, m = 8\)</span> 。</p><h2 id="使用量化搜索">3. 使用量化搜索</h2><h3 id="使用量化编码计算距离">3.1 使用量化编码计算距离</h3><p>假设有查询向量 <span class="math inline">\(x\)</span> 和数据库中向量<span class="math inline">\(y\)</span>，有两种方法计算其之间的近似欧氏距离，如下图所示：</p><img src="/2024/01/29/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AProduct-Quantization-for-Nearest-Neighbor-Search/image-20240129165042859.png" class="" title="image-20240129165042859"><ul><li><p>对称距离计算（Symmetric distance computation，SDC）</p><p>向量 <span class="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> 都由其聚类中心 <spanclass="math inline">\(q(x)\)</span> 和 <spanclass="math inline">\(q(y)\)</span> 表示，即： <spanclass="math inline">\(d(x,y) \triangleq d(q(x),q(y))\)</span>。</p></li><li><p>非对称距离计算（Asymmetric distance computation，ADC）</p><p>查询向量 <span class="math inline">\(x\)</span> 不经过量化，即：<spanclass="math inline">\(d(x,y) \triangleq d(x,q(y))\)</span> 。</p></li></ul><p>下表总结了在具有 <span class="math inline">\(n\)</span>个向量的数据集中搜索向量 <span class="math inline">\(x\)</span> 的 <spanclass="math inline">\(k\)</span> 近邻的不同步骤复杂度：</p><img src="/2024/01/29/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AProduct-Quantization-for-Nearest-Neighbor-Search/image-20240129170200142.png" class="" title="image-20240129170200142"><h3 id="距离误差分析">3.2 距离误差分析</h3><p>在 3.1 小节中计算的距离 <span class="math inline">\(\tilde{d}(x,y)\)</span> 与真实距离 <span class="math inline">\(d(x, y)\)</span>之间存在误差，此小节分析了误差界。</p><p>使用 MSE（ mean squared error）评估量化器的距离误差，有 mean squareddistance error (MSDE) 为： <span class="math display">\[\operatorname{MSDE}(q) \triangleq \iint(d(x, y)-\tilde{d}(x, y))^2 p(x)d x p(y) d y\]</span> 又根据三角不等式： <span class="math display">\[d(x, q(y))-d(y, q(y)) \leq d(x, y) \leq d(x, q(y))+d(y, q(y)) \text {, }\]</span> 其等价于（上述不等式右侧两项移项加平方可得）： <spanclass="math display">\[(d(x, y)-d(x, q(y)))^2 \leq d(y, q(y))^2 .\]</span> 将此不等式与 MSDE 联合，得： <span class="math display">\[\begin{aligned}\operatorname{MSDE}(q) &amp; \leq \int p(x)\left(\int d(y, q(y))^2 p(y)d y\right) d x \\&amp; \leq \operatorname{MSE}(q) .\end{aligned}\]</span> 这个不等式表明，距离误差的统计上界等于量化器的 MSE。</p><h3 id="距离平方估计">3.3 距离平方估计</h3><p>由于使用了 <span class="math inline">\(\tilde{d}\)</span> 或 <spanclass="math inline">\(\hat{d}\)</span> 来估计距离 <spanclass="math inline">\(d\)</span>，很明显可以看出，估计的距离是小于真实的距离的。以SIFT 数据集为例，如下图所示：</p><img src="/2024/01/29/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AProduct-Quantization-for-Nearest-Neighbor-Search/image-20240129211108318.png" class="" title="image-20240129211108318"><p>大部分点是落于直线 <span class="math inline">\(y = x\)</span>的下方的，且对称版本的距离误差要比非对称的更大。那么，我们应该如何更好地估计距离，以消除上述公式计算的偏差呢？</p><p>首先计算距离平方的期望 <span class="math inline">\(\tilde{e}(x,q(y))\)</span> ： <span class="math display">\[\begin{aligned}\tilde{e}(x, y) &amp; \triangleq \mathbb{E}_Y\left[(x-Y)^2 \midq(Y)=c_i\right] \\&amp; =\int_{\mathcal{V}_i}(x-y)^2 p(y \mid i) d y, \\&amp; =\frac{1}{p_i} \int_{\mathcal{V}_i}\left(x-c_i+c_i-y\right)^2 p(y)d y .\end{aligned}\]</span> 其中 <span class="math inline">\(Y\)</span> 为随机变量，且<span class="math inline">\(q(Y)=q(y)=c_i\)</span>。由于一个沃罗诺伊单元满足以下条件： <span class="math display">\[\int_{\mathcal{V}_i}\left(y-c_i\right) p(y) d y=0\]</span> 则前面式子可简化为： <span class="math display">\[\begin{aligned}\tilde{e}(x, y) &amp; =(x-q(y))^2+\int_{\mathcal{V}_i}(q(y)-y)^2p\left(y \mid y \in \mathcal{V}_i\right) d y \\&amp; =\tilde{d}(x, y)^2+\xi(q, q(y))\end{aligned}\]</span> 又对乘积量化，量化器由多个子量化器组成，于是有： <spanclass="math display">\[\tilde{e}(x, y)=\tilde{d}(x, y)^2+\sum_j \xi_j(y)\]</span> 其中，校正项，也就是平均失真为： <span class="math display">\[\xi_j(y) \triangleq \xi\left(q_j, q_j\left(u_j(y)\right)\right)\]</span> 其与将 <span class="math inline">\(u_j(y)\)</span> 转换为<span class="math inline">\(q_j(y)\)</span> 的第 <spanclass="math inline">\(j\)</span>个子量化器有关。可将其计算并存储与查找表中。</p><p>修正前后的概率分布函数如下图所示：</p><img src="/2024/01/29/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AProduct-Quantization-for-Nearest-Neighbor-Search/image-20240129213900251.png" class="" title="image-20240129213900251"><p>可以看出，校正后的版本偏差更小。然而，论文指出，在这种情况下，纠正偏差会导致估计量的更高方差，这是统计学中的常见现象。不过，在作者的实验中，观察到校正距离返回较差的结果。因此，建议在ANN 查询过程中采用 ADC计算距离。只有当我们对距离本身感兴趣时，修正后的版本才有用。</p><h2 id="非穷尽搜索">4. 非穷尽搜索</h2><p>尽管使用 PQ算法能减少内存占用，且通过查找表的方式让距离计算成本很低，但是其仍需要遍历聚类中心。</p><p>在 PQ 算法中，穷尽搜索（exhaustive search）指的是对于查询向量 <spanclass="math inline">\(x\)</span>，算法需要对每个子向量 <spanclass="math inline">\(u_j(x)\)</span>分别与子量化器的聚类中心（即子量化器的质心）进行比较，以确定每个子向量在相应子空间中的最近邻居。这个过程涉及到对每个子向量与所有聚类中心的距离计算，即使在实际应用中，可能只需要考虑每个子空间中的一小部分聚类中心。</p><p>在 PQ 算法中，查询向量 <span class="math inline">\(x\)</span>被分解为 <span class="math inline">\(m\)</span> 个子向量，每个子向量<span class="math inline">\(u_j(x)\)</span> 通过一个子量化器 <spanclass="math inline">\(q_j\)</span>被量化为一个索引。然后，对于每个子向量，算法需要在相应的子空间中找到最接近的聚类中心，这通常涉及到对所有聚类中心的距离计算。这个过程在每个子空间中独立进行，最终通过组合所有子空间的结果来确定整个查询向量的最近邻居。</p><p>在大规模数据集上，这种穷尽搜索仍然是计算密集型的，因为它需要对每个查询向量的每个子向量进行多次距离计算。为了提高搜索效率，论文提出了结合倒排文件系统的方法，该方法通过使用粗粒度量化器进行数据分区，首先确定一个大概的搜索范围，然后在进行细粒度的ANN搜索，从而减少了实际搜索过程中需要进行的距离计算次数。这样，搜索过程就不再是对整个数据库的穷尽搜索，而是对预先确定的、数量较少的候选向量进行搜索。</p><h3 id="粗粒度量化器与局部定义乘积量化器">4.1粗粒度量化器与局部定义乘积量化器</h3><p>粗粒度量化器 <span class="math inline">\(q_c\)</span> 的聚类中心数<span class="math inline">\(k&#39;\)</span> 需要根据数据集规模确定，对SIFT 数据集，取值范围为 1000 ~ 1000000。首先使用粗粒度量化器将向量 <spanclass="math inline">\(y\)</span> 编码为 <spanclass="math inline">\(q_c(y)\)</span> ，定义残差向量为： <spanclass="math display">\[r(y)=y-q_{\mathrm{c}}(y),\]</span> 其对应于沃罗诺伊单元中的偏移量。原始向量 <spanclass="math inline">\(y\)</span> 则近似表示为： <spanclass="math display">\[\ddot{y} \triangleqq_{\mathrm{c}}(y)+q_{\mathrm{p}}\left(y-q_{\mathrm{c}}(y)\right) ,\]</span> 即由元组 <span class="math inline">\(\left(q_{\mathrm{c}}(y),q_{\mathrm{p}}(r(y))\right)\)</span>表示。这可以类比二进制数值的表示方式，粗量化器提供了显著的位，而乘积量化器的码则对应于不显著的位。</p><p>对查询向量 <span class="math inline">\(x\)</span> 和数据库中向量<span class="math inline">\(y\)</span> ，距离 <spanclass="math inline">\(d(x, y)\)</span> 估算为： <spanclass="math display">\[\ddot{d}(x, y)=d(x, \ddot{y})=d\left(x-q_{\mathrm{c}}(y),q_{\mathrm{p}}\left(y-q_{\mathrm{c}}(y)\right)\right) .\]</span> <span class="math inline">\(q_{\mathrm{p}_j}\)</span> 表示第<span class="math inline">\(j\)</span>个子量化器，则可使用下面的分解来有效地计算这个距离估计值： <spanclass="math display">\[\ddot{d}(x, y)^2=\sum_j d\left(u_j\left(x-q_{\mathrm{c}}(y)\right),q_{\mathrm{p}_j}\left(u_j\left(y-q_{\mathrm{c}}(y)\right)\right)\right)^2.\]</span>乘积量化器是在从学习集收集的残差向量集上学习的。尽管粗粒度量化器将向量量化到不同的索引，但由此产生的残差向量被用来学习一个唯一的乘积量化器。我们假设，当残差在所有沃罗诺伊单元上的分布被边缘化时，相同的乘积量化器仍然准确。这可能比为每个沃罗诺伊单元学习和使用不同的乘积量化器的方法得到的结果要差。然而，这样做在计算上会很昂贵，并且需要存储<span class="math inline">\(k&#39;\)</span> 个乘积量化器码本，即 <spanclass="math inline">\(k&#39; \times d \times k^{*}\)</span>个浮点值，对于 <span class="math inline">\(k&#39;\)</span>的常见值来说，这在内存上是不可行的。</p><h3 id="索引结构">4.2 索引结构</h3><p>使用粗粒度量化器来实现倒排索引。倒排索引可看作一个 list 数组：<spanclass="math inline">\(\mathcal{L}_1,…,\mathcal{L}_{k&#39;}\)</span> 。若<span class="math inline">\(\mathcal{Y}\)</span>是需要索引的数据集，粗粒度量化器 <spanclass="math inline">\(q_c\)</span> 的聚类中心 <spanclass="math inline">\(c_i\)</span> 的对应列表是 <spanclass="math inline">\(\mathcal{L}_i\)</span> ，其存储了： <spanclass="math inline">\(\mathcal{y} \in \mathcal{Y} : q_c(\mathcal{y} =c_i)\)</span> 。</p><p>在倒排列表 <span class="math inline">\(\mathcal{L}_i\)</span>中，向量 <span class="math inline">\(y\)</span>的一个条目包括向量标识符和量化残差 <spanclass="math inline">\(q_p(r(y))\)</span> ：</p><center><img src="/2024/01/29/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AProduct-Quantization-for-Nearest-Neighbor-Search/image-20240129225039353.png" class="" title="image-20240129225039353"></center><p>标识符字段是由于倒排文件结构造成的开销。根据要存储的向量的性质，标识符并不一定是唯一的。例如，为了通过局部描述符描述图像，图像标识符可以替代向量标识符，即同一图像的所有向量具有相同的标识符。因此，一个20 位的字段就足以从一百万的图像数据集中识别一个图像。</p><h3 id="查询算法">4.3 查询算法</h3><p>倒排索引是实现非穷尽查询的关键。给定查询向量 <spanclass="math inline">\(x\)</span> ，倒排索引根据估计的距离提供了一个子集<span class="math inline">\(\mathcal{Y}\)</span> ：只有对应于 <spanclass="math inline">\(q_c(x)\)</span> 的列表 <spanclass="math inline">\(\mathcal{L}_i\)</span> 需要被扫描。</p><p>由于 <span class="math inline">\(x\)</span>与其最近邻不一定量化到一个单元，查询 <spanclass="math inline">\(x\)</span> 被分配给 <spanclass="math inline">\(w\)</span>个索引，而不是只有一个索引，这些索引对应于 <spanclass="math inline">\(q_c\)</span> 的码本中 <spanclass="math inline">\(x\)</span> 的 <spanclass="math inline">\(w\)</span>个最近邻居。扫描所有相应的倒排表。多重赋值不应用于数据库向量，因为这会增加内存使用。</p><p>插入和查询过程如下图所示：<img src="/2024/01/29/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AProduct-Quantization-for-Nearest-Neighbor-Search/image-20240129225855425.png" class="" title="算法示意图"></p><p>算法流程解释如下：</p><ul><li><p>插入算法</p><img src="/2024/01/29/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AProduct-Quantization-for-Nearest-Neighbor-Search/image-20240129225945206.png" class="" title="插入算法"></li><li><p>查询算法</p><img src="/2024/01/29/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AProduct-Quantization-for-Nearest-Neighbor-Search/image-20240129230000301.png" class="" title="查询算法"></li></ul><h2 id="总结">5. 总结</h2><p>本文引入了乘积量化用于近似最近邻搜索。我们的紧凑编码方案提供了对欧几里得距离的准确近似。此外，它与倒排文件系统相结合，避免了穷尽搜索，从而实现了高效率。我们的方法在搜索质量和内存使用之间的权衡上显著优于现有技术。对于SIFT 和 GIST图像描述符的实验结果非常出色，并且表明，基于我们对描述符设计先验知识的组件分组可以进一步改善结果。我们的方法在20 亿个向量的数据集上验证了其可扩展性。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>读论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>近似最近邻</tag>
      
      <tag>ANN</tag>
      
      <tag>向量相似度检索</tag>
      
      <tag>K近邻</tag>
      
      <tag>索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈 C++ 类的拷贝控制</title>
    <link href="/2024/01/14/%E6%B5%85%E8%B0%88-C-%E7%B1%BB%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/"/>
    <url>/2024/01/14/%E6%B5%85%E8%B0%88-C-%E7%B1%BB%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>在 C++语言的学习过程中，类的拷贝控制是一个较为繁杂的知识点。虽然它的难度不是很大，但是细节很多，需要理解记忆。本文介绍C++类的拷贝控制基本内容，即：拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符、析构函数这5 个函数的写法。</p><p>为了便于介绍，我们自己实现一个简单的 string 类，命名为<code>String</code>。它只包含一个私有的数据成员：<code>char *data</code>，关键函数成员包括：两个构造函数和五大拷贝控制函数。</p><p>类的定义（部分辅助函数在类内定义，下文介绍）如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT(message) \</span><br><span class="hljs-meta">  std::cout &lt;&lt; message &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;:\t&quot;</span> &lt;&lt; __FUNCTION__ &lt;&lt; std::endl</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">error</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">copy_str</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span> <span class="hljs-keyword">noexcept</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">release_memory</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>;<br><br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">String</span>() = <span class="hljs-keyword">default</span>;<br><br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">String</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)</span> <span class="hljs-keyword">noexcept</span></span>;<br><br>  <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String &amp;) <span class="hljs-keyword">noexcept</span>;  <span class="hljs-comment">// 拷贝构造函数</span><br><br>  String &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String &amp;) <span class="hljs-keyword">noexcept</span>;  <span class="hljs-comment">// 拷贝赋值运算符</span><br><br>  <span class="hljs-built_in">String</span>(String &amp;&amp;) <span class="hljs-keyword">noexcept</span>;  <span class="hljs-comment">// 移动构造函数</span><br><br>  String &amp;<span class="hljs-keyword">operator</span>=(String &amp;&amp;) <span class="hljs-keyword">noexcept</span>;  <span class="hljs-comment">// 移动赋值运算符</span><br><br>  ~<span class="hljs-built_in">String</span>() <span class="hljs-keyword">noexcept</span>;  <span class="hljs-comment">// 析构函数</span><br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">char</span> *data&#123;<span class="hljs-literal">nullptr</span>&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>构造函数与拷贝构造相关的 5 个函数都应该声明为 <code>noexcept</code>，以让编译器更好地进行编译优化。同时这也意味着：一般情况下，构造函数、析构函数、拷贝/移动相关的函数都不应该抛出异常，一旦这些函数运行时出错，将直接退出程序。</p><h2 id="构造函数">1. 构造函数</h2><p>为了介绍五大拷贝控制函数，需要先看类的两个构造函数。</p><p>首先是默认构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">String</span>() = <span class="hljs-keyword">default</span>;<br></code></pre></td></tr></table></figure><p>注意，这里在类内直接初始化数据成员：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">char</span> *data&#123;<span class="hljs-literal">nullptr</span>&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>而不是在默认构造函数中使用如下形式初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">String</span>() : data&#123;<span class="hljs-literal">nullptr</span>&#125; &#123;&#125;<br></code></pre></td></tr></table></figure><p>因为前一种形式直接对数据成员进行初始化，代码具有更好的局部性和可读性。C++Core Guideline 推荐采用前一种写法。</p><p>第二个构造函数接收一个 <code>const char *</code>类型指针，动态申请内存并从参数中拷贝构造字符串。代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">String::<span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s) <span class="hljs-keyword">noexcept</span> &#123;<br>  <span class="hljs-built_in">PRINT</span>(<span class="hljs-string">&quot;构造函数&quot;</span>);<br>  <span class="hljs-built_in">copy_str</span>(s);<br>&#125;<br></code></pre></td></tr></table></figure><p>构造函数中包括一个用于追踪函数调用的宏，打印函数调用信息，以及真正执行构造的<code>copy_str</code> 函数，其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">error</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cerr &lt;&lt; <span class="hljs-string">&quot;Error!&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">copy_str</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">nullptr</span>) &#123;<br>      data = <span class="hljs-literal">nullptr</span>;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> length = <span class="hljs-built_in">strlen</span>(s);<br>    data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[length + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span> (data != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-built_in">strcpy</span>(data, s);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">error</span>();<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>函数内进行动态内存分配及字符串拷贝，并处理可能出现的内存不足错误。</p><p>接下来正式进入拷贝控制的内容。</p><h2 id="析构函数">2. 析构函数</h2><p>先从最简单的析构函数开始：</p><p>析构函数的声明形式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">~<span class="hljs-built_in">ClassName</span>() <span class="hljs-keyword">noexcept</span> &#123;  <span class="hljs-comment">/* 函数体 */</span>  &#125;<br></code></pre></td></tr></table></figure><p>析构函数一般进行类的资源释放，对于本 <code>String</code> 类，需要释放<code>data</code> 指针对应的内存，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">String::~<span class="hljs-built_in">String</span>() <span class="hljs-keyword">noexcept</span> &#123;<br>  <span class="hljs-built_in">PRINT</span>(<span class="hljs-string">&quot;析构函数&quot;</span>);<br>  <span class="hljs-built_in">release_memory</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>析构函数内调用 <code>release_memory</code>函数释放动态分配的内存：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">release_memory</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (data != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">delete</span>[] data;<br>      data = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><em>何时调用析构函数：</em></p><ol type="1"><li>变量离开作用域时</li><li>当一个对象被销毁时，其成员被销毁</li><li>容器（标准库容器以及数组）被销毁时，其元素被销毁</li><li>动态分配对象被 <code>delete</code> 时</li><li>对于临时对象，当创建它的完整表达式结束时被销毁</li></ol><h2 id="拷贝构造函数">3. 拷贝构造函数</h2><p>拷贝构造函数声明形式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">ClassName</span>(<span class="hljs-type">const</span> ClassName &amp;s) <span class="hljs-keyword">noexcept</span> &#123;  <span class="hljs-comment">/* 函数体 */</span>   &#125;<br></code></pre></td></tr></table></figure><p><em>注意点：</em></p><ol type="1"><li>拷贝构造函数是构造函数，<strong>无返回类型</strong></li><li>拷贝构造函数的参数类型为 <strong>const 引用类型</strong></li><li>拷贝构造函数一般需要动态申请内存，进行深拷贝工作，对于本<code>String</code> 类，需要申请内存，并从参数字符串中拷贝数据</li></ol><p><code>String</code> 类的拷贝构造函数实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">String::<span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String &amp;s) <span class="hljs-keyword">noexcept</span> &#123;<br>  <span class="hljs-built_in">PRINT</span>(<span class="hljs-string">&quot;拷贝构造函数&quot;</span>);<br>  <span class="hljs-built_in">copy_str</span>(s.data);<br>&#125;<br></code></pre></td></tr></table></figure><p><em>何时调用拷贝构造函数：</em></p><ol type="1"><li>用 = 定义变量时</li><li>将一个对象作为实参传递给一个非引用类型的形参（函数调用以值传递）</li><li>从一个返回类型为非引用类型的函数返回一个对象（函数返回）</li><li>用花括号列表初始化一个数组中的元素或者一个聚合类中的成员</li></ol><h2 id="拷贝赋值运算符">4. 拷贝赋值运算符</h2><p>拷贝赋值运算符声明形式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ClassName &amp; <span class="hljs-keyword">operator</span>= (<span class="hljs-type">const</span> ClassName &amp;s) <span class="hljs-keyword">noexcept</span> &#123;  <span class="hljs-comment">/* 函数体 */</span>   &#125;<br></code></pre></td></tr></table></figure><p><em>注意点：</em></p><ol type="1"><li>拷贝赋值运算符是一种运算符重载，可以看作名字为：<code>operator=</code>的函数，其 <strong>参数类型为 const引用类型</strong>，<strong>返回类型为引用类型</strong></li><li>拷贝赋值运算符一般需要执行析构函数和构造函数的功能</li><li>需要考虑自赋值情况，即：<code>a = a</code>，确保自赋值情况拷贝赋值运算符正确执行。为了保证自赋值正确执行，一般采取：先申明临时变量，然后将参数拷贝到临时变量，最后将临时变量拷贝到本对象的步骤</li></ol><p><code>String</code> 类的拷贝赋值运算符实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">String &amp;String::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String &amp;s) <span class="hljs-keyword">noexcept</span> &#123;<br>  <span class="hljs-built_in">PRINT</span>(<span class="hljs-string">&quot;拷贝赋值运算符&quot;</span>);<br>  <span class="hljs-built_in">release_memory</span>();<br>  <span class="hljs-built_in">copy_str</span>(s.data);<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>何时调用拷贝赋值运算符：</em></p><ol type="1"><li>赋值符号右侧为一个左值时</li></ol><h2 id="移动构造函数">5. 移动构造函数</h2><p>移动构造函数声明形式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-built_in">ClassName</span>(ClassName &amp;&amp;s) <span class="hljs-keyword">noexcept</span> &#123;  <span class="hljs-comment">/* 函数体 */</span>   &#125;<br></code></pre></td></tr></table></figure><p><em>注意点：</em></p><ol type="1"><li>移动构造函数属于构造函数，无返回类型。其<strong>参数类型为右值引用</strong>，<strong>不取const 类型</strong></li><li>移动构造函数的特性在于“移动”，它一般执行“浅拷贝”，即不需要动态申请内存，而是将<code>s</code> 的动态内存指针赋值给本对象的指针，然后将 <code>s</code>的指针赋值为空</li></ol><p><code>String</code> 类的移动构造函数实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">String::<span class="hljs-built_in">String</span>(String &amp;&amp;s) <span class="hljs-keyword">noexcept</span> &#123;<br>  <span class="hljs-built_in">PRINT</span>(<span class="hljs-string">&quot;移动构造函数&quot;</span>);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;s)  <span class="hljs-comment">// 排除自赋值情况</span><br>  &#123;<br>    data = s.data;     <span class="hljs-comment">// 直接赋值 不申请内存</span><br>    s.data = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// 将赋值运算符右侧对象指针置为空</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>何时调用移动构造函数：</em></p><ol type="1"><li>显式地从一个右值进行构造时，例如：利用标准库 <code>move</code>函数返回一个右值进行构造</li><li>利用移动迭代器构造时</li></ol><h2 id="移动赋值运算符">6. 移动赋值运算符</h2><p>移动赋值运算符声明形式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>ClassName &amp;<span class="hljs-keyword">operator</span>= (ClassName &amp;&amp;s) <span class="hljs-keyword">noexcept</span> &#123;  <span class="hljs-comment">/* 函数体 */</span>   &#125;<br></code></pre></td></tr></table></figure><p><em>注意点：</em></p><ol type="1"><li>移动赋值运算符同样是一种运算符重载，其返回类型为类的引用类型，参数类型为类的右值引用，<strong>不是const 类型</strong></li><li>移动赋值运算符特性同样在“移动”二字，它不执行拷贝，执行的动作一般拷贝析构本对象原有的动态内存，然后将参数对象动态内存指针赋值给本对象内指针，最后将参数对象指针赋值为空。正因为该函数需要改变参数，因此不声明为<code>const</code> 类型</li></ol><p><code>String</code> 类移动赋值运算符实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">String &amp;String::<span class="hljs-keyword">operator</span>=(String &amp;&amp;s) <span class="hljs-keyword">noexcept</span> &#123;<br>  <span class="hljs-built_in">PRINT</span>(<span class="hljs-string">&quot;移动赋值运算符&quot;</span>);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;s)  <span class="hljs-comment">// 排除自赋值情况</span><br>  &#123;<br>    <span class="hljs-built_in">release_memory</span>();<br>    data = s.data;     <span class="hljs-comment">// 直接赋值 不申请内存</span><br>    s.data = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// 将赋值运算符右侧对象指针置为空</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>何时调用移动赋值运算符：</em></p><ol type="1"><li>赋值符号右侧为一个右值时</li></ol><h2 id="运行结果">7. 运行结果</h2><p><strong>完整测试函数：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT(message) \</span><br><span class="hljs-meta">  std::cout &lt;&lt; message &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;:\t&quot;</span> &lt;&lt; __FUNCTION__ &lt;&lt; std::endl</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">error</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cerr &lt;&lt; <span class="hljs-string">&quot;Error!&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">copy_str</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">nullptr</span>) &#123;<br>      data = <span class="hljs-literal">nullptr</span>;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> length = <span class="hljs-built_in">strlen</span>(s);<br>    data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[length + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span> (data != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-built_in">strcpy</span>(data, s);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">error</span>();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">release_memory</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (data != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">delete</span>[] data;<br>      data = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>  &#125;<br><br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">String</span>() = <span class="hljs-keyword">default</span>;<br><br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">String</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)</span> <span class="hljs-keyword">noexcept</span></span>;<br><br>  <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String &amp;) <span class="hljs-keyword">noexcept</span>;  <span class="hljs-comment">// 拷贝构造函数</span><br><br>  String &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String &amp;) <span class="hljs-keyword">noexcept</span>;  <span class="hljs-comment">// 拷贝赋值运算符</span><br><br>  <span class="hljs-built_in">String</span>(String &amp;&amp;) <span class="hljs-keyword">noexcept</span>;  <span class="hljs-comment">// 移动构造函数</span><br><br>  String &amp;<span class="hljs-keyword">operator</span>=(String &amp;&amp;) <span class="hljs-keyword">noexcept</span>;  <span class="hljs-comment">// 移动赋值运算符</span><br><br>  ~<span class="hljs-built_in">String</span>() <span class="hljs-keyword">noexcept</span>;  <span class="hljs-comment">// 析构函数</span><br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">char</span> *data&#123;<span class="hljs-literal">nullptr</span>&#125;;<br>&#125;;<br><br>String::<span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s) <span class="hljs-keyword">noexcept</span> &#123;<br>  <span class="hljs-built_in">PRINT</span>(<span class="hljs-string">&quot;构造函数&quot;</span>);<br>  <span class="hljs-built_in">copy_str</span>(s);<br>&#125;<br><br>String::~<span class="hljs-built_in">String</span>() <span class="hljs-keyword">noexcept</span> &#123;<br>  <span class="hljs-built_in">PRINT</span>(<span class="hljs-string">&quot;析构函数&quot;</span>);<br>  <span class="hljs-built_in">release_memory</span>();<br>&#125;<br><br>String::<span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String &amp;s) <span class="hljs-keyword">noexcept</span> &#123;<br>  <span class="hljs-built_in">PRINT</span>(<span class="hljs-string">&quot;拷贝构造函数&quot;</span>);<br>  <span class="hljs-built_in">copy_str</span>(s.data);<br>&#125;<br><br>String &amp;String::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String &amp;s) <span class="hljs-keyword">noexcept</span> &#123;<br>  <span class="hljs-built_in">PRINT</span>(<span class="hljs-string">&quot;拷贝赋值运算符&quot;</span>);<br>  <span class="hljs-built_in">release_memory</span>();<br>  <span class="hljs-built_in">copy_str</span>(s.data);<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br>String::<span class="hljs-built_in">String</span>(String &amp;&amp;s) <span class="hljs-keyword">noexcept</span> &#123;<br>  <span class="hljs-built_in">PRINT</span>(<span class="hljs-string">&quot;移动构造函数&quot;</span>);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;s)  <span class="hljs-comment">// 排除自赋值情况</span><br>  &#123;<br>    data = s.data;     <span class="hljs-comment">// 直接赋值 不申请内存</span><br>    s.data = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// 将赋值运算符右侧对象指针置为空</span><br>  &#125;<br>&#125;<br><br>String &amp;String::<span class="hljs-keyword">operator</span>=(String &amp;&amp;s) <span class="hljs-keyword">noexcept</span> &#123;<br>  <span class="hljs-built_in">PRINT</span>(<span class="hljs-string">&quot;移动赋值运算符&quot;</span>);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;s)  <span class="hljs-comment">// 排除自赋值情况</span><br>  &#123;<br>    <span class="hljs-built_in">release_memory</span>();<br>    data = s.data;     <span class="hljs-comment">// 直接赋值 不申请内存</span><br>    s.data = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// 将赋值运算符右侧对象指针置为空</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  String s1;                   <span class="hljs-comment">// 默认构造函数</span><br>  <span class="hljs-function">String <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-string">&quot;I&#x27;m String.\n&quot;</span>)</span></span>;  <span class="hljs-comment">// 由字符串构造</span><br><br>  String s3 = s2;            <span class="hljs-comment">// 拷贝构造函数</span><br>  s1 = s2;                   <span class="hljs-comment">// 拷贝赋值运算符</span><br>  <span class="hljs-function">String <span class="hljs-title">s4</span><span class="hljs-params">(std::move(s1))</span></span>;  <span class="hljs-comment">// 移动构造函数</span><br>  s2 = <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;hhh&quot;</span>);        <span class="hljs-comment">// 移动赋值运算符</span><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;-----------------&quot;</span> &lt;&lt; std::endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><p>在 ubuntu 22.04 上使用 11.4.0 版本的 GCC 编译器，使用编译命令<code>g++ test.cpp -o test</code> 编译运行，运行结果如下：</p><center><img src="/2024/01/14/%E6%B5%85%E8%B0%88-C-%E7%B1%BB%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/image-20240115141151453.png" class="" title="运行结果"></center><p>根据输出结果，可以追踪到各个函数在什么时候被调用。</p><p><br></p><p><br></p><p><strong>参考文献</strong></p><ul><li>《C++ Primer 第五版》 第 13 章 拷贝控制</li><li>《C++ Core Guidelines 解析》第 5 章 类和类层次结构</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>拷贝控制</tag>
      
      <tag>构造函数</tag>
      
      <tag>析构函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何实现学术论文？</title>
    <link href="/2024/01/13/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87%EF%BC%9F/"/>
    <url>/2024/01/13/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>译者注：</p><p>本文译自 <ahref="https://www.elastic.co/search-labs/blog/articles/implementing-academic-papers-lessons-learned-from-elasticsearch-and-lucene">Implementingacademic papers: lessons learned from Elasticsearch and Lucene</a>，作者：<ahref="https://www.elastic.co/search-labs/author/julie-tibshirani">JulieTibshirani</a>。本文主要讨论了如何将学术论文中的前沿研究成果引入到实际的软件系统中，讨论了在此过程中需要注意的一些问题。</p><p>译者：<a href="https://arcsin2.cloud/about">arcsin2</a></p></blockquote><p>在开发 Elasticsearch时，我们偶尔会遇到一些重要的问题，它们没有简单或既定的解决方法。这时，会很自然地会问：“有没有学术论文解决了这个问题？”。有时候，学术工作会成为灵感的来源。我们可能会看到一篇提出新算法或数据结构的论文，然后想：“这会非常有用！”以下是 Elasticsearch 和 Apache Lucene 如何融入学术工作的几个例子：</p><ul><li><a href="https://research.google/pubs/pub40671/">HyperLogLog++</a>for <ahref="https://www.elastic.co/guide/en/elasticsearch/reference/7.15/search-aggregations-metrics-cardinality-aggregation.html">cardinalityaggregations</a></li><li><ahref="https://www.usenix.org/system/files/conference/nsdi15/nsdi15-paper-suresh.pdf">C3algorithm</a> for <ahref="https://www.elastic.co/blog/improving-response-latency-in-elasticsearch-with-adaptive-replica-selection">adaptivereplica selection</a></li><li><a href="https://arxiv.org/abs/1603.09320">Hierarchical NavigableSmall World Graphs (HNSW)</a> for nearest vector search in Lucene</li><li><ahref="https://jmlr.csail.mit.edu/papers/volume17/15-308/15-308.pdf">MICstatistic</a> to <ahref="https://github.com/elastic/ml-cpp/pull/488">improve machinelearning classification</a></li><li><a href="http://engineering.nyu.edu/~suel/papers/bmw.pdf">Block-maxWAND</a> for <ahref="https://www.elastic.co/blog/faster-retrieval-of-top-hits-in-elasticsearch-with-block-max-wand">fastertop-hits retrieval in Lucene</a></li><li>... and <ahref="https://www.elastic.co/guide/en/elasticsearch/reference/7.15/query-dsl-combined-fields-query.html">many</a><ahref="https://github.com/elastic/elasticsearch/blob/b2a9328890b23e7ccf6c66a3b13d6d65e453a3dd/server/src/main/java/org/elasticsearch/search/sort/BucketedSort.java#L302-L323">more</a></li></ul><p>对于开发数据密集型系统的工程师来说，学术论文是一种宝贵的资源。但实现这些论文可能会令人生畏且容易出错——算法描述通常很复杂，并且经常省略重要的实用细节。并且测试是一个真正的挑战，例如：我们如何彻底测试一个其输出紧密依赖于数据集的机器学习算法？</p><p>本文分享了在软件应用中实现学术论文的策略。它借鉴了 Elasticsearch 和Lucene的实例，希望帮助其他工程师从我们的经验中学习。阅读这些策略时，您可能会想：“但这不过是软件开发而已！”确实如此：作为工程师，我们已经有了正确的实践和工具，只需要适应新的挑战。</p><h2 id="像评估软件依赖一样评估论文">1. 像评估软件依赖一样评估论文</h2><p>添加新的软件依赖需要仔细评估：如果依赖的包不正确、运行缓慢或不安全，我们的项目也可能受到影响。在引入依赖之前，开发者要确保评估其质量。</p><p>当你考虑实现学术论文时，这同样适用。人们可能会认为发表在学术论文上的算法一定是正确且表现良好的。但是，即使通过了审查程序，学术论文也可能存在问题：</p><ul><li>正确性证明依赖于不切实际的假设；</li><li>“实验”部分显示了比基线更好的性能，但这只适用于特定的数据集；</li></ul><p>即使论文质量很高，它的方法也可能不适合你的项目。</p><p>当考虑是否要“依赖”一篇学术论文时，提出我们对软件包会问的同样问题是很有帮助的：</p><ul><li>这个库是否被广泛使用并且经过了“实战测试”？→是否有其他包实现了这篇论文，并且对它们来说运行良好吗？</li><li>是否有性能基准测试？这些基准看起来准确和公正吗？→论文中包含了现实世界的实验吗？这些实验设计得好吗？</li><li>是否有足够大的性能提升，以接受算法的复杂性？→论文是否与一个强大的基线方法进行了比较？它比基线方法表现好多少？</li><li>这种方法是否能很好地集成到我们的系统中？→算法的假设和权衡是否符合我们的用例？</li></ul><p>不知何故，当一个软件包与其竞争对手发布性能比较时，该软件包总是最快的！如果由第三方设计基准，它们可能会更加公平。同样的现象也适用于学术论文。如果一种算法不仅在原始论文中表现良好，而且在其他论文中作为强基线出现，那么它很可能是可靠的。</p><h2 id="创造性地进行测试">2. 创造性地进行测试</h2><p>学术论文中的算法通常比我们日常遇到的算法具有更复杂的行为。也许它是一个近似算法，为了提高速度而牺牲准确性。或者它是一种机器学习方法，它处理大量数据集，并产生（有时是意想不到的）输出。如果我们不能简单地描述这些算法的行为，我们该如何为它们编写测试呢？</p><h3 id="关注不变性">2.1 关注不变性</h3><p>在设计单元测试时，通常我们会以示例为基础进行思考：如果我们给算法这个示例输入，它应该产生那个输出。不幸的是，对于大多数数学算法来说，基于示例的测试并不能充分覆盖它们的行为。</p><p>让我们考虑一下 C3 算法，Elasticsearch使用它来确定哪个节点应该处理搜索请求。它使用一个微妙的公式对每个节点进行排名，这个公式考虑了节点的先前服务和响应时间，以及它的队列大小。仅仅测试几个例子并不能真正验证我们是否正确理解了这个公式。退一步考虑测试不变性是有帮助的：如果服务时间增加，节点的排名会降低吗？如果队列大小为0，那么排名是否如论文中所说的由响应时间决定?</p><p>关注不变性可以在许多常见情况下有所帮助：</p><ul><li>方法是否应该是顺序无关的？如果是，那么以不同的顺序传递输入数据应该产生相同的输出。</li><li>算法中的某个步骤是否产生类别概率？如果是，那么这些概率应该加起来等于1。</li><li>函数是否关于原点对称？如果是，那么改变输入的符号应该只是改变输出的符号。</li></ul><p>当我们最初实现 C3算法时，我们在公式中犯了一个错误，不小心用响应时间的倒数代替了响应时间。这意味着速度较慢的节点可能会被排名更高！在修复这个问题时，我们确保添加了<ahref="https://github.com/elastic/elasticsearch/pull/70283">不变性检查</a>，以防止未来的错误。</p><h3 id="与参考实现比较">2.2 与参考实现比较</h3><p>作者可能随论文一起发布了算法的实现。（如果论文包含实验，这种情况尤其可能，因为许多期刊要求作者发布代码以便重现结果。）你可以将你的方法与这个参考实现进行对比测试，以确保你没有遗漏算法的重要细节。</p><p>在开发 Lucene 的 HNSW实现用于最近邻搜索时，我们对比了论文作者提供的<ahref="https://issues.apache.org/jira/browse/LUCENE-9937">参考库</a>进行了测试。我们让Lucene和这个库都运行在同一个数据集上，比较了它们的结果准确性以及它们执行的计算次数。当这些数字非常接近时，我们知道Lucene 忠实地实现了该算法。</p><p>当将一个算法集成到系统中时，你通常需要进行修改或扩展，比如将其扩展到多个核心，或者添加启发式方法以提高性能。最好是首先实现一个“普通”版本，然后与参考实现进行对比测试，再进行增量式的更改。这样你可以确信在进行定制之前已经捕捉到了所有关键部分。</p><h3 id="与现有算法对决">2.3 与现有算法对决</h3><p>本小节提出了测试不变量的另一个想法：将算法的输出与更简单、更容易理解的算法的输出进行比较。以Lucene 中的 block-max WAND算法为例，该算法通过跳过不可能出现在顶部结果中的文档来加速文档检索。虽然很难精确描述block-max WAND在每种情况下应该如何表现，但我们确实知道应用它不应该改变顶部结果！因此，我们的测试可以生成几个随机搜索查询，然后分别在<ahref="https://github.com/apache/lucene/blob/main/lucene/core/src/test/org/apache/lucene/search/TestWANDScorer.java#L669">应用和不应用WAND 优化</a>的情况下运行它们，并检查它们的结果是否始终匹配。</p><p>这些测试的一个重要方面是它们<ahref="https://www.elastic.co/blog/elasticsearch-testing-qa-increasing-coverage-randomizing-test-runs">生成随机输入</a>来进行比较。这可以帮助测试到你可能没有想到的情况，并揭示出意外的问题。例如，Lucene的 BM25F 评分的随机比较测试帮助<ahref="https://issues.apache.org/jira/browse/LUCENE-10039">捕捉到了微妙边缘情况下的错误</a>。给算法提供随机输入的想法与模糊测试（<ahref="https://en.wikipedia.org/wiki/Fuzzing">fuzzing</a>）的概念密切相关，这是计算机安全中常用的一种测试技术。</p><p>Elasticsearch 和 Lucene经常使用这种测试方法。如果你看到一个测试提到了两种算法之间的“对决”（TestDuelingAnalyzers,testDuelTermsQuery...），那么你就知道这种策略正在发挥作用。</p><h2 id="使用论文的术语">3. 使用论文的术语</h2><p>当其他开发者使用你的代码时，他们需要查阅论文来理解其细节。Elasticsearch的 <ahref="https://github.com/elastic/elasticsearch/blob/4f22f437ee50cacb94b37b457be1da0b8ba0e8ce/server/src/main/java/org/elasticsearch/search/aggregations/metrics/HyperLogLogPlusPlus.java#L24-L39">HyperLogLog++实现中的注释</a>很好地说明了这一点：“试图在没有阅读论文的情况下理解这个类的功能被认为是冒险的。”这个方法注释也树立了一个好榜样。它包含了指向学术论文的链接，并突出显示了算法在原始描述中所做的修改。</p><p>由于开发者将基于论文来理解代码，因此使用与论文完全相同的术语是有帮助的。由于数学符号简洁，这可能导致一些通常不会被认为是“良好风格”的名称，但在论文的上下文中却非常清晰。学术论文中的公式是你在Elasticsearch 中遇到像 <ahref="https://github.com/elastic/elasticsearch/blob/4f22f437ee50cacb94b37b457be1da0b8ba0e8ce/server/src/main/java/org/elasticsearch/node/ResponseCollectorService.java#L151">rS和 muBarSInverse</a> 这样神秘变量名的少数情况之一。</p><h2 id="邮件联系论文作者">4. 邮件联系论文作者</h2><p>当你在研究一篇难懂的论文时，你可能会花费数小时去琢磨一个公式，不确定是自己理解错了还是论文中存在打字错误。如果是开源项目，你可以在GitHub或StackOverflow上提问。但对于学术论文，你可以向哪里求助呢？作者们似乎很忙，可能会被你的邮件惹恼。</p><p>相反，许多学者喜欢听到他们的想法被付诸实践，并乐于通过电子邮件回答问题。如果你在他们熟悉的产品上工作，他们甚至可能会在他们的网站上列出这个应用！</p><p>学术界也越来越多地使用软件开发中的许多相同工具来公开讨论论文。如果一篇论文附带了软件包，你可能会<ahref="https://github.com/facebookresearch/faiss/issues/1928">在 GitHub上找到关于常见问题的解答</a>。像“理论计算机科学”和“交叉验证”这样的 StackExchange 社区也包含了<ahref="https://cstheory.stackexchange.com/questions/49296/problem-in-the-paper-stable-minimum-space-partitioning-in-linear-time">关于热门论文的详细讨论</a>。一些会议也开始在线发布所有论文审稿意见。这些评审包含了<ahref="https://openreview.net/forum?id=H1eA7AEtvS">与作者的来回讨论</a>，可以揭示关于方法的有用见解。</p><h2 id="未完待续">5. 未完待续</h2><p>本文聚焦于选择学术论文并正确实施的基本要点，但并未涵盖实际部署算法的所有方面。例如，如果算法只是复杂系统中的一个组件，我们如何确保对组件的更改导致端到端的改进？如果整合算法需要大量修改或扩展，而这是原始论文没有涉及到的呢？这些都是我们希望在以后的文章中做更多分享的重要话题。</p>]]></content>
    
    
    <categories>
      
      <category>方法论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实现学术论文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 语言入门</title>
    <link href="/2024/01/08/Go-%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"/>
    <url>/2024/01/08/Go-%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>本文介绍学习 Go 语言一些学习材料，总结学习 Go时容易理解错误的一些概念，可用于已掌握 C++、Java等编程语言的程序员快速入门 Go。</p><h2 id="基础语法">1. 基础语法</h2><p>入门 Go 语言基础语法和关键语言概念的最佳材料是 Go语言官方提供的在线教程：</p><ul><li>英文版：<ahref="https://go.dev/tour/welcome/1">https://go.dev/tour/welcome/1</a></li><li>中文版：<ahref="https://tour.go-zh.org/welcome/1">https://tour.go-zh.org/welcome/1</a></li></ul><p>这一在线教程提供了文档+在线编程环境，可在浏览器中编辑和运行代码。同时，也穿插了一些小练习，能够在写代码中学习Go 语言。学习完该教程预估要几个小时，学习完后即可使用 Go语言编写自己的程序。</p><p>这一教程涵盖的内容大概包括：</p><ul><li>基本数据类型：<code>int</code>、<code>float64</code>、<code>string</code>等 Go语言支持的基本数据类型，以及定义变量、常量、函数内变量的语法等；</li><li>常用容器：包括 <code>slice</code>、<code>map</code>等数据结构，分别提供可变长数组、哈希等功能；</li><li>控制语句：<code>if</code> 、<code>for</code> 、<code>switch</code>等控制语句结构，尤其是 Go 语言提供的类似于<code>if expression; bool</code> 的语法；</li><li>函数与接口：Go语言中函数定义语法、多返回值、接口定义与实现、结构体方法等；</li><li>并发：介绍 Go语言提供的并发编程相关概念，包括：<code>goroutine</code>、<code>select</code>、<code>channel</code>等的使用。</li></ul><p>学习完这些内容后，该教程也指出了继续学习的方向，链接：<ahref="https://tour.go-zh.org/concurrency/11">https://tour.go-zh.org/concurrency/11</a>。</p><h2 id="值传递-or-引用传递">2. 值传递 or 引用传递？</h2><p>学习完 Go基础语法后，难免会遇到一个问题：为什么同样是语法上的以值传递，对<code>int</code> 等类型的修改不改变函数外参数；而对<code>map</code>、<code>slice</code>、<code>channel</code>的更改却会改变传递给函数的原参数。乍一看，这似乎类似于 Java语言中的机制：对基本类型以值传递；对对象类型引用传递。但是这一理解实际上是不对的，Go语言中只存在以值传递。看似 “引用传递” 实际上是 Go语言为了方便我们使用所做的一层隐藏或抽象。</p><p>对 Go 以值传递的介绍文章网上已有很多，这里贴两个链接供参考：</p><ul><li><ahref="https://zhuanlan.zhihu.com/p/542218435">Golang是值传递还是引用传递- 码农在新加坡的文章 - 知乎</a></li><li><a href="https://juejin.cn/post/7221730647043244090">【Go 进阶】Go语言到底是值传递，还是引用传递？</a></li></ul><p>简单来说就是：</p><ul><li>Go 语言函数传参只存在以值传递；</li><li><code>map</code>、<code>channel</code>等语言提供的功能，其本质上是调用 <code>make_xxx</code>函数并返回指针类型，语言隐藏了其实际上是指针的事实，从而方便程序员使用；</li><li><code>slice</code>更为特殊，其本质上是一个结构体，内部含有指向堆内存的指针，因此函数传递<code>slice</code>时，需要做结构体拷贝，但是由于指针实际上指向堆内存，通过下标访问<code>arr[i]</code> 并进行更改时，更改也对函数体外的原<code>slice</code> 可见。</li></ul><h2 id="并发编程">3. 并发编程</h2><p>Go 语言提供的 <code>goroutine</code> 和 <code>channel</code>提供了一种抽象层级更高的并发编程模型，而不是传统的面向锁、条件变量等的并发编程。个人认为，初次学习Go的并发编程时还是比较难理解的，尤其是思维方式的转变，从习惯的：共享数据结构（内存）+锁的并发编程，转向Go 语言的：如何定义消息和划分读写 <code>channel</code> 功能，以使用<code>goroutine</code> 和 <code>channel</code>进行并发编程。这是完全两种不同的思考方式，需要花费一定时间来转换。这里提供一些可参考的资料以学习Go 并发编程的惯用法：</p><ul><li><a href="https://www.youtube.com/watch?v=f6kdp27TYZs">Go并发模型</a>(<ahref="https://talks.go-zh.org/2012/concurrency.slide">幻灯片</a>) ：Go语言设计者之一关于 Go 并发编程模式的演讲视频；</li><li><a href="https://www.youtube.com/watch?v=QDDwwePbDtw">深入 Go并发模型</a>(<ahref="https://talks.go-zh.org/2013/advconc.slide">幻灯片</a>) ：Google的另一关于 Go 并发编程的演讲视频；</li><li><a href="https://go-zh.org/doc/codewalk/sharemem/">Codewalk:通过通信共享内存</a> ：通过通信来共享内存示例；</li><li><ahref="https://github.com/lotusirous/go-concurrency-patterns">lotusirous/go-concurrency-patterns:Concurrency patterns in Go (github.com)</a> ：收集了常用 Go并发编程模式的 GitHub 仓库。</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DB 论文阅读：Hierarchical Navigable Small World</title>
    <link href="/2024/01/03/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AHierarchical-Navigable-Small-World/"/>
    <url>/2024/01/03/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AHierarchical-Navigable-Small-World/</url>
    
    <content type="html"><![CDATA[<p>本文介绍向量近似最近邻（Approximate NearestNeighbor，ANN）的另一经典算法：HNSW（Hierarchical Navigable SmallWorld，HNSW）。HNSW 工业界使用最多的 ANN 算法之一，得到了Milvus、Elasticsearch、Fasis、pgvector 等系统或库的广泛支持。原文： <ahref="https://arxiv.org/ftp/arxiv/papers/1603/1603.09320.pdf">Efficientand robust approximate nearest neighbor search using HierarchicalNavigable Small World graphs</a> 。</p><p><strong>摘要</strong></p><p>本文提出了一种具有可控层次的基于可导航小世界图的近似 k近邻算法。所提出的解决方案完全基于图而无需任何额外的搜索结构，这些结构通常用于大多数邻近图技术的粗搜索阶段。HNSW逐步构建一个多层结构，由嵌套的接近图集合（层）组成，用于存储元素的子集。元素所在的最大层数是随机选择的，遵循指数衰减的概率分布。这允许生成类似于之前研究的可导航小世界（NSW）结构的图，同时额外具有按其特征距离尺度分离的连接。与NSW 相比，HNSW从上层开始搜索并利用尺度分离可以提高性能，实现对数复杂度。额在高召回率和高度聚集的数据情况下，使用启发式方法选择邻近图近邻显著提高了性能。性能评估表明，所提出的通用度量空间搜索索引能够明显优于之前开源的仅用于向量空间的方法。该索引结构与跳表相似，允许直接、平衡的分布式实现。</p><h2 id="动机">1. 动机</h2><p>由于 HNSW 是 NSW 的改进，因此首先需要分析 NSW 有什么问题。</p><p>NSW 在进行 ANN搜索时，采用贪心策略从一个节点跳转到下一个距离最近的邻居节点，这一寻找下一个节点的过程称为“路由”，和网络中的路由概念类似。NSW的贪心搜索算法可以分为两个阶段，即：</p><ul><li>zoom-out</li><li>zoom-in</li></ul><p>搜索算法的起始阶段是 zoom-out，从一个低度节点开始遍历图，直到：thecharacteristic radius of the node links length reaches the scale of thedistance to thequery。这句英文很关键，但是不太好翻译，不过其表达的意思就是：随着搜索过程的进行，从当前节点到其邻居节点的连接长度（即特征半径，characteristicradius）降低到与查询点到这些邻居节点的距离相当的程度。也即，当搜索过程中节点的连接长度降低到与查询点到这些节点的距离相近时，搜索算法会遇到问题，因为它可能会陷入到一个局部最小值，而不是继续向更远的节点扩展搜索范围。</p><p>这一问题可以通过直接从度数最大的顶点开始搜索解决，直接进入 zoom-in阶段。尽管在低维空间中，这样设置提供了更好的性能，但是 NSW查询算法仍然是 <span class="math inline">\(\log^{p}\)</span>（polylogarithmic，严谨定义参考：<ahref="https://en.wikipedia.org/wiki/Polylogarithmic_function">Polylogarithmicfunction</a> ）复杂度，即对数的次幂复杂度。</p><p>NSW 查询算法之所以是 <span class="math inline">\(\log^{p}\)</span>复杂度，是因为总的距离计算数大致与贪婪算法步数（跳数）的平均值乘以贪婪路径上节点度数（度数）的平均值成比例。平均跳数随数据集规模呈对数增长，平均度数也随数据集规模呈对数增长。因此，最终的算法复杂度是<span class="math inline">\(\log^{p}\)</span> 。</p><p>HNSW算法的思想是根据连接的长度尺度将连接分到不同层，然后在多层图上进行搜索。在这种情况下，我们可以独立于网络大小，仅评估每个元素所需的固定部分的连接，从而实现对数复杂度。在该数据结构中，查询从仅具有最长连接的最上层开始（zoom-in阶段）。算法贪婪地从上层遍历元素，直到达到局部最小值。之后，搜索切换到下一层（该层的连接较短），从上一层中的局部最小元素重新开始，然后重复这个过程。在所有层中，每个元素的最大连接数可以保持恒定，从而允许在可导航小世界网络中进行对数复杂度的路由扩展。搜索过程如下图所示：</p><center><img src="/2024/01/03/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AHierarchical-Navigable-Small-World/image-20240103170648753.png" class="" title="Illustration of the HNSW idea."></center><p>形成这种分层结构的一种方法是通过引入层来明确设置具有不同长度尺度的连接。对于每个元素，我们选择一个整数层级<spanclass="math inline">\(l\)</span>，该层级定义了元素所属的最大层。对于一个层中的所有元素，会逐步构建一个近似Delaunay 图的邻近图（即只包含“短”连接的图）。如果我们设置 <spanclass="math inline">\(l\)</span>的指数衰减概率（即遵循几何分布），我们将得到结构中预期层数的对数缩放。搜索过程是一个从顶层开始，以零层结束的迭代贪婪搜索。</p><p>如果我们将所有层的连接合并，结构就会变得类似于 NSW图（在这种情况下，<span class="math inline">\(l\)</span> 可以与 NSW中的节点度数相对应）。与 NSW 不同的是，HNSW的构建算法不需要在插入元素之前对元素进行洗牌——随机性是通过使用层级随机化来实现的，从而允许在数据分布暂时变化的情况下进行真正的增量索引（尽管由于构建过程只是部分确定性的，插入顺序的改变会轻微影响性能）。</p><p>在元素插入过程中，为了选择邻近图的连接，我们利用一种启发式方法，该方法考虑了候选元素之间的距离以创建多样化的连接，而不仅仅是选择最近的邻居。这种启发式方法从距离插入元素最近的候选元素开始检查，并仅当候选元素比任何已连接的候选元素更接近基础（插入的）元素时，才创建到该候选元素的连接。</p><p>当候选元素的数量足够大时，启发式方法允许获取精确的相对邻域图作为子图，这是一个仅使用节点间距离就可以推导出的Delaunay图的最小子图。相对邻域图允许即使在高度聚类的数据情况下也能轻松保持全局连接。如下图所示：</p><center><img src="/2024/01/03/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AHierarchical-Navigable-Small-World/image-20240103194034338.png" class="" title="Illustration of the heuristic used to select the graph neighbors  for  two  isolated  clusters."></center><p>注意，与精确的相对邻域图相比，启发式方法创建了额外的边，允许控制连接的数量，这对于搜索性能很重要。对于一维数据的情况，启发式方法允许通过仅使用元素间距离信息来获取精确的Delaunay 子图（在这种情况下与相对邻域图重合），从而使得从 HNSW直接过渡到一维概率跳表成为可能。</p><h2 id="算法描述">2. 算法描述</h2><h3 id="insert算法">2.1 INSERT算法</h3><p>插入算法伪代码如下：</p><center><img src="/2024/01/03/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AHierarchical-Navigable-Small-World/image-20240103195220090.png" class="" title="INSERT"></center><p>各个参数含义如下：</p><ul><li><span class="math inline">\(hnsw\)</span> ：HNSW 索引数据结构</li><li><span class="math inline">\(q\)</span> ：插入向量</li><li><span class="math inline">\(M\)</span> ：建立连接的数量</li><li><span class="math inline">\(M_{max}\)</span>：每层每个元素的最大连接数</li><li><span class="math inline">\(efConstruction\)</span>：动态候选列表的大小</li><li><span class="math inline">\(m_{L}\)</span>：用于层级生成的标准化因子</li></ul><p>算法主要执行流程如下：</p><ol type="1"><li>从顶层开始使用贪心算法遍历图，以找到该层距离插入元素 <spanclass="math inline">\(q\)</span> 最近的进入点 <spanclass="math inline">\(ep\)</span> ；</li><li>使用从前一层找到的最近邻作为进入点，继续从下一层搜索，并重复该过程。直到搜索到达小于等于<span class="math inline">\(l\)</span> 的层，插入算法进入第二阶段；</li><li>依次在剩余层，调用 <code>SEARCH-LAYER</code>函数获取候选列表，从候选列表中选择 <spanclass="math inline">\(M\)</span> 个邻居，可使用算法 3 或 算法 4；</li><li>当插入元件的连接在零层上建立时，插入过程终止。</li></ol><p>注意，第二阶段中调用的 <code>SEARCH-LAYER</code>函数相比第一阶段有以下不同：</p><ul><li><code>SEARCH-LAYER</code> 函数中的参数 <spanclass="math inline">\(ef\)</span> 从 1 改变为 <spanclass="math inline">\(efConstruction\)</span>，以控制贪心搜索的召回率；</li><li>在每一层上找到的最近邻也被用作插入元素连接的候选者。</li></ul><h3 id="search-layer-算法">2.2 SEARCH-LAYER 算法</h3><p>插入算法中用到的 <code>SEARCH-LAYER</code> 算法伪代码如下：</p><center><img src="/2024/01/03/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AHierarchical-Navigable-Small-World/image-20240103201014963.png" class="" title="SEARCH-LAYER"></center><p>参数含义如下：</p><ul><li><span class="math inline">\(q\)</span> ：查询元素</li><li><span class="math inline">\(ep\)</span> ：进入点</li><li><span class="math inline">\(ef\)</span> ：距离 <spanclass="math inline">\(q\)</span> 最近的元素数量，即 k 近邻中的 k</li><li><span class="math inline">\(l_{c}\)</span> ：层数</li></ul><p>该算法是 NSW 中贪心查询算法的改进，其与 NSW中查询算法不同点在于：</p><ul><li>进入点是固定的</li><li>搜索的质量是由一个不同的参数 <span class="math inline">\(ef\)</span>控制，而不是 NSW 的改变多重搜索的数量</li></ul><h3 id="select-neighbors-simple-算法">2.3 SELECT-NEIGHBORS-SIMPLE算法</h3><p>算法伪代码描述如下：</p><center><img src="/2024/01/03/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AHierarchical-Navigable-Small-World/image-20240103203613228.png" class="" title="SELECT-NEIGHBORS-SIMPLE"></center><p>该算法非常简单，参数及流程不再介绍。</p><h3 id="select-neighbors-heuristic-算法">2.4 SELECT-NEIGHBORS-HEURISTIC算法</h3><p>算法伪代码描述如下：</p><center><img src="/2024/01/03/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AHierarchical-Navigable-Small-World/image-20240103203653389.png" class="" title="SELECT-NEIGHBORS-HEURISTIC"></center><p>启发式算法的两个额外参数含义如下：</p><ul><li><span class="math inline">\(extendCandidates\)</span>：用于标识是否扩展候选集合的 <code>bool</code>值，仅对极度聚集的数据有用</li><li><span class="math inline">\(keepPrunedConnections\)</span>：标识每个元素是否使用固定数量的连接</li></ul><p>每层元素所能拥有的最大连接数由参数 <spanclass="math inline">\(M\)</span> 确定（最底层需额外参数 <spanclass="math inline">\(M_{max0}\)</span>单独指定）。如果一个节点在建立新连接时已经满了，那么它的扩展连接列表将通过用于选择邻居的相同算法进行缩减。</p><h3 id="k-nn-search-算法">2.5 K-NN-SEARCH 算法</h3><p>近似 k-ANN 查询算法伪代码如下：</p><center><img src="/2024/01/03/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AHierarchical-Navigable-Small-World/image-20240103205242367.png" class="" title="K-NN-SEARCH"></center><p>查询算法类似于 <span class="math inline">\(l = 0\)</span>的插入算法，与插入的不同之处在于在最底层找到的最近邻居(用作连接的候选者)现在作为搜索结果返回。查询质量由参数<span class="math inline">\(ef\)</span> 控制。</p><h3 id="构造参数的影响">2.6 构造参数的影响</h3><p>参数 <span class="math inline">\(m_{L}\)</span> 和 <spanclass="math inline">\(m_{max0}\)</span>用于维持图的可导航小世界属性，当对这两个参数设置不同值时得到具有不同特性的图：</p><ul><li><span class="math inline">\(m_{L} = 0, m_{max0} = M\)</span>时，产生有向 K-NN 图</li><li><span class="math inline">\(m_{L} = 0, m_{max0} = \infty\)</span>时，等价于 NSW</li><li><span class="math inline">\(m_{L} \gt 0\)</span> 时，HNSW</li></ul><p>为了实现可控层次结构的最佳性能优势，不同层之间邻居之间的重叠（即元素邻居中也属于其他层的比例）必须小。这需要减小参数<span class="math inline">\(m_{L}\)</span> ，但同时，减小 <spanclass="math inline">\(m_{L}\)</span>会增加每层贪婪搜索的平均跳数，给性能带来负面影响。因此，存在一个最优的<span class="math inline">\(m_L\)</span> 值。一个简单的最优 <spanclass="math inline">\(m_L\)</span> 选择是 <spanclass="math inline">\(1/\ln(M)\)</span>，这对应于跳表参数 <spanclass="math inline">\(p=1/M\)</span>，其中层之间有平均单个元素的重叠。</p><p>通过模拟实验，作者发现在低维数据上增加 <spanclass="math inline">\(m_L\)</span>会导致显著的性能提升，而在高维数据上，增加 <spanclass="math inline">\(m_L\)</span>的效果则不那么明显。此外，使用启发式方法选择图连接（而不是简单地连接到最近的邻居）可以显著提高性能，尤其是在低维数据、高召回率、中维数据和高度聚类数据的情况下。</p><p><span class="math inline">\(M_{max0}\)</span>参数也会显著影响搜索性能，尤其是在高召回率的情况下。作者通过模拟，推荐设置<span class="math inline">\(M_{max0} = 2 \times M\)</span> 。</p><p>参数 <span class="math inline">\(M\)</span> 的合理范围是 <spanclass="math inline">\([5, 48]\)</span> 。模拟表明较小的 <spanclass="math inline">\(M\)</span> 适用于较低的召回率 和/或低维数据；较大的 <span class="math inline">\(M\)</span> 适用于高召回率和/或 高维数据。该参数还影响占用的存储大小。</p><p><span class="math inline">\(efConstruction\)</span>参数值的选择比较直接。正如在 NSW中所建议的那样，它必须足够大，以便在构建过程中产生接近 1 的 K-ANNS召回(0.95对于大多数用例来说已经足够了)。这一参数可通过采样数据自动设置。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>读论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>近似最近邻</tag>
      
      <tag>ANN</tag>
      
      <tag>向量相似度检索</tag>
      
      <tag>K近邻</tag>
      
      <tag>索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DB 论文阅读：Approximate nearest neighbor algorithm based on navigable small world graphs</title>
    <link href="/2023/12/29/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AApproximate-nearest-neighbor-algorithm-based-on-navigable-small-world-graphs/"/>
    <url>/2023/12/29/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AApproximate-nearest-neighbor-algorithm-based-on-navigable-small-world-graphs/</url>
    
    <content type="html"><![CDATA[<p>本文介绍向量近似最近邻（Approximate NearestNeighbor，ANN）的一种经典算法：NSW（Navigable Small World，NSW），原文：<ahref="https://www.researchgate.net/profile/Yu-Malkov/publication/259126397_Approximate_nearest_neighbor_algorithm_based_on_navigable_small_world_graphs/links/63733c302f4bca7fd06030b8/Approximate-nearest-neighbor-algorithm-based-on-navigable-small-world-graphs.pdf">Approximatenearest neighbor algorithm based on navigable small world graphs</a>。</p><p><strong>摘要</strong></p><p>NSW 是一种用于度量空间的近似 K近邻算法。该算法基于图，每个向量构成顶点，向量之间的连接构成边。使用一种贪心算法的变体来进行K 近邻查询操作；插入算法基于查询操作并连接边。插入和查询操作时间复杂度为<spanclass="math inline">\({\log}^{2}(n)\)</span>。查询和插入操作可并行执行，且该索引数据结构可分布式。无需调整索引结构即可改变K 近邻查询正确性的概率。</p><h2 id="核心思想">1. 核心思想</h2><p>索引结构是一个可导航小世界图 <span class="math inline">\(G = (V,E)\)</span> ，向量集合 <span class="math inline">\(X\)</span>中的每个元素一一映射到顶点集合 <span class="math inline">\(V\)</span>。边集 <span class="math inline">\(E\)</span> 由索引构造算法决定。</p><p>相关名词含义：</p><ul><li>朋友（friends）：共享某条边的顶点集</li><li>顶点 <span class="math inline">\(v_i\)</span> 的朋友列表：与顶点<span class="math inline">\(v_i\)</span> 共享一条边的顶点列表</li></ul><p>图中的边有两个目的：</p><ul><li>部分边是短程连接，用来作为 Delaunay图的近似，以使用贪心搜索算法；</li><li>其余边是长程连接，用于实现对数级别复杂度的贪婪搜索。长程连负责构建图的可导航小世界属性。</li></ul><p>数据结构示意图如下：</p><center><img src="/2023/12/29/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AApproximate-nearest-neighbor-algorithm-based-on-navigable-small-world-graphs/image-20231229161552498.png" class="" title="数据结构示意图"></center><p>其中，蓝色圆表示图中顶点（数据集向量），绿色圆表示查询向量，黑色边是Delaunay 图的近似（短程连接），红色边是长程连接。箭头表示从进入点（entrypoint）的一个贪心搜索过程。</p><p>数据结构由顶点的逐个插入形成。对于每个新加入的元素，从结构中找到其最接近的邻居集合（Delaunay图的近似）。这个集合与插入元素相互连接。随着越来越多的元素被插入到结构中，之前作为短程连接的连接现在变成了长程连接，从而形成了一个可导航小世界图。</p><h2 id="查询算法">2. 查询算法</h2><h3 id="基本贪心查询算法">2.1 基本贪心查询算法</h3><p>该小节的算法用于近似最近邻查询，即只返回 1个查询结果。算法伪代码如下：</p><center><img src="/2023/12/29/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AApproximate-nearest-neighbor-algorithm-based-on-navigable-small-world-graphs/image-20231229163003622.png" class="" title="基本贪心查询算法"></center><p>算法接收两个参数：</p><ul><li><span class="math inline">\(q\)</span> ：表示查询向量</li><li><span class="math inline">\(v_{entry\_point}\)</span>：表示查询起始顶点，且 <span class="math inline">\(v_{entry\_point} \inV\)</span> ，即 <span class="math inline">\(v_{entry\_point}\)</span>是顶点集合 <span class="math inline">\(V\)</span> 的一个元素。</li></ul><p>执行流程如下：</p><p>从入口点开始，算法计算查询 <span class="math inline">\(q\)</span>到当前顶点的好友列表中每个顶点的距离，然后选择距离最小的顶点。如果查询与所选顶点之间的距离小于查询与当前元素之间的距离，那么算法会移动到所选顶点，它成为新的当前顶点。当算法达到一个局部最小值时停止，即：其好友列表中没有比该顶点更接近查询<span class="math inline">\(q\)</span> 的顶点。</p><p>注意，该算法并不保证返回最近邻结果，而是返回近似最近邻。</p><h3 id="k-近邻查询">2.2 K 近邻查询</h3><p>近似 K 近邻查询算法伪代码如下：</p><center><img src="/2023/12/29/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AApproximate-nearest-neighbor-algorithm-based-on-navigable-small-world-graphs/image-20231229164309519.png" class="" title="近似 K 近邻查询算法"><img src="/2023/12/29/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AApproximate-nearest-neighbor-algorithm-based-on-navigable-small-world-graphs/image-20231229164334787.png" class="" title="近似 K 近邻查询算法"></center><p>算法参数含义：</p><ul><li><span class="math inline">\(q\)</span> ：表示查询向量</li><li><span class="math inline">\(k\)</span> ：即 k 近邻</li><li><span class="math inline">\(m\)</span>：重复进行 <spanclass="math inline">\(m\)</span> 循环体</li></ul><p>伪代码中一些变量含义解释如下：</p><ul><li>创建一个<code>TreeSet</code>对象<code>tempRes</code>，用于存储临时结果。</li><li>创建一个<code>TreeSet</code>对象<code>candidates</code>，用于存储当前考虑的候选顶点。</li><li>创建一个<code>TreeSet</code>对象<code>visitedSet</code>，用于记录已访问过的顶点，以避免重复访问。</li><li>创建一个列表<code>result</code>，用于存储最终的 k 个最近邻居。</li></ul><p>算法主体中，外层循环即进行 <span class="math inline">\(m\)</span>次查询，以提高查询精度；内层循环对集合 <code>candidates</code>进行动态插入及遍历，直到满足 break 条件或遍历完 <code>candidates</code>结束内层循环。</p><h2 id="插入算法">3. 插入算法</h2><p>插入算法伪代码如下：</p><center><img src="/2023/12/29/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AApproximate-nearest-neighbor-algorithm-based-on-navigable-small-world-graphs/image-20231229171153499.png" class="" title="插入算法"></center><p>参数含义：</p><ul><li><span class="math inline">\(new\_object\)</span> ：插入元素</li><li><span class="math inline">\(f\)</span> ：表示进行 k 近邻查询时的参数k</li><li><span class="math inline">\(w\)</span>：表示调用<code>k-NNSearch</code> 算法时的参数 <spanclass="math inline">\(m\)</span></li></ul><p>该算法首先调用 <code>k-NNSearch</code> 返回近似 k近邻结果，然后将插入元素与近似最近邻结果互相连接边。从伪代码中也可以看出索引结构是无向图。</p><h3 id="参数选择">3.1 参数选择</h3><p>参数 <span class="math inline">\(w\)</span>决定了在构建算法中确定最近邻居的准确性（召回率）。作者建议设置足够大的<span class="math inline">\(w\)</span> ，以让召回率接近1（如：0.95~0.99）。小的召回率会增加错误连接的比例，这只会提高算法的复杂性，而实验表明，插入时召回率超过0.99 对搜索质量没有可测量的影响。测试还显示，对于最佳召回率，<spanclass="math inline">\(w\)</span>随着数据集大小的变化缓慢（对数）变化，因此，如果我们已经知道一个好的召回率的近似值<span class="math inline">\(w0\)</span>，我们可以首先使用大得多的 <spanclass="math inline">\(m\)</span>（例如，<span class="math inline">\(m =2\times w0 + 10\)</span>），假设 <span class="math inline">\(m\)</span>足够大，使得搜索结果真正是最近的 k 个邻居，然后增加 <spanclass="math inline">\(w\)</span>，并重复测试，直到达到一个高召回率（如：0.95~0.99）。操作的复杂度与数据集大小成对数关系，因此它不影响整体构建复杂度。</p><p>参数 <span class="math inline">\(f\)</span>决定了在插入新元素时，与新元素连接的最近邻居的数量。测试结果显示，对于维度在1~20 的欧式空间数据，<span class="math inline">\(f\)</span>的值应该大约是维度 <span class="math inline">\(d\)</span> 的 3倍，这样可以保持内存消耗与维度线性增长，同时保持较高的搜索召回率。小的<span class="math inline">\(f\)</span>能够减少单次搜索的复杂度，但是牺牲了召回质量。</p><h2 id="总结与问题">4. 总结与问题</h2><p>以上就是对 NSW关键的查询、插入算法的介绍。实验部分请参考原论文。在原论文中，作者还提出了可改进的方向，以降低复杂度和/或提高准确性：</p><ul><li><strong>更复杂的节点朋友选择算法</strong>：选择最近的邻居作为朋友并不是近似Delaunay图的最佳方法，因为这种方法只考虑了新元素与候选节点之间的距离，而忽略了候选节点之间的距离。</li><li><strong>更复杂的可导航小世界创建算法</strong></li><li><strong>更有效地管理多个搜索</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>读论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>近似最近邻</tag>
      
      <tag>ANN</tag>
      
      <tag>向量相似度检索</tag>
      
      <tag>K近邻</tag>
      
      <tag>索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DB 论文阅读：A Relational Model of Data for Large Shared Data Banks</title>
    <link href="/2023/12/25/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AA-Relational-Model-of-Data-for-Large-Shared-Data-Banks/"/>
    <url>/2023/12/25/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AA-Relational-Model-of-Data-for-Large-Shared-Data-Banks/</url>
    
    <content type="html"><![CDATA[<p>关系模型是现代数据库的理论基础。1969 和 1970 年，Codd 的两篇论文《Derivability, Redundancy and Consistency of Relations Stored in LargeData Banks》和《A Relational Model of Data for Large Shared DataBanks》提出了关系模型理论，为后续几十年数据库领域的发展提供了基础。</p><p>由于 1969 年的论文实际上就是《A Relational Model of Data for LargeShared Data Banks》的非正式版本，二者内容基本一致，所以本文仅介绍 1970年发表在 <em>Communications of the ACM</em> 上的正式论文《A RelationalModel of Data for Large Shared Data Banks》。</p><h2 id="背景介绍">1. 背景介绍</h2><p>要想理解关系模型为什么被提出，首先需要了解论文发表时的时代背景。</p><p>当时的数据库系统大多采用树形或网状结构，应用程序与数据库的物理存储结构紧密耦合，应用程序的开发者必须知道数据库中数据的物理存储结构，并在应用程序中实现相关逻辑进行数据访问。一旦数据库的物理存储结构发生变化，那么应用程序的相关代码也必须进行相应的改变。</p><p>这种应用和数据库紧密耦合的问题在论文中被统称为 “DataDependencies”，具体地，有以下 3 种迫切需要移除的数据依赖：</p><ul><li><p><strong>Ordering Dependence</strong></p><p>排序依赖指在某些系统中，数据元素的存储方式与硬件确定的地址顺序紧密相关。例如，一个存储零件记录的文件可能按照零件序列号升序存储。这些系统允许应用程序员假设记录的展示顺序与物理存储顺序一致。应用程序可能依赖于这一假设实现，这导致当需要更换物理存储顺序时，依赖于存储顺序的应用程序可能无法正确运行。</p></li><li><p><strong>Indexing Dependence</strong></p><p>索引通常被视为数据表示的性能导向组件，它通常能提高对查询和更新的响应，同时可能会减慢插入和删除操作的响应。从信息角度来看，索引是数据表示的冗余部分。索引依赖指应用程序和终端活动能否在索引的创建和销毁过程中保持不变，也即索引存在与否不影响应用的正常运行。</p></li><li><p><strong>Access Path Dependence</strong></p><p>访问路径依赖指许多现有的格式化数据系统为用户提供了树状文件或更一般的网络模型的数据。为这些系统开发的应用程序在树或网络结构发生变化时，逻辑上可能会受损。</p></li></ul><h2 id="关系模型">2. 关系模型</h2><p>为了解决已有系统的问题，Codd提出了关系模型，将数据的表示和数据的存储解耦。关系模型仅描述数据的逻辑结构，而不限制数据的物理存储结构。</p><h3 id="概念">2.1 概念</h3><p>在原论文中，关系是使用集合和笛卡尔积严格定义的：</p><p>给定集合 <span class="math inline">\(S_1, S_2, …, S_n\)</span>，<span class="math inline">\(R\)</span> 是 <spanclass="math inline">\(n\)</span> 个集合上的关系，如果 <spanclass="math inline">\(R\)</span> 是 <spanclass="math inline">\(n\)</span>元元组的集合，且元组的第一个元素来自集合 <spanclass="math inline">\(S_1\)</span> ，元组的第二个元素来自 <spanclass="math inline">\(S_2\)</span>，……，以此类推。用更简洁的形式表述，也就是 <spanclass="math inline">\(R\)</span> 是 <span class="math inline">\(S_1\times S_2 \times … \times S_n\)</span> 的子集。</p><p>据此，可以引出我们已经非常熟悉的概念，如：元组、表、列等等，在此不再介绍。</p><p>关系型模型的优点在于提供了一种描述数据的自然结构的方式，即只描述数据本身，而不涉及机器表示的额外结构。这为高级数据语言提供了基础，并有助于清晰评估当前格式化数据系统的逻辑限制。</p><h3 id="正规形式">2.2 正规形式</h3><p>2.1小节定义的关系允许含有非简单域，也就是允许某个列也是关系。当关系中含有非简单域时，需要更复杂的数据结构来存储。为了降低存储复杂度，可以将关系进行规范化。</p><p>Codd提出了一种称为规范化（Normalization）的过程，该过程从树状结构的顶部关系开始，通过插入父关系的主键来扩展每个直接下级关系。然后从父关系中删除所有非简单域，移除树的顶部节点，并在剩余的子树上重复这个过程。为了使规范化过程适用，非规范化的关系集合必须满足两个条件：非简单域之间的相互关系图必须是一系列树，且没有任何主键包含非简单域的组成部分。</p><p>原论文的例子可以帮助理解：</p><center><img src="/2023/12/25/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AA-Relational-Model-of-Data-for-Large-Shared-Data-Banks/image-20231225204945313.png" class="" title="关系的树形依赖结构"></center><center><img src="/2023/12/25/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AA-Relational-Model-of-Data-for-Large-Shared-Data-Banks/image-20231225204927954.png" class="" title="原始关系与规范化后关系"></center><h3 id="关系的操作">2.3 关系的操作</h3><p>此小节实际上就是关系代数的内容，讨论了如何使用运算符及运算符的组合对关系进行运算。</p><p>对关系代数的介绍可参考： <ahref="https://arcsin2.cloud/2023/09/05/%E4%BB%8E%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0%E5%88%B0-SQL/">从关系代数到SQL</a> ，本文不再介绍。</p><h3 id="冗余性">2.4 冗余性</h3><p>本小节讨论了数据库中数据冗余的概念，以及如何通过关系型数据模型来管理和减少冗余。</p><p>首先需要引入定义 <spanclass="math inline">\(θ\)</span>-<em>derivable</em> ：</p><p>给定关系的操作集合 <span class="math inline">\(\theta\)</span>，如果存在来自 <span class="math inline">\(\theta\)</span>的操作序列，能够从关系集合 <span class="math inline">\(S\)</span>中经过这些操作产生关系 <span class="math inline">\(R\)</span> ，则称<span class="math inline">\(R\)</span> 是可从 <spanclass="math inline">\(S\)</span> 中 <spanclass="math inline">\(θ\)</span>-<em>derivable</em> 的。</p><p>在此基础上引出强冗余性和弱冗余性的定义。</p><ul><li><p><strong>强冗余性</strong></p><p>当关系集中至少有一个关系可以通过其他关系的投影推导出来时，就存在强冗余。这意味着关系集中存在不必要的重复数据，一般需要重新设计关系模式以消除冗余。</p></li><li><p><strong>弱冗余性</strong></p><p>当关系集中存在一个关系，其投影不是从其他关系推导出来的，但始终是其他关系投影的某个连接的投影时，就存在弱冗余。这种冗余是固有的，通常与用户社区的逻辑需求相关，一般不需要消除。</p></li></ul><h3 id="一致性">2.5 一致性</h3><p>在本小节中，Codd 定义了数据一致性的概念，即在给定的一组关系（<spanclass="math inline">\(C\)</span>）、一组约束声明（<spanclass="math inline">\(Z\)</span>）和关系集的即时值（<spanclass="math inline">\(V\)</span>）的情况下，如果 <spanclass="math inline">\(V\)</span> 满足 <spanclass="math inline">\(Z\)</span> ，则称状态 （<spanclass="math inline">\(C, Z, V\)</span>） 是一致的，否则是不一致的。</p><p>为了保持系统的一致性，可在插入、删除或更新操作时检查可能的不一致性，以及定期进行一致性检查。</p><h2 id="总结">3. 总结</h2><p>以上就是对论文 《A Relational Model of Data for Large Shared DataBanks》主要内容的总结。本文章节与原论文章节并非一一对应，而是重新进行了组织，同时删除了个人认为不影响理解论文核心内容的章节，如原论文1.5 和 1.6 小节等，具体请参阅原论文。</p><p><br></p><p><br></p><p><strong>参考：</strong></p><ol type="1"><li><ahref="https://technology.amis.nl/wp-content/uploads/images/RJ599.pdf">Derivability,Redundancy and Consistency of Relations Stored in Large DataBanks</a></li><li><ahref="https://www.db.dobo.sk/wp-content/uploads/2015/11/Codd_1970_A_relational_model.pdf">ARelational Model of Data for Large Shared Data Banks</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>读论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>关系模型</tag>
      
      <tag>关系代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从关系代数到 SQL</title>
    <link href="/2023/09/05/%E4%BB%8E%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0%E5%88%B0-SQL/"/>
    <url>/2023/09/05/%E4%BB%8E%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0%E5%88%B0-SQL/</url>
    
    <content type="html"><![CDATA[<p>关系模型与关系代数是关系型数据库系统的基础，SQL是用户与数据库系统交互的媒介。本文简要介绍关系模型与关系代数的基本内容，从展示关系代数在SQL 中的对应语句。</p><h2 id="关系模型">1. 关系模型</h2><p>关系模型是对数据库系统的抽象，其用 “关系”来表示数据库，而隐藏数据在数据库系统内部是如何组织的。关系模型的核心原则是：</p><ul><li>以简单的数据结构(关系)存储数据库。</li><li>物理存储结构由 DBMS 实现决定。</li><li>通过高级语言访问数据，DBMS 负责找到最好的执行策略。</li></ul><p>关系模型具有几个关键概念：</p><ul><li>关系（relation）：关系是包含表示实体的属性关系的无序集合。</li><li>元组（tuple）：元组是关系中的一组属性值。</li></ul><h2 id="关系代数">2. 关系代数</h2><p>关系代数是用于操作关系模型的工具，以在数据库中进行查询等操作。关系代数的每个操作符接受一个或多个关系作为其输入，并输出一个新的关系。关系代数运算符根据输入的关系数量可分为单目运算符和双目运算符。最常用的操作有：</p><ul><li>选择（Select）：<span class="math inline">\(\sigma\)</span></li><li>投影（Projection）：<span class="math inline">\(\Pi\)</span></li><li>并集（Union）：<span class="math inline">\(\cup\)</span></li><li>交集（Intersection）：<span class="math inline">\(\cap\)</span></li><li>差集（Difference）：<span class="math inline">\(-\)</span></li><li>笛卡尔积（Product）：<spanclass="math inline">\(\times\)</span></li><li>连接（Join）：<span class="math inline">\(\bowtie\)</span></li><li>……</li></ul><h3 id="选择">2.1 选择</h3><p>含义：从关系中选择满足选择谓词的元组。谓词用来充当过滤器，仅保留满足谓词条件的元组。可以使用合取/析取合并多个谓词。</p><p>语法：<spanclass="math inline">\(\sigma_{predicate}(\text{R})\)</span></p><p>例子：<span class="math inline">\(\sigma_{{\text{a}\_\text{id}=\text{&#39;a2 &#39;}} \wedge {\text{ b}\_\text{id}&gt; \text{102}}}(\text{R})\)</span></p><p>SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> R<br><span class="hljs-keyword">WHERE</span> a_id<span class="hljs-operator">=</span><span class="hljs-string">&#x27;a2&#x27;</span> <span class="hljs-keyword">AND</span> b_id<span class="hljs-operator">&gt;</span><span class="hljs-number">102</span>;<br></code></pre></td></tr></table></figure><h3 id="投影">2.2 投影</h3><p>含义：用只包含指定属性的元组生成关系。可用于重新排列属性顺序和操作属性的值。</p><p>语法：<span class="math inline">\(\Pi_{\text{A1},\text{A2},...,\text{An} }(\text{R})\)</span></p><p>例子：<span class="math inline">\(\Pi_{\text{b}\_\text{id-100},\text{a}\_\text{id} }( \sigma_{\text{a}\_\text{id}=\text{&#39;a2&#39;} }(\text{R}) )\)</span></p><p>SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> b_id<span class="hljs-number">-100</span>, a_id<br><span class="hljs-keyword">FROM</span> R <span class="hljs-keyword">WHERE</span> a_id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a2&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="并集">2.3 并集</h3><p>含义：生成一个关系，其中包含只出现在一个或两个输入关系中的所有元组。</p><p>语法：<span class="math inline">\(\text{R} \cup \text{S}\)</span></p><p>SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">(<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> R)<br><span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span><br>(<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> S);<br></code></pre></td></tr></table></figure><h3 id="交集">2.4 交集</h3><p>含义：生成一个关系，该关系只包含出现在两个输入关系中的元组。</p><p>语法：<span class="math inline">\(\text{R} \cap \text{S}\)</span></p><p>SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">(<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> R)<br><span class="hljs-keyword">INTERSECT</span><br>(<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> S);<br></code></pre></td></tr></table></figure><h3 id="差集">2.5 差集</h3><p>含义：生成一个关系，其中只包含第一个输入关系中出现的元组，而不包含第二个输入关系中出现的元组。</p><p>语法：<span class="math inline">\(\text{R} - \text{S}\)</span></p><p>SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">(<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> R)<br><span class="hljs-keyword">EXCEPT</span><br>(<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> S);<br></code></pre></td></tr></table></figure><h3 id="笛卡尔积">2.6 笛卡尔积</h3><p>含义：生成包含来自输入关系的元组的所有可能组合的关系。</p><p>语法：<span class="math inline">\(\text{R} \times\text{S}\)</span></p><p>SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> R <span class="hljs-keyword">CROSS</span> <span class="hljs-keyword">JOIN</span> S;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> R, S;<br></code></pre></td></tr></table></figure><h3 id="连接">2.7 连接</h3><p>含义：生成一个包含元组的关系，该元组是两个具有一个或多个属性的共同值元组(每个输入关系一个)的组合。</p><p>语法：<span class="math inline">\(\text{R} \bowtie\text{S}\)</span></p><p>SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> R <span class="hljs-keyword">NATURAL</span> <span class="hljs-keyword">JOIN</span> S;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> R <span class="hljs-keyword">JOIN</span> S <span class="hljs-keyword">USING</span> (a_id, b_id);<br></code></pre></td></tr></table></figure><p>连接操作还可以附加谓词，相当于先做笛卡尔积再进行选择操作，见《Database System Concepts》一书解释：</p><img src="/2023/09/05/%E4%BB%8E%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0%E5%88%B0-SQL/image-20231222215127913.png" class="" title="连接+谓词&#x3D;&#x3D;笛卡尔积+选择"><p>这种形式相当于以下 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> R, S <span class="hljs-keyword">ON</span> R.a1<span class="hljs-operator">=</span>S.a2;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> R, S<br><span class="hljs-keyword">WHERE</span> R.a1<span class="hljs-operator">=</span>S.a2;<br></code></pre></td></tr></table></figure><h3 id="赋值">2.8 赋值</h3><p>含义：提供一种工具，更容易地表达复杂查询。</p><p>符号：<span class="math inline">\(\leftarrow\)</span></p><p>例子：</p><img src="/2023/09/05/%E4%BB%8E%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0%E5%88%B0-SQL/image-20231222221314760.png" class="" title="image-20231222221314760"><h3 id="重命名">2.9 重命名</h3><p>含义：用于给关系代数计算中间结果取名。</p><p>符号：<span class="math inline">\(\rho\)</span></p><p>语法：<span class="math inline">\(\rho_{\text{x} }(\text{E})\)</span>或 <span class="math inline">\(\rho_{\text{x} (\text{A1},\text{A2},...,\text{An} ) }(\text{E})\)</span></p><p>SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> T.name<br><span class="hljs-keyword">FROM</span> instructor <span class="hljs-keyword">AS</span> T, instructor <span class="hljs-keyword">AS</span> S<br><span class="hljs-keyword">WHERE</span> T.salary <span class="hljs-operator">&gt;</span> S.salary <span class="hljs-keyword">AND</span> S.dept name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Biology&#x27;</span>;<br><br><span class="hljs-keyword">SELECT</span> name <span class="hljs-keyword">AS</span> instructor_name, course_id<br><span class="hljs-keyword">FROM</span> instructor, teaches<br><span class="hljs-keyword">WHERE</span> instructor.ID <span class="hljs-operator">=</span> teaches.ID;<br></code></pre></td></tr></table></figure><h3 id="聚合">2.10 聚合</h3><p>含义：计算 AVG、MAX、MIN、SUM、COUNT 值</p><p>符号：<span class="math inline">\(\gamma\)</span></p><p>例子：<span class="math inline">\(_\text{A2} \gamma_{\textbf{average}\text{(A1)}} (R)\)</span> ，表示在关系 R 上，在 A2属性上分组，计算 A1 属性的平均值。</p><p>SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> dept_name, <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-keyword">AS</span> avg salary<br><span class="hljs-keyword">FROM</span> instructor<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> dept_name;<br></code></pre></td></tr></table></figure><p>更复杂的例子：</p><img src="/2023/09/05/%E4%BB%8E%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0%E5%88%B0-SQL/image-20231222223632496.png" class="" title="image-20231222223632496"><p><br></p><p><br></p><p><strong>参考：</strong></p><ol type="1"><li><ahref="https://15445.courses.cs.cmu.edu/fall2022/slides/01-introduction.pdf">CMU15-445/645 Fall 2022 Lecture #01: Course Overview &amp; RelationalModel</a></li><li><a href="https://codex.cs.yale.edu/avi/db-book/">Database SystemConcepts Seventh Edition</a></li><li><ahref="https://www.db.dobo.sk/wp-content/uploads/2015/11/Codd_1970_A_relational_model.pdf">ARelational Model of Data for Large Shared Data Banks</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>关系模型</tag>
      
      <tag>关系代数</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 网络编程基础 API</title>
    <link href="/2023/08/11/Linux%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%20API/"/>
    <url>/2023/08/11/Linux%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%20API/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文是《Linux高性能服务器编程》阅读记录，供以后查阅参考。推荐阅读原书。</p></blockquote><h2id="主机字节序和网络字节序转换函数">主机字节序和网络字节序转换函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">ntohl</span> <span class="hljs-params">(<span class="hljs-type">uint32_t</span> __netlong)</span>;<span class="hljs-comment">// network to host long</span><br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">ntohs</span> <span class="hljs-params">(<span class="hljs-type">uint16_t</span> __netshort)</span>;<span class="hljs-comment">// network to host short</span><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">htonl</span> <span class="hljs-params">(<span class="hljs-type">uint32_t</span> __hostlong)</span>;<br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">htons</span> <span class="hljs-params">(<span class="hljs-type">uint16_t</span> __hostshort)</span>;<br></code></pre></td></tr></table></figure><p>其中，<code>int32</code> 型函数通常用来转换 IP地址；<code>int16</code> 型函数通常用来转换端口号。</p><h2 id="ip-地址转换函数">IP 地址转换函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-comment">/* Convert Internet host address from numbers-and-dots notation in CP</span><br><span class="hljs-comment">   into binary data in network byte order.  */</span><br><span class="hljs-type">in_addr_t</span> <span class="hljs-title function_">inet_addr</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *__cp)</span>;<span class="hljs-comment">// 失败时返回 INADDR_NONE</span><br><br><span class="hljs-comment">/* Convert Internet host address from numbers-and-dots notation in CP</span><br><span class="hljs-comment">   into binary data and store the result in the structure INP.  */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">inet_aton</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *__cp, <span class="hljs-keyword">struct</span> in_addr *__inp)</span>;<br><br><span class="hljs-comment">/* Convert Internet number in IN to ASCII representation.  The return value</span><br><span class="hljs-comment">   is a pointer to an internal array containing the string.  */</span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">inet_ntoa</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> in_addr __in)</span>;<span class="hljs-comment">// 不可重入（如需要记录点分十进制 IP 地址，需拷贝到另外内存地址）</span><br></code></pre></td></tr></table></figure><h2 id="创建-socket">创建 socket</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-comment">/* Create a new socket of type TYPE in domain DOMAIN, using</span><br><span class="hljs-comment">   protocol PROTOCOL.  If PROTOCOL is zero, one is chosen automatically.</span><br><span class="hljs-comment">   Returns a file descriptor for the new socket, or -1 for errors.  */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">socket</span> <span class="hljs-params">(<span class="hljs-type">int</span> __domain, <span class="hljs-type">int</span> __type, <span class="hljs-type">int</span> __protocol)</span>;<br><span class="hljs-comment">// domain 参数可选值： PF_INET 表示 IPv4；PF_INET6 表示 IPv6</span><br><span class="hljs-comment">// type 参数可选值：SOCK_STREAM 表示 TCP；SOCK_UGRAM 表示 UDP</span><br><span class="hljs-comment">// protocol 一般都设置为 0，表示使用默认协议</span><br></code></pre></td></tr></table></figure><h2 id="命名-socket">命名 socket</h2><p>服务端需要调用 <code>bind</code> 函数以给 socket 命名地址（IP地址、端口号等），定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-comment">/* Give the socket FD the local address ADDR (which is LEN bytes long).  */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">bind</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* __addr, <span class="hljs-type">socklen_t</span> __len)</span>;<br></code></pre></td></tr></table></figure><h2 id="监听-socket">监听 socket</h2><p>使用 <code>listen</code>函数创建监听队列以存放待处理的客户端连接：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-comment">/* Prepare to accept connections on socket FD.</span><br><span class="hljs-comment">   N connection requests will be queued before further requests are refused.</span><br><span class="hljs-comment">   Returns 0 on success, -1 for errors.  */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">listen</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fd, <span class="hljs-type">int</span> __n)</span>;<br></code></pre></td></tr></table></figure><h2 id="接受连接">接受连接</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-comment">/* Await a connection on socket FD.</span><br><span class="hljs-comment">   When a connection arrives, open a new socket to communicate with it,</span><br><span class="hljs-comment">   set *ADDR (which is *ADDR_LEN bytes long) to the address of the connecting</span><br><span class="hljs-comment">   peer and *ADDR_LEN to the address&#x27;s actual length, and return the</span><br><span class="hljs-comment">   new socket&#x27;s descriptor, or -1 for errors.</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">accept</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fd, <span class="hljs-keyword">struct</span> sockaddr *__addr, <span class="hljs-type">socklen_t</span> *__addr_len)</span>;<br></code></pre></td></tr></table></figure><h2 id="发起连接">发起连接</h2><p>客户端需要通过如下调用主动与服务器建立连接：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-comment">/* Open a connection on socket FD to peer at ADDR (which LEN bytes long).</span><br><span class="hljs-comment">   For connectionless socket types, just set the default address to send to</span><br><span class="hljs-comment">   and the only address from which to accept transmissions.</span><br><span class="hljs-comment">   Return 0 on success, -1 for errors.  */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">connect</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *__addr, <span class="hljs-type">socklen_t</span> __len)</span>;<br></code></pre></td></tr></table></figure><h2 id="关闭连接">关闭连接</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span>;<span class="hljs-comment">// 实际上该函数将 fd 引用计数减 1，只有当 fd 引用计数为 0 时，才真正关闭连接</span><br><br><span class="hljs-comment">// 可使用如下 shutdown 函数立即终止连接，而不是将 socket 引用计数减 1</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-comment">/* Shut down all or part of the connection open on socket FD.</span><br><span class="hljs-comment">   HOW determines what to shut down:</span><br><span class="hljs-comment">     SHUT_RD   = No more receptions;</span><br><span class="hljs-comment">     SHUT_WR   = No more transmissions;</span><br><span class="hljs-comment">     SHUT_RDWR = No more receptions or transmissions.</span><br><span class="hljs-comment">   Returns 0 on success, -1 for errors.  */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">shutdown</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fd, <span class="hljs-type">int</span> __how)</span>;<br></code></pre></td></tr></table></figure><h2 id="tcp-数据读写">TCP 数据读写</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-comment">/* Read N bytes into BUF from socket FD.</span><br><span class="hljs-comment">   Returns the number read or -1 for errors.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">recv</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fd, <span class="hljs-type">void</span> *__buf, <span class="hljs-type">size_t</span> __n, <span class="hljs-type">int</span> __flags)</span>;<br><br><span class="hljs-comment">/* Send N bytes of BUF to socket FD.  Returns the number sent or -1.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">send</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *__buf, <span class="hljs-type">size_t</span> __n, <span class="hljs-type">int</span> __flags)</span>;<br></code></pre></td></tr></table></figure><h2 id="udp-数据读写">UDP 数据读写</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><br><span class="hljs-comment">/* Read N bytes into BUF through socket FD.</span><br><span class="hljs-comment">   If ADDR is not NULL, fill in *ADDR_LEN bytes of it with tha address of</span><br><span class="hljs-comment">   the sender, and store the actual size of the address in *ADDR_LEN.</span><br><span class="hljs-comment">   Returns the number of bytes read or -1 for errors.</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">recvfrom</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fd, <span class="hljs-type">void</span> *__buf, <span class="hljs-type">size_t</span> __n,</span><br><span class="hljs-params"> <span class="hljs-type">int</span> __flags, <span class="hljs-keyword">struct</span> sockaddr* __addr,</span><br><span class="hljs-params"> <span class="hljs-type">socklen_t</span> * __addr_len)</span>;<br><br><br><span class="hljs-comment">/* Send N bytes of BUF on socket FD to peer at address ADDR (which is</span><br><span class="hljs-comment">   ADDR_LEN bytes long).  Returns the number sent, or -1 for errors.</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">sendto</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *__buf, <span class="hljs-type">size_t</span> __n,</span><br><span class="hljs-params">       <span class="hljs-type">int</span> __flags, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* __addr,</span><br><span class="hljs-params">       <span class="hljs-type">socklen_t</span> __addr_len)</span>;<br></code></pre></td></tr></table></figure><h2 id="通用数据读写函数">通用数据读写函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><br><span class="hljs-comment">/* Receive a message as described by MESSAGE from socket FD.</span><br><span class="hljs-comment">   Returns the number of bytes read or -1 for errors.</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">recvmsg</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fd, <span class="hljs-keyword">struct</span> msghdr *__message, <span class="hljs-type">int</span> __flags)</span>;<br><br><br><span class="hljs-comment">/* Send a message described MESSAGE on socket FD.</span><br><span class="hljs-comment">   Returns the number of bytes sent, or -1 for errors.</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">sendmsg</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> msghdr *__message, <span class="hljs-type">int</span> __flags)</span>;<br><br><span class="hljs-comment">// msghdr 结构体定义</span><br><span class="hljs-comment">/* Structure describing messages sent by</span><br><span class="hljs-comment">   `sendmsg&#x27; and received by `recvmsg&#x27;.  */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msghdr</span></span><br><span class="hljs-class">  &#123;</span><br>    <span class="hljs-type">void</span> *msg_name;<span class="hljs-comment">/* Address to send to/receive from.  */</span><br>    <span class="hljs-type">socklen_t</span> msg_namelen;<span class="hljs-comment">/* Length of address data.  */</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span> *<span class="hljs-title">msg_iov</span>;</span><span class="hljs-comment">/* Vector of data to send/receive into.  */</span><br>    <span class="hljs-type">size_t</span> msg_iovlen;<span class="hljs-comment">/* Number of elements in the vector.  */</span><br><br>    <span class="hljs-type">void</span> *msg_control;<span class="hljs-comment">/* Ancillary data (eg BSD filedesc passing). */</span><br>    <span class="hljs-type">size_t</span> msg_controllen;<span class="hljs-comment">/* Ancillary data buffer length.</span><br><span class="hljs-comment">   !! The type should be socklen_t but the</span><br><span class="hljs-comment">   definition of the kernel is incompatible</span><br><span class="hljs-comment">   with this.  */</span><br><br>    <span class="hljs-type">int</span> msg_flags;<span class="hljs-comment">/* Flags on received message.  */</span><br>  &#125;;<br><br><span class="hljs-comment">// iovoc 结构体定义</span><br><span class="hljs-comment">/* Structure for scatter/gather I/O.  */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span></span><br><span class="hljs-class">  &#123;</span><br>    <span class="hljs-type">void</span> *iov_base;<span class="hljs-comment">/* Pointer to data.  */</span><br>    <span class="hljs-type">size_t</span> iov_len;<span class="hljs-comment">/* Length of data.  */</span><br>  &#125;;<br></code></pre></td></tr></table></figure><h2 id="带外标记">带外标记</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-comment">/* Determine whether socket is at a out-of-band mark.  */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sockatmark</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fd)</span>;<br><span class="hljs-comment">// 判断下一个被读取到的数据是否是带外数据</span><br></code></pre></td></tr></table></figure><h2 id="地址信息函数">地址信息函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-comment">/* Put the local address of FD into *ADDR and its length in *LEN.  */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getsockname</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fd, <span class="hljs-keyword">struct</span> sockaddr* __addr, <span class="hljs-type">socklen_t</span> * __len)</span>;<br><br><span class="hljs-comment">/* Put the address of the peer connected to socket FD into *ADDR</span><br><span class="hljs-comment">   (which is *LEN bytes long), and its actual length into *LEN.  */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getpeername</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fd, <span class="hljs-keyword">struct</span> sockaddr* __addr, <span class="hljs-type">socklen_t</span> * __len)</span>;<br></code></pre></td></tr></table></figure><h2 id="socket-选项">socket 选项</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-comment">/* Put the current value for socket FD&#x27;s option OPTNAME at protocol level LEVEL</span><br><span class="hljs-comment">   into OPTVAL (which is *OPTLEN bytes long), and set *OPTLEN to the value&#x27;s</span><br><span class="hljs-comment">   actual length.  Returns 0 on success, -1 for errors.  */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getsockopt</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fd, <span class="hljs-type">int</span> __level, <span class="hljs-type">int</span> __optname,</span><br><span class="hljs-params">       <span class="hljs-type">void</span> * __optval,</span><br><span class="hljs-params">       <span class="hljs-type">socklen_t</span> * __optlen)</span>;<br><br><br><span class="hljs-comment">/* Set socket FD&#x27;s option OPTNAME at protocol level LEVEL</span><br><span class="hljs-comment">   to *OPTVAL (which is OPTLEN bytes long).</span><br><span class="hljs-comment">   Returns 0 on success, -1 for errors.  */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">setsockopt</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fd, <span class="hljs-type">int</span> __level, <span class="hljs-type">int</span> __optname,</span><br><span class="hljs-params">       <span class="hljs-type">const</span> <span class="hljs-type">void</span> *__optval, <span class="hljs-type">socklen_t</span> __optlen)</span>;<br><br><span class="hljs-comment">// level 参数指定要操作哪个协议的选项，如 IPv4、IPv6、TCP 等</span><br></code></pre></td></tr></table></figure><h2 id="so_reuseaddr-选项">SO_REUSEADDR 选项</h2><p>该选项可以让服务器程序强制使用被处于 TIME_WAIT 状态的连接占用的socket 地址，例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (argc &lt;= <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage: %s ip_address port_number\n&quot;</span>, basename(argv[<span class="hljs-number">0</span>]));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> port = atoi(argv[<span class="hljs-number">2</span>]);<br><br>    <span class="hljs-type">int</span> sock = socket(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    assert(sock &gt;= <span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> reuse = <span class="hljs-number">1</span>;<br>    setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="hljs-keyword">sizeof</span>(reuse));  <span class="hljs-comment">// set SO_REUSEADDR</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    bzero(&amp;address, <span class="hljs-keyword">sizeof</span>(address));<br>    address.sin_family = AF_INET;<br>    inet_pton(AF_INET, ip, &amp;address.sin_addr);<br>    address.sin_port = htons(port);<br>    <span class="hljs-type">int</span> ret = bind(sock, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;address, <span class="hljs-keyword">sizeof</span>(address));<br>    assert(ret != <span class="hljs-number">-1</span>);<br><br>    ret = listen(sock, <span class="hljs-number">5</span>);<br>    assert(ret != <span class="hljs-number">-1</span>);<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client</span>;</span><br>    <span class="hljs-type">socklen_t</span> client_addrlength = <span class="hljs-keyword">sizeof</span>(client);<br>    <span class="hljs-type">int</span> connfd = accept(sock, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;client, &amp;client_addrlength);<br>    <span class="hljs-keyword">if</span> (connfd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;errno is: %d\n&quot;</span>, errno);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-type">char</span> remote[INET_ADDRSTRLEN];<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connected with ip: %s and port: %d\n&quot;</span>,<br>               inet_ntop(AF_INET, &amp;client.sin_addr, remote, INET_ADDRSTRLEN), ntohs(client.sin_port));<br>        close(connfd);<br>    &#125;<br><br>    close(sock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="网络信息-api">网络信息 API</h2><h3 id="gethostbyname-和-gethostbyaddr">gethostbyname 和gethostbyaddr</h3><p><code>gethostbyname</code> 根据主机名称获取主机完整信息。其首先在本地<code>/etc/hosts</code> 配置文件查找主机，若没找到，访问 DNS 服务。</p><p><code>gethostbyaddr</code> 根据 IP 地址获取主机的完整信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netdb.h&gt;</span></span><br><br><span class="hljs-keyword">struct</span> hostent* <span class="hljs-title function_">gethostbyname</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name)</span>;<br><span class="hljs-keyword">struct</span> hostent* <span class="hljs-title function_">gethostbyaddr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* addr, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> type)</span>;<br><br><span class="hljs-comment">/* Description of data base entry for a single host.  */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hostent</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">char</span> *h_name;<span class="hljs-comment">/* Official name of host.  */</span><br>  <span class="hljs-type">char</span> **h_aliases;<span class="hljs-comment">/* Alias list.  */</span><br>  <span class="hljs-type">int</span> h_addrtype;<span class="hljs-comment">/* Host address type.  */</span><br>  <span class="hljs-type">int</span> h_length;<span class="hljs-comment">/* Length of address.  */</span><br>  <span class="hljs-type">char</span> **h_addr_list;<span class="hljs-comment">/* List of addresses from name server.  */</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="getservbyname-和-getservbyport">getservbyname 和getservbyport</h3><p><code>getservbyname</code> 根据名称获取某个服务完整信息；</p><p><code>getservbyport</code> 根据端口号获取某个服务完整信息。</p><p>两个函数实际上都通过读取 <code>/etc/services</code>文件来获取服务信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netdb.h&gt;</span></span><br><br><span class="hljs-keyword">struct</span> servent* <span class="hljs-title function_">getservbyname</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* proto)</span>;<br><span class="hljs-keyword">struct</span> servent* <span class="hljs-title function_">getservbyport</span><span class="hljs-params">(<span class="hljs-type">int</span> port, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* proto)</span>;<br><br><span class="hljs-comment">/* Description of data base entry for a single service.  */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">servent</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">char</span> *s_name;<span class="hljs-comment">/* Official service name.  */</span><br>  <span class="hljs-type">char</span> **s_aliases;<span class="hljs-comment">/* Alias list.  */</span><br>  <span class="hljs-type">int</span> s_port;<span class="hljs-comment">/* Port number.  */</span><br>  <span class="hljs-type">char</span> *s_proto;<span class="hljs-comment">/* Protocol to use.  */</span><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>socket</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是向量数据库？</title>
    <link href="/2023/08/03/%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F/"/>
    <url>/2023/08/03/%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>译者注：</p><p>本文译自 <ahref="https://www.pinecone.io/learn/vector-database/">What is a VectorDatabase?</a> ，作者：Roie Schwaber-Cohen。译文与原文基本相同，删除部分不影响理解向量数据库基本概念的内容。</p><p>译者：<a href="https://arcsin2.cloud/about">arcsin2</a></p></blockquote><p>随着人工智能的发展，出现了许多涉及大语言模型、生成式人工智能和语义搜索的应用程序。这些新应用都依赖于向量嵌入——一种包含语义信息、对人工智能在执行复杂任务时获取理解并保持长期记忆至关重要的数据表示类型。向量嵌入由人工智能模型生成，也就是数学中的向量，它们通常具有特定的维度，代表AI模型学习到的大量属性或特征。在人工智能和机器学习场景中，这些特征代表了对于理解数据的模式、关系和底层结构至关重要的不同维度，可以看作图片、文本等原始数据的压缩表示。</p><p>因此，我们需要一种专门的数据库——向量数据库来处理这种数据类型。向量数据库通过提供针对向量数据进行优化的存储和查询能力满足AI程序的需求。向量数据库具有传统数据库所具备的功能，而独立的向量索引库（如FAISS等向量搜索库）并不具备数据库的功能。向量数据库还专门处理向量嵌入，而传统的基于标量的数据库则不具备这种能力。</p><p>传统基于标量的数据库难以应对向量数据的复杂性和规模，无法进行实时分析。这就是向量数据库发挥作用的地方——它们被专门地设计来处理这种类型的数据，并提供性能、可扩展性和灵活性。</p><p>有了向量数据库，就能够给 AI应用添加高级功能，如：语义信息检索、长期记忆等。下图展示了向量数据库在这类应用中扮演的角色：</p><figure><imgsrc="https://cdn.sanity.io/images/vr8gru94/production/e88ebbacb848b09e477d11eedf4209d10ea4ac0a-1399x537.png"alt="Vector Database" /><figcaption aria-hidden="true">Vector Database</figcaption></figure><p>每个步骤含义分别为：</p><ol type="1"><li>首先，我们使用<strong>嵌入模型</strong>为我们想要索引的<strong>内容</strong>创建<strong>向量嵌入</strong>。</li><li>将<strong>向量嵌入</strong>插入到<strong>向量数据库</strong>中，并将其与创建该嵌入的原始<strong>内容</strong>进行关联。</li><li>当<strong>应用程序</strong>发出查询时，我们使用同样的<strong>嵌入模型</strong>为查询创建嵌入，并使用这些嵌入查询<strong>数据库</strong>中的<em>相似</em>向量嵌入。正如之前提到的，这些相似的嵌入与用于创建它们的原始<strong>内容</strong>相关联。</li></ol><h2 id="向量索引与向量数据库有什么不同">1.向量索引与向量数据库有什么不同？</h2><p>向量索引，如： <ahref="https://www.pinecone.io/learn/faiss/">FAISS</a>（Facebook AISimilaritySearch，FAISS），可以显著改善向量嵌入的检索，但它们缺乏任何数据库具有的功能。而向量数据库则是专门为<em>管理</em>向量嵌入而构建的，相比使用独立的向量索引，它具有以下优点：</p><ol type="1"><li><p><strong>数据管理：</strong>向量数据库提供了易于使用的数据存储功能，比如插入、删除和更新数据。这使得管理和维护向量数据比使用类似FAISS 这样的独立向量 <em>索引</em>更加简便，后者需要额外的工作来与存储解决方案进行集成。</p></li><li><p><strong>元数据存储和过滤：</strong>向量数据库可以存储与每个向量条目相关联的元数据。用户可以使用额外的元数据过滤器查询数据库，实现更精细化的查询。</p></li><li><p><strong>可扩展性：</strong>向量数据库被设计为随着数据量和用户需求的增长而扩展，更好地支持分布式和并行处理。独立的向量索引可能需要定制解决方案才能实现类似的可扩展性（比如在Kubernetes 集群或其他类似系统上部署和管理它们）。</p></li><li><p><strong>实时更新：</strong>向量数据库通常支持实时数据更新，允许动态地更改数据，而独立的向量索引可能需要进行完整的重新索引过程来纳入新数据，这可能耗时且计算成本高。</p></li><li><p><strong>备份：</strong>向量数据库处理定期备份数据库中存储的所有数据。</p></li><li><p><strong>生态系统集成：</strong>向量数据库更容易与数据处理生态系统的其他组件集成，例如 ETL 流水线（如Spark）、分析工具（如 <a href="https://www.tableau.com/">Tableau</a> 和<a href="https://segment.com/">Segment</a>）以及可视化平台（如 <ahref="https://grafana.com/">Grafana</a>），从而简化数据管理工作流程。它还可以轻松集成其他AI 相关工具，如 <ahref="https://python.langchain.com/en/latest/index.html">LangChain</a>、<ahref="https://gpt-index.readthedocs.io/">LlamaIndex</a> 和 <ahref="https://openai.com/blog/chatgpt-plugins">ChatGPT’s插件</a>。</p></li><li><p><strong>数据安全和访问控制：</strong>向量数据库通常提供内置的数据安全功能和访问控制机制，以保护敏感信息，而这些可能在独立的向量索引解决方案中不可用。</p></li></ol><p>简而言之，向量数据库通过解决独立向量索引的局限性（如可扩展性挑战、繁琐的集成过程以及缺乏实时更新和内置安全措施等），为处理向量嵌入提供了更优越的解决方案，确保了更有效和流畅的数据管理体验。</p><h2 id="向量数据库如何工作">2. 向量数据库如何工作？</h2><p>我们都或多或少知道传统数据库的工作方式：它们将字符串、数字和其他类型的标量数据存储在行和列中。另一方面，向量数据库操作的是向量，因此它的优化和查询方式有很大的不同。</p><p>在传统数据库中，我们通常查询数据库中的行，其中值通常与我们的查询完全匹配。在向量数据库中，我们使用相似性度量来找到与我们的查询<strong>最相似</strong>的向量。</p><p>向量数据库使用一系列不同的算法，所有这些算法都参与到近似最近邻（ApproximateNearestNeighbor，ANN）搜索中。这些算法通过哈希、量化或基于图的搜索来优化搜索过程。</p><p>这些算法被组装成一个流水线，用于快速准确地检索被查询向量的最近邻。由于向量数据库提供的是<strong>近似</strong>结果，我们需要在准确性和速度之间进行权衡。结果越准确，查询就越慢。然而，一个好的系统可以以超快的速度提供几乎完美的准确性。</p><p>以下是一个向量数据库的常见流水线：</p><figure><imgsrc="https://cdn.sanity.io/images/vr8gru94/production/ff9ba425d0c78d696372e0a43ce57851b4f1d4b7-1307x233.png"alt="Vector Database pipeline" /><figcaption aria-hidden="true">Vector Database pipeline</figcaption></figure><ol type="1"><li><p><strong>索引（Indexing）</strong>：向量数据库使用 PQ、LSH 或 HNSW等算法对向量进行索引（后文将对这些进行详细介绍）。这一步将向量映射到数据结构，以便实现更快速的检索。</p></li><li><p><strong>查询（Querying）</strong>：向量数据库将索引化的查询向量与数据集中的索引化向量进行比较，找到最近的邻居（应用该索引所使用的相似性度量）。</p></li><li><p><strong>后处理（PostProcessing）</strong>：在某些情况下，向量数据库从数据集中检索出最终的最近邻居，并对其进行后处理以返回最终结果。这一步可以包括使用不同的相似性度量对最近邻居进行重新排序。</p></li></ol><p>在接下来的部分中，我们将详细讨论这些算法，并解释它们如何对向量数据库的整体性能做出贡献。</p><h3 id="算法">2.1 算法</h3><p>有几种算法可以促进向量索引的创建。它们的共同目标是通过创建一个可以快速遍历的数据结构，实现快速查询。它们通常会将原始向量的表示转换为压缩形式，以优化查询过程。下面详细介绍。</p><h4 id="随机投影random-projection">2.1.1 随机投影（RandomProjection）</h4><p>随机投影背后的出发点是使用<strong>随机投影矩阵</strong>，将原始的高维向量压缩为低维向量。我们创建一个由随机数构成的矩阵。矩阵的大小将是我们想要的目标低维值。然后，我们计算输入向量与矩阵的点积，得到一个<strong>投影矩阵</strong>，其维度比我们的原始向量更少，但仍保持它们的相似性。</p><figure><imgsrc="https://cdn.sanity.io/images/vr8gru94/production/22dffa542410c1b542fcaeafcafc088ad278add5-1303x534.png"alt="Random Projection" /><figcaption aria-hidden="true">Random Projection</figcaption></figure><p>当我们查询时，我们使用同样的投影矩阵将查询向量投影到较低维空间。然后，我们将投影后的查询向量与数据库中的投影向量进行比较，找到最近邻居。由于数据的维度降低，搜索过程比在整个高维空间中搜索要快得多。</p><p>随机投影是一种近似方法，投影质量取决于投影矩阵的属性。一般来说，投影矩阵越随机，投影的质量就越好。但是生成一个真正随机的投影矩阵可能在计算上是昂贵的，特别是对于大型数据集而言。<ahref="https://www.pinecone.io/learn/locality-sensitive-hashing-random-projection/">了解更多关于随机投影的信息。</a></p><h4 id="乘积量化product-quantization">2.1.2 乘积量化（ProductQuantization）</h4><p>另一种构建索引的方法是乘积量化（ProductQuantization，PQ），这是一种用于高维向量（如向量嵌入）的 <em>有损</em>压缩技术。它将原始向量分解成较小的块，通过为每个块创建代表性的“码”来简化每个块的表示，然后将所有块重新组合在一起，这不会丢失对相似性操作至关重要的信息。PQ的过程可以分解为四个步骤：分割、训练、编码和查询。</p><figure><imgsrc="https://cdn.sanity.io/images/vr8gru94/production/791910350d7d2140dbe684b405ef5ee761c8fc6a-1060x720.png"alt="Product Quantization" /><figcaption aria-hidden="true">Product Quantization</figcaption></figure><ol type="1"><li><strong>分割</strong>： 将向量分割成片段。</li><li><strong>训练：</strong>我们为每个片段构建一个“码本”（codebook）。简而言之，该算法生成一个潜在的“码”池，可以分配给一个向量。实际上，这个“码本”由对向量的每个片段执行k-means 聚类所创建的聚类的中心点组成。对于 k-means聚类使用的值，我们的片段码本将包含与 k-means 聚类相同的值。</li><li><strong>编码：</strong>算法将为每个片段分配一个特定的码。实际上，在训练完成后，我们找到码本中最接近每个向量片段的值。我们的PQ 码将是对应码本中的值的标识符。我们可以使用任意数量的 PQ码，这意味着我们可以选择多个码本值来表示每个片段。</li><li><strong>查询：</strong>当我们查询时，算法将向量分解成子向量，并使用相同的码本进行量化。然后，它使用索引码来找到与查询向量最接近的向量。</li></ol><p>码本中代表性向量的数量是表示精度和搜索码本的计算成本之间的权衡。码本中代表性向量越多，子空间中向量的表示就越精确，但搜索码本的计算成本就越高。相比之下，码本中代表性向量越少，表示就越不准确，但计算成本也较低。<ahref="https://www.pinecone.io/learn/product-quantization/">了解更多关于PQ 的信息</a>。</p><h4 id="局部敏感哈希locality-sensitive-hashing">2.1.3局部敏感哈希（Locality-sensitive hashing）</h4><p>局部敏感哈希（Locality-SensitiveHashing，LSH）是一种用于近似最近邻搜索的索引技术。它在提供近似、有限的搜索结果的同时尽快提高搜索速度。LSH使用一组哈希函数将相似的向量映射到“桶”中，如下所示：</p><figure><imgsrc="https://cdn.sanity.io/images/vr8gru94/production/606382d0ca90a8d24f26780f5f9954123e37be91-575x603.png"alt="Locality-sensitive hashing" /><figcaption aria-hidden="true">Locality-sensitive hashing</figcaption></figure><p>为了找到给定查询向量的最近邻居，我们使用与将相似向量“分桶”到哈希表中相同的哈希函数。查询向量被哈希到特定的表格，然后与该表格中的其他向量进行比较，以找到最接近的匹配项。这种方法比搜索整个数据集要快得多，因为每个哈希表中的向量数量远远少于整个空间中的向量数量。</p><p>需要记住 LSH是一种近似方法，近似的质量取决于哈希函数的属性。通常情况下，使用的哈希函数越多，近似质量就越好。然而，使用大量哈希函数可能在计算上代价昂贵，并且对于大型数据集可能不可行。<ahref="https://www.pinecone.io/learn/locality-sensitive-hashing/">了解更多关于LSH 的信息</a>。</p><h4 id="层次导航小世界hierarchical-navigable-small-world-hnsw">2.1.4层次导航小世界（Hierarchical Navigable Small World, HNSW）</h4><p>层次导航小世界（Hierarchical Navigable Small World,HNSW）创建了一个层次化的类似树的结构，其中树的每个节点表示一组向量。节点之间的边表示向量之间的<strong>相似性</strong>。该算法首先创建一组节点，每个节点包含少量向量。这可以通过随机选择或使用k-means 等聚类算法对向量进行聚类来完成，其中每个聚类成为一个节点。</p><figure><imgsrc="https://cdn.sanity.io/images/vr8gru94/production/e06c4bb4c0095a1fb5b45b04acaa15663b6d6a96-734x696.png"alt="Hierarchical Navigable Small World (HNSW)" /><figcaption aria-hidden="true">Hierarchical Navigable Small World(HNSW)</figcaption></figure><p>然后，该算法检查每个节点的向量，并在该节点与具有与其最相似向量的节点之间绘制一条边。</p><figure><imgsrc="https://cdn.sanity.io/images/vr8gru94/production/63110626f18b50b5a15c48a8eea3c852ff64196b-496x467.png"alt="Hierarchical Navigable Small World (HNSW)" /><figcaption aria-hidden="true">Hierarchical Navigable Small World(HNSW)</figcaption></figure><p>当我们查询一个 HNSW索引时，它使用这个图来在树中导航，访问最有可能包含与查询向量最接近的向量的节点。<ahref="https://www.pinecone.io/learn/hnsw/">了解更多关于 HNSW的信息</a>。</p><h3 id="相似性度量similarity-measures">2.2 相似性度量（SimilarityMeasures）</h3><p>在之前讨论的算法基础上，我们需要了解相似性度量在向量数据库中的作用。这些度量是向量数据库比较和识别给定查询的最相关结果的基础。</p><p>相似性度量是一种数学方法，用于确定向量空间中两个向量的相似程度。在向量数据库中，相似性度量用于比较存储在数据库中的向量，并找到与给定查询向量最相似的向量。</p><p>可以使用多种相似性度量，包括：</p><ul><li><strong>余弦相似性（Cosinesimilarity）</strong>：衡量向量空间中两个向量之间夹角的余弦。它的取值范围从-1 到 1，其中 1 表示完全相同的向量，0 表示正交的向量，-1表示完全相反的向量。</li><li><strong>欧氏距离（Euclideandistance）</strong>：衡量向量空间中两个向量之间的直线距离。它的取值范围从0 到无穷大，其中 0 表示完全相同的向量，越大的值表示越不相似的向量。</li><li><strong>点积（Dotproduct）</strong>：衡量两个向量的大小和它们之间夹角的余弦的乘积。它的取值范围从负无穷到正无穷，其中正值表示指向相同方向的向量，0表示正交的向量，负值表示指向相反方向的向量。</li></ul><p>选择相似性度量将影响从向量数据库中获取的结果。还需要注意的是，每种相似性度量都有其优缺点，在选择时需要根据使用案例和要求做出正确的选择。<ahref="https://www.pinecone.io/learn/vector-similarity/">了解更多关于相似性度量的信息</a>。</p><h3 id="过滤filtering">2.3 过滤（Filtering）</h3><p>数据库中存储的每个向量都包含元数据。除了能够查询相似向量外，向量数据库还可以根据元数据查询对结果进行过滤。为此，向量数据库通常维护两个索引：一个向量索引和一个元数据索引。然后，它在进行向量搜索之前或之后执行元数据过滤，但在任何情况下，都会遇到导致查询过程减慢的困难。</p><figure><imgsrc="https://cdn.sanity.io/images/vr8gru94/production/fede570123cbdabff288da8900330d472834ceb8-1920x1220.png"alt="Post-filtering and Pre-filtering" /><figcaption aria-hidden="true">Post-filtering andPre-filtering</figcaption></figure><p>过滤过程可以在向量搜索之前或之后执行，但每种方法都有自己的挑战，可能会影响查询性能：</p><ul><li><strong>预过滤（Pre-filtering）：</strong>在这种方法中，元数据过滤是在向量搜索之前进行的。虽然这可以帮助减少搜索空间，但可能会导致系统忽略不符合元数据过滤条件的相关结果。此外，广泛的元数据过滤可能会因增加计算开销而减慢查询过程。</li><li><strong>后过滤（Post-filtering）：</strong>在这种方法中，元数据过滤是在向量搜索之后进行的。这可以确保考虑到所有相关结果，但也可能引入额外的开销，并在搜索完成后需要过滤掉不相关的结果，从而减慢查询过程。</li></ul><p>为了优化过滤过程，向量数据库使用各种技术，例如利用先进的索引方法进行元数据过滤或使用并行处理来加速过滤任务。在向量数据库中，平衡搜索性能和过滤准确性的权衡对于提供高效且相关的查询结果至关重要。<ahref="https://www.pinecone.io/learn/vector-search-filtering/">了解更多关于向量搜索过滤的信息</a>。</p><h3 id="数据库操作database-operations">2.4 数据库操作（DatabaseOperations）</h3><p>与向量索引不同，向量数据库配备了一组功能，使其更适合在高规模生产环境中使用。让我们对数据库操作涉及的组件进行一个总体概述。</p><figure><imgsrc="https://cdn.sanity.io/images/vr8gru94/production/d0adc44e56739a985cc198ea327fbb3d701f21e5-1094x984.png"alt="Database Operations" /><figcaption aria-hidden="true">Database Operations</figcaption></figure><h4 id="性能与容错性performance-and-fault-tolerance">2.4.1性能与容错性（Performance and Fault tolerance）</h4><p>性能和容错性密切相关。我们拥有的数据越多，就需要更多的节点，这同时也增加了错误和故障的可能。与其他类型的数据库一样，我们希望确保即使某些底层节点出现故障，查询也能尽快执行。这可能是由于硬件故障、网络故障或其他类型的技术错误。这种故障可能导致停机时间，甚至产生不正确的查询结果。</p><p>为了确保高性能和容错性，向量数据库使用分片和复制策略：</p><ol type="1"><li><strong>分片（Sharding）：</strong>将数据分布到多个节点。有不同的数据分片方法。例如，可以按照不同数据簇的相似性进行分片，以便将相似向量存储在同一分片中。当进行查询时，查询会被发送到所有分片，然后结果会被检索和合并。这被称为“scatter-gather” 模式。</li><li><strong>复制（Replication）：</strong>在不同节点上创建多个数据副本。这确保即使某个节点出现故障，其他节点也能够取而代之。有两种主要的一致性模型：<em>最终一致性</em>和<em>强一致性</em>。最终一致性允许在数据的不同副本之间存在临时的不一致性，这将提高可用性并减少延迟，但可能导致冲突甚至数据丢失。另一方面，强一致性要求在写操作被视为完成之前，所有数据副本都会得到更新。这种方法提供了更强的一致性，但可能导致更高的延迟。</li></ol><h4 id="监控monitoring">2.4.2 监控（Monitoring）</h4><p>为了有效地管理和维护向量数据库，我们需要一个强大的监控系统，跟踪数据库性能、健康状况和整体状态的重要方面。监控对于检测潜在问题、优化性能和确保生产运营的顺利进行至关重要。监控向量数据库的一些方面包括以下内容：</p><ol type="1"><li><strong>资源使用情况：</strong> 监控资源使用情况，如CPU、内存、磁盘空间和网络活动，这可以识别可能影响数据库性能的潜在问题或资源限制。</li><li><strong>查询性能：</strong>查询延迟、吞吐量和错误率可能表明需要解决的潜在系统性问题。</li><li><strong>系统健康：</strong>整体系统健康监控包括单个节点、复制过程和其他关键组件的状态。</li></ol><h4 id="访问控制access-control">2.4.3 访问控制（Access-control）</h4><p>访问控制是管理和监管用户对数据和资源的访问的过程。这是数据安全的重要组成部分，确保只有授权用户能够查看、修改或与存储在向量数据库中的敏感数据进行交互。</p><p>访问控制的重要性如下：</p><ol type="1"><li><strong>数据保护：</strong>由于人工智能应用通常涉及敏感和机密信息，实施严格的访问控制机制有助于防止未经授权的访问和潜在的数据泄漏。</li><li><strong>合规性：</strong>许多行业，如医疗保健和金融，受到严格的数据隐私法规的约束。实施适当的访问控制有助于组织遵守这些法规，保护其免受法律和财务后果。</li><li><strong>责任和审计：</strong>访问控制机制使组织能够维护向量数据库中用户活动的记录。这些信息对于审计目的至关重要，当发生安全漏洞时，它有助于追溯任何未经授权的访问或修改。</li><li><strong>可扩展性和灵活性：</strong>随着组织的成长和演变，其访问控制需求可能会发生变化。强大的访问控制系统允许无缝修改和扩展用户权限，确保在整个组织的成长过程中数据安全保持完整。</li></ol><h4 id="备份与收集backups-and-collections">2.4.4 备份与收集（Backups andcollections）</h4><p>当其他方法失效时，向量数据库提供了依赖定期创建备份的能力。这些备份可以存储在外部存储系统或云存储服务中，确保数据的安全性和可恢复性。在发生数据丢失或损坏的情况下，这些备份可以用来将数据库恢复到先前的状态，最大限度地减少停机时间并降低对整个系统的影响。使用Pinecone，用户可以选择备份特定的索引，并将它们保存为“集合”，这些集合可以在以后用来填充新的索引。</p><h4 id="api-and-sdks">2.4.5 API and SDKs</h4><p>这就是关键所在：与数据库进行交互的开发人员希望通过易于使用的 API来实现，并使用熟悉和舒适的工具集。通过提供用户友好的界面，向量数据库 API层简化了高性能向量搜索应用程序的开发。</p><p>除了 API 之外，向量数据库通常还会提供针对特定编程语言的SDK（软件开发工具包），用于封装 API。SDK使开发人员更轻松地在他们的应用程序中与数据库进行交互。这使得开发人员可以专注于他们的具体用例，比如语义文本搜索、生成问答、混合搜索、图像相似性搜索或产品推荐，而无需担心底层基础设施的复杂性。</p><h2 id="总结">3. 总结</h2><p>在自然语言处理（NLP）、计算机视觉和其他人工智能应用等领域，向量嵌入的指数增长导致了向量数据库的出现，它作为计算引擎使我们能够有效地与应用程序中的向量嵌入进行交互。</p><p>向量数据库是专门构建的数据库，专门用于解决在生产环境中管理向量嵌入时出现的问题。因此，它们相比传统基于标量的数据库和独立向量索引提供了显著的优势。</p><p>在本文中，我们回顾了向量数据库的关键方面，包括它的工作原理、所使用的算法以及使其在生产环境中运行的附加功能。我们希望这有助于您理解向量数据库的内部工作机制。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>向量数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>向量数据库</tag>
      
      <tag>Vector Database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 WSL 搭建 Linux 开发环境</title>
    <link href="/2023/07/31/%E4%BD%BF%E7%94%A8-WSL-%E9%85%8D%E7%BD%AE-Linux-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <url>/2023/07/31/%E4%BD%BF%E7%94%A8-WSL-%E9%85%8D%E7%BD%AE-Linux-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<p>如何方便、快捷地在 Windows 和 Linux 两个操作系统切换，以既能够使用Windows 的办公软件等，也能够使用 Linux的开发工具，是一个困扰不少程序员的问题。通常的解决方案有以下几种：</p><ul><li>双系统：系统之间切换必须关机并重启；能够使用最原汁原味且无性能损失的操作系统</li><li>虚拟机：方便系统之间切换；启动关闭较慢，虚拟机软件较沉重</li><li>远程开发机：原生 Linux 系统，通常硬件配置不错；需要网络</li></ul><p>上述方案结合实际需求和场景，往往能够满足日常需求。不过，随着微软推出适用于Linux 的 Windows 子系统（Windows Subsystem forLinux，WSL），我们也多了一个在 Windows 和 Linux之间更加无缝切换的选项。本文对如何使用 WSL 搭建 Linux C/C++开发环境做简要介绍。</p><h2 id="安装-wsl">1. 安装 WSL</h2><p>WSL 的安装非常简单，参考微软详细的 <ahref="https://learn.microsoft.com/zh-cn/windows/wsl/install">安装文档</a>即可。</p><p>同时，推荐阅读 WSL 的其他相关文档，对 WSL的基本概念及原理有大概的认识，并学习 WSL常用的命令。以下是供参考的文档：</p><ul><li><ahref="https://learn.microsoft.com/zh-cn/windows/wsl/basic-commands">WSL基本命令</a></li><li><ahref="https://learn.microsoft.com/zh-cn/windows/wsl/tutorials/wsl-vscode">WSL搭配 VS Code 使用指南</a></li><li><ahref="https://learn.microsoft.com/pdf?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fwindows%2Fwsl%2Ftoc.json">WSL官方中文 PDF文档</a>：提供了概念、安装、使用、开发环境搭建等一系列说明</li></ul><h2 id="更新软件源">2. 更新软件源</h2><p>Ubuntu 默认的软件源在国内访问很慢，本节以 Ubuntu 22.04配置阿里云源为例，介绍如何更新软件源。注意，不同的 Ubuntu版本，软件源的地址并不一致，请根据实际情况修改。</p><p>首先进行备份：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">cp</span> /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></code></pre></td></tr></table></figure><p>然后，编辑文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo vim /etc/apt/sources.list</span><br></code></pre></td></tr></table></figure><p>并用以下内容覆盖原本内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">deb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse<br></code></pre></td></tr></table></figure><p>保存并退出编辑，执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt update</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt upgrade</span><br></code></pre></td></tr></table></figure><p>完成包更新。</p><h2 id="安装-cc-开发工具">3. 安装 C/C++ 开发工具</h2><p>WSL 默认没有安装 gcc、g++、make 等 C/C++开发工具，需要我们手动安装。执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt install build-essential gdb</span><br></code></pre></td></tr></table></figure><p>执行完成后，将安装 gcc、g++、make 和 gdb 等开发工具。</p><p>然后，使用以下命令验证是否安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc --version</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">g++ --version</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make --version</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">gdb --version</span><br></code></pre></td></tr></table></figure><p>若正常输出版本号等信息，则安装成功。</p><p>至此，你已收获一个在 Windows 系统能够无缝切换并使用 Linux进行程序开发的环境。</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>Linux</category>
      
      <category>开发环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Windows Subsystem for Linux（WSL）</tag>
      
      <tag>Ubuntu</tag>
      
      <tag>开发环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小样本字体生成</title>
    <link href="/2023/07/01/%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90/"/>
    <url>/2023/07/01/%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90/</url>
    
    <content type="html"><![CDATA[<p>本文介绍 Few-shot Font Generation 的基本概念和两篇论文。</p><p>两篇论文为：</p><ul><li><ahref="https://openaccess.thecvf.com/content/CVPR2021/papers/Xie_DG-Font_Deformable_Generative_Networks_for_Unsupervised_Font_Generation_CVPR_2021_paper.pdf">DG-Font:Deformable Generative Networks for Unsupervised Font Generation</a></li><li><ahref="https://openaccess.thecvf.com/content/CVPR2023/papers/Wang_CF-Font_Content_Fusion_for_Few-Shot_Font_Generation_CVPR_2023_paper.pdf">CF-Font:Content Fusion for Few-shot Font Generation</a></li></ul><p>也可参考整理的 <a href="FFG.pdf">slides</a>。</p><h2 id="背景">1. 背景</h2><p>不同于英语，由 ASCII 码（8 位二进制，且仅使用其中 7位）即可表示绝大多数常用字母和符号。中日韩语言由上万个字组成，因此，想构建一个新字体往往涉及大量的工作，需要专业字体设计人员一个字一个字地设计。小样本字体生成（Few-shotFont Generation,FFG）就是在这样的背景下提出的，它希望在给定标准内容字体（通常为宋体或楷体）的情况下，使用少量的风格字（如自己的手写体或新设计字体），就可以由模型自动生成目标风格的其他字。这样，我们仅需花费少量精力设计几个风格字体，其余字由模型自动生成即可，大大降低劳动量。</p><p>在 GAN 提出后，FFG领域取得了许多不错的进展。目前的方法也大多基于生成对抗模型进行字体生成。此外，FFG领域的一个核心问题就是如何将文字的内容（content）与风格（style）解耦合，模型的不同分支能够分别学习到内容和风格的特征表示。在推理时，给定几个风格字体（称为：reference），风格编码器基于这些reference提取特征并进行平均，作为目标字体的风格特征向量。在已有的内容字体上的每个字轮流使用特征编码器提取内容特征，将内容特征与风格特征融合，输入解码器，即可生成目标字体。</p><p>下面，分别介绍两篇已有的工作。</p><h2 id="df-font">2. DF-Font</h2><p>本文的 motivation是：不同的字体之间，其笔画、偏旁等常常不在相同的位置，而是有一个区域变换。传统的卷积只能感知固定区域的像素并逐层提取语义信息；而变形卷积能够自动学习偏移量（offset），使卷积核的感受野不再局限于固定的区域，进而能够学习到更好的内容特征表示。下面介绍具体做法。</p><center><img src="/2023/07/01/%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90/image-20230701221526835.png" class="" title="image-20230701221526835"></center><p><br></p><p>由上面论文主图可以看出，模型整体分为生成器和判别器两个部分，即典型的GAN 结构。具体地，生成器包括两个分支：</p><ul><li>上面为 style encoder，给定字体图片，将生成图片的风格特征向量</li><li>下面为 contentencoder，给定字体图片，将生成图片的内容特征图；同时，后面紧跟着decoder，将内容和风格表示融合，生成目标字体图片</li><li>下面的内容表示及生成分支还有两个 FDSC模块，其应用了变形卷积，图示和具体介绍如下：</li></ul><center><img src="/2023/07/01/%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90/image-20230701222142980.png" class="" title="image-20230701222142980"></center><p>可变形卷积实际上由两个卷积核构成：</p><ul><li><p>第一个卷积核输入是 content encoder 的特征图 <spanclass="math inline">\(K_c\)</span> 以及后面 mixer 的特征图 <spanclass="math inline">\(K_s\)</span>；生成 offset 和 mask，即： <spanclass="math display">\[\Theta=f_\theta\left(K_s, K_c\right)\]</span> 其中，<span class="math inline">\(f_\theta\)</span>表示卷积层， <span class="math inline">\(\Theta=\left\{\Delta p_k,\Delta m_k\right.\)</span> <span class="math inline">\(|k=1, \cdots,|\mathcal{R} \mid\}\)</span> 为卷积层输出的 offset 和 mask，<spanclass="math inline">\(\mathcal{R}=\{(-1,-1),(-1,0),\cdots,(0,1),(1,1)\}\)</span> 表示普通卷积的 offset；</p></li><li><p>输出 offset 和 mask 后，后续的卷积层 <spanclass="math inline">\(f_{DC}\)</span> 将输出特征图 <spanclass="math inline">\(K_c^{\prime}\)</span> <spanclass="math display">\[K_c^{\prime}=f_{D C}\left(K_c, \Theta\right)\]</span> 此时，变形卷积 <span class="math inline">\(f_{DC}(\cdot)\)</span> 每个像素的计算公式可表示为： <spanclass="math display">\[K_c^{\prime}(p)=\sum_{k=1}^{\mathcal{R}} w\left(p_k\right) \cdotx\left(p+p_k+\Delta p_k\right) \cdot \Delta m_k\]</span></p></li></ul><p>然后，介绍损失函数设计，共有 4 个部分：</p><ul><li><p>对抗损失：即 GAN 的损失，用来保证生成逼真的图像：</p><center><img src="/2023/07/01/%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90/image-20230701223602085.png" class="" title="image-20230701223602085"></center></li><li><p>内容一致性损失：</p><center><img src="/2023/07/01/%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90/image-20230701223612919.png" class="" title="image-20230701223612919"></center></li><li><p>图像重构损失：</p><center><img src="/2023/07/01/%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90/image-20230701223620435.png" class="" title="image-20230701223620435"></center></li><li><p>偏移量归一化损失：</p><center><img src="/2023/07/01/%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90/image-20230701223627704.png" class="" title="image-20230701223627704"></center></li></ul><p>总损失表示为：</p><center><img src="/2023/07/01/%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90/image-20230701223642827.png" class="" title="image-20230701223642827"></center><p>然后是实验结果：</p><center><img src="/2023/07/01/%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90/image-20230701223940563.png" class="" title="image-20230701223940563"></center><center><img src="/2023/07/01/%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90/image-20230701224008919.png" class="" title="image-20230701224008919"></center><p><br></p><p>相比之前方法，本文方法在 unseen fonts 上所有指标表现最好；在 seenfonts 上，感知性指标表现最好，像素性指标则一般。</p><h2 id="cf-font">3. CF-Font</h2><p>本文是对上篇论文的改进，其主要贡献在于：提出了内容融合模块（ContentFusion Module），让模型学得更好的内容表示。此外，在 loss及风格特征向量的表示上也有改进，下面具体介绍。</p><center><img src="/2023/07/01/%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90/image-20230701224503851.png" class="" title="image-20230701224503851"></center><p><br></p><p>首先是主图，可以发现和前篇文章的确差不多。多出的是 Content FusionModule 和 Iterative Style-vector Refinement，下面分别介绍。</p><p>传统的内容字体选取由两种方式：</p><ul><li>对所有目标字体，都选取宋体作为 content font（下图黄色线）</li><li>对给定目标字体，从候选集合中选择与目标字体最接近的字体作为 contentfont（下图红色线）</li></ul><p>本文则提出了一种新方法，其从可选的 <spanclass="math inline">\(N\)</span>个字体中提取特征图，进行聚类，聚类中心设置为 <spanclass="math inline">\(M\)</span> 个，选择距离聚类中心最近的 <spanclass="math inline">\(M\)</span> 个字体作为基字体（basisfont）；然后，对于给定的目标字体，计算其与 basis fonts 的相似度，经过softmax函数后赋予权重；权重与基字体相乘并求和，得到全新的内容特征图表示方式，公式表示如下：</p><ol type="1"><li><p>聚类 <span class="math display">\[\begin{aligned}\boldsymbol{C}_i &amp; =f_{c e}\left(\boldsymbol{I}_i\right),{ }^1 \\\boldsymbol{d}_i &amp; =\left(d_{i 1}, d_{i 2}, \ldots, d_{i N}\right),\quad d_{i j}=\left\|\boldsymbol{C}_i-\boldsymbol{C}_j\right\|_1, \\\boldsymbol{e}_i &amp; =\sigma\left(\boldsymbol{d}_i\right), \\\mathcal{B} &amp;=\operatorname{Cluster}\left(M,\left\{\boldsymbol{e}_1,\boldsymbol{e}_2, \ldots, \boldsymbol{e}_N\right\}\right),\end{aligned}\]</span></p></li><li><p>计算权重 <span class="math display">\[\begin{aligned}\boldsymbol{d}_t^{\prime} &amp; =\left(d_{t 1}, d_{t 2}, \ldots, d_{tM}\right), \quad d_{tm}=\left\|\boldsymbol{C}_t-\boldsymbol{C}_m\right\|_1, \\\boldsymbol{w}_t &amp; =\sigma\left(-\boldsymbol{d}_t^{\prime} /\tau\right),\end{aligned}\]</span></p></li><li><p>得到新特征表示 <span class="math display">\[\boldsymbol{C}_t^{\prime}=\sum_{m \in \mathcal{B}} w_{t m} \cdot\boldsymbol{C}_m\]</span></p></li></ol><p>示意图如下：</p><center><img src="/2023/07/01/%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90/image-20230701225207555.png" class="" title="image-20230701225207555"></center><p>此外，提出了一个新的 loss，用来在 generated image 和 ground-truthimage 的投影分类后的分布施加限制：</p><center><img src="/2023/07/01/%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90/image-20230701225120502.png" class="" title="image-20230701225120502"></center><p><br></p><p>公式表示为： <span class="math display">\[\mathcal{L}_p(\boldsymbol{Y}, \hat{\boldsymbol{Y}})=\frac{1}{P}\sum_{p=1}^P \mathcal{L}_{1 d}\left(\phi_p(\boldsymbol{Y}),\phi_p(\hat{\boldsymbol{Y}})\right),\]</span> <span class="math inline">\(\mathcal{L}_{1 d}\)</span>表示两个分布之间的差异，可选用推土机距离或者 KL 散度，分布表示为： <spanclass="math display">\[\begin{aligned}\mathcal{L}_{p c-w d l}(\boldsymbol{Y}, \hat{\boldsymbol{Y}}) &amp;=\frac{1}{P}\sum_{p=1}^P\left\|\frac{\Lambda\left(\phi_p(\boldsymbol{Y})\right)}{\sum\phi_p(\boldsymbol{Y})}-\frac{\Lambda\left(\phi_p(\hat{\boldsymbol{Y}})\right)}{\sum\phi_p(\hat{\boldsymbol{Y}})}\right\| \\\mathcal{L}_{p c-k l}(\boldsymbol{Y}, \hat{\boldsymbol{Y}}) &amp;=\frac{1}{P} \sum_{p=1}^P \mathbf{KL}\left(\frac{\phi_p(\boldsymbol{Y})}{\sum\phi_p(\boldsymbol{Y})}-\frac{\phi_p(\hat{\boldsymbol{Y}})}{\sum\phi_p(\hat{\boldsymbol{Y}})}\right),\end{aligned}\]</span> 其余损失与上文相同，总损失函数表示为： <spanclass="math display">\[\begin{array}{r}\mathcal{L}=\mathcal{L}_{a d v}+\lambda_{\text {img}}\left(\mathcal{L}_{\text {img }}+\lambda_{\text {pll }}\mathcal{L}_{\text {pcl }}\right) \\+\lambda_{\text {cnt }} \mathcal{L}_{\text {cnt }}+\lambda_{\text{offset }} \mathcal{L}_{\text {offset }},\end{array}\]</span></p><p>在推理阶段，初始化风格特征向量为已有的几个 reference image特征向量的均值： <span class="math display">\[\boldsymbol{s}_t^{\prime}=\frac{1}{Q} \sum_{q=1}^Q f_{se}\left(\boldsymbol{I}_t^q\right)\]</span>然后，设置该特征向量为可学习的，并冻结模型其他部分的参数，使用重构损失微调大约10 个 epoch：</p><center><img src="/2023/07/01/%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90/image-20230701230455898.png" class="" title="image-20230701230455898"></center><p>使用最终微调后的特征向量作为推理时使用的风格特征向量。</p><p>最后是实验：</p><center><img src="/2023/07/01/%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90/image-20230701230621924.png" class="" title="image-20230701230621924"></center><center><img src="/2023/07/01/%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90/image-20230701230641799.png" class="" title="image-20230701230641799"></center><p><br></p><p>在绝大多数指标上，本文方法均超过已有方法。</p>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
      <category>读论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Few-shot Font Gereration</tag>
      
      <tag>FFG</tag>
      
      <tag>字体生成</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Git LFS管理大文件及GitHub LFS扩容</title>
    <link href="/2023/05/25/LFS%E6%89%A9%E5%AE%B9/"/>
    <url>/2023/05/25/LFS%E6%89%A9%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<p>在使用 Git管理代码库时，如果代码仓库中有含有大文件，则可能出现错误。特别是当上传代码库到GitHub 仓库时，由于 GitHub 有文件大小限制（100MB 以上文件 push失败；50MB 以上文件可以 push 成功，但是会有警告；且 GitHub 仅支持 1GB的免费容量；详情参考：<ahref="https://docs.github.com/zh/repositories/working-with-files/managing-large-files/about-large-files-on-github">https://docs.github.com/zh/repositories/working-with-files/managing-large-files/about-large-files-on-github</a>），因此必须使用Git Large File Storage（GitLFS）工具，对代码库进行适当的设置，以正常使用 Git进行版本控制及提交至远程仓库。本文介绍 Git LFS的安装及基本使用方法，并介绍如何扩大 GitHub LFS 存储容量。</p><h2 id="git-lfs-安装">1. Git LFS 安装</h2><p>Git LFS 的安装非常简单，具体参考官网：<ahref="https://git-lfs.com/">https://git-lfs.com/</a>，根据自己的操作系统等环境选择合适的安装方法。本文以 Ubuntu上安装为例介绍。</p><p>安装命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | sudo bash</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install git-lfs</span><br></code></pre></td></tr></table></figure><p>首先下载并运行脚本，对系统环境进行检查及更新；然后使用 apt 安装 GitLFS 即可。</p><p>详情参考：<ahref="https://github.com/git-lfs/git-lfs/blob/main/INSTALLING.md">https://github.com/git-lfs/git-lfs/blob/main/INSTALLING.md</a>。</p><h2 id="git-lfs-基本用法">2. Git LFS 基本用法</h2><p>安装完成后，使用 Git LFS 对代码库进行一些设置，即可正常管理大文件并push 到远程仓库。</p><p>首先，进入代码库根目录，然后运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git lfs install</span><br></code></pre></td></tr></table></figure><p>这条命令是为了让该仓库支持 LFS 存储。</p><p>然后，设置使用 Git LFS 追踪的文件类型，根据自己需求调整即可，这里以<code>pth</code> 文件为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git lfs track <span class="hljs-string">&quot;*.pth&quot;</span></span><br></code></pre></td></tr></table></figure><p>运行该命令后，将生成（或修改）仓库下的 <code>.gitattributes</code>文件，使用 <code>git add .gitattributes</code>命令将该文件添加到暂存区并提交：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add .gitattributes</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git commit -m <span class="hljs-string">&#x27;support LFS&#x27;</span></span><br></code></pre></td></tr></table></figure><p>注意，如果你是已经出现了提交错误然后才进行 Git LFS相关配置，需要先使用 <code>git reset HEAD~x</code> 命令撤销提交（命令中<code>x</code> 取值请根据自己实际情况调整），然后在重新执行<code>add</code> 及 <code>commit</code> 命令。</p><p>至此，即可继续使用 <code>git</code>命令进行开发，不会因为大文件而报错。</p><h2 id="github-lfs-扩容">3. GitHub LFS 扩容</h2><p>经过上述步骤后，在本地即可进行正常的分支管理等 <code>git</code>操作。但是，如果将大文件 push 到 GitHub仓库，则可能遇到类似以下内容的报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">batch response: This repository is over its data quota. Account responsible for LFS bandwidth should purchase more data packs to restore access.<br></code></pre></td></tr></table></figure><p>这是因为上传的文件总大小超过了 GitHub LFS的免费额度。如果想继续上传，需要对 GitHub 账号相关权限进行升级。</p><p>首先，进入 GitHub 设置页面并点击进入如下页面：</p><center><img src="/2023/05/25/LFS%E6%89%A9%E5%AE%B9/image-20230525221616086.png" class="" title="image-20230525221616086"></center><p>也可以直接访问：<a href="https://github.com/settings/billing">Billing(github.com)</a> 查看。</p><p>将该页面拉到下面，可以查看 Git LFS Data：</p><center><img src="/2023/05/25/LFS%E6%89%A9%E5%AE%B9/image-20230525221836887.png" class="" title="image-20230525221836887"></center><p>默认的存储和带宽都是 1GB（示例图片是升级后的容量）。</p><p>点击右上角的 <code>Edit</code> 按钮，并选择<code>Add more data packs</code> 即可进行 GitHub LFS 容量升级。</p><p>在升级之前，需要先设置好付款账户，按照 GitHub页面指引操作即可，这里推荐使用 PayPal。</p><p>PayPal 官网为：<a href="https://www.paypal.com/">PayPal</a>，打开官网后使用 GitHub注册使用的邮箱进行账号注册，并绑定银行卡即可。绑定银行卡时需要填写到期时间、CVC等信息，根据银行卡如实填写即可。以如下网络上图片为例：</p><center><img src="/2023/05/25/LFS%E6%89%A9%E5%AE%B9/image-20230525223008190.png" class="" title="image-20230525223008190"></center><p>CVC 指图片中的后 3 位数字，即：169。填写好完成 PayPal注册及银行卡绑定后，即可回到 GitHub 网页，在付款方式绑定页面选择 PayPal方式即可，GitHub 会自动检测使用 GitHub 注册邮箱注册的 PayPal账号并尝试绑定，出现提示信息后同意绑定即可。</p><p>绑定好 PayPal 账号后，确认升级 GitHub LFS 容量，即可顺利在 GitHub提交大文件。</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git LFS</tag>
      
      <tag>LFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C 语言拾遗</title>
    <link href="/2023/05/01/C-%E8%AF%AD%E8%A8%80%E6%8B%BE%E9%81%97/"/>
    <url>/2023/05/01/C-%E8%AF%AD%E8%A8%80%E6%8B%BE%E9%81%97/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作为第一门语言是 C++ 的程序员，一直觉得对 C语言的一些重要特性不清晰，对一些 C 程序惯用法也不了解。故借阅读 《C程序设计语言》 一书的机会，将相关曾经遗漏的知识整理如下。</p></blockquote><h2 id="extern-声明">1. extern 声明</h2><p><code>extern</code>关键字用于声明外部变量，注意声明与定义的不同：</p><ul><li>定义（define）：表示创建变量或分配存储单元</li><li>声明（declaration）：说明变量的性质，但并不分配存储单元</li></ul><p>当外部变量的定义出现在使用它的函数之前时，可以省略<code>extern</code> 声明；反之，必须有 <code>extern</code>声明（如：涉及多个源文件）。</p><p>Example：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> n = <span class="hljs-number">1</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> n;<span class="hljs-meta"># extern declaration</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>用 <code>static</code>关键字修饰外部变量或函数，可以将其后声明的对象的作用域限定为被编译文件的剩余部分，其他文件不能访问该对象。</p><p><code>static</code>也可用于声明内部变量：该变量仅能在某函数内使用但一直占据存储空间。</p><h2 id="宏">2. 宏</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 取消宏定义</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> getchar</span><br><br><br><span class="hljs-comment">// 调试打印宏</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> dprint(expr) printf(#expr <span class="hljs-string">&quot; = %g\n&quot;</span>, expr)</span><br><br>dprint(x/y);<br><br><span class="hljs-comment">// 宏将展开为：</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x/y&quot;</span> <span class="hljs-string">&quot; = %g\n&quot;</span>, x/y);<br><br><br><span class="hljs-comment">// 预处理器运算符 ##</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> paste(front, end) front ## end</span><br><br><span class="hljs-comment">// 宏调用 paste(name, 1) 的结果将创建符号 name1</span><br></code></pre></td></tr></table></figure><p>条件包含</p><p>example 1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(HDR)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HDR</span><br><br><span class="hljs-comment">/* hdr.h 文件内容 */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> HDR</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HDR</span><br><br><span class="hljs-comment">/* code here */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>example 2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> SYSTEM == SYSV</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HDR <span class="hljs-string">&quot;sysv.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> SYSTEM == BSD:</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HDR <span class="hljs-string">&quot;bsd.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> SYSTEM == MSDOS:</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HDR <span class="hljs-string">&quot;msdos.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span>:</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HDR <span class="hljs-string">&quot;default.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> HDR</span><br></code></pre></td></tr></table></figure><h2 id="union">3. union</h2><p><code>union</code>：在不同时刻保存不同类型和长度的对象的变量。</p><p>example：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">u_tag</span> &#123;</span><br>    <span class="hljs-type">int</span> ival;<br>    <span class="hljs-type">float</span> fval;<br>    <span class="hljs-type">char</span> *sval;<br>&#125; u;<br></code></pre></td></tr></table></figure><p><code>union</code> 实际上就是<code>struct</code>，它的所有成员相对与基地址的偏移量都为 0，此<code>struct</code>空间要大到足够容纳最宽的成员，并且，其对齐方式要适合于<code>union</code> 中所有类型的成员。</p><h2 id="位字段-bit-field">4. 位字段 bit-field</h2><p>example：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 定义位字段，&#x27;:&#x27; 后数字表示字段的宽度</span><br><span class="hljs-comment">// 字段作用与小整数类似，可以出现在算术表达式中</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> is_keyword : <span class="hljs-number">1</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> is_extern : <span class="hljs-number">1</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> is_static : <span class="hljs-number">1</span>;<br>&#125; flags;<br><br><span class="hljs-comment">// 设置字段值</span><br>flags.is_extern = flags.is_static = <span class="hljs-number">1</span>;<br>flags.is_extern = flags.is_static = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 位测试</span><br><span class="hljs-keyword">if</span> (flags.is_extern == <span class="hljs-number">0</span> &amp;&amp; flags.is_static ==<span class="hljs-number">0</span>)<br>    ...<br></code></pre></td></tr></table></figure><p>字段不是数组，且没有地址，不能对其使用 <code>&amp;</code>运算符。</p><h2 id="文件访问">5. 文件访问</h2><p>example：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c">FILE *fp = fopen(name, mode);<span class="hljs-comment">// 以指定 mode 打开文件；失败返回 NULL</span><br>fclose(fp);<span class="hljs-comment">// 关闭文件</span><br><br><span class="hljs-comment">// 从文件中返回下一个字符；若达到文件结尾或出错，返回 EOF</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getc</span><span class="hljs-params">(FILE *fp)</span>;<br><br><span class="hljs-comment">// 将字符 c 写入到 fp 指向的文件中，并返回写入的字符</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">putc</span><span class="hljs-params">(<span class="hljs-type">int</span> c, FILE *fp)</span>;<br><br><span class="hljs-comment">// 对文件的格式化输入输出</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fscanf</span><span class="hljs-params">(FILE *fp, <span class="hljs-type">char</span> *format, ...)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">fprintf</span><span class="hljs-params">(FILE *fp, <span class="hljs-type">char</span> *format, ...)</span>;<br><br><span class="hljs-comment">// 错误判断</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ferror</span><span class="hljs-params">(FILE *fp)</span>;<span class="hljs-comment">// 如果流 fp 中出现错误，则返回一个非 0 值</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">feof</span><span class="hljs-params">(FILE *fp)</span>;<span class="hljs-comment">// 如果文件到达文件结尾，返回一个非 0 值</span><br><br><span class="hljs-comment">// 行输入和行输出</span><br><span class="hljs-comment">// 从 fp 指向的文件中读取下一个输入行（包括换行符），并将它存放在 line 中。最多读取 maxline-1 个字符。正常结束返回 line；出错返回 NULL</span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">fgets</span><span class="hljs-params">(<span class="hljs-type">char</span> *line, <span class="hljs-type">int</span> maxline, FILE *fp)</span>;<br><span class="hljs-comment">// 将 line 写入 fp 指向的文件中。出错返回 EOF；否则返回一个非负值。</span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">fputs</span><span class="hljs-params">(<span class="hljs-type">char</span> *line, FILE *fp)</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>C</category>
      
    </categories>
    
    
    <tags>
      
      <tag>define</tag>
      
      <tag>extern</tag>
      
      <tag>union</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据集与样本难度度量</title>
    <link href="/2023/03/12/%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8E%E6%A0%B7%E6%9C%AC%E9%9A%BE%E5%BA%A6%E5%BA%A6%E9%87%8F/"/>
    <url>/2023/03/12/%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8E%E6%A0%B7%E6%9C%AC%E9%9A%BE%E5%BA%A6%E5%BA%A6%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<p>本文分享关于数据集与样本难度度量的论文，具体为：</p><ul><li><a href="https://arxiv.org/pdf/2002.10689">A Theory of UsableInformation Under Computational Constraints</a></li><li><ahref="https://proceedings.mlr.press/v162/ethayarajh22a/ethayarajh22a.pdf">UnderstandingDataset Difficulty with <spanclass="math inline">\(\mathcal{V}\)</span>-Usable Information</a></li></ul><p>主要内容来自于组会分享，slides 可<ahref="Dataset%20&amp;%20Example%20Difficulty.pdf">点此查看</a>。</p><h2 id="香农互信息">1. 香农互信息</h2><p>在概率论和信息论中，两个随机变量的互信息（MutualInformation，MI）度量了两个变量之间相互依赖的程度。具体来说，对于两个随机变量，MI是一个随机变量由于已知另一个随机变量而减少的“信息量”（单位通常为比特）。</p><p>离散随机变量 X 和 Y 的互信息可以计算为：</p><center><img src="/2023/03/12/%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8E%E6%A0%B7%E6%9C%AC%E9%9A%BE%E5%BA%A6%E5%BA%A6%E9%87%8F/image-20230312222959237.png" class="" title="离散变量香农互信息定义"></center><p>其中 p(x, y) 是 <em>X</em> 和 <em>Y</em> 的联合概率质量函数，而 p(x)和 p(y) 分别是 <em>X</em> 和 <em>Y</em> 的边缘概率质量函数。</p><p>互信息又可以等价地表示成：</p><center><img src="/2023/03/12/%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8E%E6%A0%B7%E6%9C%AC%E9%9A%BE%E5%BA%A6%E5%BA%A6%E9%87%8F/image-20230312223006884.png" class=""></center><p>但是，在机器学习场景下，香农互信息与我们目前的一些经验性认识存在冲突，比如下面图片展示的例子：</p><center><img src="/2023/03/12/%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8E%E6%A0%B7%E6%9C%AC%E9%9A%BE%E5%BA%A6%E5%BA%A6%E9%87%8F/image-20230312223134757.png" class="" title="明文与密文与标签的香农互信息相等"></center><p>在香农互信息理论下，<em>明文与标注的互信息</em> 和<em>密文与标注的互信息</em>相等。但是，对于我们人类而言，从明文能够轻易识别出标注；而不能够根据密文判断标注。即如下图所示：</p><center><img src="/2023/03/12/%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8E%E6%A0%B7%E6%9C%AC%E9%9A%BE%E5%BA%A6%E5%BA%A6%E9%87%8F/image-20230312223458019.png" class=""></center><p>为了解决这一冲突，作者提出了新的概念：考虑计算约束下的互信息。</p><h2 id="对香农互信息的扩展定义mathcalv-information">2.对香农互信息的扩展定义——<spanclass="math inline">\(\mathcal{V}\)</span>-Information</h2><p>首先，作者引入三个概念：</p><ol type="1"><li><p><strong>predictive family</strong></p><p>Let <span class="math inline">\(\Omega=\{f: \mathcal{X}\cup\{\varnothing\} \rightarrow \mathcal{P}(\mathcal{Y})\}\)</span>. Wesay that <span class="math inline">\(\mathcal{V} \subseteq\Omega\)</span> is a predictive family if it satisfies <spanclass="math display">\[\forall f \in \mathcal{V}, \forall P \in \operatorname{range}(f), \quad\exists f^{\prime} \in \mathcal{V}, \quad \text { s.t. } \quad \forall x\in \mathcal{X}, f^{\prime}[x]=P, f^{\prime}[\varnothing]=P\]</span></p></li><li><p><strong>predictive conditional <spanclass="math inline">\(\mathcal{V}\)</span>-entropy</strong></p><p>Let <span class="math inline">\(X, Y\)</span> be two random variablestaking values in <span class="math inline">\(\mathcal{X} \times\mathcal{Y}\)</span>, and <spanclass="math inline">\(\mathcal{V}\)</span> be a predictive family. Thenthe predictive conditional <spanclass="math inline">\(\mathcal{V}\)</span>-entropy is defined as <spanclass="math display">\[\begin{aligned}H_{\mathcal{V}}(Y \mid X) &amp; =\inf _{f \in \mathcal{V}}\mathbb{E}_{x, y \sim X, Y}[-\log f[x](y)] \\H_{\mathcal{V}}(Y \mid \varnothing) &amp; =\inf _{f \in \mathcal{V}}\mathbb{E}_{y \sim Y}[-\log f[\varnothing](y)]\end{aligned}\]</span> We additionally call <spanclass="math inline">\(H_{\mathcal{V}}(Y \mid \varnothing)\)</span> the<span class="math inline">\(\mathcal{V}\)</span>-entropy, and alsodenote it as <span class="math inline">\(H_{\mathcal{V}}(Y)\)</span>.</p></li><li><p><strong>predictive conditional <spanclass="math inline">\(\mathcal{V}\)</span>-information</strong></p><p>Let <span class="math inline">\(X, Y\)</span> be two random variablestaking values in <span class="math inline">\(\mathcal{X} \times\mathcal{Y}\)</span>, and <spanclass="math inline">\(\mathcal{V}\)</span> be a predictive family. Thepredictive <span class="math inline">\(\mathcal{V}\)</span>-informationfrom <span class="math inline">\(X\)</span> to <spanclass="math inline">\(Y\)</span> is defined as <spanclass="math display">\[I_{\mathcal{V}}(X \rightarrow Y)=H_{\mathcal{V}}(Y \mid\varnothing)-H_{\mathcal{V}}(Y \mid X)\]</span></p></li></ol><p><span class="math inline">\(\mathcal{V}\)</span>-information有以下一些性质：</p><ul><li><p>基本性质</p><p>Let <span class="math inline">\(Y\)</span> and <spanclass="math inline">\(X\)</span> be any random variables on <spanclass="math inline">\(\mathcal{Y}\)</span> and <spanclass="math inline">\(\mathcal{X}\)</span>, and <spanclass="math inline">\(\mathcal{V}\)</span> and <spanclass="math inline">\(\mathcal{U}\)</span> be any predictive families,then we have</p><ul><li>Monotonicity: If <span class="math inline">\(\mathcal{V} \subseteq\mathcal{U}\)</span>, then <spanclass="math inline">\(H_{\mathcal{V}}(Y) \geq H_{\mathcal{U}}(Y),H_{\mathcal{V}}(Y \mid X) \geq H_{\mathcal{U}}(Y \mid X)\)</span>.</li><li>Non-Negativity: <span class="math inline">\(I_{\mathcal{V}}(X\rightarrow Y) \geq 0\)</span>.</li><li>Independence: If <span class="math inline">\(X\)</span> isindependent of <span class="math inline">\(Y, I_{\mathcal{V}}(X\rightarrow Y)=I_{\mathcal{V}}(Y \rightarrow X)=0\)</span>.</li></ul></li><li><p>数据处理不等式（与香农互信息不同）</p><ul><li><strong>Shannon Mutual Information</strong>: Letting <spanclass="math inline">\(t: \mathcal{X} \rightarrow \mathcal{X}\)</span> beany function, <span class="math inline">\(t(X)\)</span> cannot havehigher mutual information with <span class="math inline">\(Y\)</span>than <span class="math inline">\(X: I(t(X) ; Y) \leq I(X ;Y)\)</span>.</li><li><strong><spanclass="math inline">\(\mathcal{V}\)</span>-Information</strong>:Denoting <span class="math inline">\(t\)</span> as the decryptionalgorithm and <span class="math inline">\(\mathcal{V}\)</span> as aclass of natural language processing functions, we have that: <spanclass="math inline">\(I_{\mathcal{V}}(t(X) \rightarrowY)&gt;I_{\mathcal{V}}(X \rightarrow Y) \approx 0\)</span>.</li></ul></li><li><p>不对称性（与香农互信息不同）</p><p>If <span class="math inline">\(\mathcal{V}\)</span> contains allpolynomial-time computable functions, then <spanclass="math inline">\(I_{\mathcal{V}}(X \rightarrow h(X)) \ggI_{\mathcal{V}}(h(X) \rightarrow X)\)</span> , where <spanclass="math inline">\(h: \mathcal{X} \rightarrow\mathcal{Y}\)</span>.</p></li></ul><p>根据 <span class="math inline">\(\mathcal{V}\)</span>-information的性质，我们就能够合理解释上面例子展示的问题，从而有：</p><center><img src="/2023/03/12/%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8E%E6%A0%B7%E6%9C%AC%E9%9A%BE%E5%BA%A6%E5%BA%A6%E9%87%8F/image-20230312225113429.png" class=""></center><p><br></p><p>上面介绍的是 <spanclass="math inline">\(\mathcal{V}\)</span>-Information的严格定义，但是在机器学习中，我们不存在真实的分布，而是仅有从分布上采样的有限大小的数据集。下面，作者要解决如何在有限大小的数据集上估计<span class="math inline">\(\mathcal{V}\)</span>-Information：</p><p>Let <span class="math inline">\(X, Y\)</span> be two random variablestaking values in <span class="math inline">\(\mathcal{X},\mathcal{Y}\)</span> and <spanclass="math inline">\(\mathcal{D}=\left\{\left(x_i,y_i\right)\right\}_{i=1}^N \sim X, Y\)</span> denotes the set of samplesdrawn from the joint distribution over <spanclass="math inline">\(\mathcal{X}\)</span> and <spanclass="math inline">\(\mathcal{Y} . \mathcal{V}\)</span> is a predictivefamily. The empirical <spanclass="math inline">\(\mathcal{V}\)</span>-information (under <spanclass="math inline">\(\mathcal{D}\)</span> ) is the following <spanclass="math inline">\(\mathcal{V}\)</span>-information under theempirical distribution defined via <spanclass="math inline">\(\mathcal{D}\)</span> : <spanclass="math display">\[\hat{I}_{\mathcal{V}}(X \rightarrow Y ; \mathcal{D})=\inf _{f \in\mathcal{V}} \frac{1}{|\mathcal{D}|} \sum_{y_i \in \mathcal{D}} \log\frac{1}{f[\varnothing]\left(y_i\right)}-\inf _{f \in \mathcal{V}}\frac{1}{|\mathcal{D}|} \sum_{x_i, y_i \in \mathcal{D}} \log\frac{1}{f\left[x_i\right]\left(y_i\right)}\]</span> Then we have the following PAC bound over the empirical <spanclass="math inline">\(\mathcal{V}\)</span>-information:</p><p>Assume <span class="math inline">\(\forall f \in \mathcal{V}, x \in\mathcal{X}, y \in \mathcal{Y}, \log f[x](y) \in[-B, B]\)</span>. Thenfor any <span class="math inline">\(\delta \in(0,0.5)\)</span>, withprobability at least <span class="math inline">\(1-2 \delta\)</span>, wehave: <span class="math display">\[\left|I_{\mathcal{V}}(X \rightarrow Y)-\hat{I}_{\mathcal{V}}(X\rightarrow Y ; \mathcal{D})\right| \leq 4\mathfrak{R}_{|\mathcal{D}|}\left(\mathcal{G}_{\mathcal{V}}\right)+2 B\sqrt{\frac{2 \log \frac{1}{\delta}}{|\mathcal{D}|}}\]</span> where we define the function family <spanclass="math inline">\(\mathcal{G}_{\mathcal{V}}=\{g \mid g(x, y)=\logf[x](y), f \in \mathcal{V}\}\)</span>, and <spanclass="math inline">\(\mathfrak{R}_N(\mathcal{G})\)</span> denotes theRademacher complexity of <spanclass="math inline">\(\mathcal{G}\)</span> with sample number <spanclass="math inline">\(N\)</span>.</p><h2 id="使用-mathcalv-information-评估数据集和样本难度">3. 使用 <spanclass="math inline">\(\mathcal{V}\)</span>-Information评估数据集和样本难度</h2><p>利用上面介绍的 <spanclass="math inline">\(\mathcal{V}\)</span>-Information工具并进行实验，能够发现一些有趣的现象。</p><center><img src="/2023/03/12/%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8E%E6%A0%B7%E6%9C%AC%E9%9A%BE%E5%BA%A6%E5%BA%A6%E9%87%8F/image-20230312225802256.png" class=""></center><ul><li>大模型 accuracy 与<spanclass="math inline">\(\mathcal{V}\)</span>-Usable Information都更高，因为提取更多的信息让识别更容易</li><li><span class="math inline">\(\mathcal{V}\)</span>-Information 相比accuracy 对过拟合更加敏感</li></ul><center><img src="/2023/03/12/%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8E%E6%A0%B7%E6%9C%AC%E9%9A%BE%E5%BA%A6%E5%BA%A6%E9%87%8F/image-20230312225854120.png" class=""></center><ul><li>提供了衡量不同数据集难度的方法</li></ul><p>然后，引入评估样本点 <spanclass="math inline">\(\mathcal{V}\)</span>-Information （Pointwise <spanclass="math inline">\(\mathcal{V}\)</span>-Information，PVI）的方法：</p><p>Given random variables <span class="math inline">\(X, Y\)</span> anda predictive family <span class="math inline">\(\mathcal{V}\)</span>,the pointwise <spanclass="math inline">\(\mathcal{V}\)</span>-information (PVI) of aninstance <span class="math inline">\((x, y)\)</span> is <spanclass="math display">\[\operatorname{PVI}(x \rightarrow y)=-\log _2 g[\varnothing](y)+\log _2g^{\prime}[x](y)\]</span> where <span class="math inline">\(g \in \mathcal{V}\)</span>s.t. <span class="math inline">\(\mathbb{E}[-\logg[\varnothing](Y)]=H_{\mathcal{V}}(Y)\)</span> and <spanclass="math inline">\(g^{\prime} \in \mathcal{V}\)</span> s.t. <spanclass="math inline">\(\mathbb{E}\left[-\logg^{\prime}[X](Y)\right]=H_{\mathcal{V}}(Y \mid X)\)</span>.</p><p>PVI is to <spanclass="math inline">\(\mathcal{V}\)</span>-information what PMI is toShannon information: <span class="math display">\[\begin{aligned}I(X ; Y) &amp; =\mathbb{E}_{x, y \sim P(X, Y)}[\operatorname{PMI}(x, y)]\\I_{\mathcal{V}}(X \rightarrow Y) &amp; =\mathbb{E}_{x, y \sim P(X,Y)}[\operatorname{PVI}(x \rightarrow y)]\end{aligned}\]</span></p><p>完整算法流程如下：</p><center><img src="/2023/03/12/%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8E%E6%A0%B7%E6%9C%AC%E9%9A%BE%E5%BA%A6%E5%BA%A6%E9%87%8F/image-20230312230205356.png" class=""></center><p><br></p><p>然后，利用 PVI 进行实验，同样可以观察到一些有趣的现象：</p><center><img src="/2023/03/12/%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8E%E6%A0%B7%E6%9C%AC%E9%9A%BE%E5%BA%A6%E5%BA%A6%E9%87%8F/image-20230312230304658.png" class=""></center><ul><li>PVI 最低的样本中存在不少标注错误</li></ul><center><img src="/2023/03/12/%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8E%E6%A0%B7%E6%9C%AC%E9%9A%BE%E5%BA%A6%E5%BA%A6%E9%87%8F/image-20230312230341812.png" class=""></center><ul><li>模型能够正确分类样本的 PVI 阈值在 0.5 左右</li></ul><p><br></p><p>此外，原论文中还展示了一些有趣的实验现象，这里不再赘述，具体请参阅原论文。</p>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
      <category>读论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dataset &amp; example difficulty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 22.04 安装 QEMU 流程</title>
    <link href="/2023/03/03/Ubuntu-22-04-%E5%AE%89%E8%A3%85-QEMU-%E6%B5%81%E7%A8%8B/"/>
    <url>/2023/03/03/Ubuntu-22-04-%E5%AE%89%E8%A3%85-QEMU-%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.qemu.org/download/">QEMU</a>官方网站已经提供了安装 QEMU 的教程，按照其内容，Ubuntu 平台仅需执行<code>sudo apt-get install qemu</code>命令即可。但是，在实际安装过程中遇到了错误且未能解决，于是采用源码方式安装。以QEMU 7.2.0 版本为例，介绍安装流程。</p><ol type="1"><li><p>下载源码并解压缩</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">wget https://download.qemu.org/qemu-7.2.0.tar.xz</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">tar xvJf qemu-7.2.0.tar.xz</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> qemu-7.2.0</span><br></code></pre></td></tr></table></figure></li><li><p>编译前预处理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./configure</span><br></code></pre></td></tr></table></figure></li><li><p>处理报错</p><p>执行上述命令后，可能会出现以下报错：</p><center><img src="/2023/03/03/Ubuntu-22-04-%E5%AE%89%E8%A3%85-QEMU-%E6%B5%81%E7%A8%8B/image-20230303200128068.png" class=""></center><p>报错原因是系统缺少 QEMU 需要的相关依赖。执行以下命令安装依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install ninja-build</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install zlib1g zlib1g-dev</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install libglib2.0-dev</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install libpixman-1-dev</span><br></code></pre></td></tr></table></figure><p>重新执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./configure</span><br></code></pre></td></tr></table></figure></li><li><p>make 编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make</span><br></code></pre></td></tr></table></figure><p>执行上述命令后，开始漫长的编译过程，请耐心等待。</p></li><li><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo make install</span><br></code></pre></td></tr></table></figure></li><li><p>验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">qemu-</span><br></code></pre></td></tr></table></figure><p>输入 <code>qemu-</code> 后按两次 TAB键，若出现类似下面的输出，则安装成功。</p><center><img src="/2023/03/03/Ubuntu-22-04-%E5%AE%89%E8%A3%85-QEMU-%E6%B5%81%E7%A8%8B/image-20230303214138504.png" class="" title="image-20230303214138504"></center></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>QEMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 博客无法显示图片解决方法</title>
    <link href="/2023/02/23/Hexo-%E5%8D%9A%E5%AE%A2%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <url>/2023/02/23/Hexo-%E5%8D%9A%E5%AE%A2%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>Hexo 官方提供了很多在 Markdown 中 <ahref="https://hexo.io/zh-cn/docs/asset-folders#使用-Markdown-嵌入图片">插入图片</a>的方式，其语法主要可分为两种：</p><ol type="1"><li><p>Markdown 原生支持的语法</p><p><code>![图片描述](图片路径)</code></p><p>其中，图片路径不可以使用相对于本地系统的绝对路径，例如：<code>C:/Users/admin/Pictures/a.jpg</code>，这样 Hexo在生成静态网页时无法正确解析图片，从而导致图片无法在网页正常显示。</p><p>正确的图片路径有以下两种形式：</p><ul><li><p>相对于博客的根目录：<code>/imgs/a.jpg</code>，使用这种方式需要在博客 <code>source</code> 目录下新建<code>imgs</code> 文件夹，并在 <code>imgs</code>文件夹中存放文章需要使用的图片。</p><p>例如，使用：<code>/imgs/0_0.jpg</code>语法，可显示如下图片：</p></li></ul><p><img src="/imgs/0_0.jpg" /></p><ul><li><p>相对于某篇博客的相对路径：<code>./article_1/a.jpg</code>。使用这种方式需要在 Hexo 配置文件 <code>_config.yaml</code> 将<code>post_asset_folder</code> 选项设为 <code>true</code> 。然后使用<code>hexo new xxx</code> 新建文章时，Hexo 便会在<code>source/_posts</code>目录下新建与文章同名的文件夹，然后将文章需要使用的图片放在该文件夹中，通过相对路径引用即可。</p><p>例如，使用：<code>Hexo-博客无法显示图片解决方法/0_1.jpg</code>语法，可显示如下图片：</p><img src="/2023/02/23/Hexo-%E5%8D%9A%E5%AE%A2%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/0_1.jpg" class=""></li></ul></li><li><p>Hexo 特有的 asset_img 标签语法</p><p>Hexo 推荐使用的图片引用方式如下：</p><p><code>&#123;% asset_img example.jpg This is an example image %&#125;</code></p><p>但是，这种语法无法在 Markdown编辑器中正常显示图片，会影响我们在编辑器中查看文章内容，个人不推荐这种方式。</p></li></ol><p>经过个人探索，得到以下比较好用的解决方法，能够同时在 Hexo 博客和Markdown 编辑器中正确显示图片。</p><p>首先，根据 Hexo 官方文档，在 <code>_config.yaml</code> 将<code>post_asset_folder</code> 选项设为 <code>true</code>。然后，安装插件 <code>hexo-image-link</code>，安装命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install hexo-image-link --save<br></code></pre></td></tr></table></figure><p>如果安装了 <code>hexo-asset-img</code> 插件，需要将其卸载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm uninstall --save hexo-asset-img<br></code></pre></td></tr></table></figure><p>然后，配置 Markdown 编辑器 Typora 如下：</p><img src="/2023/02/23/Hexo-%E5%8D%9A%E5%AE%A2%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/image-20230223101720679.png" class="" title="Typora 配置"><p>配置完成后，在 Typora 中粘贴图片时，Typora就会自动将图片保存到与文件名同名的目录下，并在 Markdown中使用相对路径引用图片。这样，我们就可以在 Hexo 博客和 Typora中同时看到图片。</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>鸟哥的 Linux 私房菜阅读笔记</title>
    <link href="/2023/02/20/%E9%B8%9F%E5%93%A5%E7%9A%84-Linux-%E7%A7%81%E6%88%BF%E8%8F%9C%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/02/20/%E9%B8%9F%E5%93%A5%E7%9A%84-Linux-%E7%A7%81%E6%88%BF%E8%8F%9C%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>写在前面：</strong></p><p>本文是阅读 《鸟哥的 Linux 私房菜：基础学习篇》一书的笔记，记录了个人认为的一些重点内容，供本人后续查阅参考。对于偏向于系统运维方面的内容，则未记录。</p><p>《鸟哥的 Linux 私房菜：基础学习篇》无疑是入门 Linux命令行的一本好书，但是在个人阅读过程中，发现本书部分内容更偏向于系统运维人员，而不是大多数的普通程序员。当然，技多不压身，不过，对于仅想了解与日常编程开发紧密相关的命令行内容的读者，不妨选择性地跳跃阅读本书，或者找一些更符合您需求的资料。</p></blockquote><h2 id="linux-是什么与如何学习">1. Linux 是什么与如何学习</h2><h3 id="linux-是什么">1.1 Linux 是什么</h3><ul><li>1991 年 Linus 编写</li><li>操作系统发展历程<ol type="1"><li>1969 年，<strong>批处理操作系统</strong></li><li><strong>分时操作系统</strong>， “Multics” 系统</li><li>1973 年，UNIX 正式诞生； 1977 年，BSD 诞生; 1979 年，SystemV，<em>引发商业纠纷</em></li><li>1984 年，Minix 系统开始编写 ； GNU （GNU's NotUnix）计划（斯托曼发起）与 FSF（Free SoftwareFoundation）基金会成立</li><li>1988 年，图形用户界面模式 XFree86 计划</li><li>1991 年，芬兰 Linus Torvalds 发布 Linux 内核</li></ol></li><li>常见的开放源代码的授权（<ahref="https://www.runoob.com/w3cnote/open-source-license.html">详细介绍</a>）<ol type="1"><li>Apache Lisense 2.0</li><li>BSD</li><li>GPL</li><li>MIT License</li><li>……</li></ol></li></ul><h3 id="托瓦兹的-linux-的发展">1.2 托瓦兹的 Linux 的发展</h3><ul><li><p>1994 年，Linux 内核正式版， Version 1.0</p></li><li><p>1996 年， 2.0 版</p></li><li><p>2011 年，3.0 版</p></li><li><p>2015 年 4 月，4.0 版</p></li><li><p>查看内核版本命令： <code>uname -r</code></p></li><li><p>Linux 发行版分类（按照包管理工具）</p><ol type="1"><li>RPM 方式管理：Red Hat、Fedora、SUSE 等</li><li>dpkg 方式管理：Debian、Ubuntu、B2D 等</li><li>其他：Gentoo</li></ol></li></ul><h3 id="linux-该如何学习">1.3 Linux 该如何学习</h3><ol type="1"><li>Linux 的安装与命令</li><li>Linux 操作系统的基础技能：用户用户组、权限的概念等</li><li>vi 文本编辑器</li><li>Shell 与 Shell 脚本的学习</li><li>软件管理</li><li>网络基础</li></ol><p>核心：<strong><em>实践 动手</em></strong></p><h2 id="主机规划与磁盘划分">2. 主机规划与磁盘划分</h2><h3 id="linux-与硬件的搭配">2.1 Linux 与硬件的搭配</h3><p>略</p><h3 id="磁盘分区">2.2 磁盘分区</h3><p>P69 - P82 略</p><h3 id="安装-linux-前的规划">2.3 安装 Linux 前的规划</h3><p>确定用途 -&gt; 磁盘分区</p><h2 id="安装-centos7.x">3. 安装 CentOS7.x</h2><p>略 见第 3 章</p><h2 id="首次登录与在线求助">4. 首次登录与在线求助</h2><h3 id="首次登录系统">4.1 首次登录系统</h3><p>略</p><h3 id="命令行模式下命令的执行">4.2 命令行模式下命令的执行</h3><h4 id="开始执行命令">4.2.1 开始执行命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">命令一般格式</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">command</span> [-options] parameter1 parameter2 ...</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  命令      选项       参数</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">示例：查看home目录下所有文件（包括隐藏文件 -a）及其属性（-l）</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -al ~</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span>        -al     ~</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -a -l ~</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看日期和时间</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">date</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看语言语系</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">locale</span><br></code></pre></td></tr></table></figure><blockquote><p>番外：</p><p><strong>如何使用Windows ssh 连接远程CentOS主机？</strong></p><p><em>CentOS 端：</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看本机是否安装SSH软件包</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash"> rpm -qa | grep ssh</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果没有安装SSH</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yum install openssh-server</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">开启SSH服务</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">service sshd start</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看22号端口是否开启</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">netstat -ntpl | grep 22</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改服务器端断开连接时长</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">vi /etc/ssh/sshd_config</span> <br>找到<br><span class="hljs-meta prompt_">#</span><span class="language-bash">ClientAliveInterval 0</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">ClientAliveCountMax 3</span><br>修改为<br>ClientAliveInterval 60<br>ClientAliveCountMax 5<br>然后重启sshd服务<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl restart sshd</span><br></code></pre></td></tr></table></figure><p><em>Windows 端：</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh username@hostname(hostIP)</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">命令 用户名@主机名或者IP地址</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">然后输入密码即可连接远程主机</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="基础命令的操作">4.2.2 基础命令的操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">date</span><span class="hljs-comment"># 查看时间日期</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">cal<span class="hljs-comment"># 查看日历（calender）</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">bc<span class="hljs-comment"># 计算器</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">date</span> 具体</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">date</span> +%Y/%m/%d<span class="hljs-comment"># 以 year/month/day 格式输出 如“2021/03/22”</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">date</span> +%H:%M<span class="hljs-comment"># 以 hour:minute 格式输出 如“23:49”</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">cal 具体</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">cal year<span class="hljs-comment"># 显示 year 年的日历</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">cal [month] [year]<span class="hljs-comment"># 显示某年某月日历</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">bc 简单计算器</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">bc<span class="hljs-comment"># 支持 + - * / ^ %quit 退出计算器</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">bc 默认输出整数  scale = n 使输出小数点后 n 位</span><br></code></pre></td></tr></table></figure><h4 id="重要的几个热键-tabctrl-cctrl-d">4.2.3 重要的几个热键[Tab]、[Ctrl]-c、[Ctrl]-d</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">Tab 键</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">命令补全</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ca[Tab][Tab]<span class="hljs-comment"># 输入 ca 后按两次 Tab 键，终端输出以 ca 为前缀的命令</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出如下：</span><br>cacertdir_rehash     cache_restore        ca-legacy            cancel               cat<br>cache_check          cache_writeback      calibrate_ppa        cancel.cups          catchsegv<br>cache_dump           cagent_tools         caller               capsh                catman<br>cache_metadata_size  cairo-sphinx         canberra-boot        captoinfo<br>cache_repair         cal                  canberra-gtk-play    case<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">文件补齐</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -al .bash[Tab][Tab]<span class="hljs-comment"># 自动补齐文件名</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出如下</span><br>.bash_history  .bash_logout   .bash_profile  .bashrc<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">选项/参数补齐</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">date</span> --[Tab][Tab]<span class="hljs-comment"># 自动补齐参数</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出如下</span><br>--date        --help        --reference=  --rfc-3339=   --universal<br>--date=       --iso-8601    --rfc-2822    --set=        --version<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">[Ctrl]-c</span><br>作用：终端正在运行中的命令<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">[Ctrl]-d</span><br>作用：<br>1、相当于 exit 命令<br>2、代表键盘输入结束（End Of File）<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">[Shift] + &#123;[Page UP][Page Down]&#125;</span><br>作用：用于命令行输出的翻页<br></code></pre></td></tr></table></figure><h3 id="linux-系统的在线求助-man-page-和-info-page">4.3 Linux系统的在线求助 man page 和 info page</h3><h4 id="命令的---help-求助说明">4.3.1 命令的 --help 求助说明</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">date</span> --<span class="hljs-built_in">help</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查询已经使用过的命令选项</span><br></code></pre></td></tr></table></figure><h4 id="man-page">4.3.2 man page</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">man <span class="hljs-built_in">date</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">man 为 manual(操作说明)的缩写</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">按下 空格键 翻页；q 退出</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">向下查找词语： 输入 “/word” ，然后按 Enter 键，即可查找 “word”</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">向上查找词语： 输入 “?word” ，然后按 Enter 键，即可查找 “word”</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看 man 的帮助</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">man man</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看系统中和 man 命令有关的说明文件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">man -f man</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">whatis [命令或文件]<span class="hljs-comment"># 等价于上面 man -f ...</span></span><br>man (7)              - 格式化手册页的宏<br>man (1)              - 格式化并显示在线帮助手册页<br>man (1p)             - display system documentation<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">man 1 man<span class="hljs-comment"># 根据上面输出查看指定说明文件</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">找到系统中说明文件，只有有 man 关键字就将该说明列出来</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">man -k man</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">apropos [命令或文件]<span class="hljs-comment"># 相当于 man -k ...</span></span><br></code></pre></td></tr></table></figure><h4 id="info-page">4.3.3 info page</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">info info</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">按 N 、 P 、 U 到下一个、上一个、上一层的节点</span><br></code></pre></td></tr></table></figure><h3 id="超简单的文本编辑器nano">4.4 超简单的文本编辑器：nano</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">nano file.txt<span class="hljs-comment"># 打开 或者 创建 文件</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">打开 nano 之后下面的 <span class="hljs-string">&quot;^X&quot;</span> 代表 Ctrl + X 键，完成一定功能</span><br></code></pre></td></tr></table></figure><h3 id="正确的关机方法">4.5 正确的关机方法</h3><ol type="1"><li><p>观察系统的使用状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">who</span>  <span class="hljs-comment"># 查看当前谁在线</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">netstat -a<span class="hljs-comment"># 查看网络的联机状态</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ps -aux<span class="hljs-comment"># 查看后台进程</span></span><br></code></pre></td></tr></table></figure></li><li><p>通知在线用户关机的时刻</p></li><li><p>正确使用关机命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">sync</span><span class="hljs-comment"># 将数据同步写入硬盘中mingl</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">shutdown<span class="hljs-comment"># 常用的关机命令</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重新启动、关机</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">reboot</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">halt</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">poweroff</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">以 root 身份登录</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">su -</span><br></code></pre></td></tr></table></figure></li><li><p>shutdown 使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">shutdown [-krhc][时间] [警告信息]</span><br>-k: 不关机，只发送警告信息<br>-r: 将系统服务停掉之后就重新启动<br>-h: 将系统服务停掉之后，立即关机<br>-c: 取消已经在进行的 shutdown 命令内容<br>时间 : 指定系统关机时间。默认一分钟后自动进行<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">常用示例</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">shutdown -h now<span class="hljs-comment"># 立刻关机</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">shutdown -h 20:25<span class="hljs-comment"># 今天 20:25 关机 （或次日20:25关机）</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">shutdown -h +10<span class="hljs-comment"># 系统 10 分钟后自动关机</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">shutdown -r now<span class="hljs-comment"># 立刻重新启动</span></span><br></code></pre></td></tr></table></figure></li><li><p>reboot、 halt、 poweroff 使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">halt<span class="hljs-comment"># 系统停止，屏幕可能会保留系统已经停止的信息</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">poweroff<span class="hljs-comment"># 系统关机，屏幕空白</span></span><br></code></pre></td></tr></table></figure></li><li><p>实际使用管理工具 systemctl 关机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl [命令]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl reboot<span class="hljs-comment"># 系统重新启动</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl poweroff<span class="hljs-comment"># 系统关机</span></span><br></code></pre></td></tr></table></figure></li></ol><h2 id="linux-的文件权限与目录配置">5. Linux 的文件权限与目录配置</h2><h3 id="用户与用户组">5.1 用户与用户组</h3><ol type="1"><li><p>文件拥有者的三个层次：</p><blockquote><ol type="1"><li>文件所有者( User )：</li><li>用户组( Group )：每个用户可以有多个用户组的支持</li><li>其他人( Others )：</li></ol></blockquote></li><li><p>系统上所有账号相关信息记录在文件： /etc/passwd （可用 cat/etc/passwd 命令查看文件内容）</p></li><li><p>密码记录在： /etc/shadow 文件内</p></li><li><p>组名记录在： /etc/group 文件内</p></li></ol><h3 id="linux-文件权限概念">5.2 Linux 文件权限概念</h3><h4 id="linux-文件属性">5.2.1 Linux 文件属性</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">su -<span class="hljs-comment"># 切换到 root 权限</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -al<span class="hljs-comment"># list 查看文件名及相关属性</span></span><br>总用量 104<br>dr-xr-x---. 16 root root 4096 3月  22 23:14 .<br>dr-xr-xr-x. 20 root root 4096 3月  31 20:50 ..<br>-rw-------   1 root root 1955 3月  31 20:50 .bash_history<br>-rw-r--r--.  1 root root   18 12月 29 2013 .bash_logout<br>-rw-r--r--.  1 root root  176 12月 29 2013 .bash_profile<br>-rw-r--r--.  1 root root  176 12月 29 2013 .bashrc<br>drwxr-xr-x   9 root root 4096 3月  22 23:14 .cache<br>drwxr-xr-x  13 root root 4096 3月  22 23:14 .config<br>-rw-r--r--.  1 root root  100 12月 29 2013 .cshrc<br>drwx------   3 root root 4096 3月  22 23:13 .dbus<br>-rw-------   1 root root   16 3月  22 23:13 .esd_auth<br>-rw-------   1 root root  310 3月  22 23:13 .ICEauthority<br>drwx------   3 root root 4096 3月  22 23:13 .local<br>drwxr-xr-x   2 root root 4096 3月   8 22:34 .pip<br>-rw-r--r--   1 root root   73 3月   8 22:34 .pydistutils.cfg<br>drwx------   2 root root 4096 1月  21 2019 .ssh<br>-rw-r--r--.  1 root root  129 12月 29 2013 .tcshrc<br>-rw-------   1 root root  508 3月   8 22:37 .viminfo<br>-rw-------   1 root root    0 3月  22 23:14 .Xauthority<br><br>各字段解释如下：<br>-rw-------   1 root root    0 3月  22 23:14 .Xauthority<br>[1][2] [3]  [4]    [5]    [6]         [7]<br><br></code></pre></td></tr></table></figure><p>各字段含义解释如下：</p><ol type="1"><li><p>文件类型权限：共有<strong>10个字符</strong>，第一个字符代表该文件是<strong>目录</strong>，<strong>文件</strong>，或<strong>链接文件</strong> 等</p><blockquote><p>第一个字符含义说明：</p><p>d ：目录（directory）</p><p>- ：文件</p><p>l ：链接文件（link file）</p><p>b ：设备文件里面的可供存储的周边设备（可按块随机读写的设备）</p><p>c ：设备文件里面的串行端口设备，如键盘、鼠标（一次性读写的设备）</p><p>剩余字符，3个一组，均为 [rwx] 的组合，r 代表可读（read），w代表可写（write），x代表可执行（execute）。这三个权限的位置不会改变，若无权限，则为减号 [-]。</p><p>第一组为：<strong>文件拥有者</strong> 可具备的权限</p><p>第二组为：加入此用户组之账号的权限</p><p>第三组为：非本人且没有加入本用户组的其他账户的权限</p></blockquote></li><li><p>链接数：表示有多少个文件名链接到此节点（ inode），即记录有多少个文件名链接到相同的 inode 号码</p></li><li><p>文件拥有者：表示文件（或目录）拥有者的账号</p></li><li><p>文件所属用户组：表示文件的所属用户组</p></li><li><p>文件大小：文件的容量大小，默认单位为字节 Bytes</p></li><li><p>文件最后被修改的时间：文件的创建时间或者最近修改时间（若修改时间据现在太久，则只显示年份）。如果要显示完整的时间格式，则需要使用<code>ls -l --full-time</code> 命令</p></li><li><p>文件名：这个文件名，若文件名之前多一个 <code>.</code>，则代表该文件为隐藏文件</p></li></ol><h4 id="如何修改文件属性与权限">5.2.2 如何修改文件属性与权限</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">修改文件所属用户组 (change group)</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chgrp</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chgrp</span> [-R] dirName/fileName</span><br>-R : 进行递归修改，即将目录下子目录及文件都更新成为这个用户组<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改文件拥有者 (change own)</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chown</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chown</span> [-R] 账号名称 dirName/fileName</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chown</span> [-R] 账号名称:用户组名称 dirName/fileName</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">复制文件后修改文件所有者示例：</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cp</span> 源文件 目标文件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chown</span> 账号名称 目标文件名</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改文件的权限</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1.数字类型修改文件权限</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">各权限对应数字如下：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">r ： 4</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">w ： 2</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">x ： 1</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">则 rwx = 4 + 2 + 1 = 4    rw- = 4 + 2 + 0 = 6</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> [-R] xyz 文件或目录</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">其中 xyz 为数字，例如：666 、 777、 640 等</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">示例：将一个 shell 文件修改为可执行,非拥有者用户可以执行、查看但不可以修改</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> 755 fileName.sh</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2.符号类型修改文件权限</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">格式</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> [u | g | o | a] [+ | - | =] [r | w | x] [dirName | fileName]</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">含义：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">u ：user   g ： group   o ： others  a ： all</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">+ ：加入    - ： 移除    = ： 设置</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">rwx ： 读写执行</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">例：</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> u=rwx,go=rx .bashrc</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> u=rwx,g=rx,o=r fileName</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> a+w fileName<span class="hljs-comment"># 令 fileName 对所有人都可以写</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> a-x fileName<span class="hljs-comment"># 去除所有人执行权限</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">给某文件添加执行权限</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> a+x fileName</span><br></code></pre></td></tr></table></figure><h4 id="目录与文件的权限意义">5.2.3 目录与文件的权限意义</h4><blockquote><p>对 <strong>文件</strong> ：</p><p>r ： 读取文件实际内容</p><p>w： 编辑、修改、新增文件内容（不能删除该文件）</p><p>e ： 文件可以被系统执行 （与文件名无关）</p><p>对 <strong>目录</strong> ：</p><p>r ： 读取目录结构列表 （可以使用 ls 命令查看目录内容列表）</p><p>w ：可以改动目录结构列表，即建立新文件与目录、删除已经存在文件和目录、重命名文件和目录、移动该目录内文件和目录位置（与该目录下文件名的变动有关）</p><p>x ： 代表用户能否进入该目录成为工作目录，工作目录及当前所在的目录</p><p><strong>能不能进入目录，只与该目录执行权限有关</strong></p><p><strong>要开放目录给任何人浏览时，应该开放 r 和 x 权限， w权限不可随便给 </strong></p><p>要读一个文件时，至少应具备该文件所在目录 r 和 x 权限。</p></blockquote><h4 id="linux-文件种类与扩展名">5.2.4 Linux 文件种类与扩展名</h4><ol type="1"><li><p>文件种类：</p><ol type="1"><li>常规文件（regular file）：<code>ls -al</code> 命令输出的第一个字符<code>-</code> ，如 <code>-rwxrwxrwx</code> 。<ul><li>纯文本文件（ASCII）：</li><li>二进制文件（binary）：可执行文件等</li><li>数据文件（date）：有些程序在运行时会读取某些特定格式的文件，这些文件被称为数据文件。</li></ul></li><li>目录（directory）：第一个属性为 <code>d</code> 。</li><li>链接文件（link）：第一个属性为 <code>l</code> ，如<code>lrwxrwxrwx</code> ，类似于 Windows 下快捷方式 。</li><li>设备与设备文件（device）：与系统周边及存储等相关的一些文件，通常集中在<code>/dev</code> 目录下，又可分为：<ul><li>区块（block）设备文件：第一个属性为 <code>d</code>，可供系统随机存取的接口设备 。</li><li>字符（character）设备文件：一些串行端口的接口设备，如键盘、鼠标等，特色：一次性读取，不能够截断输出，第一个属性为<code>c</code> 。</li></ul></li><li>数据接口文件（sockets）：用于网络上的数据交换，第一个属性为<code>s</code> ，通常可在 <code>/run</code> 或 <code>/tmp</code>这些目录中可看到这种文件类型 。</li><li>数据输送文件（FIFO，pipe）：主要目的：用于解决多个进程同时读写一个文件所造成的的错误问题，即管道，第一个属性为<code>p</code></li></ol></li><li><p>Linux 文件扩展名：Linux下文件无所谓文件扩展名，扩展名只能用来大概了解文件是什么类型。</p><blockquote><p><strong>常用文件扩展名</strong></p><ol type="1"><li>*.sh ：脚本或批处理文件</li><li>*.Z、*.tar、、*.tar.gz、*.zip、*.tgz ：压缩文件</li><li>、*.html、*.php ：网页相关文件</li></ol></blockquote></li><li><p>Linux 文件名长度限制：单一文件或目录的最大允许文件名为 255字节</p></li><li><p>Linux 文件名的限制：</p><blockquote><p>不能包含以下字符：</p><p>* ? &gt; &lt; ; &amp; ! [ ] | \ ' " ` ( ) { } - +</p></blockquote></li></ol><h3 id="linux-目录配置">5.3 Linux 目录配置</h3><h4 id="linux-目录配置的依据-fhs">5.3.1 Linux 目录配置的依据 —— FHS</h4><p>FHS（Filesystem HierarchyStandard）：规定每个特定目录下应该放置什么数据</p><hr /><table><thead><tr class="header"><th style="text-align: left;"></th><th style="text-align: center;">可分享</th><th style="text-align: center;">不可分享</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">不变（static）</td><td style="text-align: center;">/usr （软件存放处）</td><td style="text-align: center;">/etc （配置文件）</td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: center;">/opt （第三方辅助软件）</td><td style="text-align: center;">/boot （启动与内核文件）</td></tr><tr class="odd"><td style="text-align: left;">可变动（variable）</td><td style="text-align: center;">/var/mail （用户邮箱）</td><td style="text-align: center;">/var/run （程序相关）</td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: center;">/var/spool/news （新闻组）</td><td style="text-align: center;">/var/lock （程序相关）</td></tr></tbody></table><blockquote><p>FHS 仅针对三个目录规定应该放置什么数据：</p><p>/ （root ，根目录）：与启动系统有关</p><p>/usr （Unix software resource）：与软件安装 / 执行有关</p><p>/var （variable）：与系统运行过程有关</p></blockquote><p>FHS 具体要求：图片来源：<ahref="https://zh.wikipedia.org/zh-hans/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86">维基百科：文件系统层次结构标准</a></p><figure><imgsrc="https://raw.githubusercontent.com/UnpureRationalist/Pictures/main/FHS.png"alt="FHS" /><figcaption aria-hidden="true">FHS</figcaption></figure><h4 id="目录树">5.3.2 目录树</h4><p><imgsrc="https://raw.githubusercontent.com/UnpureRationalist/Pictures/main/image-20210407000259422.png" /></p><h4 id="绝对路径与相对路径">5.3.3 绝对路径与相对路径</h4><p>略</p><h4 id="centos-的观察">5.3.4 CentOS 的观察</h4><p>Linux Standard Base（LSB）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">uname</span> -r<span class="hljs-comment"># 查看内核版本</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">uname</span> -m<span class="hljs-comment"># 查看操作系统架构版本</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看 LSB 标准</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yum install redhat-lsb<span class="hljs-comment"># 安装软件</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">lsb_relase -a<span class="hljs-comment"># 查看 LSB 标准</span></span><br>LSB Version:    :core-4.1-amd64:core-4.1-noarch:cxx-4.1-amd64:cxx-4.1-noarch:desktop-4.1-amd64:desktop-4.1-noarch:languages-4.1-amd64:languages-4.1-noarch:printing-4.1-amd64:printing-4.1-noarch<br>Distributor ID: CentOS<br>Description:    CentOS Linux release 7.5.1804 (Core)<br>Release:        7.5.1804<br>Codename:       Core<br></code></pre></td></tr></table></figure><h2 id="linux-文件与目录管理">6. Linux 文件与目录管理</h2><h3 id="目录与路径">6.1 目录与路径</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">pwd</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> [-p]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">rmdir</span> [-p]</span><br></code></pre></td></tr></table></figure><p>显示环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">给 PATH 环境变量添加路径：</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;PATH&#125;</span>:/root&quot;</span></span><br></code></pre></td></tr></table></figure><h3 id="文件与目录管理">6.2 文件与目录管理</h3><p><code>ls</code> 命令常用选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">-a ：全部的文件，连同隐藏文件（开头为 . 的文件）一起列出来<br>-d ：仅列出目录本身，而不是列出目录内的文件数据<br>-h ：将文件大小以人类较易读的方式（例如 GB, KB等等）列出来<br>-l ：长数据串行出，包含文件的属性与权限等等数据<br>-i ：列出 inode 号码<br></code></pre></td></tr></table></figure><p>其他命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cp</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mv</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">rm</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">basename</span>  <span class="hljs-comment"># 获取路径的文件名</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">dirname</span><span class="hljs-comment"># 获取路径的目录名</span></span><br></code></pre></td></tr></table></figure><h3 id="文件内容查看">6.3 文件内容查看</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">tac</span>   <span class="hljs-comment"># 从最后一行开始显示文件内容</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">nl</span><span class="hljs-comment"># 同时输出行号</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">more<span class="hljs-comment"># 一页一页显示文件内容</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">less<span class="hljs-comment"># 与 more 类似，但可以向前翻页</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">head</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">tail</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">od</span><span class="hljs-comment"># 以二进制形式读取文件内容</span></span><br></code></pre></td></tr></table></figure><h3 id="文件与目录的默认权限与隐藏权限">6.4文件与目录的默认权限与隐藏权限</h3><p>umask：指定目前用户在建立文件或目录时的默认权限，具体指要被拿掉的权限。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">umask</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">umask</span> -S</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置 <span class="hljs-built_in">umask</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">umask</span> 002</span><br></code></pre></td></tr></table></figure><p>文件的隐藏属性：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">chattr<span class="hljs-comment"># 配置文件隐藏属性</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">lsattr<span class="hljs-comment"># 显示文件隐藏属性</span></span><br></code></pre></td></tr></table></figure><p>查看文件类型命令：<code>file</code></p><h3 id="命令与文件的查找">6.5 命令与文件的查找</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">which</span> [-a] 命令名</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">wnereis [-bmsu] 文件或目录名</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">locate [-ir] keyword</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">updatedb<span class="hljs-comment"># 更新数据库</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">find [PATH] [option] [action]</span><br></code></pre></td></tr></table></figure><h2 id="linux-磁盘与文件系统管理">7. Linux 磁盘与文件系统管理</h2><h3 id="文件系统的简单操作">7.1 文件系统的简单操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">df</span><span class="hljs-comment"># 列出文件系统的整体磁盘使用量</span></span><br>-h : 以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示<br>-i : 不用磁盘容量，而以 inode 的数量来显示<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">du</span><span class="hljs-comment"># 查看文件系统的磁盘使用量</span></span><br>-h : 同上<br>-s : 仅列出总量，而不列出每个各别的目录占用容量<br></code></pre></td></tr></table></figure><p>链接：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ln</span> [-sf] 源文件 目标文件</span><br>-s ：有 -s 选项为符号链接；否则为硬链接<br>-f : 目标文件存在时，就主动的将目标文件直接删除后再创建<br></code></pre></td></tr></table></figure><h3 id="磁盘的分区格式化检验与挂载">7.2磁盘的分区、格式化、检验与挂载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gdisk 设备名称</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">mount [-t 文件系统] UUID=<span class="hljs-string">&#x27;&#x27;</span> 挂载点</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">umount [-fn] 设备文件名或挂载点</span><br></code></pre></td></tr></table></figure><h2 id="文件与文件系统的压缩">8. 文件与文件系统的压缩</h2><h3 id="linux-系统常见的压缩命令">8.1 Linux 系统常见的压缩命令</h3><blockquote><p><em>.Z compress 程序压缩的文件； </em>.zip zip 程序压缩的文件；<em>.gz gzip 程序压缩的文件； </em>.bz2 bzip2 程序压缩的文件； <em>.xzxz 程序压缩的文件； </em>.tar tar 程序打包的数据，并没有压缩过；<em>.tar.gz tar 程序打包的文件，其中并且经过 gzip 的压缩 </em>.tar.bz2tar 程序打包的文件，其中并且经过 bzip2 的压缩 *.tar.xz tar程序打包的文件，其中并且经过 xz 的压缩</p></blockquote><p>gzip 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gzip[-cdtv<span class="hljs-comment">#] 文件名</span></span><br>-c：将压缩的数据输出到屏幕上，可通过数据流重导向来处理；<br>-d：解压缩的参数；<br>-t：可以用来检验一个压缩文件的一致性,看看文件有无错误；<br>-v：可以显示出原文件/压缩文件的压缩比等信息；<br><span class="hljs-meta prompt_">-#</span><span class="language-bash">：<span class="hljs-comment">#为数字的意思，代表压缩等级，-1最快，但是压缩比最差、-9最慢，但是压缩比最好！默认是-6</span></span><br></code></pre></td></tr></table></figure><h3 id="打包命令tar">8.2 打包命令：tar</h3><p>最简单的使用 tar 就只要记忆下面的方式即可：</p><ul><li>压　缩：tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称</li><li>查　询：tar -jtv -f filename.tar.bz2</li><li>解压缩：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录</li></ul><h2 id="vim-程序编辑器">9. vim 程序编辑器</h2><h3 id="vi-的使用">9.1 vi 的使用</h3><p>三种模式：</p><ul><li>一般命令模式</li><li>编辑模式</li><li>命令行模式</li></ul><p><imgsrc="https://linux.vbird.org/linux_basic/centos7/0310vi//centos7_vi-mode.gif" /></p><h3 id="vim-的额外功能">9.2 vim 的额外功能</h3><ul><li>可视区块：以列为单位编辑</li><li>多文件编辑</li><li>多窗口功能</li></ul><h2 id="认识与学习-bash">10. 认识与学习 BASH</h2><h3 id="认识-bash-这个-shell">10.1 认识 BASH 这个 SHELL</h3><p><imgsrc="https://linux.vbird.org/linux_basic/centos7/0320bash//0320bash_1.jpg" /></p><p>快捷键：</p><table><thead><tr class="header"><th style="text-align: center;">组合键</th><th style="text-align: center;">功能与示范</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">[ctrl]+u/[ctrl]+k</td><td style="text-align: center;">分别是从游标处向前删除指令串([ctrl]+u)及向后删除指令串([ctrl]+k)。</td></tr><tr class="even"><td style="text-align: center;">[ctrl]+a/[ctrl]+e</td><tdstyle="text-align: center;">分别是让游标移动到整个指令串的最前面([ctrl]+a)或最后面([ctrl]+e)。</td></tr></tbody></table><h3 id="shell-的变量功能">10.2 Shell 的变量功能</h3><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span><span class="hljs-comment"># PATH 即为变量，使用时签名需加上 $</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者：</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;PATH&#125;</span><span class="hljs-comment"># recommend</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;MAIL&#125;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;HOME&#125;</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置变量值</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">var_name=value</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">取消设置变量</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">unset</span> var_name</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">export</span> var_name<span class="hljs-comment"># 以export来使变量变成环境变量</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">read</span> [-pt] var_name<span class="hljs-comment"># 读取键盘输入的变量值</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">declare</span> [-aixr] var_name</span><br>选项与参数：<br>-a ：将后面名为variable 的变数定义成为阵列(array) 类型<br>-i ：将后面名为variable 的变数定义成为整数数字(integer) 类型<br>-x ：用法与export 一样，就是将后面的variable 变成环境变数；<br>-r ：将变数设定成为readonly 类型，该变数不可被更改内容，也不能unset<br></code></pre></td></tr></table></figure><h3 id="命令别名与历史">10.3 命令别名与历史</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">alias</span> lm=<span class="hljs-string">&#x27;ls -al | more&#x27;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">unalias</span> lm</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">history</span> [n]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">history</span> [-c]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">history</span> [-raw] histfiles</span><br>选项与参数：<br>n  ：数字，意思是『要列出最近的 n 条命令列表』的意思！<br>-c ：将目前的shell 中的所有history 内容全部消除<br>-a ：将目前新增的history 指令新增入histfiles 中，若没有加histfiles ，<br>      则预设写入~/.bash_history<br>-r ：将histfiles 的内容读到目前这个shell 的history 记忆中；<br>-w ：将目前的history 记忆内容写入histfiles 中<br></code></pre></td></tr></table></figure><h3 id="bash-shell-的操作环境">10.4 Bash shell 的操作环境</h3><p>命令查找顺序：</p><ol type="1"><li>以相对/绝对路径执行指令，例如『 /bin/ls 』或『 ./ls 』；</li><li>由alias 找到该指令来执行；</li><li>由bash 内建的(builtin) 指令来执行；</li><li>透过$PATH 这个变量的顺序搜寻到的第一个指令来执行。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">source</span> ~/.bashrc<span class="hljs-comment"># 读入环境配置文件</span></span><br></code></pre></td></tr></table></figure><h3 id="数据流重定向">10.5 数据流重定向</h3><ol type="1"><li>标准输入(stdin) ：代码为0 ，使用&lt; 或&lt;&lt; ；</li><li>标准输出(stdout)：代码为1 ，使用&gt; 或&gt;&gt; ；</li><li>标准错误输出(stderr)：代码为2 ，使用2&gt; 或2&gt;&gt; ；</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">find /home -name .bashrc 2&gt; /dev/null<span class="hljs-comment"># dev/null 垃圾桶黑洞装置与特殊写法</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">command1; command2; command3<span class="hljs-comment"># ; 依次连续执行多条命令</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">cmd1 &amp;&amp; cmd2</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">cmd1 || cmd2</span><br></code></pre></td></tr></table></figure><table><thead><tr class="header"><th style="text-align: left;">指令下达情况</th><th style="text-align: left;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">cmd1 &amp;&amp; cmd2</td><td style="text-align: left;">1. 若cmd1执行完毕且正确执行($?=0)，则开始执行cmd2。 2. 若cmd1执行完毕且为错误($?≠0)，则cmd2 不执行。</td></tr><tr class="even"><td style="text-align: left;">cmd1 || cmd2</td><td style="text-align: left;">1. 若cmd1 执行完毕且正确执行($?=0)，则cmd2不执行。 2. 若cmd1 执行完毕且为错误($?≠0)，则开始执行cmd2。</td></tr></tbody></table><h3 id="管道命令">10.6 管道命令</h3><ul><li>管道命令仅会处理standard output，对于standard error output会予以忽略</li><li>管道命令必须要能够接受来自前一个指令的资料成为standard input继续处理才行。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">split</span> [-bl] file PREFIX</span><br>选项与参数：<br>-b ：后面可接欲分割成的档案大小，可加单位，例如b, k, m 等；<br>-l ：以行数来进行分割。<br>PREFIX ：代表前置字元的意思，可作为分割档案的前导文字。<br></code></pre></td></tr></table></figure><h2 id="正则表达式与文件格式化处理">11. 正则表达式与文件格式化处理</h2><h3 id="基础正则表达式">11.1 基础正则表达式</h3><table><thead><tr class="header"><th>特殊符号</th><th>代表意义</th></tr></thead><tbody><tr class="odd"><td>[:alnum:]</td><td>代表英文大小写字元及数字，亦即0-9, A-Z, a-z</td></tr><tr class="even"><td>[:alpha:]</td><td>代表任何英文大小写字元，亦即A-Z, a-z</td></tr><tr class="odd"><td>[:blank:]</td><td>代表空白键与[Tab] 按键两者</td></tr><tr class="even"><td>[:cntrl:]</td><td>代表键盘上面的控制按键，亦即包括CR, LF, Tab, Del 等等</td></tr><tr class="odd"><td>[:digit:]</td><td>代表数字而已，亦即0-9</td></tr><tr class="even"><td>[:graph:]</td><td>除了空白字元(空白键与[Tab] 按键) 外的其他所有按键</td></tr><tr class="odd"><td>[:lower:]</td><td>代表小写字元，亦即a-z</td></tr><tr class="even"><td>[:print:]</td><td>代表任何可以被列印出来的字元</td></tr><tr class="odd"><td>[:punct:]</td><td>代表标点符号(punctuation symbol)，亦即：" ' ? ! ; : # $</td></tr><tr class="even"><td>[:upper:]</td><td>代表大写字元，亦即A-Z</td></tr><tr class="odd"><td>[:space:]</td><td>任何会产生空白的字元，包括空白键, [Tab], CR 等等</td></tr><tr class="even"><td>[:xdigit:]</td><td>代表16 进位的数字类型，因此包括： 0-9, A-F, a-f 的数字与字元</td></tr></tbody></table><ul><li>查找特定字符串</li><li>利用中括号 <code>[]</code> 来查找集合字符</li><li>行首和行尾字符 <code>^$</code></li><li>任意一个字符 <code>.</code> 与重复字符 <code>*</code></li><li>限定连续 RE 字符范围 <code>&#123;&#125;</code>（需使用转义字符<code>\</code>）</li></ul><p>基础的正规表示法特殊字符汇整如下：</p><table><thead><tr class="header"><th>E 字符</th><th>意义与范例</th></tr></thead><tbody><tr class="odd"><td>^word</td><td>意义：待搜寻的字串(word)在行首！ <br/>范例：搜寻行首为#开始的那一行，并列出行号<br/>grep -n '^#' regular_express.txt</td></tr><tr class="even"><td>word$</td><td>意义：待搜寻的字串(word)在行尾！ <br/>范例：将行尾为!的那一行列印出来，并列出行号<br/>grep -n '!$' regular_express.txt</td></tr><tr class="odd"><td>.</td><td>意义：代表『一定有一个任意字元』的字符！<br/>范例：搜寻的字串可以是(eve) (eae) (eee) (ee)， 但不能仅有(ee)！亦即e 与e 中间『一定』仅有一个字元，而空白字元也是字元！<br/>grep -n'ee' regular_express.txt</td></tr><tr class="even"><td>\</td><td>意义：透过shell 的跳脱字符，将特殊符号的特殊意义去除！<br/>范例：搜寻含有单引号' 的那一行！<br/>grep -n 'regular_express.txt</td></tr><tr class="odd"><td>*</td><td>意义：重复零个到无穷多个的前一个RE 字符 <br/>范例：找出含有(es)(ess) (esss) 等等的字串，注意，因为* 可以是0 个，所以es也是符合带搜寻字串。另外，因为* 为重复『前一个RE 字符』的符号，因此，在* 之前必须要紧接着一个RE 字符喔！例如任意字元则为『.*』！<br/>grep -n 'ess*' regular_express.txt</td></tr><tr class="even"><td>[list]</td><td>意义：字元集合的RE 字符，里面列出想要撷取的字元！<br/>范例：搜寻含有(gl) 或(gd) 的那一行，需要特别留意的是，在[]当中『谨代表一个待搜寻的字元』， 例如『 a[afl]y』代表搜寻的字串可以是aay, afy, aly 即[afl] 代表a 或f 或l的意思！<br/>grep -n 'g[ld]' regular_express.txt</td></tr><tr class="odd"><td>[n1-n2]</td><td>意义：字元集合的RE 字符，里面列出想要撷取的字元范围！<br/>范例：搜寻含有任意数字的那一行！需特别留意，在字元集合[] 中的减号-是有特殊意义的，他代表两个字元之间的所有连续字元！但这个连续与否与ASCII编码有关，因此，你的编码需要设定正确(在 bash 当中，需要确定LANG与LANGUAGE 的变数是否正确！) 例如所有大写字元则为[AZ]<br/>grep -n '[AZ]'regular_express.txt</td></tr><tr class="even"><td>[^list]</td><td>意义：字元集合的RE 字符，里面列出不要的字串或范围！<br/>范例：搜寻的字串可以是(oog) (ood) 但不能是(oot) ，那个^ 在[]内时，代表的意义是『反向选择』的意思。例如，我不要大写字元，则为[^AZ]。但是，需要特别注意的是，如果以grep-n [^AZ] regular_express.txt来搜寻，却发现该档案内的所有行都被列出，为什么？因为这个[^AZ]是『非大写字元』的意思， 因为每一行均有非大写字元，例如第一行的"OpenSource" 就有p,e,n,o.... 等等的小写字<br/>grep -n 'oo[^t]'regular_express.txt</td></tr><tr class="odd"><td>{n,m}</td><td>意义：连续n 到m 个的『前一个RE 字符』 <br/>意义：若为{n} 则是连续n个的前一个RE 字符， <br/>意义：若是{n,} 则是连续n 个以上的前一个RE字符！ <br/>范例：在g 与g 之间有2 个到3 个的o存在的字串，亦即(goog)(gooog)<br/>grep -n 'go\{2,3\}g'regular_express.txt</td></tr></tbody></table><h3 id="扩展正则表达式">11.2 扩展正则表达式</h3><table><thead><tr class="header"><th>RE 字符</th><th>意义与范例</th></tr></thead><tbody><tr class="odd"><td>+</td><td>意义：重复『一个或一个以上』的前一个RE 字符 <br/>范例：搜寻(god)(good) (goood)... 等等的字串。那个o+ 代表『一个以上的o』所以，底下的执行成果会将第1, 9, 13 行列出来。<br/>egrep -n 'go+d'regular_express.txt</td></tr><tr class="even"><td>?</td><td>意义：『零个或一个』的前一个RE 字符 <br/>范例：搜寻(gd) (god)这两个字串。那个o? 代表『空的或1 个o 』所以，上面的执行成果会将第13, 14行列出来。有没有发现到，这两个案例( 'go+d' 与'go?d' )的结果集合与'go*d'相同？想想看，这是为什么喔！<br/>egrep -n 'go?d'regular_express.txt</td></tr><tr class="odd"><td>|</td><td>意义：用或( or )的方式找出数个字串 <br/>范例：搜寻gd 或good这两个字串，注意，是『或』！所以，第1,9,14这三行都可以被列印出来喔！那如果还想要找出dog 呢？<br/>egrep -n'gd|good' regular_express.txt egrep -n 'gd|good|dog'regular_express.txt</td></tr><tr class="even"><td>()</td><td>意义：找出『群组』字串 范<br/>例：搜寻(glad) 或(good)这两个字串，因为g 与d 是重复的，所以， 我就可以将la 与oo 列于( )当中，并以| 来分隔开来，就可以啦！<br/>egrep -n 'g(la|oo)d'regular_express.txt</td></tr><tr class="odd"><td>()+</td><td>意义：多个重复群组的判别 <br/>范例：将『AxyzxyzxyzxyzC』用echo叫出，然后再使用如下的方法搜寻一下！<br/>echo 'AxyzxyzxyzxyzC' | egrep'A(xyz)+C'<br/>上面的例子意思是说，我要找开头是A 结尾是C，中间有一个以上的"xyz" 字串的意思</td></tr></tbody></table><h2 id="学习-shell-脚本">12. 学习 shell 脚本</h2><h3 id="什么是-shell-脚本">12.1 什么是 shell 脚本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">This program shows <span class="hljs-string">&quot;Hello World!&quot;</span> <span class="hljs-keyword">in</span> your screen.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/16 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br>echo -e &quot;Hello World! \a \n&quot;<br>exit 0<br></code></pre></td></tr></table></figure><p>良好的script 撰写习惯，在每个script 的档头处记录好：</p><ul><li>script 的功能；</li><li>script 的版本资讯；</li><li>script 的作者与联络方式；</li><li>script 的版权宣告方式；</li><li>script 的History (历史纪录)；</li><li>script 内较特殊的指令，使用『绝对路径』的方式来下达；</li><li>script 运作时需要的环境变量预先声明与设置。</li></ul><h3 id="简单的-shell-脚本练习">12.2 简单的 shell 脚本练习</h3><p>处理用户输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">User inputs his first name and last name. Program shows his full name.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/16 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>read -p &quot;Please input your first name: &quot; firstname       # 提示使用者输入<br>read -p &quot;Please input your last name: &quot; lastname        # 提示使用者输入<br>echo -e &quot;\nYour full name is: $&#123;firstname&#125; $&#123;lastname&#125;&quot; # 结果由屏幕输出<br></code></pre></td></tr></table></figure><p>随日期变化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program creates three files, <span class="hljs-built_in">which</span> named by user<span class="hljs-string">&#x27;s input and date command.</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">History:</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">2015/07/16 VBird First release</span></span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">1. 让使用者输入档案名称，并取得fileuser 这个变数；</span></span> <br>echo -e &quot;I will use &#x27;touch&#x27; command to create 3 files.&quot; # 纯粹显示资讯<br>read -p &quot;Please input your filename: &quot; fileuser          # 提示使用者输入<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">2. 为了避免使用者随意按Enter ，利用变数功能分析档名是否有设定？</span></span><br>filename=$&#123;fileuser:-&quot;filename&quot;&#125;            # 开始判断有否设定档名<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">3. 开始利用date 指令来取得所需要的档名了；</span></span> <br>date1=$(date --date=&#x27;2 days ago&#x27; +%Y%m%d)   # 前两天的日期<br>date2=$(date --date=&#x27;1 days ago&#x27; +%Y%m%d)   # 前一天的日期<br>date3=$(date +%Y%m%d)                       # 今天的日期<br>file1=$&#123;filename&#125;$&#123;date1&#125;                   # 底下三行在设定档名<br>file2=$&#123;filename&#125;$&#123;date2&#125;<br>file3=$&#123;filename&#125;$&#123;date3&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">4. 将档名建立吧！</span></span><br>touch &quot;$&#123;file1&#125;&quot;                            # 底下三行在建立档案<br>touch &quot;$&#123;file2&#125;&quot;<br>touch &quot;$&#123;file3&#125;&quot;<br></code></pre></td></tr></table></figure><p>数值运算：简单的加减乘除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">User inputs 2 <span class="hljs-built_in">integer</span> numbers; program will cross these two numbers.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/16 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br>echo -e &quot;You SHOULD input 2 numbers, I will multiplying them! \n&quot;<br>read -p &quot;first number: &quot; firstnu<br>read -p &quot;second number: &quot; secnu<br>total=$(($&#123;firstnu&#125;*$&#123;secnu&#125;))<br>echo -e &quot;\nThe result of $&#123;firstnu&#125; x $&#123;secnu&#125; is ==&gt; $&#123;total&#125;&quot;<br></code></pre></td></tr></table></figure><p>计算含小数点数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;123.123*55.9&quot;</span> | bc</span><br></code></pre></td></tr></table></figure><p>计算 Pi</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">User input a scale number to calculate pi number.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/16 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br>echo -e &quot;This program will calculate pi value. \n&quot;<br>echo -e &quot;You should input a float number to calculate pi value.\n&quot;<br>read -p &quot;The scale number (10~10000) ? &quot; checking<br>num=$&#123;checking:-&quot;10&quot;&#125;            # 开始判断有否有输入数值<br>echo -e &quot;Starting calculate pi value. Be patient.&quot;<br>time echo &quot;scale=$&#123;num&#125;; 4*a(1)&quot; | bc -lq<br></code></pre></td></tr></table></figure><h3 id="善用判断式">12.3 善用判断式</h3><table><thead><tr class="header"><th>测试的标志</th><th>代表意义</th></tr></thead><tbody><tr class="odd"><td>1. 关于某个文件名的『文件类型』判断，如test -e filename表示存在否</td><td></td></tr><tr class="even"><td>-e</td><td>该『文件名』是否存在？(常用)</td></tr><tr class="odd"><td>-f</td><td>该『文件名』是否存在且为文件(file)？(常用)</td></tr><tr class="even"><td>-d</td><td>该『文件名』是否存在且为目录(directory)？(常用)</td></tr><tr class="odd"><td>-b</td><td>该『文件名』是否存在且为一个block device 设备？</td></tr><tr class="even"><td>-c</td><td>该『文件名』是否存在且为一个character device 设备？</td></tr><tr class="odd"><td>-S</td><td>该『文件名』是否存在且为一个Socket 文件？</td></tr><tr class="even"><td>-p</td><td>该『文件名』是否存在且为一个FIFO (pipe) 文件？</td></tr><tr class="odd"><td>-L</td><td>该『文件名』是否存在且为一个链接文件？</td></tr><tr class="even"><td>2. 关于档案的权限检测，如test -r filename 表示可读否(但root权限常有例外)</td><td></td></tr><tr class="odd"><td>-r</td><td>检测该文件名是否存在且具有『可读』的权限？</td></tr><tr class="even"><td>-w</td><td>检测该文件名是否存在且具有『可写』的权限？</td></tr><tr class="odd"><td>-x</td><td>检测该文件名是否存在且具有『可执行』的权限？</td></tr><tr class="even"><td>-u</td><td>检测该文件名是否存在且具有『SUID』的属性？</td></tr><tr class="odd"><td>-g</td><td>检测该文件名是否存在且具有『SGID』的属性？</td></tr><tr class="even"><td>-k</td><td>检测该文件名是否存在且具有『Sticky bit』的属性？</td></tr><tr class="odd"><td>-s</td><td>检测该文件名是否存在且为『非空白文件』？</td></tr><tr class="even"><td>3. 两个档案之间的比较，如： test file1 -nt file2</td><td></td></tr><tr class="odd"><td>-nt</td><td>(newer than)判断file1 是否比file2 新</td></tr><tr class="even"><td>-ot</td><td>(older than)判断file1 是否比file2 旧</td></tr><tr class="odd"><td>-ef</td><td>判断file1 与file2 是否为同一档案，可用在判断hard link的判定上。主要意义在判定，两个档案是否均指向同一个inode</td></tr><tr class="even"><td>4. 关于两个整数之间的判定，例如test n1 -eq n2</td><td></td></tr><tr class="odd"><td>-eq</td><td>两数值相等(equal)</td></tr><tr class="even"><td>-ne</td><td>两数值不等(not equal)</td></tr><tr class="odd"><td>-gt</td><td>n1 大于n2 (greater than)</td></tr><tr class="even"><td>-lt</td><td>n1 小于n2 (less than)</td></tr><tr class="odd"><td>-ge</td><td>n1 大于等于n2 (greater than or equal)</td></tr><tr class="even"><td>-le</td><td>n1 小于等于n2 (less than or equal)</td></tr><tr class="odd"><td>5. 判定字符串的数据</td><td></td></tr><tr class="even"><td>test -z string</td><td>判定字串是否为0 ？若string 为空字串，则为true</td></tr><tr class="odd"><td>test -n string</td><td>判定字串是否非为0 ？若string 为空字串，则为false。 注： -n亦可省略</td></tr><tr class="even"><td>test str1 == str2</td><td>判定str1 是否等于str2 ，若相等，则回传true</td></tr><tr class="odd"><td>test str1 != str2</td><td>判定str1 是否不等于str2 ，若相等，则回传false</td></tr><tr class="even"><td>6. 多重条件判定，例如： test -r filename -a -x filename</td><td></td></tr><tr class="odd"><td>-a</td><td>(and)两状况同时成立！例如test -r file -a -x file，则file 同时具有r与 x 权限时，才回传true。</td></tr><tr class="even"><td>-o</td><td>(or)两状况任何一个成立！例如test -r file -o -x file，则file 具有r 或x 权限时，就可回传true。</td></tr><tr class="odd"><td>!</td><td>反相状态，如test ! -x file ，当file 不具有x 时，回传true</td></tr></tbody></table><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">User input a filename, program will check the flowing:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1.) exist? 2.) file/directory? 3.) file permissions</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/16 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 让使用者输入档名，并且判断使用者是否真的有输入字串？</span><br>echo -e &quot;Please input a filename, I will check the filename&#x27;s type and permission. \n\n&quot;<br>read -p &quot;Input a filename : &quot; filename<br>test -z $&#123;filename&#125; &amp;&amp; echo &quot;You MUST input a filename.&quot; &amp;&amp; exit 0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 判断档案是否存在？若不存在则显示讯息并结束脚本</span><br>test ! -e $&#123;filename&#125; &amp;&amp; echo &quot;The filename &#x27;$&#123;filename&#125;&#x27; DO NOT exist&quot; &amp;&amp; exit 0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">3. 开始判断档案类型与属性</span><br>test -f $&#123;filename&#125; &amp;&amp; filetype=&quot;regulare file&quot;<br>test -d $&#123;filename&#125; &amp;&amp; filetype=&quot;directory&quot;<br>test -r $&#123;filename&#125; &amp;&amp; perm=&quot;readable&quot;<br>test -w $&#123;filename&#125; &amp;&amp; perm=&quot;$&#123;perm&#125; writable&quot;<br>test -x $&#123;filename&#125; &amp;&amp; perm=&quot;$&#123;perm&#125; executable&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">4. 开始输出资讯！</span><br>echo &quot;The filename: $&#123;filename&#125; is a $&#123;filetype&#125;&quot;<br>echo &quot;And the permissions for you are : $&#123;perm&#125;&quot;<br></code></pre></td></tr></table></figure><p>使用中括号 <code>[]</code> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">This program shows the user<span class="hljs-string">&#x27;s choice</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">History:</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">2015/07/16 VBird First release</span></span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>read -p &quot;Please input (Y/N): &quot; yn<br>[ &quot;$&#123;yn&#125;&quot; == &quot;Y&quot; -o &quot;$&#123;yn&#125;&quot; == &quot;y&quot; ] &amp;&amp; echo &quot;OK, continue&quot; &amp;&amp; exit 0<br>[ &quot;$&#123;yn&#125;&quot; == &quot;N&quot; -o &quot;$&#123;yn&#125;&quot; == &quot;n&quot; ] &amp;&amp; echo &quot;Oh, interrupt!&quot; &amp;&amp; exit 0<br>echo &quot;I don&#x27;t know what your choice is&quot; &amp;&amp; exit 0<br></code></pre></td></tr></table></figure><p>shell 脚本的默认变量（<code>$0</code> <code>$1</code> ...）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program shows the script name, parameters...</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/16 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>echo &quot;The script name is ==&gt; $&#123;0&#125;&quot;<br>echo &quot;Total parameter number is ==&gt; $#&quot;<br>[ &quot;$#&quot; -lt 2 ] &amp;&amp; echo &quot;The number of parameter is less than 2. Stop here.&quot; &amp;&amp; exit 0<br>echo &quot;Your whole parameter is ==&gt; &#x27;$@&#x27;&quot;<br>echo &quot;The 1st parameter ==&gt; $&#123;1&#125;&quot;<br>echo &quot;The 2nd parameter ==&gt; $&#123;2&#125;&quot;<br></code></pre></td></tr></table></figure><h3 id="条件判断式">12.4 条件判断式</h3><h4 id="if...then">12.4.1 if...then</h4><p>单层、简单条件判断式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">if [条件判断式]; then<br>当条件判断式成立时，可以进行的指令工作内容；<br>fi<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">This program shows the user<span class="hljs-string">&#x27;s choice</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">History:</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">2015/07/16 VBird First release</span></span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>read -p &quot;Please input (Y/N): &quot; yn<br><br>if [ &quot;$&#123;yn&#125;&quot; == &quot;Y&quot; ] || [ &quot;$&#123;yn&#125;&quot; == &quot;y&quot; ]; then<br>echo &quot;OK, continue&quot;<br>exit 0<br>fi<br>if [ &quot;$&#123;yn&#125;&quot; == &quot;N&quot; ] || [ &quot;$&#123;yn&#125;&quot; == &quot;n&quot; ]; then<br>echo &quot;Oh, interrupt!&quot;<br>exit 0<br>fi<br>echo &quot;I don&#x27;t know what your choice is&quot; &amp;&amp; exit 0<br></code></pre></td></tr></table></figure><p>多重、复杂条件判断式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">一个条件判断，分成功进行与失败进行(<span class="hljs-keyword">else</span>)</span> <br>if [条件判断式]; then<br>当条件判断式成立时，可以进行的指令工作内容；<br>else<br>当条件判断式不成立时，可以进行的指令工作内容；<br>fi<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">多个条件判断(<span class="hljs-keyword">if</span> ... <span class="hljs-keyword">elif</span> ... <span class="hljs-keyword">elif</span> ... <span class="hljs-keyword">else</span>) 分多种不同情况执行</span><br>if [条件判断式一]; then<br>当条件判断式一成立时，可以进行的指令工作内容；<br>elif [条件判断式二]; then<br>当条件判断式二成立时，可以进行的指令工作内容；<br>else<br>当条件判断式一与二均不成立时，可以进行的指令工作内容；<br>fi<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">This program shows the user<span class="hljs-string">&#x27;s choice</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">History:</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">2015/07/16 VBird First release</span></span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>read -p &quot;Please input (Y/N): &quot; yn<br><br>if [ &quot;$&#123;yn&#125;&quot; == &quot;Y&quot; ] || [ &quot;$&#123;yn&#125;&quot; == &quot;y&quot; ]; then<br>echo &quot;OK, continue&quot;<br>elif [ &quot;$&#123;yn&#125;&quot; == &quot;N&quot; ] || [ &quot;$&#123;yn&#125;&quot; == &quot;n&quot; ]; then<br>echo &quot;Oh, interrupt!&quot;<br>else<br>echo &quot;I don&#x27;t know what your choice is&quot;<br>fi<br></code></pre></td></tr></table></figure><p>从命令行获取用户输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Check <span class="hljs-variable">$1</span> is equal to <span class="hljs-string">&quot;hello&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/16 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>if [ &quot;$&#123;1&#125;&quot; == &quot;hello&quot; ]; then<br>echo &quot;Hello, how are you ?&quot;<br>elif [ &quot;$&#123;1&#125;&quot; == &quot;&quot; ]; then<br>echo &quot;You MUST input parameters, ex&gt; &#123;$&#123;0&#125; someword&#125;&quot;<br>else<br>echo &quot;The only parameter is &#x27;hello&#x27;, ex&gt; &#123;$&#123;0&#125; hello&#125;&quot;<br>fi<br></code></pre></td></tr></table></figure><p>检测服务端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Using netstat and grep to detect WWW,SSH,FTP and Mail services.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/16 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 先作一些告知的动作而已～</span><br>echo &quot;Now, I will detect your Linux server&#x27;s services!&quot;<br>echo -e &quot;The www, ftp, ssh, and mail(smtp) will be detected! \n&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 开始进行一些测试的工作，并且也输出一些资讯啰！</span><br>testfile=/dev/shm/netstat_checking.txt<br>netstat -tuln &gt; $&#123;testfile&#125;           # 先转存资料到记忆体当中！不用一直执行netstat <br>testing=$(grep &quot;:80 &quot; $&#123;testfile&#125;)    # 侦测看port 80 在否？<br>if [ &quot;$&#123;testing&#125;&quot; != &quot;&quot; ]; then<br>echo &quot;WWW is running in your system.&quot;<br>fi<br>testing=$(grep &quot;:22 &quot; $&#123;testfile&#125;)    # 侦测看port 22 在否？<br>if [ &quot;$&#123;testing&#125;&quot; != &quot;&quot; ]; then<br>echo &quot;SSH is running in your system.&quot;<br>fi<br>testing=$(grep &quot;:21 &quot; $&#123;testfile&#125;)    # 侦测看port 21 在否？<br>if [ &quot;$&#123;testing&#125;&quot; != &quot;&quot; ]; then<br>echo &quot;FTP is running in your system.&quot;<br>fi<br>testing=$(grep &quot;:25 &quot; $&#123;testfile&#125;)    # 侦测看port 25 在否？<br>if [ &quot;$&#123;testing&#125;&quot; != &quot;&quot; ]; then<br>echo &quot;Mail is running in your system.&quot;<br>fi<br></code></pre></td></tr></table></figure><p>计算距离指定日期剩余天数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">You input your demobilization <span class="hljs-built_in">date</span>, I calculate how many days before you demobilize.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/16 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 告知使用者这支程式的用途，并且告知应该如何输入日期格式？</span><br>echo &quot;This program will try to calculate :&quot;<br>echo &quot;How many days before your demobilization date...&quot;<br>read -p &quot;Please input your demobilization date (YYYYMMDD ex&gt;20150716): &quot; date2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 测试一下，这个输入的内容是否正确？利用正规表示法啰～</span> <br>date_d=$(echo $&#123;date2&#125; |grep &#x27;[0-9]\&#123;8\&#125;&#x27;)    # 看看是否有八个数字<br>if [ &quot;$&#123;date_d&#125;&quot; == &quot;&quot; ]; then<br>echo &quot;You input the wrong date format....&quot;<br>exit 1<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3. 开始计算日期啰～</span> <br>declare -i date_dem=$(date --date=&quot;$&#123;date2&#125;&quot; +%s)       # 退伍日期秒数<br>declare -i date_now=$(date +%s)                         # 现在日期秒数<br>declare -i date_total_s=$(($&#123;date_dem&#125;-$&#123;date_now&#125;))    # 剩余秒数统计<br>declare -i date_d=$(($&#123;date_total_s&#125;/60/60/24))         # 转为日数<br>if [ &quot;$&#123;date_total_s&#125;&quot; -lt &quot;0&quot; ]; then                  # 判断是否已退伍<br>echo &quot;You had been demobilization before: &quot; $((-1*$&#123;date_d&#125;)) &quot; ago&quot;<br>else<br>declare -i date_h=$(($(($&#123;date_total_s&#125;-$&#123;date_d&#125;*60*60*24))/60/60))<br>echo &quot;You will demobilize after $&#123;date_d&#125; days and $&#123;date_h&#125; hours.&quot;<br>fi<br></code></pre></td></tr></table></figure><h4 id="case...esac">12.4.2 case...esac</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">case $变数名称 in    &lt;==关键字为case ，还有变数前有钱字号<br>  &quot;第一个变数内容&quot; )    &lt;==每个变数内容建议用双引号括起来，关键字则为小括号)<br>程式段<br>;;             &lt;==每个类别结尾使用两个连续的分号来处理！<br>  &quot;第二个变数内容&quot; )<br>程式段<br>;; <br>  * )                   &lt;==最后一个变数内容都会用* 来代表所有其他值<br>不包含第一个变数内容与第二个变数内容的其他程式执行段<br>exit 1<br>;; <br>esac<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Show <span class="hljs-string">&quot;Hello&quot;</span> from <span class="hljs-variable">$1</span>.... by using <span class="hljs-keyword">case</span> .... <span class="hljs-keyword">esac</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/16 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>case $&#123;1&#125; in<br>  &quot;hello&quot;)<br>echo &quot;Hello, how are you ?&quot;<br>;;<br>  &quot;&quot;)<br>echo &quot;You MUST input parameters, ex&gt; &#123;$&#123;0&#125; someword&#125;&quot;<br>;;<br>  *)    # 其实就相当于万用字元，0~无穷多个任意字元之意！<br>echo &quot;Usage $&#123;0&#125; &#123;hello&#125;&quot;<br>;;<br>esac<br></code></pre></td></tr></table></figure><h4 id="function">12.4.3 function</h4><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">function fname () &#123;<br>程序段<br>&#125;<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Use <span class="hljs-keyword">function</span> to repeat information.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/17 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>function printit()&#123;<br>echo -n &quot;Your choice is &quot;      # 加上-n 可以不断行继续在同一行显示<br>&#125;<br><br>echo &quot;This program will print your selection !&quot;<br>case $&#123;1&#125; in<br>  &quot;one&quot;)<br>printit ; echo $&#123;1&#125; | tr &#x27;az&#x27; &#x27;AZ&#x27;   # 将参数做大小写转换！<br>;;<br>  &quot;two&quot;)<br>printit ; echo $&#123;1&#125; | tr &#x27;az&#x27; &#x27;AZ&#x27;<br>;;<br>  &quot;three&quot;)<br>printit ; echo $&#123;1&#125; | tr &#x27;az&#x27; &#x27;AZ&#x27;<br>;;<br>  *)<br>echo &quot;Usage $&#123;0&#125; &#123;one|two|three&#125;&quot;<br>;;<br>esac<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Use <span class="hljs-keyword">function</span> to repeat information.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/17 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>function printit()&#123;<br>echo &quot;Your choice is $&#123;1&#125;&quot;    # 这个$1 必须要参考底下指令的下达<br>&#125;<br><br>echo &quot;This program will print your selection !&quot;<br>case $&#123;1&#125; in<br>  &quot;one&quot;)<br>printit 1   # 请注意， printit 指令后面还有接参数！<br>;;<br>  &quot;two&quot;)<br>printit 2<br>;;<br>  &quot;three&quot;)<br>printit 3<br>;;<br>  *)<br>echo &quot;Usage $&#123;0&#125; &#123;one|two|three&#125;&quot;<br>;;<br>esac<br></code></pre></td></tr></table></figure><h3 id="循环">12.5 循环</h3><h4 id="while-do-doneuntil-do-done不定循环">12.5.1 while do done、untildo done（不定循环）</h4><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">while [ condition ]   &lt;==中括号内的状态就是判断式<br>do             &lt;==do 是循环的开始！<br>程式段落<br>done<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">until [ condition ]<br>do<br>程式段落<br>done<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Repeat question until user input correct answer.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/17 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>while [ &quot;$&#123;yn&#125;&quot; != &quot;yes&quot; -a &quot;$&#123;yn&#125;&quot; != &quot;YES&quot; ]<br>do<br>read -p &quot;Please input yes/YES to stop this program: &quot; yn<br>done<br>echo &quot;OK! you input the correct answer.&quot;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Repeat question until user input correct answer.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/17 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>until [ &quot;$&#123;yn&#125;&quot; == &quot;yes&quot; -o &quot;$&#123;yn&#125;&quot; == &quot;YES&quot; ]<br>do<br>read -p &quot;Please input yes/YES to stop this program: &quot; yn<br>done<br>echo &quot;OK! you input the correct answer.&quot;<br></code></pre></td></tr></table></figure><p>示例：(计算1+2+3+....+100)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Use loop to calculate <span class="hljs-string">&quot;1+2+3+...+100&quot;</span> result.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/17 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>s=0   # 这是加总的数值变数<br>i=0   # 这是累计的数值，亦即是1, 2, 3....<br>while [ &quot;$&#123;i&#125;&quot; != &quot;100&quot; ]<br>do<br>i=$(($i+1))    # 每次i 都会增加1 <br>s=$(($s+$i))   # 每次都会求和一次<br>done<br>echo &quot;The result of &#x27;1+2+3+...+100&#x27; is ==&gt; $s&quot;<br></code></pre></td></tr></table></figure><h4 id="for...do...done固定循环">12.5.2 for...do...done（固定循环）</h4><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for var in con1 con2 con3 ...<br>do<br>程式段<br>done<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Using <span class="hljs-keyword">for</span> .... loop to <span class="hljs-built_in">print</span> 3 animals</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/17 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>for animal in dog cat elephant<br>do<br>echo &quot;There are $&#123;animal&#125;s.... &quot;<br>done<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Use ping <span class="hljs-built_in">command</span> to check the network<span class="hljs-string">&#x27;s PC state.</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">History</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">2015/07/17 VBird first release</span></span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br>network=&quot;192.168.1&quot;               # 先定义一个网域的前面部分！<br>for sitenu in $(seq 1 100)        # seq 为sequence(连续) 的缩写之意<br>do<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">底下的程式在取得ping 的回传值是正确的还是失败的！</span></span><br>        ping -c 1 -w 1 $&#123;network&#125;.$&#123;sitenu&#125; &amp;&gt; /dev/null &amp;&amp; result=0 || result=1<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">开始显示结果是正确的启动(UP) 还是错误的没有连通(DOWN)</span></span><br>        if [ &quot;$&#123;result&#125;&quot; == 0 ]; then<br>                echo &quot;Server $&#123;network&#125;.$&#123;sitenu&#125; is UP.&quot;<br>        else<br>                echo &quot;Server $&#123;network&#125;.$&#123;sitenu&#125; is DOWN.&quot;<br>        fi<br>done<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">User input <span class="hljs-built_in">dir</span> name, I find the permission of files.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/17 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 先看看这个目录是否存在啊？</span><br>read -p &quot;Please input a directory: &quot; dir<br>if [ &quot;$&#123;dir&#125;&quot; == &quot;&quot; -o ! -d &quot;$&#123;dir&#125;&quot; ]; then<br>echo &quot;The $&#123;dir&#125; is NOT exist in your system.&quot;<br>exit 1<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 开始测试档案啰～</span> <br>filelist=$(ls $&#123;dir&#125;)         # 列出所有在该目录下的档案名称<br>for filename in $&#123;filelist&#125;<br>do<br>perm=&quot;&quot;<br>test -r &quot;$&#123;dir&#125;/$&#123;filename&#125;&quot; &amp;&amp; perm=&quot;$&#123;perm&#125; readable&quot;<br>test -w &quot;$&#123;dir&#125;/$&#123;filename&#125;&quot; &amp;&amp; perm=&quot;$&#123;perm&#125; writable&quot;<br>test -x &quot;$&#123;dir&#125;/$&#123;filename&#125;&quot; &amp;&amp; perm=&quot;$&#123;perm&#125; executable&quot;<br>echo &quot;The file $&#123;dir&#125;/$&#123;filename&#125;&#x27;s permission is $&#123;perm&#125; &quot;<br>done<br></code></pre></td></tr></table></figure><h4 id="for...do...done-的数值处理">12.5.3 for...do...done的数值处理</h4><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for ((初始值;限制值;赋值运算))<br>do<br>程式段<br>done<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Try <span class="hljs-keyword">do</span> calculate 1+2+....+<span class="hljs-variable">$&#123;your_input&#125;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/17 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>read -p &quot;Please input a number, I will count for 1+2+...+your_input: &quot; nu<br><br>s=0<br>for (( i=1; i&lt;=$&#123;nu&#125;; i=i+1 ))<br>do<br>s=$(($&#123;s&#125;+$&#123;i&#125;))<br>done<br>echo &quot;The result of &#x27;1+2+3+...+$&#123;nu&#125;&#x27; is ==&gt; $&#123;s&#125;&quot;<br></code></pre></td></tr></table></figure><h4 id="搭配随机数和数组的实验">12.5.4 搭配随机数和数组的实验</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Try <span class="hljs-keyword">do</span> tell you what you may eat.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/17 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>eat[1]=&quot;卖当当汉堡&quot;        # 写下你所收集到的店家！<br>eat[2]=&quot;肯爷爷炸鸡&quot;<br>eat[3]=&quot;彩虹日式便当&quot;<br>eat[4]=&quot;越油越好吃大雅&quot;<br>eat[5]=&quot;想不出吃啥学餐&quot;<br>eat[6]=&quot;太师父便当&quot;<br>eat[7]=&quot;池上便当&quot;<br>eat[8]=&quot;怀念火车便当&quot;<br>eat[9]=&quot;一起吃泡面&quot;<br>eatnum=9                   # 需要输入有几个可用的餐厅数！<br><br>check=$(( $&#123;RANDOM&#125; * $&#123;eatnum&#125; / 32767 + 1 ))<br>echo &quot;your may eat $&#123;eat[$&#123;check&#125;]&#125;&quot;<br></code></pre></td></tr></table></figure><h3 id="shell-脚本的跟踪与调试">12.6 shell 脚本的跟踪与调试</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sh [-nvx] scripts.sh</span><br>选项与参数：<br>-n ：不要执行script，仅查询语法的问题；<br>-v ：再执行script 前，先将scripts 的内容输出到萤幕上；<br>-x ：将使用到的script 内容显示到萤幕上，这是很有用的参数！<br><br>范例一：测试dir_perm.sh 有无语法的问题？<br>[dmtsai@study ~]$ sh -n dir_perm.sh <br><span class="hljs-meta prompt_"># </span><span class="language-bash">若语法没有问题，则不会显示任何资讯！</span><br><br>范例二：将show_animal.sh 的执行过程全部列出来～ <br>[dmtsai@study ~]$ sh -x show_animal.sh <br>+ PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:/root/bin<br>+ export PATH<br>+ for animal in dog cat elephant<br>+ echo &#x27;There are dogs.... &#x27;<br>There are dogs....<br>+ for animal in dog cat elephant<br>+ echo &#x27;There are cats.... &#x27;<br>There are cats....<br>+ for animal in dog cat elephant<br>+ echo &#x27;There are elephants.... &#x27;<br>There are elephants....<br></code></pre></td></tr></table></figure><h2 id="linux-账号管理与-acl-权限设置">13. Linux 账号管理与 ACL权限设置</h2><h3 id="账号管理">13.2 账号管理</h3><p>用户管理：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">useradd [-u UID] [-g 初始群组] [-G 次要群组] [-mM]\ </span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">[-c 说明栏] [-d 家目录绝对路径] [-s shell] 使用者帐号名</span><br>选项与参数：<br>-u ：后面接的是UID ，是一组数字。直接指定一个特定的UID 给这个帐号；<br>-g ：后面接的那个群组名称就是我们上面提到的initial group 啦～<br>      该群组的GID 会被放置到/etc/passwd 的第四个栏位内。<br>-G ：后面接的群组名称则是这个帐号还可以加入的群组。<br>      这个选项与参数会修改/etc/group 内的相关资料喔！<br>-M ：强制！不要建立使用者家目录！(系统帐号预设值)<br>-m ：强制！要建立使用者家目录！(一般帐号预设值)<br>-c ：这个就是/etc/passwd 的第五栏的说明内容啦～可以随便我们设定的啦～<br>-d ：指定某个目录成为家目录，而不要使用预设值。务必使用绝对路径！<br>-r ：建立一个系统的帐号，这个帐号的UID 会有限制(参考/etc/login.defs)<br>-s ：后面接一个shell ，若没有指定则预设是/bin/bash 的啦～<br>-e ：后面接一个日期，格式为『YYYY-MM-DD』此项目可写入shadow 第八栏位，<br>      亦即帐号失效日的设定项目啰；<br>-f ：后面接shadow 的第七栏位项目，指定密码是否会失效。0为立刻失效，<br>      -1 为永远不失效(密码只会过期而强制于登入时重新设定而已。)<br><br>范例一：完全参考预设值建立一个使用者，名称为vbird1 <br>[root@study ~]# useradd vbird1 <br>[root@study ~]# ll -d /home/vbird1<br>drwx------. 3 vbird1 vbird1 74 Jul 20 21:50 /home/vbird1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">预设会建立使用者家目录，且权限为700 ！这是重点！</span><br><br>[root@study ~]# grep vbird1 /etc/passwd /etc/shadow /etc/group<br>/etc/passwd:vbird1:x:1003:1004::/home/vbird1:/bin/bash<br>/etc/shadow:vbird1:!!:16636:0:99999:7:::<br>/etc/group:vbird1:x:1004:      &lt;==预设会建立一个与帐号一模一样的群组名<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">passwd [--stdin] [帐号名称]   &lt;==所有人均可使用来改自己的密码</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">passwd [-l] [-u] [--stdin] [-S] \ </span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">  [-n 日数] [-x 日数] [-w 日数] [-i 日数] 帐号 &lt;==root 功能</span><br>选项与参数：<br>--stdin ：可以透过来自前一个管线的资料，作为密码输入，对shell script 有帮助！<br>-l ：是Lock 的意思，会将/etc/shadow 第二栏最前面加上! 使密码失效；<br>-u ：与-l 相对，是Unlock 的意思！<br>-S ：列出密码相关参数，亦即shadow 档案内的大部分资讯。<br>-n ：后面接天数，shadow 的第4 栏位，多久不可修改密码天数<br>-x ：后面接天数，shadow 的第5 栏位，多久内必须要更动密码<br>-w ：后面接天数，shadow 的第6 栏位，密码过期前的警告天数<br>-i ：后面接天数，shadow 的第7 栏位，密码失效天数<br><br>范例一：请root 给予vbird2 密码<br><span class="hljs-meta prompt_"># </span><span class="language-bash">passwd vbird2</span><br>Changing password for user vbird2.<br>New UNIX password: &lt;==这里直接输入新的密码，萤幕不会有任何反应<br>BAD PASSWORD: The password is shorter than 8 characters &lt;==密码太简单或过短的错误！<br>Retype new UNIX password:   &lt;==再输入一次同样的密码<br>passwd: all authentication tokens updated successfully .   &lt;==竟然还是成功修改了！<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">usermod [-cdegGlsuLU] username</span><br>选项与参数：<br>-c ：后面接帐号的说明，即/etc/passwd 第五栏的说明栏，可以加入一些帐号的说明。<br>-d ：后面接帐号的家目录，即修改/etc/passwd 的第六栏；<br>-e ：后面接日期，格式是YYYY-MM-DD 也就是在/etc/shadow 内的第八个栏位资料啦！<br>-f ：后面接天数，为shadow 的第七栏位。<br>-g ：后面接初始群组，修改/etc/passwd 的第四个栏位，亦即是GID 的栏位！<br>-G ：后面接次要群组，修改这个使用者能够支援的群组，修改的是/etc/group 啰～<br>-a ：与-G 合用，可『增加次要群组的支援』而非『设定』喔！<br>-l ：后面接帐号名称。亦即是修改帐号名称， /etc/passwd 的第一栏！<br>-s ：后面接Shell 的实际档案，例如/bin/bash 或/bin/csh 等等。<br>-u ：后面接UID 数字啦！即/etc/passwd 第三栏的资料；<br>-L ：暂时将使用者的密码冻结，让他无法登入。其实仅改/etc/shadow 的密码栏。<br>-U ：将/etc/shadow 密码栏的! 拿掉，解冻啦！<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">userdel [-r] username</span><br>选项与参数：<br>-r ：连同使用者的家目录也一起删除<br><br>范例一：删除vbird2 ，连同家目录一起删除<br><span class="hljs-meta prompt_"># </span><span class="language-bash">userdel -r vbird2</span><br></code></pre></td></tr></table></figure><p>用户组管理：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">groupadd [-g gid] [-r] 群组名称</span><br>选项与参数：<br>-g ：后面接某个特定的GID ，用来直接给予某个GID ～<br>-r ：建立系统群组啦！与/etc/login.defs 内的GID_MIN 有关。<br><br>范例一：新建一个群组，名称为group1 <br><span class="hljs-meta prompt_"># </span><span class="language-bash">groupadd group1</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">grep group1 /etc/group /etc/gshadow</span> <br>/etc/group:group1:x: 1503 :<br>/etc/gshadow:group1:!::<br><span class="hljs-meta prompt_"># </span><span class="language-bash">群组的GID 也是会由1000 以上最大GID+1 来决定！</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">groupmod [-g gid] [-n group_name] 群组名</span><br>选项与参数：<br>-g ：修改既有的GID 数字；<br>-n ：修改既有的群组名称<br><br>范例一：将刚刚上个指令建立的group1 名称改为mygroup ， GID 为201 <br><span class="hljs-meta prompt_"># </span><span class="language-bash">groupmod -g 201 -n mygroup group1</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">grep mygroup /etc/group /etc/gshadow</span> <br>/etc/group:mygroup:x: 201 :<br>/etc/gshadow:mygroup:!::<br></code></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># groupdel [groupname]</span><br><br>范例一：将刚刚的mygroup 删除！<br><span class="hljs-comment"># groupdel mygroup</span><br><br>范例二：若要删除vbird1 这个群组的话？<br><span class="hljs-comment"># groupdel vbird1</span><br>groupdel: cannot remove the primary <span class="hljs-keyword">group</span> <span class="hljs-title">of</span> <span class="hljs-keyword">user</span> <span class="hljs-title">&#x27;vbird1</span>&#x27;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">关于系统管理员(root)做的动作：</span> <br>[root@study ~]# gpasswd groupname <br>[root@study ~]# gpasswd [-A user1,...] [-M user3,...] groupname <br>[root@study ~]# gpasswd [-rR] groupname<br>选项与参数：<br>    ：若没有任何参数时，表示给予groupname 一个密码(/etc/gshadow)<br>-A ：将groupname 的主控权交由后面的使用者管理(该群组的管理员)<br>-M ：将某些帐号加入这个群组当中！<br>-r ：将groupname 的密码移除<br>-R ：让groupname 的密码栏失效<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">关于群组管理员(Group administrator)做的动作：</span> <br>[someone@study ~]$ gpasswd [-ad] user groupname<br>选项与参数：<br>-a ：将某位使用者加入到groupname 这个群组当中！<br>-d ：将某位使用者移除出groupname 这个群组当中。<br><br>范例一：建立一个新群组，名称为testgroup 且群组交由vbird1 管理： <br>[root@study ~]# groupadd testgroup   &lt;==先建立群组<br>[root@study ~]# gpasswd testgroup   &lt;==给这个群组一个密码吧！<br>Changing the password for group testgroup<br>New Password:<br>Re-enter new password:<br><span class="hljs-meta prompt_"># </span><span class="language-bash">输入两次密码就对了！</span><br>[root@study ~]# gpasswd -A vbird1 testgroup   &lt;==加入群组管理员为vbird1 <br>[root@study ~]# grep testgroup /etc/group /etc/gshadow<br>/etc/group:testgroup:x:1503:<br>/etc/gshadow:testgroup: $6$MnmChP3D$mrUn.Vo.buDjObMm8F2emTkvGSeuWikhRzaKHxpJ...:vbird1: <br><span class="hljs-meta prompt_"># </span><span class="language-bash">很有趣吧！此时vbird1 则拥有testgroup 的主控权喔！身份有点像板主啦！</span><br><br>范例二：以vbird1 登入系统，并且让他加入vbird1, vbird3 成为testgroup 成员<br>[vbird1@study ~]$ id<br>uid=1003(vbird1) gid=1004(vbird1) groups=1004(vbird1) ...<br><span class="hljs-meta prompt_"># </span><span class="language-bash">看得出来，vbird1 尚未加入testgroup 群组喔！</span><br><br>[vbird1@study ~]$ gpasswd -a vbird1 testgroup <br>[vbird1@study ~]$ gpasswd -a vbird3 testgroup <br>[vbird1@study ~]$ grep testgroup /etc/group <br>testgroup:x:1503: vbird1,vbird3<br></code></pre></td></tr></table></figure><h3 id="用户身份切换">13.4 用户身份切换</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">su [-lm] [-c 指令] [username]</span><br>选项与参数：<br>- ：单纯使用- 如『 su - 』代表使用login-shell 的变数档案读取方式来登入系统；<br>      若使用者名称没有加上去，则代表切换为root 的身份。<br>-l ：与- 类似，但后面需要加欲切换的使用者帐号！也是login-shell 的方式。<br>-m ：-m 与-p 是一样的，表示『使用目前的环境设定，而不读取新使用者的设定档』<br>-c ：仅进行一次指令，所以-c 后面可以加上指令<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell">范例一：假设你原本是dmtsai 的身份，想要使用non-login shell 的方式变成root <br>[ dmtsai @study ~]$ su        &lt;==注意提示字元，是dmtsai 的身份喔！<br>Password:                   &lt;==这里输入root 的密码喔！<br>[root@study dmtsai ]# id     &lt;==提示字元的目录是dmtsai 喔！<br>uid=0(root) gid=0(root) groups=0(root) context=unconf....   &lt;==确实是root 的身份！<br>[root@study dmtsai]# env | grep &#x27;dmtsai&#x27; <br>USER=dmtsai                                          &lt;==竟然还是dmtsai 这家伙！<br>PATH=...:/home/dmtsai/.local/bin:/home/dmtsai/bin    &lt;==这个影响最大！ <br>MAIL=/var/spool/mail/dmtsai                          &lt;==收到的mailbox 是vbird1<br>PWD=/home/dmtsai                                     &lt;==并非root 的家目录<br>LOGNAME=dmtsai<br><span class="hljs-meta prompt_"># </span><span class="language-bash">虽然你的UID 已经是具有root 的身份，但是看到上面的输出讯息吗？</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">还是有一堆变数为原本dmtsai 的身份，所以很多资料还是无法直接利用。</span><br>[root@study dmtsai]# exit    &lt;==这样可以离开su 的环境<br><br><br>范例二：使用login shell 的方式切换为root 的身份并观察变数<br>[dmtsai@study ~]$ su - <br>Password:    &lt;==这里输入root 的密码喔！<br>[root@study ~]# env | grep root<br>USER=root<br>MAIL=/var/spool/mail/root<br>PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin<br>PWD=/root<br>HOME=/root<br>LOGNAME=root<br><span class="hljs-meta prompt_"># </span><span class="language-bash">了解差异了吧？下次变换成为root 时，记得最好使用su - 喔！</span><br>[root@study ~]# exit    &lt;==这样可以离开su 的环境<br></code></pre></td></tr></table></figure><p>sudo：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# sudo [-b] [-u 新使用者帐号]<br>选项与参数：<br>-b ：将后续的指令放到背景中让系统自行执行，而不与目前的shell 产生影响<br>-u ：后面可以接欲切换的使用者，若无此项则代表切换身份为root 。<br><br>范例一：你想要以sshd 的身份在/tmp 底下建立一个名为mysshd 的档案<br>[root@study ~]# sudo -u sshd touch /tmp/mysshd <br>[root@study ~]# ll /tmp/mysshd <br>-rw-r--r--. 1 sshd sshd 0 Jul 21 23:37 /tmp/mysshd<br><span class="hljs-meta prompt_"> # </span><span class="language-bash">特别留意，这个档案的权限是由sshd 所建立的情况喔！</span><br><br>范例二：你想要以vbird1 的身份建立~vbird1/www 并于其中建立index.html 档案<br>[root@study ~]# sudo -u vbird1 sh -c &quot;mkdir ~vbird1/www; cd ~vbird1/www; \ <br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">  <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;This is index.html file&#x27;</span> &gt; index.html<span class="hljs-string">&quot;</span></span> <br>[root@study ~]# ll -a ~vbird1/www<br>drwxr-xr-x. 2 vbird1 vbird1 23 Jul 21 23:38 .<br>drwx------. 6 vbird1 vbird1 4096 Jul 21 23:38 ..<br>-rw-r--r--. 1 vbird1 vbird1 24 Jul 21 23:38 index.html<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">要注意，建立者的身份是vbird1 ，且我们使用sh -c &quot;</span>一串指令<span class="hljs-string">&quot; 来执行的！</span></span><br></code></pre></td></tr></table></figure><h2 id="磁盘配额quota与高级文件系统管理">14.磁盘配额（Quota）与高级文件系统管理</h2><p>略</p><h2 id="计划任务crontab">15. 计划任务（crontab）</h2><h3 id="什么是计划任务">15.1 什么是计划任务</h3><ul><li><strong>at</strong>：at是个可以处理仅执行一次就结束排程的指令，不过要执行at 时， 必须要有atd这个服务的支援才行。在某些新版的distributions 中，atd可能预设并没有启动，那么at 这个指令就会失效</li><li><strong>crontab</strong>：crontab这个指令所设定的工作将会循环的一直进行下去！可循环的时间为分钟、小时、每周、每月或每年等。crontab除了可以使用指令执行外，亦可编辑/etc/crontab 来支援。至于让crontab可以生效的服务则是crond 这个服务</li></ul><h3 id="仅执行一次的计划任务">15.2 仅执行一次的计划任务</h3><p>需先启动 atd 服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# systemctl restart atd   # 重新启动atd 这个服务<br>[root@study ~]# systemctl enable atd   # 让这个服务开机就自动启动<br>[root@study ~]# systemctl status atd   # 查阅一下atd 目前的状态<br>atd.service - Job spooling tools<br>   Loaded: loaded (/usr/lib/systemd/system/atd.service; enabled )        # 是否开机启动<br>   Active: active (running) since Thu 2015-07-30 19:21:21 CST; 23s ago # 是否正在运作中<br> Main PID: 26503 (atd)<br>   CGroup: /system.slice/atd.service<br>           └─26503 /usr/sbin/atd -f<br><br>Jul 30 19:21:21 study.centos.vbird systemd[1]: Starting Job spooling tools...<br>Jul 30 19:21:21 study.centos.vbird systemd[1]: Started Job spooling tools.<br></code></pre></td></tr></table></figure><p>使用 at这个指令来产生所要运作的工作，并将这个工作以文本文件的方式写入/var/spool/at/ 目录内，该工作便能等待atd 这个服务的取用与执行了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# at [-mldv] TIME <br>[root@study ~]# at -c 任务号码<br>选项与参数：<br>-m ：当at 的工作完成后，即使没有输出讯息，亦以email 通知使用者该工作已完成。<br>-l ：at -l 相当于atq，列出目前系统上面的所有该使用者的at 计划；<br>-d ：at -d 相当于atrm ，可以取消一个在at 计划中的工作；<br>-v ：可以使用较明显的时间格式列出at 计划中的工作列表；<br>-c ：可以列出后面接的该项工作的实际指令内容。<br><br>TIME：时间格式，这里可以定义出『什么时候要进行at 这项计划』的时间，格式有：<br>  HH:MM ex&gt; 04:00<br>在今日的HH:MM 时刻进行，若该时刻已超过，则明天的HH:MM 进行此工作。<br>  HH:MM YYYY-MM-DD ex&gt; 04:00 2015-07-30<br>强制规定在某年某月的某一天的特殊时刻进行该工作！<br>  HH:MM[am|pm] [Month] [Date] ex&gt; 04pm July 30<br>也是一样，强制在某年某月某日的某时刻进行！<br>  HH:MM[am|pm] + number [minutes|hours|days|weeks]<br><span class="hljs-meta prompt_">ex&gt; </span><span class="language-bash">now + 5 minutes ex&gt; 04pm + 3 days</span><br>就是说，在某个时间点『再加几个时间后』才进行。<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell">范例一：再过五分钟后，将/root/.bashrc 寄给root 自己<br>[root@study ~]# at now + 5 minutes   &lt;==记得单位要加s 喔！<br><span class="hljs-meta prompt_">at&gt; </span><span class="language-bash">/bin/mail -s <span class="hljs-string">&quot;testing at job&quot;</span> root &lt; /root/.bashrc</span> <br><span class="hljs-meta prompt_">at&gt; </span><span class="language-bash">&lt;EOT&gt;    &lt;==这里输入[ctrl] + d 就会出现&lt;EOF&gt; 的字样！代表结束！</span><br>job 2 at Thu Jul 30 19:35:00 2015<br><span class="hljs-meta prompt_"># </span><span class="language-bash">上面这行资讯在说明，第2 个at 工作将在2015/07/30 的19:35 进行！</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">而执行at 会进入所谓的at shell 环境，让你下达多重指令等待运作！</span><br><br>范例二：将上述的第2 项工作内容列出来查阅<br>[root@study ~]# at -c 2 <br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/sh                &lt;==就是透过bash shell 的啦！</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">atrun uid=0 gid=0</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">mail root 0</span><br>umask 22<br>....(中间省略许多的环境变数项目)....<br>cd /etc/cron\.d || &#123;<br>         echo &#x27;Execution directory inaccessible&#x27; &gt;&amp;2<br>         exit 1<br>&#125;<br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;SHELL:-/bin/sh&#125; &lt;&lt; <span class="hljs-string">&#x27;marcinDELIMITER410efc26&#x27;</span></span><br>/bin/mail -s &quot;testing at job&quot; root &lt; /root/.bashrc     # 这一行最重要！<br>marcinDELIMITER410efc26 <br><span class="hljs-meta prompt_"># </span><span class="language-bash">你可以看到指令执行的目录(/root)，还有多个环境变数与实际的指令内容啦！</span><br><br>范例三：由于机房预计于2015/08/05 停电，我想要在2015/08/04 23:00 关机？<br>[root@study ~]# at 23:00 2015-08-04 <br><span class="hljs-meta prompt_">at&gt; </span><span class="language-bash">/bin/sync</span> <br><span class="hljs-meta prompt_">at&gt; </span><span class="language-bash">/bin/sync</span> <br><span class="hljs-meta prompt_">at&gt; </span><span class="language-bash">/sbin/shutdown -h now</span><br><span class="hljs-meta prompt_">at&gt; </span><span class="language-bash">&lt;EOT&gt;</span><br>job 3 at Tue Aug 4 23:00:00 2015<br><span class="hljs-meta prompt_"># </span><span class="language-bash">您瞧瞧！at 还可以在一个工作内输入多个指令呢！不错吧！</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# atq <br>[root@study ~]# atrm (jobnumber)<br><br>范例一：查询目前主机上面有多少的at 工作排程？<br>[root@study ~]# atq<br>3 Tue Aug 4 23:00:00 2015 a root<br><span class="hljs-meta prompt_"># </span><span class="language-bash">上面说的是：『在2015/08/04 的23:00 有一项工作，该项工作指令下达者为</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">root』而且，该项工作的工作号码(jobnumber) 为3 号喔！</span><br><br>范例二：将上述的第3 个工作移除！<br>[root@study ~]# atrm 3 <br>[root@study ~]# atq <br><span class="hljs-meta prompt_"># </span><span class="language-bash">没有任何资讯，表示该工作被移除了！</span><br></code></pre></td></tr></table></figure><h3 id="循环执行的计划任务">15.3 循环执行的计划任务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# crontab [-u username] [-l|-e|-r]<br>选项与参数：<br>-u ：只有root 才能进行这个任务，亦即帮其他使用者建立/移除crontab 工作排程；<br>-e ：编辑crontab 的工作内容<br>-l ：查阅crontab 的工作内容<br>-r ：移除所有的crontab 的工作内容，若仅要移除一项，请用-e 去编辑。<br><br>范例一：用dmtsai 的身份在每天的12:00 发信给自己<br>[dmtsai@study ~]$ crontab -e <br><span class="hljs-meta prompt_"># </span><span class="language-bash">此时会进入vi 的编辑画面让您编辑工作！注意到，每项工作都是一行。</span><br>0 12 * * * mail -s &quot;at 12:00&quot; dmtsai &lt; /home/dmtsai/.bashrc <br><span class="hljs-meta prompt_">#</span><span class="language-bash">分时日月周|&lt;==============指令串========================&gt;|</span><br></code></pre></td></tr></table></figure><p>每项工作(每行) 的格式都是具有六个栏位，这六个栏位的意义为：</p><table><thead><tr class="header"><th style="text-align: center;">代表意义</th><th style="text-align: center;">分钟</th><th style="text-align: center;">小时</th><th style="text-align: center;">日期</th><th style="text-align: center;">月份</th><th style="text-align: center;">周</th><th style="text-align: center;">命令</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">数字范围</td><td style="text-align: center;">0-59</td><td style="text-align: center;">0-23</td><td style="text-align: center;">1-31</td><td style="text-align: center;">1-12</td><td style="text-align: center;">0-7</td><td style="text-align: center;">需要执行的命令</td></tr></tbody></table><p>特殊字符：</p><table><thead><tr class="header"><th>特殊字符</th><th>代表意义</th></tr></thead><tbody><tr class="odd"><td>*(星号)</td><td>代表任何时刻都接受的意思！举例来说，范例一内那个日、月、周都是* ，就代表着『不论何月、何日的礼拜几的12:00 都执行后续指令』的意思！</td></tr><tr class="even"><td>,(逗号)</td><td>代表分隔时段的意思。举例来说，如果要下达的工作是3:00 与6:00时，就会是：0 3,6 * * * command时间参数还是有五栏，不过第二栏是3,6，代表3 与6 都适用！</td></tr><tr class="odd"><td>-(减号)</td><td>代表一段时间范围内，举例来说， 8 点到12 点之间的每小时的20分都进行一项工作：20 8-12 * * * command仔细看到第二栏变成8-12喔！代表8,9,10,11,12 都适用的意思！</td></tr><tr class="even"><td>/n(斜线)</td><td>那个n 代表数字，亦即是『每隔n单位间隔』的意思，例如每五分钟进行一次，则： <em>/5 </em> * * *command很简单吧！用* 与/5 来搭配，也可以写成0-59/5 ，相同意思！</td></tr></tbody></table><p>注意：『如果只是要删除某个crontab 的工作项目，那么请使用crontab -e来重新编辑即可！』如果使用-r 的参数，是会将所有的 crontab资料内容都删掉的！</p><h3 id="可唤醒停机期间的工作任务">15.4 可唤醒停机期间的工作任务</h3><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# anacron [-sfn] [job].. <br>[root@study ~]# anacron -u [job]..<br>选项与参数：<br>-s ：开始一连续的执行各项工作(job)，会依据时间记录档的资料判断是否进行；<br>-f ：强制进行，而不去判断时间记录档的时间戳记；<br>-n ：立刻进行未进行的任务，而不延迟(delay) 等待时间；<br>-u ：仅更新时间记录档的时间戳记，不进行任何工作。<br>job ：由/etc/anacrontab 定义的各项工作名称。<br></code></pre></td></tr></table></figure><h2 id="进程管理与-selinux-初探">16. 进程管理与 SELinux 初探</h2><p>kill：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# kill -signal %jobnumber <br>[root@study ~]# kill -l<br>选项与参数：<br>-l ：这个是L 的小写，列出目前kill 能够使用的讯号(signal) 有哪些？<br>signal ：代表给予后面接的那个工作什么样的指示啰！用man 7 signal 可知：<br>  -1 ：重新读取一次参数的设定档(类似reload)；<br>  -2 ：代表与由键盘输入[ctrl]-c 同样的动作；<br>  -9 ：立刻强制删除一个工作；<br>  -15：以正常的程序方式终止一项工作。与-9 是不一样的。<br><br>范例一：找出目前的bash 环境下的背景工作，并将该工作『强制删除』。<br>[root@study ~]# jobs<br>[1]+ Stopped vim ~/.bashrc<br>[2] Stopped find / -print<br>[root@study ~]# kill -9 %2; jobs<br>[1]+ Stopped vim ~/.bashrc<br>[2]    Killed                   find / -print<br><span class="hljs-meta prompt_"> # </span><span class="language-bash">再过几秒你再下达<span class="hljs-built_in">jobs</span> 一次，就会发现2 号工作不见了！因为被移除了！</span><br><br>范例二：找出目前的bash 环境下的背景工作，并将该工作『正常终止』掉。<br>[root@study ~]# jobs<br>[1]+ Stopped vim ~/.bashrc<br>[root@study ~]# kill -SIGTERM %1 <br><span class="hljs-meta prompt_"># </span><span class="language-bash">-SIGTERM 与-15 是一样的！您可以使用<span class="hljs-built_in">kill</span> -l 来查阅！</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">不过在这个案例中， vim 的工作无法被结束喔！因为他无法透过<span class="hljs-built_in">kill</span> 正常终止的意思！</span><br></code></pre></td></tr></table></figure><table><thead><tr class="header"><th>代号</th><th>名称</th><th>内容</th></tr></thead><tbody><tr class="odd"><td>1</td><td>SIGHUP</td><td>启动被终止的程序，可让该PID 重新读取自己的设定档，类似重新启动</td></tr><tr class="even"><td>2</td><td>SIGINT</td><td>相当于用键盘输入[ctrl]-c 来中断一个程序的进行</td></tr><tr class="odd"><td>9</td><td>SIGKILL</td><td>代表强制中断一个程序的进行，如果该程序进行到一半，那么尚未完成的部分可能会有『半产品』产生，类似vim会有.filename.swp保留下来。</td></tr><tr class="even"><td>15</td><td>SIGTERM</td><td>以正常的结束程序来终止该程序。由于是正常的终止，所以后续的动作会将他完成。不过，如果该程序已经发生问题，就是无法使用正常的方法终止时，输入这个signal 也是没有用的。</td></tr><tr class="odd"><td>19</td><td>SIGSTOP</td><td>相当于用键盘输入[ctrl]-z 来暂停一个程序的进行</td></tr></tbody></table><p>killall：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">root@study ~</span>]<span class="hljs-meta"># killall [-iIe] [command name]</span><br>选项与参数：<br>-i ：interactive 的意思，互动式的，若需要删除时，会出现提示字元给使用者；<br>-e ：exact 的意思，表示『后面接的command name 要一致』，但整个完整的指令<br>      不能超过<span class="hljs-number">15</span> 个字元。<br>-I ：指令名称(可能含参数)忽略大小写。<br><br>范例一：给予rsyslogd 这个指令启动的PID 一个SIGHUP 的讯号<br>[<span class="hljs-meta">root@study ~</span>]<span class="hljs-meta"># killall -1 rsyslogd </span><br><span class="hljs-meta"># 如果用ps aux 仔细看一下，若包含所有参数，则/usr/sbin/rsyslogd -n 才是最完整的！</span><br><br>范例二：强制终止所有以httpd 启动的程序(其实并没有此程序在系统内) <br>[<span class="hljs-meta">root@study ~</span>]<span class="hljs-meta"># killall -9 httpd</span><br><br>范例三：依次询问每个bash 程式是否需要被终止运作！<br>[<span class="hljs-meta">root@study ~</span>]<span class="hljs-meta"># killall -i -9 bash </span><br><span class="hljs-function">Signal <span class="hljs-title">bash</span>(<span class="hljs-params"><span class="hljs-number">13888</span></span>) ? (<span class="hljs-params">y/N</span>) n  &lt;</span>==这个不杀！<br><span class="hljs-function">Signal <span class="hljs-title">bash</span>(<span class="hljs-params"><span class="hljs-number">13928</span></span>) ? (<span class="hljs-params">y/N</span>) n  &lt;</span>==这个不杀！<br><span class="hljs-function">Signal <span class="hljs-title">bash</span>(<span class="hljs-params"><span class="hljs-number">13970</span></span>) ? (<span class="hljs-params">y/N</span>) n  &lt;</span>==这个不杀！<br><span class="hljs-function">Signal <span class="hljs-title">bash</span>(<span class="hljs-params"><span class="hljs-number">14836</span></span>) ? (<span class="hljs-params">y/N</span>) y  &lt;</span>==这个杀掉！<br><span class="hljs-meta"># 具有互动的功能！可以询问你是否要删除bash 这个程式。要注意，若没有-i 的参数，</span><br><span class="hljs-meta"># 所有的bash 都会被这个root 给杀掉！包括root 自己的bash 喔！^_^</span><br></code></pre></td></tr></table></figure><p>ps 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# ps aux  &lt;==观察系统所有的程序资料<br>[root@study ~]# ps -lA  &lt;==也是能够观察所有系统的资料<br>[root@study ~]# ps axjf  &lt;==连同部分程序树状态<br>选项与参数：<br>-A ：所有的process 均显示出来，与-e 具有同样的效用；<br>-a ：不与terminal 有关的所有process ；<br>-u ：有效使用者(effective user) 相关的process ；<br>x ：通常与a 这个参数一起使用，可列出较完整资讯。<br>输出格式规划：<br>l ：较长、较详细的将该PID 的的资讯列出；<br>j ：工作的格式(jobs format)<br>-f ：做一个更为完整的输出。<br></code></pre></td></tr></table></figure><p>top 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# top [-d 数字] | top [-bnp]<br>选项与参数：<br>-d ：后面可以接秒数，就是整个程序画面更新的秒数。预设是5 秒；<br>-b ：以批次的方式执行top ，还有更多的参数可以使用喔！<br>      通常会搭配资料流重导向来将批次的结果输出成为档案。<br>-n ：与-b 搭配，意义是，需要进行几次top 的输出结果。<br>-p ：指定某些个PID 来进行观察监测而已。<br>在top 执行过程当中可以使用的按键指令：<br>? ：显示在top 当中可以输入的按键指令；<br>P ：以CPU 的使用资源排序显示；<br>M ：以Memory 的使用资源排序显示；<br>N ：以PID 来排序喔！<br>T ：由该Process 使用的CPU 时间累积(TIME+) 排序。<br>k ：给予某个PID 一个讯号(signal)<br>r ：给予某个PID 重新制订一个nice 值。<br>q ：离开top 软体的按键。<br></code></pre></td></tr></table></figure><p>pstree 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# pstree [-A|U] [-up]<br>选项与参数：<br>-A ：各程序树之间的连接以ASCII 字元来连接；<br>-U ：各程序树之间的连接以万国码的字元来连接。在某些终端介面下可能会有错误；<br>-p ：并同时列出每个process 的PID；<br>-u ：并同时列出每个process 的所属帐号名称。<br><br>范例一：列出目前系统上面所有的程序树的相关性： <br>[root@study ~]# pstree -A <br>systemd-+-ModemManager---2*[&#123;ModemManager&#125;]        # 这行是ModenManager 与其子程序<br>        |-NetworkManager---3*[&#123;NetworkManager&#125;]    # 前面有数字，代表子程序的数量！<br>....(中间省略).... <br>        |-sshd---sshd---sshd---bash---bash---sudo---su---bash---pstree &lt;==我们指令执行的相依性<br>....(底下省略).... <br><span class="hljs-meta prompt_"># </span><span class="language-bash">注意一下，为了节省版面，所以鸟哥已经删去很多程序了！</span><br><br>范例二：承上题，同时秀出PID 与users <br>[root@study ~]# pstree -Aup<br>systemd(1)-+-ModemManager(745)-+-&#123;ModemManager&#125;(785)<br>           | `-&#123;ModemManager&#125;(790)<br>           |-NetworkManager(870)-+-&#123;NetworkManager&#125;(907)<br>           | |-&#123;NetworkManager&#125;(911)<br>           | `-&#123;NetworkManager&#125;(914)<br>....(中间省略).... <br>           |-sshd(1326)---sshd(13923)---sshd(13927, dmtsai )---bash(13928)---bash(13970)---<br> ....(底下省略).... <br><span class="hljs-meta prompt_"># </span><span class="language-bash">在括号() 内的即是PID 以及该程序的owner 喔！一般来说，如果该程序的所有人与父程序同，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">就不会列出，但是如果与父程序不一样，那就会列出该程序的拥有者！看上面13927 就转变成dmtsai 了</span><br></code></pre></td></tr></table></figure><p>free 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">free [-b|-k|-m|-g|-h] [-t] [-s N -c N]</span><br>选项与参数：<br>-b ：直接输入free 时，显示的单位是Kbytes，我们可以使用b(bytes), m(Mbytes)<br>      k(Kbytes), 及g(Gbytes) 来显示单位喔！也可以直接让系统自己指定单位(-h)<br>-t ：在输出的最终结果，显示实体记忆体与swap 的总量。<br>-s ：可以让系统每几秒钟输出一次，不间断的一直输出的意思！对于系统观察挺有效！<br>-c ：与-s 同时处理～让free 列出几次的意思～<br><br>范例一：显示目前系统的记忆体容量<br>[root@study ~]# free -m<br>              total used free shared buff/cache available<br>Mem: 2848 346 1794 8 706 2263<br>Swap: 1023 0 1023<br></code></pre></td></tr></table></figure><p>netstat 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# netstat -[atunlp]<br>选项与参数：<br>-a ：将目前系统上所有的连线、监听、Socket 资料都列出来<br>-t ：列出tcp 网路封包的资料<br>-u ：列出udp 网路封包的资料<br>-n ：不以程序的服务名称，以埠号(port number) 来显示；<br>-l ：列出目前正在网路监听(listen) 的服务；<br>-p ：列出该网路服务的程序PID<br><br>范例一：列出目前系统已经建立的网路连线与unix socket 状态<br>[root@study ~]# netstat <br>Active Internet connections (w/o servers)  &lt;==与网路较相关的部分<br>Proto Recv-Q Send-Q Local Address Foreign Address State<br>tcp 0 0 172.16.15.100:ssh 172.16.220.234:48300 ESTABLISHED<br>Active UNIX domain sockets (w/o servers)   &lt;==与本机的程序自己的相关性(非网路)<br>Proto RefCnt Flags Type State I-Node Path<br>unix 2 [ ] DGRAM 1902 @/org/freedesktop/systemd1/notify<br>unix 2 [ ] DGRAM 1944 /run/systemd/shutdownd<br>....(中间省略)....<br>unix 3 [ ] STREAM CONNECTED 25425 @/tmp/.X11-unix/X0<br>unix 3 [ ] STREAM CONNECTED 28893<br>unix 3 [ ] STREAM CONNECTED 21262<br><br>范例二：找出目前系统上已在监听的网路连线及其PID <br>[root@study ~]# netstat -tulnp<br>Active Internet connections (only servers)<br>Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name<br>tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 1326/sshd<br>tcp 0 0 127.0.0.1:25 0.0.0.0:* LISTEN 2349/master<br>tcp6 0 0 :::22 :::* LISTEN       1326/sshd<br>tcp6 0 0 ::1:25 :::* LISTEN 2349/master<br>udp 0 0 0.0.0.0:123 0.0.0.0:* 751/chronyd<br>udp 0 0 127.0.0.1:323 0.0.0.0:* 751/chronyd<br>udp 0 0 0.0.0.0:57808 0.0.0.0:* 743/avahi-daemon: r<br>udp 0 0 0.0.0.0:5353 0.0.0.0:* 743/avahi-daemon: r<br>udp6 0 0 :::123 :::* 751/chronyd<br>udp6 0 0 ::1:323 :::* 751/chronyd<br><span class="hljs-meta prompt_"># </span><span class="language-bash">除了可以列出监听网路的介面与状态之外，最后一个栏位还能够显示此服务的</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">PID 号码以及程序的指令名称喔！例如上头的1326 就是该PID</span><br><br>范例三：将上述的0.0.0.0:57808 那个网路服务关闭的话？<br>[root@study ~]# kill -9 743 <br>[root@study ~]# killall -9 avahi-daemon<br></code></pre></td></tr></table></figure><p>dmesg 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">范例一：输出所有的核心开机时的资讯<br>[root@study ~]# dmesg | more<br><br>范例二：搜寻开机的时候，硬碟的相关资讯为何？<br>[root@study ~]# dmesg | grep -i vda<br>[ 0.758551] vda: vda1 vda2 vda3 vda4 vda5 vda6 vda7 vda8 vda9<br>[ 3.964134] XFS (vda2): Mounting V4 Filesystem<br>....(底下省略)....<br></code></pre></td></tr></table></figure><p>vmstat 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# vmstat [-a] [延迟[总计侦测次数]]  &lt;==CPU/记忆体等资讯<br>[root@study ~]# vmstat [-fs]                       &lt;==记忆体相关<br>[root@study ~]# vmstat [-S 单位]                   &lt;==设定显示数据的单位<br>[root@study ~]# vmstat [-d]                        &lt;==与磁碟有关<br>[root@study ~]# vmstat [-p 分割槽]                 &lt;==与磁碟有关<br>选项与参数：<br>-a ：使用inactive/active(活跃与否) 取代buffer/cache 的记忆体输出资讯；<br>-f ：开机到目前为止，系统复制(fork) 的程序数；<br>-s ：将一些事件(开机至目前为止) 导致的记忆体变化情况列表说明；<br>-S ：后面可以接单位，让显示的资料有单位。例如K/M 取代bytes 的容量；<br>-d ：列出磁碟的读写总量统计表<br>-p ：后面列出分割槽，可显示该分割槽的读写总量统计表<br><br>范例一：统计目前主机CPU 状态，每秒一次，共计三次！<br>[root@study ~]# vmstat 1 3<br>procs ------------memory---------- ---swap-- -----io---- -system-- ------cpu-----<br> rb swpd free buff cache si so bi bo in cs us sy id wa st<br> 1 0 0 1838092 1504 722216 0 0 4 1 6 9 0 0 100 0 0<br> 0 0 0 1838092 1504 722200 0 0 0 0 13 23 0 0 100 0 0<br> 0 0 0 1838092 1504 722200 0 0 0 0 25 46 0 0 100 0 0<br></code></pre></td></tr></table></figure><p>fuser：借由文件（或唔见系统）找出正在使用该文件的进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# fuser [-umv] [-k [i] [-signal]] file/dir<br>选项与参数：<br>-u ：除了程序的PID 之外，同时列出该程序的拥有者；<br>-m ：后面接的那个档名会主动的上提到该档案系统的最顶层，对umount 不成功很有效！<br>-v ：可以列出每个档案与程序还有指令的完整相关性！<br>-k ：找出使用该档案/目录的PID ，并试图以SIGKILL 这个讯号给予该PID；<br>-i ：必须与-k 配合，在删除PID 之前会先询问使用者意愿！<br>-signal：例如-1 -15 等等，若不加的话，预设是SIGKILL (-9) 啰！<br><br>范例一：找出目前所在目录的使用PID/所属帐号/权限为何？<br>[root@study ~]# fuser -uv .<br>                     USER PID ACCESS COMMAND<br>/root: root 13888 ..c.. (root)bash<br>                     root 31743 ..c.. (root)bash<br>                     <br><br>范例二：找到所有使用到/proc 这个档案系统的程序吧！<br>[root@study ~]# fuser -uv /proc<br>/proc: root kernel mount (root)/proc<br>                     rtkit 768 .rc.. (rtkit)rtkit-daemon<br><span class="hljs-meta prompt_"># </span><span class="language-bash">资料量还不会很多，虽然这个目录很繁忙～没关系！我们可以继续这样作，看看其他的程序！</span><br><br>[root@study ~]# fuser -mvu /proc<br>                     USER PID ACCESS COMMAND<br>/proc: root kernel mount (root)/proc<br>                     root 1 f.... (root)systemd<br>                     root 2 ...e. (root)kthreadd<br>.....(底下省略)..... <br><span class="hljs-meta prompt_"># </span><span class="language-bash">有这几支程序在进行/proc 档案系统的存取喔！这样清楚了吗？</span><br><br>范例三：找到所有使用到/home 这个档案系统的程序吧！<br>[root@study ~]# echo $$ <br>31743   # 先确认一下，自己的bash PID 号码吧！<br>[root@study ~]# cd /home <br>[root@study home]# fuser -muv .<br>                     USER PID ACCESS COMMAND<br>/home: root kernel mount (root)/home<br>                     dmtsai 31535 ..c.. (dmtsai)bash<br>                     root 31571 ..c.. (root)passwd<br>                     root 31737 ..c.. (root)sudo<br>                     root       31743 ..c.. (root)bash     # 果然，自己的PID 在啊！<br>[root@study home]# cd ~ <br>[root@study ~]# umount /home<br>umount: /home: target is busy.<br>        (In some cases useful info about processes that use<br>         the device is found by lsof(8) or fuser(1))<br><span class="hljs-meta prompt_"># </span><span class="language-bash">从fuser 的结果可以知道，总共有五只process 在该目录下运作，那即使root 离开了/home，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">当然还是无法umount 的！那要怎办？哈哈！可以透过如下方法一个一个删除～</span> <br>[root@study ~]# fuser -mki /home <br>/home: 31535c 31571c 31737c   # 你会发现， PID 跟上面查到的相同！<br>Kill process 31535 ? (y/N) # 这里会问你要不要删除！当然不要乱删除啦！通通取消！<br></code></pre></td></tr></table></figure><p>lsof：列出被进程所使用的文件名称</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# lsof [-aUu] [+d]<br>选项与参数：<br>-a ：多项资料需要『同时成立』才显示出结果时！<br>-U ：仅列出Unix like 系统的socket 档案类型；<br>-u ：后面接username，列出该使用者相关程序所开启的档案；<br>+d ：后面接目录，亦即找出某个目录底下已经被开启的档案！<br><br>范例一：列出目前系统上面所有已经被开启的档案与装置： <br>[root@study ~]# lsof<br>COMMAND PID TID USER FD TYPE DEVICE SIZE/OFF NODE NAME<br>systemd 1 root cwd DIR 253,0 4096 128 /<br>systemd 1 root rtd DIR 253,0 4096 128 /<br>systemd 1 root txt REG 253,0 1230920 967763 /usr/lib/systemd/systemd<br>....(底下省略).... <br><span class="hljs-meta prompt_"># </span><span class="language-bash">注意到了吗？是的，在预设的情况下， lsof 会将目前系统上面已经开启的</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">档案全部列出来～所以，画面多的吓人啊！您可以注意到，第一个档案systemd 执行的</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">地方就在根目录，而根目录，嘿嘿！所在的inode 也有显示出来喔！</span><br><br>范例二：仅列出关于root 的所有程序开启的socket 档案<br>[root@study ~]# lsof -u root -a -U<br>COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME<br>systemd 1 root 3u unix 0xffff8800b7756580 0t0 13715 socket<br>systemd 1 root 7u unix 0xffff8800b7755a40 0t0 1902 @/org/freedesktop/systemd1/notify<br>systemd 1 root 9u unix 0xffff8800b7756d00 0t0 1903 /run/systemd/private<br>.....(中间省略).....<br>Xorg 4496 root 1u unix 0xffff8800ab107480 0t0 25981 @/tmp/.X11-unix/X0<br>Xorg 4496 root 3u unix 0xffff8800ab107840 0t0 25982 /tmp/.X11-unix/X0<br>Xorg 4496 root 16u unix 0xffff8800b7754f00 0t0 25174 @/tmp/.X11-unix/X0<br>.....(底下省略)..... <br><span class="hljs-meta prompt_"># </span><span class="language-bash">注意到那个-a 吧！如果你分别输入lsof -u root 及lsof -U ，会有啥资讯？</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用lsof -u root -U 及lsof -u root -a -U ，呵呵！都不同啦！</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-a 的用途就是在解决同时需要两个项目都成立时啊！^_^</span><br><br>范例三：请列出目前系统上面所有的被启动的周边装置<br>[root@study ~]# lsof +d /dev<br>COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME<br>systemd 1 root 0u CHR 1,3 0t0 1028 /dev/null<br>systemd 1 root 1u CHR 1,3 0t0 1028 /dev/null<br><span class="hljs-meta prompt_"># </span><span class="language-bash">看吧！因为装置都在/dev 里面嘛！所以啰，使用搜寻目录即可啊！</span><br><br>范例四：秀出属于root 的bash 这支程式所开启的档案<br>[root@study ~]# lsof -u root | grep bash<br>ksmtuned 781 root txt REG 253,0 960384 33867220 /usr/bin/bash<br>bash 13888 root cwd DIR 253,0 4096 50331777 /root<br>bash 13888 root rtd DIR 253,0 4096 128 /<br>bash 13888 root txt REG 253,0 960384 33867220 /usr/bin/bash<br>bash 13888 root mem REG 253,0 106065056 17331169 /usr/lib/locale/locale-archive<br>....(底下省略)....<br></code></pre></td></tr></table></figure><h2 id="认识系统服务daemon">17. 认识系统服务（daemon）</h2><h3 id="什么是-daemon-与服务service">17.1 什么是 daemon与服务（service）</h3><p>完成 service 的程序称为 daemon。</p><ul><li>/usr/lib/systemd/system/：每个服务最主要的启动脚本设定，有点类似以前的/etc/init.d底下的档案；</li><li>/run/systemd/system/：系统执行过程中所产生的服务脚本，这些脚本的优先序要比/usr/lib/systemd/system/高！</li><li>/etc/systemd/system/：管理员依据主机系统的需求所建立的执行脚本，其实这个目录有点像以前/etc/rc.d/rc5.d/Sxx之类的功能！执行优先序又比/run/systemd/system/ 高喔！</li></ul><p>常见的 systemd 服务类型：</p><table><thead><tr class="header"><th>扩展名</th><th>主要服务功能</th></tr></thead><tbody><tr class="odd"><td>.service</td><td>一般服务类型(serviceunit)：主要是系统服务，包括服务器本身所需要的本机服务以及网路服务等，比较经常被使用到的服务大多是这种类型！所以，这也是最常见的类型了！</td></tr><tr class="even"><td>.socket</td><td>内部程序资料交换的插槽服务(socket unit)：主要是IPC (Inter-processcommunication) 的传输讯息插槽档(socket file)功能。这种类型的服务通常在监控讯息传递的插槽档，当有透过此插槽档传递讯息来说要连结服务时，就依据当时的状态将该用户的要求传送到对应的daemon，若daemon 尚未启动，则启动该daemon 后再传送用户的要求。使用socket类型的服务一般是比较不会被用到的服务，因此在开机时通常会稍微延迟启动的时间(因为比较没有这么常用嘛！)。一般用于本机服务比较多，例如我们的图形界面很多的软体都是透过socket来进行本机程序资料交换的行为。(这与早期的xinetd 这个super daemon有部份的相似喔！)</td></tr><tr class="odd"><td>.target</td><td>执行环境类型(target unit)：其实是一群unit的集合，例如上面表格中谈到的multi-user.target其实就是一堆服务的集合～也就是说， 选择执行multi-user.target就是执行一堆其他.service 或/及.socket 之类的服务就是了！</td></tr><tr class="even"><td>.mount .automount</td><td>档案系统挂载相关的服务(automount unit / mountunit)：例如来自网路的自动挂载、NFS档案系统挂载等与档案系统相关性较高的程序管理。</td></tr><tr class="odd"><td>.path</td><td>侦测特定档案或目录类型(pathunit)：某些服务需要侦测某些特定的目录来提供伫列服务，例如最常见的列印服务，就是透过侦测列印伫列目录来启动列印功能！这时就得要.path的服务类型支援了！</td></tr><tr class="even"><td>.timer</td><td>循环执行的服务(timer unit)：这个东西有点类似anacrontab喔！不过是由systemd 主动提供的，比anacrontab 更加有弹性！</td></tr></tbody></table><h3 id="通过-systemctl-管理服务">17.2 通过 systemctl 管理服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# systemctl [command] [unit] <br>command 主要有：<br>start ：立刻启动后面接的unit<br>stop ：立刻关闭后面接的unit<br>restart ：立刻关闭后启动后面接的unit，亦即执行stop 再start 的意思<br>reload ：不关闭后面接的unit 的情况下，重新载入设定档，让设定生效<br>enable ：设定下次开机时，后面接的unit 会被启动<br>disable ：设定下次开机时，后面接的unit 不会被启动<br>status ：目前后面接的这个unit 的状态，会列出有没有正在执行、开机预设执行否、登录等资讯等！<br>is-active ：目前有没有正在运作中<br>is-enabled：开机时有没有预设要启用这个unit<br><br>范例一：看看目前atd 这个服务的状态为何？<br>[root@study ~]# systemctl status atd.service<br>atd.service - Job spooling tools<br>   Loaded: loaded (/usr/lib/systemd/system/atd.service; enabled)<br>   Active: active (running) since Mon 2015-08-10 19:17:09 CST; 5h 42min ago<br> Main PID: 1350 (atd)<br>   CGroup: /system.slice/atd.service<br>           └─1350 /usr/sbin/atd -f<br><br>Aug 10 19:17:09 study.centos.vbird systemd[1]: Started Job spooling tools.<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重点在第二、三行喔～</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Loaded：这行在说明，开机的时候这个unit 会不会启动，enabled 为开机启动，disabled 开机不会启动</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Active：现在这个unit 的状态是正在执行(running) 或没有执行(dead)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">后面几行则是说明这个unit 程序的PID 状态以及最后一行显示这个服务的登录档资讯！</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">登录档资讯格式为：『时间』 『讯息发送主机』 『哪一个服务的讯息』 『实际讯息内容』</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">所以上面的显示讯息是：这个atd 预设开机就启动，而且现在正在运作的意思！</span><br><br>范例二：正常关闭这个atd 服务<br>[root@study ~]# systemctl stop atd.service <br>[root@study ~]# systemctl status atd.service<br>atd.service - Job spooling tools<br>   Loaded: loaded (/usr/lib/systemd/system/atd.service; enabled )<br>    Active: inactive (dead) since Tue 2015-08-11 01:04:55 CST; 4s ago<br>  Process: 1350 ExecStart=/usr/sbin/atd -f $OPTS (code=exited, status=0/SUCCESS)<br> Main PID: 1350 (code=exited, status=0/SUCCESS)<br><br>Aug 10 19:17:09 study.centos.vbird systemd[1]: Started Job spooling tools.<br>Aug 11 01:04:55 study.centos.vbird systemd[1]: Stopping Job spooling tools...<br>Aug 11 01:04:55 study.centos.vbird systemd[1]: Stopped Job spooling tools. <br><span class="hljs-meta prompt_"># </span><span class="language-bash">目前这个unit 下次开机还是会启动，但是现在是没在运作的状态中！同时，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">最后两行为新增加的登录讯息，告诉我们目前的系统状态喔！</span><br></code></pre></td></tr></table></figure><p>查看系统上所有服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# systemctl [command] [--type=TYPE] [--all] <br>command:<br>    list-units ：依据unit 列出目前有启动的unit。若加上--all 才会列出没启动的。<br>    list-unit-files ：依据/usr/lib/systemd/system/ 内的档案，将所有档案列表说明。<br>--type=TYPE：就是之前提到的unit type，主要有service, socket, target 等<br><br>范例一：列出系统上面有启动的unit <br>[root@study ~]# systemctl<br>UNIT LOAD ACTIVE SUB DESCRIPTION<br>proc-sys-fs-binfmt_mis... loaded active waiting Arbitrary Executable File Formats File System<br>sys-devices-pc...:0:1:... loaded active plugged QEMU_HARDDISK<br>sys-devices-pc...0:1-0... loaded active plugged QEMU_HARDDISK<br>sys-devices-pc...0:0-1... loaded active plugged QEMU_DVD-ROM<br>.....(中间省略).....<br>vsftpd.service loaded active running Vsftpd ftp daemon<br>.....(中间省略).....<br>cups.socket loaded failed failed CUPS Printing Service Sockets<br>.....(中间省略).....<br>LOAD = Reflects whether the unit definition was properly loaded.<br>ACTIVE = The high-level unit activation state, ie generalization of SUB.<br>SUB = The low-level unit activation state, values depend on unit type.<br><br>141 loaded units listed. Pass --all to see loaded but inactive units, too.<br>To show all installed unit files use &#x27;systemctl list-unit-files&#x27;. <br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出的项目中，主要的意义是：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">UNIT ：项目的名称，包括各个unit 的类别(看副档名)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">LOAD ：开机时是否会被载入，预设systemctl 显示的是有载入的项目而已喔！</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">ACTIVE ：目前的状态，须与后续的SUB 搭配！就是我们用systemctl status 观察时，active 的项目！</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">DESCRIPTION ：详细描述啰</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">cups 比较有趣，因为刚刚被我们玩过，所以ACTIVE 竟然是failed 的喔！被玩死了！^_^</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">另外，systemctl 都不加参数，其实预设就是list-units 的意思！</span><br><br>范例二：列出所有已经安装的unit 有哪些？<br>[root@study ~]# systemctl list-unit-files<br>UNIT FILE STATE<br>proc-sys-fs-binfmt_misc.automount static<br>dev-hugepages.mount static<br>dev-mqueue.mount static<br>proc-fs-nfsd.mount static<br>.....(中间省略).....<br>systemd-tmpfiles-clean.timer static<br><br>336 unit files listed.<br></code></pre></td></tr></table></figure><p>查看网络端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# netstat -tlunp<br>Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name<br>tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 1340/sshd<br>tcp 0 0 127.0.0.1:25 0.0.0.0:* LISTEN 2387/master<br>tcp6 0 0 :::555 :::* LISTEN 29113/vsftpd<br>tcp6 0 0 :::22 :::* LISTEN 1340/sshd<br>tcp6 0 0 ::1:25 :::* LISTEN 2387/master<br>udp 0 0 0.0.0.0:5353 0.0.0.0:* 750/avahi-daemon: r<br>udp 0 0 0.0.0.0:36540 0.0.0.0:* 750/avahi-daemon: r<br></code></pre></td></tr></table></figure><h3 id="systemctl-针对-service-类型的配置文件">17.3 systemctl 针对service 类型的配置文件</h3><p>systemctl 配置文件设置项目简介：（以 <code>sshd.service</code>文件为例）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# cat /usr/lib/systemd/system/sshd.service <br>[Unit]            # 这个项目与此unit 的解释、执行服务相依性有关<br>Description=OpenSSH server daemon<br>After=network.target sshd-keygen.service<br>Wants=sshd-keygen.service<br><br>[Service]         # 这个项目与实际执行的指令参数有关<br>EnvironmentFile=/etc/sysconfig/sshd<br>ExecStart=/usr/sbin/sshd -D $OPTIONS<br>ExecReload=/bin/kill -HUP $MAINPID<br>KillMode=process<br>Restart=on-failure<br>RestartSec=42s<br><br>[Install]         # 这个项目说明此unit 要挂载哪个target 底下<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><p>可分为三个部分：</p><ul><li>[Unit]： unit 本身的说明，以及与其他相依daemon的设定，包括在什么服务之后才启动此unit 之类的设定值；</li><li>[Service], [Socket], [Timer], [Mount], [Path]..：不同的unit type就得要使用相对应的设定项目。我们拿的是sshd.service来当范本，所以这边就使用[Service]来设定。这个项目内主要在规范服务启动的脚本、环境设定档档名、重新启动的方式等等。</li><li>[Install]：这个项目就是将此unit 安装到哪个target 里面去的意思！</li></ul><p>具体设置参数含义：</p><table><thead><tr class="header"><th style="text-align: center;">[Unit] 部分</th><th></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">设定参数</td><td>参数意义说明</td></tr><tr class="even"><td style="text-align: center;">Description</td><td>就是当我们使用systemctl list-units时，会输出给管理员看的简易说明！当然，使用systemctl status输出的此服务的说明，也是这个项目！</td></tr><tr class="odd"><td style="text-align: center;">Documentation</td><td>这个项目在提供管理员能够进行进一步的文件查询的功能！提供的文件可以是如下的资料：<br/>Documentation=http://www...<br/>Documentation=man:sshd(8)<br/>Documentation=file:/etc/ssh/sshd_config</td></tr><tr class="even"><td style="text-align: center;">After</td><td>说明此unit 是在哪个daemon启动之后才启动的意思！基本上仅是说明服务启动的顺序而已，并没有强制要求里头的服务一定要启动后此unit才能启动。以sshd.service 的内容为例，该档案提到After后面有network.target 以及sshd-keygen.service，但是若这两个unit没有启动而强制启动sshd.service 的话， 那么sshd.service应该还是能够启动的！这与Requires 的设定是有差异的喔！</td></tr><tr class="odd"><td style="text-align: center;">Before</td><td>与After的意义相反，是在什么服务启动前最好启动这个服务的意思。不过这仅是规范服务启动的顺序，并非强制要求的意思。</td></tr><tr class="even"><td style="text-align: center;">Requires</td><td>明确的定义此unit 需要在哪个daemon启动后才能够启动！就是设定相依服务啦！如果在此项设定的前导服务没有启动，那么此unit就不会被启动！</td></tr><tr class="odd"><td style="text-align: center;">Wants</td><td>与Requires 刚好相反，规范的是这个unit之后最好还要启动什么服务比较好的意思！不过，并没有明确的规范就是了！主要的目的是希望建立让使用者比较好操作的环境。因此，这个Wants后面接的服务如果没有启动，其实不会影响到这个unit 本身！</td></tr><tr class="even"><td style="text-align: center;">Conflicts</td><td>代表冲突的服务！亦即这个项目后面接的服务如果有启动，那么我们这个unit本身就不能启动！我们unit有启动，则此项目后的服务就不能启动！反正就是冲突性的检查啦！</td></tr></tbody></table><table><thead><tr class="header"><th style="text-align: center;">[Service] 部分</th><th></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">设定参数</td><td>参数意义说明</td></tr><tr class="even"><td style="text-align: center;">Type</td><td>说明这个daemon 启动的方式，会影响到ExecStart喔！一般来说，有底下几种类型<br/>simple：预设值，这个daemon主要由ExecStart接的指令串来启动，启动后常驻于记忆体中。<br/>forking：由ExecStart启动的程序透过spawns 延伸出其他子程序来作为此daemon的主要服务。原生的父程序在启动结束后就会终止运作。传统的unit服务大多属于这种项目，例如httpd 这个WWW 服务，当httpd的程序因为运作过久因此即将终结了，则systemd会再重新生出另一个子程序持续运作后，再将父程序删除。据说这样的效能比较好！！<br/>oneshot：与simple类似，不过这个程序在工作完毕后就结束了，不会常驻在记忆体中。<br/>dbus：与simple类似，但这个daemon 必须要在取得一个D-Bus的名称后，才会继续运作！因此设定这个项目时，通常也要设定BusName=才行！<br/>idle：与simple 类似，意思是，要执行这个daemon必须要所有的工作都顺利执行完毕后才会执行。这类的daemon通常是开机到最后才执行即可的服务！比较重要的项目大概是simple, forking与oneshot了！毕竟很多服务需要子程序(forking)，而有更多的动作只需要在开机的时候执行一次(oneshot)，例如档案系统的检查与挂载啊等等的。</td></tr><tr class="odd"><td style="text-align: center;">EnvironmentFile</td><td>可以指定启动脚本的环境设定档！例如sshd.service的设定档写入到/etc/sysconfig/sshd 当中！你也可以使用Environment=后面接多个不同的Shell 变数来给予设定！</td></tr><tr class="even"><td style="text-align: center;">ExecStart</td><td>就是实际执行此daemon 的指令或脚本程式。你也可以使用ExecStartPre(之前) 以及ExecStartPost (之后)两个设定项目来在实际启动服务前，进行额外的指令行为。但是你得要特别注意的是，指令串仅接受『指令参数参数...』的格式，不能接受&lt;,&gt;, &gt;&gt;, |, &amp; 等特殊字符，很多的bash语法也不支援喔！所以，要使用这些特殊的字符时，最好直接写入到指令脚本里面去！不过，上述的语法也不是完全不能用，亦即，若要支援比较完整的bash语法，那你得要使用Type=oneshot 才行喔！其他的Type才不能支援这些字符。</td></tr><tr class="odd"><td style="text-align: center;">ExecStop</td><td>与systemctl stop 的执行有关，关闭此服务时所进行的指令。</td></tr><tr class="even"><td style="text-align: center;">ExecReload</td><td>与systemctl reload 有关的指令行为</td></tr><tr class="odd"><td style="text-align: center;">Restart</td><td>当设定Restart=1 时，则当此daemon服务终止后，会再次的启动此服务。举例来说，如果你在tty2使用文字界面登入，操作完毕后登出，基本上，这个时候tty2就已经结束服务了。但是你会看到萤幕又立刻产生一个新的tty2的登入画面等待你的登入！那就是Restart 的功能！除非使用systemctl强制将此服务关闭，否则这个服务会源源不绝的一直重复产生！</td></tr><tr class="even"><td style="text-align: center;">RemainAfterExit</td><td>当设定为RemainAfterExit=1 时，则当这个daemon所属的所有程序都终止之后，此服务会再尝试启动。这对于Type=oneshot的服务很有帮助！</td></tr><tr class="odd"><td style="text-align: center;">TimeoutSec</td><td>若这个服务在启动或者是关闭时，因为某些缘故导致无法顺利『正常启动或正常结束』的情况下，则我们要等多久才进入『强制结束』的状态！</td></tr><tr class="even"><td style="text-align: center;">KillMode</td><td>可以是process, control-group, none 的其中一种，如果是process则daemon 终止时，只会终止主要的程序(ExecStart接的后面那串指令)，如果是control-group 时， 则由此daemon所产生的其他control-group 的程序，也都会被关闭。如果是none的话，则没有程序会被关闭喔！</td></tr><tr class="odd"><td style="text-align: center;">RestartSec</td><td>与Restart有点相关性，如果这个服务被关闭，然后需要重新启动时，大概要sleep多少时间再重新启动的意思。预设是100ms (毫秒)。</td></tr></tbody></table><table><thead><tr class="header"><th style="text-align: center;">[Install] 部分</th><th></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">设定参数</td><td>参数意义说明</td></tr><tr class="even"><td style="text-align: center;">WantedBy</td><td>这个设定后面接的大部分是*.target unit ！意思是，这个unit本身是附挂在哪一个target unit 底下的！一般来说，大多的服务性质的unit都是附挂在multi-user.target 底下！</td></tr><tr class="odd"><td style="text-align: center;">Also</td><td>当目前这个unit 本身被enable 时，Also 后面接的unit 也请enable的意思！也就是具有相依性的服务可以写在这里呢！</td></tr><tr class="even"><td style="text-align: center;">Alias</td><td>进行一个连结的别名的意思！当systemctl enable相关的服务时，则此服务会进行连结档的建立！以multi-user.target为例，这个家伙是用来作为预设操作环境default.target 的规划，因此当你设定用成default.target时，这个/etc/systemd/system/default.target就会连结到/usr/lib/systemd/system/multi-user.target 啰！</td></tr></tbody></table><p>示例：建立自己的备份服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# vim /backups/backup.sh <br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>source=&quot;/etc /home /root /var/lib /var/spool/&#123;cron,at,mail&#125;&quot;<br>target=&quot;/backups/backup-system-$(date +%Y-%m-%d).tar.gz&quot;<br>[ ! -d /backups ] &amp;&amp; mkdir /backups<br>tar -zcvf $&#123;target&#125; $&#123;source&#125; &amp;&gt; /backups/backup.log<br><br>[root@study ~]# chmod a+x /backups/backup.sh <br>[root@study ~]# ll /backups/backup.sh <br>-rwxr-xr-x . 1 root root 220 Aug 13 01:57 /backups/backup.sh<br><span class="hljs-meta prompt_"> # </span><span class="language-bash">记得要有可执行的权限才可以喔！</span><br> <br> <br>[root@study ~]# vim /etc/systemd/system/backup.service <br>[Unit]<br>Description=backup my server<br>Requires=atd.service<br><br>[Service]<br>Type=simple<br>ExecStart=/bin/bash -c &quot; echo /backups/backup.sh | at now&quot;<br><br>[Install]<br>WantedBy=multi-user.target <br><span class="hljs-meta prompt_"># </span><span class="language-bash">因为ExecStart 里面有用到at 这个指令，因此， atd.service 就是一定要的服务！</span><br><br>[root@study ~]# systemctl daemon-reload <br>[root@study ~]# systemctl start backup.service <br>[root@study ~]# systemctl status backup.service<br>backup.service - backup my server<br>   Loaded: loaded (/etc/systemd/system/backup.service; disabled)<br>   Active: inactive (dead)<br><br>Aug 13 07:50:31 study.centos.vbird systemd[1]: Starting backup my server...<br>Aug 13 07:50:31 study.centos.vbird bash[20490]: job 8 at Thu Aug 13 07:50:00 2015<br>Aug 13 07:50:31 study.centos.vbird systemd[1]: Started backup my server.<br><span class="hljs-meta prompt_"># </span><span class="language-bash">为什么Active 是inactive 呢？这是因为我们的服务仅是一个简单的script 啊！</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">因此执行完毕就完毕了，不会继续存在记忆体中喔！</span><br></code></pre></td></tr></table></figure><h2 id="认识与分析日志文件">18. 认识与分析日志文件</h2><p>略</p><h2 id="启动流程模块管理与-loader">19. 启动流程、模块管理与 Loader</h2><h3 id="linux-启动流程分析">19.1 Linux 启动流程分析</h3><ol type="1"><li><p>载入BIOS的硬体信息与进行自我检测（自检），并根据设置取得第一个可启动的设备；</p></li><li><p>读取并执行第一个启动设备内MBR 的启动引导程序(bootLoader，亦即是grub2, spfdisk 等程序)；</p></li><li><p>依据boot loader 的设置载入Kernel ，Kernel会开始检测硬体与加载驱动程序；</p></li><li><p>在硬体驱动成功后，Kernel 会主动调用systemd程序，并以default.target 流程启动；</p><ul><li><p>systemd 执行sysinit.target 初始化系统及basic.target准备操作系统；</p></li><li><p>systemd 启动multi-user.target 下的本机与服务器服务；</p></li><li><p>systemd 执行multi-user.target 下的/etc/rc.d/rc.local文件；</p></li><li><p>systemd 执行multi-user.target 下的getty.target及登录服务；</p></li><li><p>systemd 执行graphical 需要的服务</p></li></ul></li></ol><h2 id="基础系统设置与备份策略">20. 基础系统设置与备份策略</h2><p>略</p><h2 id="软件安装源代码与-tarball">21. 软件安装：源代码与 Tarball</h2><h3 id="开放源代码的软件安装与升级简介">21.1开放源代码的软件安装与升级简介</h3><p>通过 configure 与 make 进行编译示意图：</p><p><imgsrc="https://linux.vbird.org/linux_basic/centos7/0520source//make_configure.gif" /></p><h3 id="使用传统程序语言进行编译的简单示例">21.2使用传统程序语言进行编译的简单示例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 编辑主程式：</span> <br>[root@study ~]# vim thanks.c <br><span class="hljs-meta prompt_">#</span><span class="language-bash">include &lt;stdio.h&gt;</span><br>int main(void)<br>&#123;<br>        printf(&quot;Hello World\n&quot;);<br>        thanks_2();<br>&#125; <br><span class="hljs-meta prompt_"># </span><span class="language-bash">上面的thanks_2(); 那一行就是呼叫副程式啦！</span><br><br>[root@study ~]# vim thanks_2.c <br><span class="hljs-meta prompt_">#</span><span class="language-bash">include &lt;stdio.h&gt;</span><br>void thanks_2(void)<br>&#123;<br>        printf(&quot;Thank you!\n&quot;);<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 开始将原始码编译成为可执行的binary file ：</span> <br>[root@study ~]# gcc -c thanks.c thanks_2.c <br>[root@study ~]# ll thanks*<br>-rw-r--r--. 1 root root 75 Sep 4 11:43 thanks_2.c<br>-rw-r--r--. 1 root root 1496 Sep 4 11:43 thanks_2.o   &lt;==编译产生的！<br>-rw-r--r--. 1 root root 91 Sep 4 11:42 thanks.c<br>-rw-r--r--. 1 root root 1560 Sep 4 11:43 thanks.o     &lt;==编译产生的！<br><br>[root@study ~]# gcc -o thanks thanks.o thanks_2.o <br>[root@study ~]# ll thanks* <br>-rwxr-xr-x. 1 root root 8572 Sep 4 11:44 thanks     &lt;==最终结果会产生这玩意儿<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3. 执行一下这个档案：</span> <br>[root@study ~]# ./thanks<br>Hello World<br>Thank you!<br></code></pre></td></tr></table></figure><p>加入链接选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# vim sin.c <br><span class="hljs-meta prompt_">#</span><span class="language-bash">include &lt;stdio.h&gt;</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">include &lt;math.h&gt;</span><br>int main(void)<br>&#123;<br>        float value;<br>        value = sin ( 3.14 / 2 );<br>        printf(&quot;%f\n&quot;,value);<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">编译</span><br>[root@study ~]# gcc sin.c <br><span class="hljs-meta prompt_"># </span><span class="language-bash">新的GCC 会主动将函数抓进来给你用，所以只要加上include &lt;math.h&gt; 就好了！</span><br><br>[root@study ~]# gcc sin.c -lm -L/lib -L/lib64   &lt;==重点在-lm <br>[root@study ~]# ./a.out                          &lt;==尝试执行新档案！<br>1.000000<br></code></pre></td></tr></table></figure><p>特别注意，使用gcc 编译时所加入的那个-lm是有意义的，他可以拆开成两部份来看：</p><ul><li>-l ：是『加入某个函式库(library)』的意思，</li><li>m ：则是libm.so 这个函式库，其中， lib 与副档名(.a或.so)不需要写</li></ul><p>所以-lm 表示使用libm.so (或libm.a) 这个函式库的意思～至于那个-L后面接的路径呢？这表示： 『我要的函式库libm.so 请到/lib 或/lib64里面搜寻！』</p><p>gcc 简易用法（编译、参数和链接）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">仅将原始码编译成为目标档，并不制作连结等功能：</span> <br>[root@study ~]# gcc -c hello.c <br><span class="hljs-meta prompt_"># </span><span class="language-bash">会自动的产生hello.o 这个档案，但是并不会产生binary 执行档。</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在编译的时候，依据作业环境给予最佳化执行速度</span><br>[root@study ~]# gcc -O hello.c -c <br><span class="hljs-meta prompt_"># </span><span class="language-bash">会自动的产生hello.o 这个档案，并且进行最佳化喔！</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在进行binary file 制作时，将连结的函式库与相关的路径填入</span><br>[root@study ~]# gcc sin.c -lm -L/lib -I/usr/include <br><span class="hljs-meta prompt_"># </span><span class="language-bash">这个指令较常下达在最终连结成binary file 的时候，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-lm 指的是libm.so 或libm.a 这个函式库档案；</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-L 后面接的路径是刚刚上面那个函式库的搜寻目录；</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-I 后面接的是原始码内的include 档案之所在目录。</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将编译的结果输出成某个特定档名</span><br>[root@study ~]# gcc -o hello hello.c <br><span class="hljs-meta prompt_"># </span><span class="language-bash">-o 后面接的是要输出的binary file 档名</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在编译的时候，输出较多的讯息说明</span><br>[root@study ~]# gcc -o hello hello.c -Wall <br><span class="hljs-meta prompt_"># </span><span class="language-bash">加入-Wall 之后，程式的编译会变的较为严谨一点，所以警告讯息也会显示出来！</span><br></code></pre></td></tr></table></figure><p>我们通常称 -Wall 或者-O这些非必要的参数为旗标(FLAGS)，因为我们使用的是C程式语言，所以有时候也会简称这些旗标为 CFLAGS</p><h3 id="用-make-进行宏编译">21.3 用 make 进行宏编译</h3><p>有以下源文件：</p><ul><li>main.c ：主要的目的是让使用者输入角度资料与呼叫其他三支副程式；</li><li>haha.c ：输出一堆有的没有的讯息而已；</li><li>sin_value.c ：计算使用者输入的角度(360) sin 数值；</li><li>cos_value.c ：计算使用者输入的角度(360) cos 数值。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 先进行目标档的编译，最终会有四个*.o 的档名出现：</span> <br>[root@study ~]# gcc -c main.c <br>[root@study ~]# gcc -c haha.c <br>[root@study ~]# gcc -c sin_value.c <br>[root@study ~]# gcc -c cos_value.c<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 再进行连结成为执行档，并加入libm 的数学函式，以产生main 执行档：</span> <br>[root@study ~]# gcc -o main main.o haha.o sin_value.o cos_value.o -lm<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3. 本程式的执行结果，必须输入姓名、360 度角的角度值来计算：</span> <br>[root@study ~]# ./main <br>Please input your name: VBird   &lt;==这里先输入名字<br>Please enter the degree angle (ex&gt; 90): 30    &lt;==输入以360 度角为主的角度<br>Hi, Dear VBird, nice to meet you.     &lt;==这三行为输出的结果喔！<br>The Sin is: 0.50<br>The Cos is: 0.87<br></code></pre></td></tr></table></figure><p>使用 make 编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 先编辑makefile 这个规则档，内容只要作出main 这个执行档</span><br>[root@study ~]# vim makefile <br>main: main.o haha.o sin_value.o cos_value.o<br>gcc -o main main.o haha.o sin_value.o cos_value.o -lm <br><span class="hljs-meta prompt_"># </span><span class="language-bash">注意：第二行的gcc 之前是&lt;tab&gt; 按键产生的空格喔！</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 尝试使用makefile 制订的规则进行编译的行为：</span> <br>[root@study ~]# rm -f main *.o    &lt;==先将之前的目标档去除<br>[root@study ~]# make<br>cc -c -o main.o main.c<br>cc -c -o haha.o haha.c<br>cc -c -o sin_value.o sin_value.c<br>cc -c -o cos_value.o cos_value.c<br>gcc -o main main.o haha.o sin_value.o cos_value.o -lm<br><span class="hljs-meta prompt_"># </span><span class="language-bash">此时make 会去读取makefile 的内容，并根据内容直接去给他编译相关的档案啰！</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3. 在不删除任何档案的情况下，重新执行一次编译的动作：</span> <br>[root@study ~]# make<br>make: `main&#x27; is up to date.<br><span class="hljs-meta prompt_"># </span><span class="language-bash">看到了吧！是否很方便呢！只会进行更新(update) 的动作而已。</span><br></code></pre></td></tr></table></figure><p>make 优点：</p><ul><li>简化编译时所需要下达的指令；</li><li>若在编译完成之后，修改了某个原始码档案，则make仅会针对被修改了的档案进行编译，其他的 object file 不会被更动；</li><li>最后可以依照相依性来更新(update) 执行档。</li></ul><p>基本的 makefile 规则：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">目标(target): 目标文件1 目标文件2</span><br>&lt;tab&gt; gcc -o 欲建立的执行文件 目标文件1 目标文件2<br></code></pre></td></tr></table></figure><p><strong>命令行必须要以tab 按键作为开头</strong>，他的规则基本上是这样的：</p><ul><li>在makefile 当中的# 代表注解；</li><li>&lt;tab&gt; 需要在命令行(例如gcc 这个编译器指令) 的第一个字符；</li><li>目标(target) 与依赖文件(就是目标文件)之间需以『:』隔开。</li></ul><p>示例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 1. 先编辑makefile 来建立新的规则，此规则的标的名称为clean ： </span><br>[root@study ~]<span class="hljs-comment"># vi makefile</span><br><span class="hljs-section">main: main.o haha.o sin_value.o cos_value.o</span><br>gcc -o main main.o haha.o sin_value.o cos_value.o -lm<br><span class="hljs-section">clean:</span><br>rm -f main main.o haha.o sin_value.o cos_value.o<br><br><span class="hljs-comment"># 2. 以新的目标(clean) 测试看看执行make 的结果： </span><br>[root@study ~]<span class="hljs-comment"># make clean   &lt;==就是这里！透过make 以clean 为标的</span><br>rm -rf main main.o haha.o sin_value.o cos_value.o<br></code></pre></td></tr></table></figure><p>如此一来，我们的makefile 里面就具有至少两个标的，分别是main 与clean，如果我们想要建立main 的话，输入『makemain』，如果想要清除有的没的，输入『make clean』即可。</p><p>使用变量：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile">[root@study ~]<span class="hljs-comment"># vi makefile </span><br>LIBS = -lm<br>OBJS = main.o haha.o sin_value.o cos_value.o<br><span class="hljs-section">main: $&#123;OBJS&#125;</span><br>        gcc -o main $&#123;OBJS&#125; $&#123;LIBS&#125;<br><span class="hljs-section">clean:</span><br>        rm -f main $&#123;OBJS&#125;<br></code></pre></td></tr></table></figure><p>与 bash shell 脚本的语法有点不同，变量的基本语法为：</p><ol type="1"><li>变量与变量内容以『=』隔开，同时两边可以具有空格；</li><li>变量左边不可以有&lt;tab&gt; ，例如上面范例的第一行LIBS左边不可以是&lt;tab&gt;；</li><li>变量与变量内容在『=』两边不能具有『:』；</li><li>在习惯上，变量最好是以『大写字母』为主；</li><li>运用变量时，以${变量} 或$(变量) 使用；</li><li>在该shell 的环境变量是可以被套用的，例如提到的CFLAGS 这个变数！</li><li>在命令行模式也可以设置变量。</li></ol><p>设置 <code>CFLAGS</code> 环境变量两种方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">方式 1</span><br>[root@study ~]# CFLAGS=&quot;-Wall&quot; make clean main <br><span class="hljs-meta prompt_"># </span><span class="language-bash">这个动作在上make 进行编译时，会去取用CFLAGS 的变数内容！</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">方式 2</span><br>[root@study ~]# vi makefile<br>LIBS = -lm<br>OBJS = main.o haha.o sin_value.o cos_value.o<br>CFLAGS = -Wall<br>main: $&#123;OBJS&#125;<br>gcc -o main $&#123;OBJS&#125; $&#123;LIBS&#125;<br>clean:<br>rm -f main $&#123;OBJS&#125;<br></code></pre></td></tr></table></figure><p>环境变量使用规则（优先级）：</p><ol type="1"><li>make 命令行后面加上的环境变量为优先；</li><li>makefile 里面指定的环境变量第二；</li><li>shell 原本具有的环境变量第三。</li></ol><p><code>$@</code>：代表目前的目标(target) ，故 makefile 也可写成</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile">[root@study ~]<span class="hljs-comment"># vi makefile</span><br>LIBS = -lm<br>OBJS = main.o haha.o sin_value.o cos_value.o<br>CFLAGS = -Wall<br><span class="hljs-section">main: $&#123;OBJS&#125;</span><br>gcc -o <span class="hljs-variable">$@</span> $&#123;OBJS&#125; $&#123;LIBS&#125;    &lt;==那个<span class="hljs-variable">$@</span> 就是main ！<br><span class="hljs-section">clean:</span><br>rm -f main $&#123;OBJS&#125;<br></code></pre></td></tr></table></figure><h2 id="软件安装-rpmsrpm-与-yum">22. 软件安装 RPM、SRPM 与 YUM</h2><h3 id="rpm-软件管理程序rpm">22.1 RPM 软件管理程序：rpm</h3><p>rpm 安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# rpm -ivh package_name<br>选项与参数：<br>-i ：install 的意思<br>-v ：察看更细部的安装资讯画面<br>-h ：以安装资讯列显示安装进度<br><br>范例一：安装原版光碟上的rp-pppoe 软体<br>[root@study ~]# rpm -ivh /mnt/Packages/rp-pppoe-3.11-5.el7.x86_64.rpm<br>Preparing... ################################# [100%]<br>Updating / installing...<br>   1:rp-pppoe-3.11-5.el7 ################################# [100%]<br><br>范例二、一口气安装两个以上的软体时： <br>[root@study ~]# rpm -ivh a.i386.rpm b.i386.rpm *.rpm <br><span class="hljs-meta prompt_"># </span><span class="language-bash">后面直接接上许多的软体档案！</span><br><br>范例三、直接由网路上面的某个档案安装，以网址来安装： <br>[root@study ~]# rpm -ivh http://website.name/path/pkgname.rpm<br></code></pre></td></tr></table></figure><p>强制安装选项：</p><table><thead><tr class="header"><th>可下达的选项</th><th>代表意义</th></tr></thead><tbody><tr class="odd"><td>--nodeps</td><td>使用时机：当发生软体属性相依问题而无法安装，但你执意安装时 危险性：软体会有相依性的原因是因为彼此会使用到对方的机制或功能，如果强制安装而不考虑软体的属性相依，则可能会造成该软体的无法正常使用！</td></tr><tr class="even"><td>--replacefiles</td><td>使用时机：如果在安装的过程当中出现了『某个档案已经被安装在你的系统上面』的资讯，又或许出现版本不合的讯息(confilctingfiles) 时，可以使用这个参数来直接覆盖档案。 危险性：覆盖的动作是无法复原的！所以，你必须要很清楚的知道被覆盖的档案是真的可以被覆盖喔！否则会欲哭无泪！</td></tr><tr class="odd"><td>--replacepkgs</td><td>使用时机： 重新安装某个已经安装过的软体！如果你要安装一堆RPM软体档案时，可以使用rpm -ivh *.rpm ，但若某些软体已经安装过了，此时系统会出现『某软体已安装』的资讯，导致无法继续安装。此时可使用这个选项来重复安装喔！</td></tr><tr class="even"><td>--force</td><td>使用时机：这个参数其实就是--replacefiles 与--replacepkgs的综合体！</td></tr><tr class="odd"><td>--test</td><td>使用时机： 想要测试一下该软体是否可以被安装到使用者的Linux环境当中，可找出是否有属性相依的问题。范例为： rpm -ivh pkgname.i386.rpm--test</td></tr><tr class="even"><td>--justdb</td><td>使用时机： 由于RPM资料库破损或者是某些缘故产生错误时，可使用这个选项来更新软体在资料库内的相关资讯。</td></tr><tr class="odd"><td>--nosignature</td><td>使用时机： 想要略过数位签章的检查时，可以使用这个选项。</td></tr><tr class="even"><td>--prefix 新路径</td><td>使用时机：要将软体安装到其他非正规目录时。举例来说，你想要将某软体安装到/usr/local而非正规的/bin, /etc 等目录， 就可以使用『 --prefix /usr/local』来处理了。</td></tr><tr class="odd"><td>--noscripts</td><td>使用时机：不想让该软体在安装过程中自行执行某些系统指令。 说明： RPM的优点除了可以将档案放置到定位之外，还可以自动执行一些前置作业的指令，例如资料库的初始化。如果你不想要让RPM帮你自动执行这一类型的指令，就加上他吧！</td></tr></tbody></table><p>rpm 升级与更新：</p><table><thead><tr class="header"><th>-Uvh</th><th>后面接的软体即使没有安装过，则系统将予以直接安装；若后面接的软体有安装过旧版，则系统自动更新至新版；</th></tr></thead><tbody><tr class="odd"><td>-Fvh</td><td>如果后面接的软体并未安装到你的Linux系统上，则该软体不会被安装；亦即只有已安装至你 Linux系统内的软体会被『升级』！</td></tr></tbody></table><p>rpm 查询：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# rpm -qa                               &lt;==已安装软体<br>[root@study ~]# rpm -q[licdR] 已安装的软体名称       &lt;==已安装软体<br>[root@study ~]# rpm -qf 存在于系统上面的某个档名     &lt;==已安装软体<br>[root@study ~]# rpm -qp[licdR] 未安装的某个档案名称  &lt;==查阅RPM档案<br>选项与参数：<br>查询已安装软体的资讯：<br>-q ：仅查询，后面接的软体名称是否有安装；<br>-qa ：列出所有的，已经安装在本机Linux 系统上面的所有软体名称；<br>-qi ：列出该软体的详细资讯(information)，包含开发商、版本与说明等；<br>-ql ：列出该软体所有的档案与目录所在完整档名(list)；<br>-qc ：列出该软体的所有设定档(找出在/etc/ 底下的档名而已)<br>-qd ：列出该软体的所有说明档(找出与man 有关的档案而已)<br>-qR ：列出与该软体有关的相依软体所含的档案(Required 的意思)<br>-qf ：由后面接的档案名称，找出该档案属于哪一个已安装的软体；<br>-q --scripts：列出是否含有安装后需要执行的脚本档，可用以debug 喔！<br>查询某个RPM 档案内含有的资讯：<br>-qp[icdlR]：注意-qp 后面接的所有参数以上面的说明一致。但用途仅在于找出<br>    某个RPM 档案内的资讯，而非已安装的软体资讯！注意！<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs shell">范例一：找出你的Linux 是否有安装logrotate 这个软体？<br>[root@study ~]# rpm -q logrotate<br>logrotate-3.8.6-4.el7.x86_64<br>[root@study ~]# rpm -q logrotating<br>package logrotating is not installed<br><span class="hljs-meta prompt_"># </span><span class="language-bash">注意到，系统会去找是否有安装后面接的软体名称。注意，不必要加上版本喔！</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">至于显示的结果，一看就知道有没有安装啦！</span><br><br>范例二：列出上题当中，属于该软体所提供的所有目录与档案： <br>[root@study ~]# rpm -ql logrotate<br>/etc/cron.daily/logrotate<br>/etc/logrotate.conf<br>....(以下省略).... <br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以看出该软体到底提供了多少的档案与目录，也可以追踪软体的资料。</span><br><br>范例三：列出logrotate 这个软体的相关说明资料： <br>[root@study ~]# rpm -qi logrotate <br>Name : logrotate                           # 软体名称<br>Version : 3.8.6                               # 软体的版本<br>Release : 4.el7                               # 释出的版本<br>Architecture: x86_64                              # 编译时所针对的硬体等级<br>Install Date: Mon 04 May 2015 05:52:36 PM CST     # 这个软体安装到本系统的时间<br>Group : System Environment/Base             # 软体是放再哪一个软体群组中<br>Size : 102451                              # 软体的大小<br>License : GPL+                                # 释出的授权方式<br>Signature : RSA/SHA256, Fri 04 Jul 2014 11:34:56 AM CST, Key ID 24c6a8a7f4a80eb5<br>Source RPM : logrotate-3.8.6-4.el7.src.rpm       # 这就是SRPM 的档名<br>Build Date : Tue 10 Jun 2014 05:58:02 AM CST     # 软体编译打包的时间<br>Build Host : worker1.bsys.centos.org             # 在哪一部主机上面编译的<br>Relocations : (not relocatable)   <br>Packager : CentOS BuildSystem &lt;http://bugs.centos.org&gt;<br>Vendor : CentOS<br>URL : https://fedorahosted.org/logrotate/<br>Summary : Rotates, compresses, removes and mails system log files<br>Description :                                     # 这个是详细的描述！<br>The logrotate utility is designed to simplify the administration of<br>log files on a system which generates a lot of log files. Logrotate<br>allows for the automatic rotation compression, removal and mailing of<br>log files. Logrotate can be set to handle a log file daily, weekly,<br>monthly or when the log file gets to a certain size. Normally,<br>logrotate runs as a daily cron job.<br><br>Install the logrotate package if you need a utility to deal with the<br>log files on your system.<br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出该软体的information (资讯)，里面的资讯可多著呢，包括了软体名称、</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">版本、开发商、SRPM档案名称、打包次数、简单说明资讯、软体打包者、</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装日期等等！如果想要详细的知道该软体的资料，用这个参数来了解一下</span><br><br>范例四：分别仅找出logrotate 的设定档与说明档<br>[root@study ~]# rpm -qc logrotate <br>[root@study ~]# rpm -qd logrotate<br><br>范例五：若要成功安装logrotate ，他还需要什么档案的帮忙？<br>[root@study ~]# rpm -qR logrotate<br>/bin/sh<br>config(logrotate) = 3.8.6-4.el7<br>coreutils &gt;= 5.92<br>....(以下省略)....<br><span class="hljs-meta prompt_"># </span><span class="language-bash">由这里看起来，呵呵～还需要很多档案的支援才行喔！</span><br><br>范例六：由上面的范例五，找出/bin/sh 是那个软体提供的？<br>[root@study ~]# rpm -qf /bin/sh<br>bash-4.2.46-12.el7.x86_64<br><span class="hljs-meta prompt_"># </span><span class="language-bash">这个参数后面接的可是『档案』呐！不像前面都是接软体喔！</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这个功能在查询系统的某个档案属于哪一个软体所有的。</span><br><br>范例七：假设我有下载一个RPM 档案，想要知道该档案的需求档案，该如何？<br>[root@study ~]# rpm -qpR filename.i386.rpm <br><span class="hljs-meta prompt_"># </span><span class="language-bash">加上-qpR ，找出该档案需求的资料！</span><br></code></pre></td></tr></table></figure><p>rpm 卸载与重建数据库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 找出与pam 有关的软体名称，并尝试移除pam 这个软体：</span> <br>[root@study ~]# rpm -qa | grep pam<br>fprintd-pam-0.5.0-4.0.el7_0.x86_64<br>pam-1.1.8-12.el7.x86_64<br>gnome-keyring-pam-3.8.2-10.el7.x86_64<br>pam-devel-1.1.8-12.el7.x86_64<br>pam_krb5-2.4.8-4.el7.x86_64<br>[root@study ~]# rpm -e pam <br>error: Failed dependencies:   &lt;==这里提到的是相依性的问题<br>        libpam.so.0()(64bit) is needed by (installed) systemd-libs-208-20.el7.x86_64<br>        libpam.so.0()(64bit) is needed by (installed) libpwquality-1.2.3-4.el7.x86_64<br>....(以下省略)....<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 若仅移除pam-devel 这个之前范例安装上的软体呢？</span><br>[root@study ~]# rpm -e pam-devel   &lt;==不会出现任何讯息！<br>[root@study ~]# rpm -q pam-devel<br>package pam-devel is not installed<br><br>[root@study ~]# rpm --rebuilddb    &lt;==重建数据库<br></code></pre></td></tr></table></figure><h3 id="yum-在线升级功能">22.2 YUM 在线升级功能</h3><p>查询：yum [list|info|search|provides|whatprovides] 参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# yum [option] [查询工作项目] [相关参数]<br>选项与参数：<br>[option]：主要的选项，包括有：<br>  -y ：当yum 要等待使用者输入时，这个选项可以自动提供yes 的回应；<br>  --installroot=/some/path ：将该软体安装在/some/path 而不使用预设路径<br>[查询工作项目] [相关参数]：这方面的参数有：<br>  search ：搜寻某个软体名称或者是描述(description) 的重要关键字；<br>  list ：列出目前yum 所管理的所有的软体名称与版本，有点类似rpm -qa；<br>  info ：同上，不过有点类似rpm -qai 的执行结果；<br>  provides：从档案去搜寻软体！类似rpm -qf 的功能！<br><br>范例一：搜寻磁碟阵列(raid) 相关的软体有哪些？<br>[root@study ~]# yum search raid <br>Loaded plugins: fastestmirror, langpacks       # yum 系统自己找出最近的yum server <br>Loading mirror speeds from cached hostfile     # 找出速度最快的那一部yum server <br> * base: ftp.twaren.net                        # 底下三个软体库，且来源为该伺服器！<br> * extras: ftp.twaren.net<br> * updates: ftp.twaren.net<br>....(前面省略)....<br>dmraid-events-logwatch.x86_64 : dmraid logwatch-based email reporting<br>dmraid-events.x86_64 : dmevent_tool (Device-mapper event tool) and DSO<br>iprutils.x86_64 : Utilities for the IBM Power Linux RAID adapters<br>mdadm.x86_64 : The mdadm program controls Linux md devices (software RAID arrays)<br>....(后面省略)....<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在冒号(:) 左边的是软体名称，右边的则是在RPM 内的name 设定(软体名)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">瞧！上面的结果，这不就是与RAID 有关的软体吗？如果想了解mdadm 的软体内容呢？</span><br><br>范例二：找出mdadm 这个软体的功能为何<br>[root@study ~]# yum info mdadm <br>Installed Packages        &lt;==这说明该软体是已经安装的了<br>Name : mdadm       &lt;==这个软体的名称<br>Arch : x86_64      &lt;==这个软体的编译架构<br>Version : 3.3.2       &lt;==此软体的版本<br>Release : 2.el7       &lt;==释出的版本<br>Size : 920 k       &lt;==此软体的档案总容量<br>Repo : installed   &lt;==软体库回报说已安装的<br>From repo : anaconda<br>Summary : The mdadm program controls Linux md devices (software RAID arrays)<br>URL : http://www.kernel.org/pub/linux/utils/raid/mdadm/<br>License : GPLv2+<br>Description : The mdadm program is used to create, manage, and monitor Linux MD (software<br>            : RAID) devices. As such, it provides similar functionality to the raidtools<br>            : package. However, mdadm is a single program, and it can perform<br>            : almost all functions without a configuration file, though a configuration<br>            : file can be used to help with some common tasks.<br><span class="hljs-meta prompt_"># </span><span class="language-bash">不要跟我说，上面说些啥？自己找字典翻一翻吧！拜托拜托！</span><br><br>范例三：列出yum 伺服器上面提供的所有软体名称<br>[root@study ~]# yum list <br>Installed Packages    &lt;==已安装软体<br>GConf2.x86_64 3.2.6-8.el7 @anaconda<br>LibRaw.x86_64 0.14.8-5.el7.20120830git98d925 @base<br>ModemManager.x86_64 1.1.0-6.git20130913.el7 @anaconda<br>....(中间省略).... <br>Available Packages    &lt;==还可以安装的其他软体<br>389-ds-base.x86_64 1.3.3.1-20.el7_1 updates<br>389-ds-base-devel.x86_64 1.3.3.1-20.el7_1 updates<br>389-ds-base-libs.x86_64 1.3.3.1-20.el7_1 updates<br>....(底下省略)....<br><span class="hljs-meta prompt_"># </span><span class="language-bash">上面提供的意义为：『 软体名称版本在那个软体库内』</span><br><br>范例四：列出目前伺服器上可供本机进行升级的软体有哪些？<br>[root@study ~]# yum list updates   &lt;==一定要是update s喔！<br>Updated Packages<br>NetworkManager.x86_64 1:1.0.0-16.git20150121.b4ea599c.el7_1 updates<br>NetworkManager-adsl.x86_64 1:1.0.0-16.git20150121.b4ea599c.el7_1 updates<br>....(底下省略)....<br><span class="hljs-meta prompt_"># </span><span class="language-bash">上面就列出在那个软体库内可以提供升级的软体与版本！</span><br><br>范例五：列出提供passwd 这个档案的软体有哪些<br>[root@study ~]# yum provides passwd<br>passwd-0.79-4.el7.x86_64 : An utility for setting or changing passwords using PAM<br>Repo : base<br><br>passwd-0.79-4.el7.x86_64 : An utility for setting or changing passwords using PAM<br>Repo : @anaconda<br><span class="hljs-meta prompt_"># </span><span class="language-bash">找到啦！就是上面的这个软体提供了passwd 这个程式！</span><br></code></pre></td></tr></table></figure><p>安装/升级：yum [install|update] 软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# yum [option] [安装与升级的工作项目] [相关参数]<br>选项与参数：<br>  install ：后面接要安装的软体！<br>  update ：后面接要升级的软体，若要整个系统都升级，就直接update 即可<br><br>范例一：将前一个练习找到的未安装的pam-devel 安装起来<br>[root@study ~]# yum install pam-devel <br>Loaded plugins: fastestmirror, langpacks     # 首先的5 行在找出最快的yum server<br>Loading mirror speeds from cached hostfile<br> * base: ftp.twaren.net<br> * extras: ftp.twaren.net<br> * updates: ftp.twaren.net<br>Resolving Dependencies                       # 接下来先处理『属性相依』的软体问题<br><span class="hljs-meta prompt_">--&gt; </span><span class="language-bash">Running transaction check</span><br><span class="hljs-meta prompt_">---&gt; </span><span class="language-bash">Package pam-devel.x86_64 0:1.1.8-12.el7_1.1 will be installed</span><br><span class="hljs-meta prompt_">--&gt; </span><span class="language-bash">Processing Dependency: pam(x86-64) = 1.1.8-12.el7_1.1 <span class="hljs-keyword">for</span> package: pam-devel-</span><br>       1.1.8-12.el7_1.1.x86_64<br><span class="hljs-meta prompt_">--&gt; </span><span class="language-bash">Running transaction check</span><br><span class="hljs-meta prompt_">---&gt; </span><span class="language-bash">Package pam.x86_64 0:1.1.8-12.el7 will be updated</span><br><span class="hljs-meta prompt_">---&gt; </span><span class="language-bash">Package pam.x86_64 0:1.1.8-12.el7_1.1 will be an update</span><br><span class="hljs-meta prompt_">--&gt; </span><span class="language-bash">Finished Dependency Resolution</span><br>Dependencies Resolved<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">由上面的检查发现到pam 这个软体也需要同步升级，这样才能够安装新版pam-devel 喔！</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">至于底下则是一个总结的表格显示！</span><br>==========================================================================================<br> Package Arch Version Repository Size<br>==========================================================================================<br>Installing:<br> pam-devel x86_64 1.1.8-12.el7_1.1 updates 183 k<br>Updating for dependencies:<br> pam x86_64 1.1.8-12.el7_1.1 updates 714 k<br><br>Transaction Summary<br>==========================================================================================<br>Install 1 Package                           # 要安装的是一个软体<br>Upgrade ( 1 Dependent package)   # 因为相依属性问题，需要额外加装一个软体！<br><br>Total size: 897 k<br>Total download size: 183 k                   # 总共需要下载的容量！<br>Is this ok [y/d/N]: y    # 你得要自己决定是否要下载与安装！当然是y 啊！<br>Downloading packages:                        # 开始下载啰！<br>warning: /var/cache/yum/x86_64/7/updates/packages/pam-devel-1.1.8-12.el7_1.1.x86_64.rpm:<br>         Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEY<br>Public key for pam-devel-1.1.8-12.el7_1.1.x86_64.rpm is not installed<br>pam-devel-1.1.8-12.el7_1.1.x86_64.rpm | 183 kB 00:00:00<br>Retrieving key from file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7<br>Importing GPG key 0xF4A80EB5:<br> Userid : &quot;CentOS-7 Key (CentOS 7 Official Signing Key) &lt;security@centos.org&gt;&quot;<br> Fingerprint: 6341 ab27 53d7 8a78 a7c2 7bb1 24c6 a8a7 f4a8 0eb5<br> Package : centos-release-7-1.1503.el7.centos.2.8.x86_64 (@anaconda)<br> From : /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7<br>Is this ok [y/N]: y   # 只有在第一次安装才会出现这个项目『确定要安装数位签章』才能继续！<br>Running transaction check<br>Running transaction test<br>Transaction test succeeded<br>Running transaction<br>Warning: RPMDB altered outside of yum.<br>  Updating : pam-1.1.8-12.el7_1.1.x86_64 1/3<br>  Installing : pam-devel-1.1.8-12.el7_1.1.x86_64 2/3<br>  Cleanup : pam-1.1.8-12.el7.x86_64 3/3<br>  Verifying : pam-1.1.8-12.el7_1.1.x86_64 1/3<br>  Verifying : pam-devel-1.1.8-12.el7_1.1.x86_64 2/3<br>  Verifying : pam-1.1.8-12.el7.x86_64 3/3<br><br>Installed:<br>  pam-devel.x86_64 0:1.1.8-12.el7_1.1<br><br>Dependency Updated:<br>  pam.x86_64 0:1.1.8-12.el7_1.1<br><br>Complete!<br></code></pre></td></tr></table></figure><p>删除：yum [remove] 软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# yum remove pam-devel<br>Loaded plugins: fastestmirror, langpacks<br>Resolving Dependencies    &lt;==同样的，先解决属性相依的问题<br><span class="hljs-meta prompt_">--&gt; </span><span class="language-bash">Running transaction check</span><br><span class="hljs-meta prompt_">---&gt; </span><span class="language-bash">Package pam-devel.x86_64 0:1.1.8-12.el7_1.1 will be erased</span><br><span class="hljs-meta prompt_">--&gt; </span><span class="language-bash">Finished Dependency Resolution</span><br><br>Dependencies Resolved<br><br>==========================================================================================<br> Package Arch Version Repository Size<br>==========================================================================================<br>Removing:<br> pam-devel x86_64 1.1.8-12.el7_1.1 @updates 528 k<br><br>Transaction Summary<br>==========================================================================================<br>Remove 1 Package        # 还好！没有相依属性的问题，仅移除一个软体！<br><br>Installed size: 528 k<br>Is this ok [y/N]: y<br>Downloading packages:<br>Running transaction check<br>Running transaction test<br>Transaction test succeeded<br>Running transaction<br>  Erasing : pam-devel-1.1.8-12.el7_1.1.x86_64 1/1<br>  Verifying : pam-devel-1.1.8-12.el7_1.1.x86_64 1/1<br><br>Removed:<br>  pam-devel.x86_64 0:1.1.8-12.el7_1.1<br><br>Complete!<br></code></pre></td></tr></table></figure><h2 id="x-window-设置介绍">23. X Window 设置介绍</h2><p>略</p><h2 id="linux-内核编译与管理">24. Linux 内核编译与管理</h2><p>略</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>命令行</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux 命令行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一文读懂 C++ 运算符重载</title>
    <link href="/2023/02/19/%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82-C-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    <url>/2023/02/19/%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82-C-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<p>运算符重载是 C++语言的一个特性，利用运算符重载能够写出更加简洁的代码，对外封装类的实现细节。本文介绍运算符重载相关知识点。</p><p>谈到运算符重载，还需要从 “<strong>函数重载</strong>”说起。函数重载是指函数名相同，但函数参数类型、参数数量不同（返回类型相同）的函数。比如实现某种数据类型向string 类型运算的函数： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 函数重载示例</span><br><span class="hljs-function">string <span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-type">double</span> d)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-type">float</span> d)</span></span>;<br><span class="hljs-comment">// 等等</span><br></code></pre></td></tr></table></figure> 这就是典型的函数重载。</p><p>运算符重载本质上也是函数重载，它们可以看做函数名为<code>operator+</code>、<code>operator-</code>、<code>operator*</code>、<code>operator++</code>、<code>operator&lt;&lt;</code>等等的函数。重载即体现在函数名相同，但函数参数类型不同。当然，一些运算符也允许参数数量不同的重载，典型的就是函数调用运算符<code>operator()</code>的重载。</p><p>利用函数重载可以实现更好的封装，同时提高代码的简洁度。例如，我们要实现一个大整数类，用于支持高精度运算，如果没有运算符重载，我们只能按照如下方式实现：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BigNum</span>&#123;<br>    <span class="hljs-comment">// 相关数据成员声明</span><br>&#125;；<br><span class="hljs-function">BigNum <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">const</span> BigNum &amp;,<span class="hljs-type">const</span> BigNum &amp;)</span></span>;  <span class="hljs-comment">// 加法   </span><br><span class="hljs-function">BigNum <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-type">const</span> BigNum &amp;,<span class="hljs-type">const</span> BigNum &amp;)</span></span>;  <span class="hljs-comment">// 减法   </span><br><span class="hljs-function">BigNum <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-type">const</span> BigNum &amp;,<span class="hljs-type">const</span> BigNum &amp;)</span></span>;  <span class="hljs-comment">// 乘法   </span><br><span class="hljs-function">BigNum <span class="hljs-title">div</span><span class="hljs-params">(<span class="hljs-type">const</span> BigNum &amp;,<span class="hljs-type">const</span> BigNum &amp;)</span></span>;  <span class="hljs-comment">// 除法   </span><br><span class="hljs-function">BigNum <span class="hljs-title">mod</span><span class="hljs-params">(<span class="hljs-type">const</span> BigNum &amp;,<span class="hljs-type">const</span> BigNum &amp;)</span></span>;  <span class="hljs-comment">// 取模   </span><br></code></pre></td></tr></table></figure> 进行函数调用时，则是以下形式： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">BigNum n1, n2, n3;<br>n3 = <span class="hljs-built_in">add</span>(n1, n2);  <span class="hljs-comment">// 显式函数调用</span><br></code></pre></td></tr></table></figure>利用运算符重载，则实现方式如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BigNum</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 相关数据成员</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">friend</span> BigNum <span class="hljs-keyword">operator</span>+ (<span class="hljs-type">const</span> BigNum&amp;, <span class="hljs-type">const</span> BigNum &amp;);    <span class="hljs-comment">// 加法  </span><br>    <span class="hljs-keyword">friend</span> BigNum <span class="hljs-keyword">operator</span>- (<span class="hljs-type">const</span> BigNum&amp;, <span class="hljs-type">const</span> BigNum &amp;);    <span class="hljs-comment">// 减法  </span><br>    <span class="hljs-keyword">friend</span> BigNum <span class="hljs-keyword">operator</span>* (<span class="hljs-type">const</span> BigNum&amp;, <span class="hljs-type">const</span> BigNum &amp;);    <span class="hljs-comment">// 乘法  </span><br>    <span class="hljs-comment">// 略</span><br>&#125;;<br><span class="hljs-comment">// 进行加法运算</span><br>BigNum n1, n2, n3;<br>n3 = n1 + n2;  <span class="hljs-comment">// 直接使用 + 运算符即可，相当于调用 operator+ 函数</span><br></code></pre></td></tr></table></figure>由上面两种实现方式和调用方式，不难看出运算符重载的优点：封装与简洁（对使用者而言的简洁，对类的设计者而言工作量增加）。</p><p>知道了上面的基础知识，我们正式进入 C++运算符重载的主题，重点介绍运算符重载的语法特点和一些需要注意的问题。（下文以<em>TypeName</em> 代表自定义类型名，如上面的 <em>BigNum</em> ）</p><h2 id="重载输出运算符">1. 重载输出运算符 &lt;&lt;</h2><p>输入输出运算符的重载是为了更加方便的输入/输出数据。其语法规则如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 类内声明友元</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 相关成员定义 略</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt; (ostream &amp;, <span class="hljs-type">const</span> TypeName &amp;);    <br>&#125;;<br><span class="hljs-comment">// 类外定义函数</span><br>ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt; (ostream &amp;os, <span class="hljs-type">const</span> TypeName &amp;temp)<br>&#123;<br>    <span class="hljs-comment">// 具体实现 略</span><br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>注意点如下：</p><ol type="1"><li>形参 1 ：<strong>ostream &amp;类型</strong>，非 const 引用</li><li>形参 2 ：<strong>const 引用类型</strong>。const是因为输出运算符一般不应该改变对象的的状态；使用引用类型是处于性能与效率的考虑，减少调用时对象的拷贝，从而提高程序运行效率</li><li>返回类型： <strong>ostream 引用</strong>，这是为了能够连续输出</li><li>一般定义为友元</li></ol><h2 id="重载输入运算符">2. 重载输入运算符 &gt;&gt;</h2><p>输入运算符与输出运算符比较相似，其语法规则如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 类内声明友元与上面输出运算符类似 此处略</span><br><span class="hljs-comment">// 类外实现如下</span><br>istream &amp; <span class="hljs-keyword">operator</span>&gt;&gt; (istream &amp;is, TypeName &amp;temp) <br>&#123;<br>    <span class="hljs-comment">// 具体实现 略</span><br>    <span class="hljs-keyword">return</span> is;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>注意点如下：</p><ol type="1"><li>形参 1 ：<strong>istream &amp;类型</strong>, 同样是非 const引用类型</li><li>形参 2 ：<strong>非 const 引用</strong>，之所以是非 const是因为输入一般要改变对象内部状态；之所以是引用类型是因为要改变形参对象本身</li><li>返回类型：与输出运算符重载类型，返回引用，目的是能够连续输入</li><li>一般定义为友元</li></ol><h2 id="重载算术和关系运算符">3. 重载算术和关系运算符</h2><p>实际上，算术和关系运算符重载有两种实现方法，即重载是定义为成员函数还是定义为非成员函数（友元）。以加法为例说明如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 方法 1 ：非成员函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 类内声明</span><br>    <span class="hljs-keyword">friend</span> TypeName <span class="hljs-keyword">operator</span>+ (<span class="hljs-type">const</span> TypeName &amp;, <span class="hljs-type">const</span> TypeName &amp;);   <br>&#125;;<br><span class="hljs-comment">// 类外定义</span><br>TypeName <span class="hljs-keyword">operator</span>+ (<span class="hljs-type">const</span> TypeName &amp;lop, <span class="hljs-type">const</span> TypeName &amp;rop)<br>&#123;<br>    <span class="hljs-comment">// 略</span><br>&#125;<br><br><span class="hljs-comment">// 方法 2： 成员函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    TypeName <span class="hljs-keyword">operator</span>+ (<span class="hljs-type">const</span> TypeName &amp;rop)<br>    &#123;<br>        <span class="hljs-comment">// 略</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>一般情况下，这两种方式差别不大，但是当类含有一个接收普通类型的构造函数时，第一种实现方法更好，这是因为非成员函数允许对左侧或者右侧的运算对象进行类型转换（即调用构造函数由普通类型构造类的对象）；而成员函数方式只允许对右侧运算对象进行类型转换。按照《C++Primer 第五版》一书的说法，推荐以非成员函数方式实现。</p><h3 id="算术运算符">3.1 算术运算符</h3><p>我们以加法为例介绍算术运算符重载。语法规则如下：(实际上这段代码和上面方法1 代码相同) <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 类内声明</span><br>    <span class="hljs-keyword">friend</span> TypeName <span class="hljs-keyword">operator</span>+ (<span class="hljs-type">const</span> TypeName &amp;, <span class="hljs-type">const</span> TypeName &amp;);   <br>&#125;;<br><span class="hljs-comment">// 类外定义</span><br>TypeName <span class="hljs-keyword">operator</span>+ (<span class="hljs-type">const</span> TypeName &amp;lop, <span class="hljs-type">const</span> TypeName &amp;rop)<br>&#123;<br>    <span class="hljs-comment">// 略</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p>注意点如下：</p><ol type="1"><li>参数类型：两个形参都为 <strong>const &amp;类型</strong>,这是因为算术运算符不改变运算对象本身；同时引用减少拷贝提高效率</li><li>返回值类型：返回一个经算术运算后生成的临时对象</li></ol><h3 id="关系运算符">3.2 关系运算符</h3><p>关系运算符很多，包括：<code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code>共6 种。它们的实现方式同样推荐方法 1，即以非成员函数方式实现。它们的参数类型都是 <strong>const引用类型</strong> ，返回值都是 <strong>bool 类型</strong>。</p><p>这 6种关系运算符实际上存在逻辑上的转换关系，因此在实际编程中，往往采用如下方式实现这些运算符重载：</p><ul><li>首先实现 <code>==</code> 运算符</li><li>利用 <code>==</code> 实现 <code>!=</code> 运算符，即<code>a != b</code> 相当于 <code>!(a == b)</code></li><li>实现 <code>&lt;</code> 运算符</li><li>实现 <code>&gt;</code> 运算符</li><li>利用 <code>&lt;</code> 和 <code>==</code> 实现 <code>&lt;=</code>运算符，即 <code>a &lt;= b</code> 相当于<code>(a &lt; b || a == b)</code> (当然，也可以用<code>!(a &gt; b)</code> 实现)</li><li>利用 <code>&gt;</code> 和 <code>==</code> 实现 <code>&gt;=</code>运算符，即 <code>a &gt;= b</code> 相当于<code>(a &gt; b || a == b)</code> (当然，也可以用<code>!(a &lt; b)</code> 实现)</li></ul><p>实际上，除了上述实现方式也有其他方法，如 <code>a == b</code> 相当于<code>!( (a&gt;b) || (a&lt;b) )</code>，其他运算符也有另外实现方式，只须符合逻辑规则即可，这里不赘述。</p><p>下面以 <code>==</code> 为例给出语法规则： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 类内声明</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>== (<span class="hljs-type">const</span> TypeName &amp;, <span class="hljs-type">const</span> TypeName &amp;);   <br>&#125;;<br><span class="hljs-comment">// 类外定义</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>== (<span class="hljs-type">const</span> TypeName &amp;lop, <span class="hljs-type">const</span> TypeName &amp;rop)<br>&#123;<br>    <span class="hljs-comment">// 略</span><br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="重载赋值运算符">4. 重载赋值运算符</h2><p>赋值运算符分为两种，一为普通的赋值运算符<code>=</code>；二为复合赋值运算符，如<code>+=</code>、<code>-=</code>等。其中，普通赋值运算符又分为拷贝赋值和移动赋值，它们实际上更应该归类与类的拷贝控制。公众号此前写过文章介绍类的拷贝控制，其中包括拷贝赋值和移动赋值运算符介绍：<ahref="https://mp.weixin.qq.com/s/Q80xH9ZlLbgXCpXTmrNUYQ">《浅谈 C++类的拷贝控制》</a>。普通赋值运算符的重载必须为类的成员函数。此外，赋值运算符的也可以重载其它参数类型，如C++ 标准库提供的初始化列表类型<code>initializer_list&lt;TypeName&gt;</code>，不过其不是本文重点，相关资料请自行查阅。</p><p>下面重点介绍复合赋值运算符的重载。复合赋值运算符不是必须定义为类的成员，但是绝大多数情况下，最好定义为类的成员函数。其语法规则如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">TypeName &amp; <span class="hljs-keyword">operator</span>+= (<span class="hljs-type">const</span> TypeName &amp;rop)<br>&#123;<br>    <span class="hljs-comment">// 具体实现 略</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>注意点如下：</p><ol type="1"><li>形参类型：<strong>const 引用类型</strong></li><li>返回值类型：<strong>引用类型</strong>，这是为了与 C++内置与普通数据成员的复合赋值运算符保持一致的特性，即返回引用类型，在代码中体现为<code>return *this</code></li><li>所有复合赋值运算符都应该定义在类内部，作为成员函数</li></ol><h2 id="重载下标运算符">5. 重载下标运算符 [ ]</h2><p>下标运算符必须是成员函数。其语法规则如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 不完全正确版本</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 略</span><br><span class="hljs-keyword">public</span>:<br>    ReturnType &amp; <span class="hljs-keyword">operator</span>[] (<span class="hljs-type">int</span> i)<br>    &#123;<br>        <span class="hljs-comment">// 略</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 代码中<code>ReturnType</code> 代表返回类型，一般取决于类内部数据成员类型。以C++ 提供的 <code>vector</code> 为例，<code>vector&lt;T&gt;</code>类型的下标运算符返回类型为<code>T &amp;</code>。这样我们就可以通过下标运算符修改数据成员。</p><p>注意点如下：</p><ol type="1"><li>参数类型：一般为整型，代表下标</li><li>返回值类型：一般返回<strong>引用类型</strong></li><li>对于 const 类型数据，其下标运算符应该返回 <strong>const引用类型</strong>。因此，在类中应该定义下标运算符的 const 和非 const两个版本重载函数，代码如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 正确版本</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 略</span><br><span class="hljs-keyword">public</span>:<br>    ReturnType &amp; <span class="hljs-keyword">operator</span>[] (<span class="hljs-type">int</span> i)  <span class="hljs-comment">// 非 const  </span><br>    &#123;<br>        <span class="hljs-comment">// 略</span><br>    &#125;<br>    <span class="hljs-comment">// const 类型重载</span><br>    <span class="hljs-type">const</span> ReturnType &amp; <span class="hljs-keyword">operator</span>[] (<span class="hljs-type">int</span> i) <span class="hljs-type">const</span>  <br>    &#123;<br>        <span class="hljs-comment">// 略</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="重载递增和递减运算符---">6. 重载递增和递减运算符 ++ --</h2><p>递增递减运算符分前置和后置两个版本，它们一般应该定义为类的成员。前置与后置版本二者差别较大，下面以<code>++</code> 运算符为例分别介绍。</p><h3 id="前置版本递增递减运算符">6.1 前置版本递增/递减运算符</h3><p>前置版本递增运算符重载语法规则如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    TypeName &amp; <span class="hljs-keyword">operator</span>++ ()<br>    &#123;<br>        <span class="hljs-comment">// 具体实现</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><p>注意点如下：</p><ol type="1"><li>无参函数</li><li>返回值类型：<strong>引用类型</strong>，代码中<code>return *this</code> 体现</li></ol><h3 id="后置版本递增递减运算符">6.2 后置版本递增/递减运算符</h3><p>后置版本递增运算符重载语法规则如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    TypeName <span class="hljs-keyword">operator</span>++ (<span class="hljs-type">int</span>)<br>    &#123;<br>        <span class="hljs-comment">// 具体实现</span><br>        <span class="hljs-keyword">return</span> 自增前的对象;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><p>注意点如下：</p><ol type="1"><li>参数类型： <code>int</code> ，不过，这个 <code>int</code>放在函数形参列表只是为了区分前置与后置， <code>int</code>形参在函数内部不需要用到，因此也不必给出标识符</li><li>返回值类型：<strong>普通类型</strong>，返回递增/递减前保存的临时对象</li><li><strong>后置版本一般利用前置版本实现</strong>，示例代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    TypeName &amp; <span class="hljs-keyword">operator</span>++ ()<br>    &#123;<br>        <span class="hljs-comment">// 具体实现</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <br>    TypeName <span class="hljs-keyword">operator</span>++ (<span class="hljs-type">int</span>)<br>    &#123;<br>        TypeName temp = *<span class="hljs-keyword">this</span>;<br>        ++*<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 调用前置版本++</span><br>        <span class="hljs-keyword">return</span> temp;  <span class="hljs-comment">// 返回递增前保存的临时对象</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h2 id="重载成员访问运算符--">7. 重载成员访问运算符 -&gt; *</h2><p>成员访问运算符包括两个：对于指针的 <code>-&gt;</code> 以及对于对象的<code>*</code> 。<code>-&gt;</code> 必须是类的成员；<code>*</code>通常是类的成员，但并非必须如此。它们的重载函数通常定义为 const的，语法规则如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ReturnType1 <span class="hljs-keyword">operator</span>* () <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-comment">// 具体实现</span><br>        <span class="hljs-comment">// 可返回任意类型</span><br>    &#125;<br>    <br>    ReturnType2 <span class="hljs-keyword">operator</span>-&gt; () <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-comment">// 具体实现</span><br>        <span class="hljs-comment">// 必须返回类的指针或者自定义了箭头运算符的某个类的对象  </span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>成员访问运算符重载一般用的比较少，这里仅做简要介绍。实际中需要用到时，可进一步参考相关资料，并根据类的需求和操作，定义合适的重载方法。</p><h2 id="重载函数调用运算符">8. 重载函数调用运算符 ( )</h2><p>函数调用运算符的重载相对比较特殊。理论上，我们可以重载任意多个函数调用运算符，只要保证这些重载之间不发生冲突即可。函数调用运算符必须是成员函数。定义了函数调用运算符的类的对象称为<strong>函数对象</strong>。举一个例子如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> a &gt; b;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure> 定义了上面的类后，我们可以显式地调用函数： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TypeName obj;<br><span class="hljs-type">bool</span> b = <span class="hljs-built_in">obj</span>(<span class="hljs-number">12</span>, <span class="hljs-number">15</span>);<br></code></pre></td></tr></table></figure>12 比 15 小，因此上述代码中 b 应该为 false。</p><p>不过，函数对象更为常用的是作为函数参数提供给标准库函数，典型的如 sort函数： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">22</span>,<span class="hljs-number">343</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-232</span>,<span class="hljs-number">-23423</span>&#125;;<br><span class="hljs-type">int</span> n = <span class="hljs-built_in">sizeof</span>(a)/<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>);<br><span class="hljs-built_in">sort</span>(a, a+n, <span class="hljs-built_in">TypeName</span>());<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n; ++i)<br>    cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span>;<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure> 将 <code>TypeName()</code>临时对象作为函数参数传递给 <code>sort</code>函数，就能够实现自定义规则排序。上面代码将数组降序排序，而<code>sort</code> 函数默认为升序排序。</p><p>值得一提的是，C++ 中提供的 lambda表达式，实际上都转换为类，这个类重载了函数调用运算符，参数类型即为lambda 表达式的参数类型。这样，调用 lambda表达式就转换为调用函数对象的函数调用运算符。</p><h2 id="重载类型转换运算符">9. 重载类型转换运算符</h2><p>类型转换运算符的重载更为特殊，是类的一种特殊成员函数，其语法规则如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">type</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 具体实现</span><br>&#125;<br></code></pre></td></tr></table></figure> 其中， <code>type</code> 表示目标转换类型。</p><p>类型转换运算符一般很少使用，在实际编程中也应该谨慎使用。若定义不当，可能产生错误或者意料之外的结果。一般而言，类定义向<code>bool</code> 类型的转换规则就足够了，而且该转换函数最好定义为<code>explicit</code> 的。</p><hr /><p>以上就是本文全部内容。不过这些并不是对运算符重载的全面介绍，想了解更深入详细的知识，仍需阅读相关书籍。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>运算符重载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Nginx(GitHub Pages) 与 Hexo 搭建个人博客</title>
    <link href="/2023/02/18/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/02/18/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>本文介绍使用 Nginx（或者 GitHub Pages） 与 Hexo搭建个人博客的主要步骤。</p><p>在正文开始之前，先介绍上面提到的几个工具的功能：</p><ul><li><a href="https://nginx.org/en/">Nginx</a>：充当 Web服务器的角色，在个人博客中，其主要功能是在公网服务器上提供 HTTP 或 HTTPS服务，让用户能够访问你的博客网站。</li><li><a href="https://pages.github.com/">GitHubPages</a>：在没有个人公网服务器时，使用 GitHub Pages同样可以达到搭建个人博客的目的。具体而言，GitHub Pages 就是一个特殊的GitHub 仓库，你可以在这个仓库内放一些 HTML、CSS 和 JS文件等，从而搭建个人网站。</li><li><a href="https://hexo.io/zh-cn/">Hexo</a>：Hexo是一个静态博客框架，使用它可以搭建博客网站，让用户专注于博客内容，而不需要熟悉CSS 和 Javascript等前端内容。使用官方以及许多开源作者提供的主题，即可快速的构建美观的网页，而博客内容使用Markdown 编写即可。</li></ul><p>下面，介绍具体步骤。</p><h2 id="本地安装-node.js">1. 本地安装 Node.js</h2><p>Node.js 官网为：https://nodejs.org/en/download/，打开链接，根据本地环境，选择合适的安装文件下载。Windows 平台与 Mac平台选择二进制 installer 文件，安装时只需要点下一步即可。</p><p>Linux 平台安装稍微复杂些，推荐以下两种安装方式，可任选其一：</p><ul><li>源代码编译安装，无需配置 bash，但是编译耗时，<ahref="https://cloud.tencent.com/developer/article/1938607">参考</a></li><li>二进制文件下载安装，需要配置 bash 环境，<ahref="https://cloud.tencent.com/developer/article/1772306">参考</a></li></ul><p>安装完成后，在命令行输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm -v<br>$ node -v<br></code></pre></td></tr></table></figure><p>若都有输出，说明安装成功。</p><h2 id="本地安装-hexo-并初始化博客环境">2. 本地安装 Hexo并初始化博客环境</h2><p>Hexo 安装命令参考<ahref="https://hexo.io/zh-cn/">官网</a>即可，具体如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install hexo-cli -g<br>$ hexo init blog<br>$ <span class="hljs-built_in">cd</span> blog<br>$ npm install<br>$ hexo server<br></code></pre></td></tr></table></figure><p>关于 Hexo 的更多信息，可参考官方文档：<ahref="https://hexo.io/zh-cn/docs/">文档 | Hexo</a> 。</p><p>为了让你的博客网站更加符合你的审美，可以选择一个合适的主题 <ahref="https://hexo.io/themes/">Themes | Hexo</a> 。本博客网站使用的是Fluid，其 GitHub 仓库地址为：<ahref="https://github.com/fluid-dev/hexo-theme-fluid">fluid-dev/hexo-theme-fluid:一款 Material Design 风格的 Hexo 主题 / An elegant Material-Design themefor Hexo (github.com)</a> ，官方文档地址为：<ahref="https://hexo.fluid-dev.com/docs/guide/">配置指南 | Hexo Fluid用户手册 (fluid-dev.com)</a>。</p><p>仔细阅读 Hexo 官方文档与你选择的主题的官方文档，根据自己的喜好配置好yml 文件，搭建个人博客的路途就走完了一半。</p><p>下面，我们要解决的问题是：如何让互联网上的广大用户能够访问你的博客网站？</p><p>3、4 小节提供了两种方式，可根据自己的具体情况选择。</p><h2 id="建立-github-pages-仓库">3. 建立 GitHub Pages 仓库</h2><p>首先，在 GitHub上建立一个仓库。这个仓库的命名有点讲究，举例说明如下：</p><p>我的 GitHub 个人主页地址为：https://github.com/UnpureRationalist，其中，<code>UnpureRationalist</code> 表示我的用户名。</p><p>打开 GitHub 并选择创建仓库选项，将仓库命名为<code>用户名.github.io</code>，比如我的仓库命名则是：<code>UnpureRationalist.github.io</code>，并设置仓库为公开可见。</p><p>然后，在该仓库上传一个名为 <code>index.html</code>的文件，参考文件内容如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Example<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello World.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在浏览器输入链接 <code>用户名.github.io</code>，如我的博客地址为：<code>UnpureRationalist.github.io</code>，然后，浏览器即可显示 <code>index.html</code>文件的内容（可能需要等待一会）。</p><p>利用此仓库，我们就可以让其他用户访问自己的博客网站。</p><h2 id="服务器安装-nginx">4. 服务器安装 Nginx</h2><p>对于拥有个人云服务器的用户来说，可以直接在个人服务器上安装 Nginx服务，将个人博客搭建在自己的服务器上。</p><p>首先，我们需要在服务器上安装 Nginx，这里以 Ubuntu系统为例，步骤如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo apt update<br>$ sudo apt install nginx<br>$ sudo systemectl <span class="hljs-built_in">enable</span> nginx<span class="hljs-comment"># 设置 nginx 开机启动</span><br>$ sudo systemctl start nginx<span class="hljs-comment"># 启动 nginx 服务</span><br></code></pre></td></tr></table></figure><p>注意，为了让 Nginx 正常工作，需要在服务器的安全组设置中开放 80 or/and443 端口，以让 HTTP or/and HTTPS服务正常工作，具体参考自己使用的服务器提供商。</p><p>如果要使用 HTTPS 服务，则需要对 Nginx进行一定的配置，具体参考链接：https://cloud.tencent.com/document/product/400/35244。</p><h2 id="配置-hexo-实现自动部署">5. 配置 Hexo 实现自动部署</h2><p>经过上面的步骤，我们在本地有了一个存放个人博客的目录；在云端有了公网用户能够访问的目录。因此，我们只需要使用Git 或 scp 等工具，将 Hexo 生成的 public 目录下的所有文件和文件夹上传到GitHub 仓库或者服务器 Web服务根目录下即可。但是，手动进行这些操作有些麻烦，我们可以使用 Hexo提供的功能实现一条命令部署。详情参考链接：<ahref="https://hexo.io/zh-cn/docs/one-command-deployment">部署 | Hexo</a>。</p><p>具体而言，就是在 <code>_config.yml</code>配置文件中进行适当的配置，然后运行如下命令即可将个人博客部署到云端：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo deploy<br></code></pre></td></tr></table></figure><p>不过，在本人实际使用过程中，发现一键部署功能不太好用，GitHub Pages有时由于网络原因无法部署成功；部署到云服务器上则会报错。因此，本人使用Hexo 提供的功能部署到 GitHub Pages；对于服务器，则使用朴实无华的<code>scp</code>命令进行手动同步。如果读者有更好的自动部署方式，欢迎交流讨论。</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/02/18/hello-world/"/>
    <url>/2023/02/18/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h2 id="测试公式">测试公式</h2><p><span class="math display">\[E=mc^2\]</span></p><p><span class="math display">\[\sigma(z_i) = \frac{e^{z_{i}}}{\sum_{j=1}^K e^{z_{j}}} \ \ \ for\i=1,2,\dots,K\]</span></p><p><span class="math display">\[L_{\delta}=    \left\{\begin{matrix}        \frac{1}{2}(y - \hat{y})^{2} &amp; if \left | (y -\hat{y})  \right | &lt; \delta\\        \delta ((y - \hat{y}) - \frac1 2 \delta) &amp; otherwise    \end{matrix}\right.\]</span></p><p><span class="math display">\[\epsilon \sim \mathcal{N}(0, \textbf{I})\]</span></p><p><span class="math display">\[\vec{z} \sim \mathcal{N}(\vec{\mu}, \sigma^2 \textbf{I})\]</span></p><p><span class="math display">\[\sum_{i=1}^{D}|x_i-y_i|\]</span></p><p><span class="math display">\[Accuracy = \frac{TP+TN}{TP+TN+FP+FN}\]</span></p><p><span class="math display">\[Precision = \frac{TP}{TP+FP}\]</span></p><p><span class="math display">\[Recall = \frac{TP}{TP+FN}\]</span></p><p><span class="math display">\[F1 = \frac{2*Precision*Recall}{Precision+Recall} =\frac{2*TP}{2*TP+FP+FN}\]</span></p><h2 id="测试代码">测试代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> net<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> face_alignment <span class="hljs-keyword">import</span> align<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><br>adaface_models = &#123;<br>    <span class="hljs-string">&#x27;ir_50&#x27;</span>:<span class="hljs-string">&quot;pretrained/adaface_ir50_ms1mv2.ckpt&quot;</span>,<br>&#125;<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_pretrained_model</span>(<span class="hljs-params">architecture=<span class="hljs-string">&#x27;ir_50&#x27;</span></span>):<br>    <span class="hljs-comment"># load model and pretrained statedict</span><br>    <span class="hljs-keyword">assert</span> architecture <span class="hljs-keyword">in</span> adaface_models.keys()<br>    model = net.build_model(architecture)<br>    statedict = torch.load(adaface_models[architecture])[<span class="hljs-string">&#x27;state_dict&#x27;</span>]<br>    model_statedict = &#123;key[<span class="hljs-number">6</span>:]:val <span class="hljs-keyword">for</span> key, val <span class="hljs-keyword">in</span> statedict.items() <span class="hljs-keyword">if</span> key.startswith(<span class="hljs-string">&#x27;model.&#x27;</span>)&#125;<br>    model.load_state_dict(model_statedict)<br>    model.<span class="hljs-built_in">eval</span>()<br>    <span class="hljs-keyword">return</span> model<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">to_input</span>(<span class="hljs-params">pil_rgb_image</span>):<br>    np_img = np.array(pil_rgb_image)<br>    brg_img = ((np_img[:,:,::-<span class="hljs-number">1</span>] / <span class="hljs-number">255.</span>) - <span class="hljs-number">0.5</span>) / <span class="hljs-number">0.5</span><br>    tensor = torch.tensor([brg_img.transpose(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)]).<span class="hljs-built_in">float</span>()<br>    <span class="hljs-keyword">return</span> tensor<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br><br>    model = load_pretrained_model(<span class="hljs-string">&#x27;ir_50&#x27;</span>)<br>    feature, norm = model(torch.randn(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">112</span>,<span class="hljs-number">112</span>))<br><br>    test_image_path = <span class="hljs-string">&#x27;face_alignment/test_images&#x27;</span><br>    features = []<br>    <span class="hljs-keyword">for</span> fname <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(os.listdir(test_image_path)):<br>        path = os.path.join(test_image_path, fname)<br>        aligned_rgb_img = align.get_aligned_face(path)<br>        bgr_tensor_input = to_input(aligned_rgb_img)<br>        feature, _ = model(bgr_tensor_input)<br>        features.append(feature)<br><br>    similarity_scores = torch.cat(features) @ torch.cat(features).T<br>    <span class="hljs-built_in">print</span>(similarity_scores)<br>    <br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span><br>&#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode *left;<br>    TreeNode *right;<br>    <span class="hljs-built_in">TreeNode</span>() : <span class="hljs-built_in">val</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x, TreeNode *left, TreeNode *right) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(left), <span class="hljs-built_in">right</span>(right) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode *root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;TreeNode *&gt; s;<br>        TreeNode *p = root;<br>        <span class="hljs-keyword">while</span> (p || !s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span> (p)<br>            &#123;<br>                s.<span class="hljs-built_in">push</span>(p);<br>                p = p-&gt;left;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                TreeNode *temp = s.<span class="hljs-built_in">top</span>();<br>                s.<span class="hljs-built_in">pop</span>();<br>                res.<span class="hljs-built_in">push_back</span>(temp-&gt;val);<br>                p = temp-&gt;right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode *root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;TreeNode *&gt; s;<br>        TreeNode *p = root;<br>        <span class="hljs-keyword">while</span> (p || !s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">while</span> (p)<br>            &#123;<br>                s.<span class="hljs-built_in">push</span>(p);<br>                p = p-&gt;left;<br>            &#125;<br>            TreeNode *temp = s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            res.<span class="hljs-built_in">push_back</span>(temp-&gt;val);<br>            p = temp-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
