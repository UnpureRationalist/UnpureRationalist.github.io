<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据集与样本难度度量</title>
    <link href="/2023/03/12/%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8E%E6%A0%B7%E6%9C%AC%E9%9A%BE%E5%BA%A6%E5%BA%A6%E9%87%8F/"/>
    <url>/2023/03/12/%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8E%E6%A0%B7%E6%9C%AC%E9%9A%BE%E5%BA%A6%E5%BA%A6%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<p>本文分享关于数据集与样本难度度量的论文，具体为：</p><ul><li><a href="https://arxiv.org/pdf/2002.10689">A Theory of UsableInformation Under Computational Constraints</a></li><li><ahref="https://proceedings.mlr.press/v162/ethayarajh22a/ethayarajh22a.pdf">UnderstandingDataset Difficulty with <spanclass="math inline">\(\mathcal{V}\)</span>-Usable Information</a></li></ul><p>主要内容来自于组会分享，slides 可<ahref="Dataset%20&amp;%20Example%20Difficulty.pdf">点此查看</a>。</p><h2 id="香农互信息">1. 香农互信息</h2><p>在概率论和信息论中，两个随机变量的互信息（MutualInformation，MI）度量了两个变量之间相互依赖的程度。具体来说，对于两个随机变量，MI是一个随机变量由于已知另一个随机变量而减少的“信息量”（单位通常为比特）。</p><p>离散随机变量 X 和 Y 的互信息可以计算为：</p><center><img src="/2023/03/12/%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8E%E6%A0%B7%E6%9C%AC%E9%9A%BE%E5%BA%A6%E5%BA%A6%E9%87%8F/image-20230312222959237.png" class="" title="离散变量香农互信息定义"></center><p>其中 p(x, y) 是 <em>X</em> 和 <em>Y</em> 的联合概率质量函数，而 p(x)和 p(y) 分别是 <em>X</em> 和 <em>Y</em> 的边缘概率质量函数。</p><p>互信息又可以等价地表示成：</p><center><img src="/2023/03/12/%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8E%E6%A0%B7%E6%9C%AC%E9%9A%BE%E5%BA%A6%E5%BA%A6%E9%87%8F/image-20230312223006884.png" class=""></center><p>但是，在机器学习场景下，香农互信息与我们目前的一些经验性认识存在冲突，比如下面图片展示的例子：</p><center><img src="/2023/03/12/%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8E%E6%A0%B7%E6%9C%AC%E9%9A%BE%E5%BA%A6%E5%BA%A6%E9%87%8F/image-20230312223134757.png" class="" title="明文与密文与标签的香农互信息相等"></center><p>在香农互信息理论下，<em>明文与标注的互信息</em> 和<em>密文与标注的互信息</em>相等。但是，对于我们人类而言，从明文能够轻易识别出标注；而不能够根据密文判断标注。即如下图所示：</p><center><img src="/2023/03/12/%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8E%E6%A0%B7%E6%9C%AC%E9%9A%BE%E5%BA%A6%E5%BA%A6%E9%87%8F/image-20230312223458019.png" class=""></center><p>为了解决这一冲突，作者提出了新的概念：考虑计算约束下的互信息。</p><h2 id="对香农互信息的扩展定义mathcalv-information">2.对香农互信息的扩展定义——<spanclass="math inline">\(\mathcal{V}\)</span>-Information</h2><p>首先，作者引入三个概念：</p><ol type="1"><li><p><strong>predictive family</strong></p><p>Let <span class="math inline">\(\Omega=\{f: \mathcal{X}\cup\{\varnothing\} \rightarrow \mathcal{P}(\mathcal{Y})\}\)</span>. Wesay that <span class="math inline">\(\mathcal{V} \subseteq\Omega\)</span> is a predictive family if it satisfies <spanclass="math display">\[\forall f \in \mathcal{V}, \forall P \in \operatorname{range}(f), \quad\exists f^{\prime} \in \mathcal{V}, \quad \text { s.t. } \quad \forall x\in \mathcal{X}, f^{\prime}[x]=P, f^{\prime}[\varnothing]=P\]</span></p></li><li><p><strong>predictive conditional <spanclass="math inline">\(\mathcal{V}\)</span>-entropy</strong></p><p>Let <span class="math inline">\(X, Y\)</span> be two random variablestaking values in <span class="math inline">\(\mathcal{X} \times\mathcal{Y}\)</span>, and <spanclass="math inline">\(\mathcal{V}\)</span> be a predictive family. Thenthe predictive conditional <spanclass="math inline">\(\mathcal{V}\)</span>-entropy is defined as <spanclass="math display">\[\begin{aligned}H_{\mathcal{V}}(Y \mid X) &amp; =\inf _{f \in \mathcal{V}}\mathbb{E}_{x, y \sim X, Y}[-\log f[x](y)] \\H_{\mathcal{V}}(Y \mid \varnothing) &amp; =\inf _{f \in \mathcal{V}}\mathbb{E}_{y \sim Y}[-\log f[\varnothing](y)]\end{aligned}\]</span> We additionally call <spanclass="math inline">\(H_{\mathcal{V}}(Y \mid \varnothing)\)</span> the<span class="math inline">\(\mathcal{V}\)</span>-entropy, and alsodenote it as <span class="math inline">\(H_{\mathcal{V}}(Y)\)</span>.</p></li><li><p><strong>predictive conditional <spanclass="math inline">\(\mathcal{V}\)</span>-information</strong></p><p>Let <span class="math inline">\(X, Y\)</span> be two random variablestaking values in <span class="math inline">\(\mathcal{X} \times\mathcal{Y}\)</span>, and <spanclass="math inline">\(\mathcal{V}\)</span> be a predictive family. Thepredictive <span class="math inline">\(\mathcal{V}\)</span>-informationfrom <span class="math inline">\(X\)</span> to <spanclass="math inline">\(Y\)</span> is defined as <spanclass="math display">\[I_{\mathcal{V}}(X \rightarrow Y)=H_{\mathcal{V}}(Y \mid\varnothing)-H_{\mathcal{V}}(Y \mid X)\]</span></p></li></ol><p><span class="math inline">\(\mathcal{V}\)</span>-information有以下一些性质：</p><ul><li><p>基本性质</p><p>Let <span class="math inline">\(Y\)</span> and <spanclass="math inline">\(X\)</span> be any random variables on <spanclass="math inline">\(\mathcal{Y}\)</span> and <spanclass="math inline">\(\mathcal{X}\)</span>, and <spanclass="math inline">\(\mathcal{V}\)</span> and <spanclass="math inline">\(\mathcal{U}\)</span> be any predictive families,then we have</p><ul><li>Monotonicity: If <span class="math inline">\(\mathcal{V} \subseteq\mathcal{U}\)</span>, then <spanclass="math inline">\(H_{\mathcal{V}}(Y) \geq H_{\mathcal{U}}(Y),H_{\mathcal{V}}(Y \mid X) \geq H_{\mathcal{U}}(Y \mid X)\)</span>.</li><li>Non-Negativity: <span class="math inline">\(I_{\mathcal{V}}(X\rightarrow Y) \geq 0\)</span>.</li><li>Independence: If <span class="math inline">\(X\)</span> isindependent of <span class="math inline">\(Y, I_{\mathcal{V}}(X\rightarrow Y)=I_{\mathcal{V}}(Y \rightarrow X)=0\)</span>.</li></ul></li><li><p>数据处理不等式（与香农互信息不同）</p><ul><li><strong>Shannon Mutual Information</strong>: Letting <spanclass="math inline">\(t: \mathcal{X} \rightarrow \mathcal{X}\)</span> beany function, <span class="math inline">\(t(X)\)</span> cannot havehigher mutual information with <span class="math inline">\(Y\)</span>than <span class="math inline">\(X: I(t(X) ; Y) \leq I(X ;Y)\)</span>.</li><li><strong><spanclass="math inline">\(\mathcal{V}\)</span>-Information</strong>:Denoting <span class="math inline">\(t\)</span> as the decryptionalgorithm and <span class="math inline">\(\mathcal{V}\)</span> as aclass of natural language processing functions, we have that: <spanclass="math inline">\(I_{\mathcal{V}}(t(X) \rightarrowY)&gt;I_{\mathcal{V}}(X \rightarrow Y) \approx 0\)</span>.</li></ul></li><li><p>不对称性（与香农互信息不同）</p><p>If <span class="math inline">\(\mathcal{V}\)</span> contains allpolynomial-time computable functions, then <spanclass="math inline">\(I_{\mathcal{V}}(X \rightarrow h(X)) \ggI_{\mathcal{V}}(h(X) \rightarrow X)\)</span> , where <spanclass="math inline">\(h: \mathcal{X} \rightarrow\mathcal{Y}\)</span>.</p></li></ul><p>根据 <span class="math inline">\(\mathcal{V}\)</span>-information的性质，我们就能够合理解释上面例子展示的问题，从而有：</p><center><img src="/2023/03/12/%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8E%E6%A0%B7%E6%9C%AC%E9%9A%BE%E5%BA%A6%E5%BA%A6%E9%87%8F/image-20230312225113429.png" class=""></center><p><br></p><p>上面介绍的是 <spanclass="math inline">\(\mathcal{V}\)</span>-Information的严格定义，但是在机器学习中，我们不存在真实的分布，而是仅有从分布上采样的有限大小的数据集。下面，作者要解决如何在有限大小的数据集上估计<span class="math inline">\(\mathcal{V}\)</span>-Information：</p><p>Let <span class="math inline">\(X, Y\)</span> be two random variablestaking values in <span class="math inline">\(\mathcal{X},\mathcal{Y}\)</span> and <spanclass="math inline">\(\mathcal{D}=\left\{\left(x_i,y_i\right)\right\}_{i=1}^N \sim X, Y\)</span> denotes the set of samplesdrawn from the joint distribution over <spanclass="math inline">\(\mathcal{X}\)</span> and <spanclass="math inline">\(\mathcal{Y} . \mathcal{V}\)</span> is a predictivefamily. The empirical <spanclass="math inline">\(\mathcal{V}\)</span>-information (under <spanclass="math inline">\(\mathcal{D}\)</span> ) is the following <spanclass="math inline">\(\mathcal{V}\)</span>-information under theempirical distribution defined via <spanclass="math inline">\(\mathcal{D}\)</span> : <spanclass="math display">\[\hat{I}_{\mathcal{V}}(X \rightarrow Y ; \mathcal{D})=\inf _{f \in\mathcal{V}} \frac{1}{|\mathcal{D}|} \sum_{y_i \in \mathcal{D}} \log\frac{1}{f[\varnothing]\left(y_i\right)}-\inf _{f \in \mathcal{V}}\frac{1}{|\mathcal{D}|} \sum_{x_i, y_i \in \mathcal{D}} \log\frac{1}{f\left[x_i\right]\left(y_i\right)}\]</span> Then we have the following PAC bound over the empirical <spanclass="math inline">\(\mathcal{V}\)</span>-information:</p><p>Assume <span class="math inline">\(\forall f \in \mathcal{V}, x \in\mathcal{X}, y \in \mathcal{Y}, \log f[x](y) \in[-B, B]\)</span>. Thenfor any <span class="math inline">\(\delta \in(0,0.5)\)</span>, withprobability at least <span class="math inline">\(1-2 \delta\)</span>, wehave: <span class="math display">\[\left|I_{\mathcal{V}}(X \rightarrow Y)-\hat{I}_{\mathcal{V}}(X\rightarrow Y ; \mathcal{D})\right| \leq 4\mathfrak{R}_{|\mathcal{D}|}\left(\mathcal{G}_{\mathcal{V}}\right)+2 B\sqrt{\frac{2 \log \frac{1}{\delta}}{|\mathcal{D}|}}\]</span> where we define the function family <spanclass="math inline">\(\mathcal{G}_{\mathcal{V}}=\{g \mid g(x, y)=\logf[x](y), f \in \mathcal{V}\}\)</span>, and <spanclass="math inline">\(\mathfrak{R}_N(\mathcal{G})\)</span> denotes theRademacher complexity of <spanclass="math inline">\(\mathcal{G}\)</span> with sample number <spanclass="math inline">\(N\)</span>.</p><h2 id="使用-mathcalv-information-评估数据集和样本难度">3. 使用 <spanclass="math inline">\(\mathcal{V}\)</span>-Information评估数据集和样本难度</h2><p>利用上面介绍的 <spanclass="math inline">\(\mathcal{V}\)</span>-Information工具并进行实验，能够发现一些有趣的现象。</p><center><img src="/2023/03/12/%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8E%E6%A0%B7%E6%9C%AC%E9%9A%BE%E5%BA%A6%E5%BA%A6%E9%87%8F/image-20230312225802256.png" class=""></center><ul><li>大模型 accuracy 与<spanclass="math inline">\(\mathcal{V}\)</span>-Usable Information都更高，因为提取更多的信息让识别更容易</li><li><span class="math inline">\(\mathcal{V}\)</span>-Information 相比accuracy 对过拟合更加敏感</li></ul><center><img src="/2023/03/12/%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8E%E6%A0%B7%E6%9C%AC%E9%9A%BE%E5%BA%A6%E5%BA%A6%E9%87%8F/image-20230312225854120.png" class=""></center><ul><li>提供了衡量不同数据集难度的方法</li></ul><p>然后，引入评估样本点 <spanclass="math inline">\(\mathcal{V}\)</span>-Information （Pointwise <spanclass="math inline">\(\mathcal{V}\)</span>-Information，PVI）的方法：</p><p>Given random variables <span class="math inline">\(X, Y\)</span> anda predictive family <span class="math inline">\(\mathcal{V}\)</span>,the pointwise <spanclass="math inline">\(\mathcal{V}\)</span>-information (PVI) of aninstance <span class="math inline">\((x, y)\)</span> is <spanclass="math display">\[\operatorname{PVI}(x \rightarrow y)=-\log _2 g[\varnothing](y)+\log _2g^{\prime}[x](y)\]</span> where <span class="math inline">\(g \in \mathcal{V}\)</span>s.t. <span class="math inline">\(\mathbb{E}[-\logg[\varnothing](Y)]=H_{\mathcal{V}}(Y)\)</span> and <spanclass="math inline">\(g^{\prime} \in \mathcal{V}\)</span> s.t. <spanclass="math inline">\(\mathbb{E}\left[-\logg^{\prime}[X](Y)\right]=H_{\mathcal{V}}(Y \mid X)\)</span>.</p><p>PVI is to <spanclass="math inline">\(\mathcal{V}\)</span>-information what PMI is toShannon information: <span class="math display">\[\begin{aligned}I(X ; Y) &amp; =\mathbb{E}_{x, y \sim P(X, Y)}[\operatorname{PMI}(x, y)]\\I_{\mathcal{V}}(X \rightarrow Y) &amp; =\mathbb{E}_{x, y \sim P(X,Y)}[\operatorname{PVI}(x \rightarrow y)]\end{aligned}\]</span></p><p>完整算法流程如下：</p><center><img src="/2023/03/12/%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8E%E6%A0%B7%E6%9C%AC%E9%9A%BE%E5%BA%A6%E5%BA%A6%E9%87%8F/image-20230312230205356.png" class=""></center><p><br></p><p>然后，利用 PVI 进行实验，同样可以观察到一些有趣的现象：</p><center><img src="/2023/03/12/%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8E%E6%A0%B7%E6%9C%AC%E9%9A%BE%E5%BA%A6%E5%BA%A6%E9%87%8F/image-20230312230304658.png" class=""></center><ul><li>PVI 最低的样本中存在不少标注错误</li></ul><center><img src="/2023/03/12/%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8E%E6%A0%B7%E6%9C%AC%E9%9A%BE%E5%BA%A6%E5%BA%A6%E9%87%8F/image-20230312230341812.png" class=""></center><ul><li>模型能够正确分类样本的 PVI 阈值在 0.5 左右</li></ul><p><br></p><p>此外，原论文中还展示了一些有趣的实验现象，这里不再赘述，具体请参阅原论文。</p>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
      <category>读论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dataset &amp; example difficulty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 22.04 安装 QEMU 流程</title>
    <link href="/2023/03/03/Ubuntu-22-04-%E5%AE%89%E8%A3%85-QEMU-%E6%B5%81%E7%A8%8B/"/>
    <url>/2023/03/03/Ubuntu-22-04-%E5%AE%89%E8%A3%85-QEMU-%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.qemu.org/download/">QEMU</a>官方网站已经提供了安装 QEMU 的教程，按照其内容，Ubuntu 平台仅需执行<code>sudo apt-get install qemu</code>命令即可。但是，在实际安装过程中遇到了错误且未能解决，于是采用源码方式安装。以QEMU 7.2.0 版本为例，介绍安装流程。</p><ol type="1"><li><p>下载源码并解压缩</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">wget https://download.qemu.org/qemu-7.2.0.tar.xz</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">tar xvJf qemu-7.2.0.tar.xz</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> qemu-7.2.0</span><br></code></pre></td></tr></table></figure></li><li><p>编译前预处理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./configure</span><br></code></pre></td></tr></table></figure></li><li><p>处理报错</p><p>执行上述命令后，可能会出现以下报错：</p><center><img src="/2023/03/03/Ubuntu-22-04-%E5%AE%89%E8%A3%85-QEMU-%E6%B5%81%E7%A8%8B/image-20230303200128068.png" class=""></center><p>报错原因是系统缺少 QEMU 需要的相关依赖。执行以下命令安装依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install ninja-build</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install zlib1g zlib1g-dev</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install libglib2.0-dev</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install libpixman-1-dev</span><br></code></pre></td></tr></table></figure><p>重新执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./configure</span><br></code></pre></td></tr></table></figure></li><li><p>make 编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make</span><br></code></pre></td></tr></table></figure><p>执行上述命令后，开始漫长的编译过程，请耐心等待。</p></li><li><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo make install</span><br></code></pre></td></tr></table></figure></li><li><p>验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">qemu-</span><br></code></pre></td></tr></table></figure><p>输入 <code>qemu-</code> 后按两次 TAB键，若出现类似下面的输出，则安装成功。</p><center><img src="/2023/03/03/Ubuntu-22-04-%E5%AE%89%E8%A3%85-QEMU-%E6%B5%81%E7%A8%8B/image-20230303214138504.png" class="" title="image-20230303214138504"></center></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>QEMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 博客无法显示图片解决方法</title>
    <link href="/2023/02/23/Hexo-%E5%8D%9A%E5%AE%A2%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <url>/2023/02/23/Hexo-%E5%8D%9A%E5%AE%A2%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>Hexo 官方提供了很多在 Markdown 中 <ahref="https://hexo.io/zh-cn/docs/asset-folders#使用-Markdown-嵌入图片">插入图片</a>的方式，其语法主要可分为两种：</p><ol type="1"><li><p>Markdown 原生支持的语法</p><p><code>![图片描述](图片路径)</code></p><p>其中，图片路径不可以使用相对于本地系统的绝对路径，例如：<code>C:/Users/admin/Pictures/a.jpg</code>，这样 Hexo在生成静态网页时无法正确解析图片，从而导致图片无法在网页正常显示。</p><p>正确的图片路径有以下两种形式：</p><ul><li><p>相对于博客的根目录：<code>/imgs/a.jpg</code>，使用这种方式需要在博客 <code>source</code> 目录下新建<code>imgs</code> 文件夹，并在 <code>imgs</code>文件夹中存放文章需要使用的图片。</p><p>例如，使用：<code>/imgs/0_0.jpg</code>语法，可显示如下图片：</p></li></ul><p><img src="/imgs/0_0.jpg" /></p><ul><li><p>相对于某篇博客的相对路径：<code>./article_1/a.jpg</code>。使用这种方式需要在 Hexo 配置文件 <code>_config.yaml</code> 将<code>post_asset_folder</code> 选项设为 <code>true</code> 。然后使用<code>hexo new xxx</code> 新建文章时，Hexo 便会在<code>source/_posts</code>目录下新建与文章同名的文件夹，然后将文章需要使用的图片放在该文件夹中，通过相对路径引用即可。</p><p>例如，使用：<code>Hexo-博客无法显示图片解决方法/0_1.jpg</code>语法，可显示如下图片：</p><img src="/2023/02/23/Hexo-%E5%8D%9A%E5%AE%A2%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/0_1.jpg" class=""></li></ul></li><li><p>Hexo 特有的 asset_img 标签语法</p><p>Hexo 推荐使用的图片引用方式如下：</p><p><code>&#123;% asset_img example.jpg This is an example image %&#125;</code></p><p>但是，这种语法无法在 Markdown编辑器中正常显示图片，会影响我们在编辑器中查看文章内容，个人不推荐这种方式。</p></li></ol><p>经过个人探索，得到以下比较好用的解决方法，能够同时在 Hexo 博客和Markdown 编辑器中正确显示图片。</p><p>首先，根据 Hexo 官方文档，在 <code>_config.yaml</code> 将<code>post_asset_folder</code> 选项设为 <code>true</code>。然后，安装插件 <code>hexo-image-link</code>，安装命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install hexo-image-link --save<br></code></pre></td></tr></table></figure><p>如果安装了 <code>hexo-asset-img</code> 插件，需要将其卸载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm uninstall --save hexo-asset-img<br></code></pre></td></tr></table></figure><p>然后，配置 Markdown 编辑器 Typora 如下：</p><img src="/2023/02/23/Hexo-%E5%8D%9A%E5%AE%A2%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/image-20230223101720679.png" class="" title="Typora 配置"><p>配置完成后，在 Typora 中粘贴图片时，Typora就会自动将图片保存到与文件名同名的目录下，并在 Markdown中使用相对路径引用图片。这样，我们就可以在 Hexo 博客和 Typora中同时看到图片。</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>鸟哥的 Linux 私房菜阅读笔记</title>
    <link href="/2023/02/20/%E9%B8%9F%E5%93%A5%E7%9A%84-Linux-%E7%A7%81%E6%88%BF%E8%8F%9C%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/02/20/%E9%B8%9F%E5%93%A5%E7%9A%84-Linux-%E7%A7%81%E6%88%BF%E8%8F%9C%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>写在前面：</strong></p><p>本文是阅读 《鸟哥的 Linux 私房菜：基础学习篇》一书的笔记，记录了个人认为的一些重点内容，供本人后续查阅参考。对于偏向于系统运维方面的内容，则未记录。</p><p>《鸟哥的 Linux 私房菜：基础学习篇》无疑是入门 Linux命令行的一本好书，但是在个人阅读过程中，发现本书部分内容更偏向于系统运维人员，而不是大多数的普通程序员。当然，技多不压身，不过，对于仅想了解与日常编程开发紧密相关的命令行内容的读者，不妨选择性地跳跃阅读本书，或者找一些更符合您需求的资料。</p></blockquote><h2 id="linux-是什么与如何学习">1. Linux 是什么与如何学习</h2><h3 id="linux-是什么">1.1 Linux 是什么</h3><ul><li>1991 年 Linus 编写</li><li>操作系统发展历程<ol type="1"><li>1969 年，<strong>批处理操作系统</strong></li><li><strong>分时操作系统</strong>， “Multics” 系统</li><li>1973 年，UNIX 正式诞生； 1977 年，BSD 诞生; 1979 年，SystemV，<em>引发商业纠纷</em></li><li>1984 年，Minix 系统开始编写 ； GNU （GNU's NotUnix）计划（斯托曼发起）与 FSF（Free SoftwareFoundation）基金会成立</li><li>1988 年，图形用户界面模式 XFree86 计划</li><li>1991 年，芬兰 Linus Torvalds 发布 Linux 内核</li></ol></li><li>常见的开放源代码的授权（<ahref="https://www.runoob.com/w3cnote/open-source-license.html">详细介绍</a>）<ol type="1"><li>Apache Lisense 2.0</li><li>BSD</li><li>GPL</li><li>MIT License</li><li>……</li></ol></li></ul><h3 id="托瓦兹的-linux-的发展">1.2 托瓦兹的 Linux 的发展</h3><ul><li><p>1994 年，Linux 内核正式版， Version 1.0</p></li><li><p>1996 年， 2.0 版</p></li><li><p>2011 年，3.0 版</p></li><li><p>2015 年 4 月，4.0 版</p></li><li><p>查看内核版本命令： <code>uname -r</code></p></li><li><p>Linux 发行版分类（按照包管理工具）</p><ol type="1"><li>RPM 方式管理：Red Hat、Fedora、SUSE 等</li><li>dpkg 方式管理：Debian、Ubuntu、B2D 等</li><li>其他：Gentoo</li></ol></li></ul><h3 id="linux-该如何学习">1.3 Linux 该如何学习</h3><ol type="1"><li>Linux 的安装与命令</li><li>Linux 操作系统的基础技能：用户用户组、权限的概念等</li><li>vi 文本编辑器</li><li>Shell 与 Shell 脚本的学习</li><li>软件管理</li><li>网络基础</li></ol><p>核心：<strong><em>实践 动手</em></strong></p><h2 id="主机规划与磁盘划分">2. 主机规划与磁盘划分</h2><h3 id="linux-与硬件的搭配">2.1 Linux 与硬件的搭配</h3><p>略</p><h3 id="磁盘分区">2.2 磁盘分区</h3><p>P69 - P82 略</p><h3 id="安装-linux-前的规划">2.3 安装 Linux 前的规划</h3><p>确定用途 -&gt; 磁盘分区</p><h2 id="安装-centos7.x">3. 安装 CentOS7.x</h2><p>略 见第 3 章</p><h2 id="首次登录与在线求助">4. 首次登录与在线求助</h2><h3 id="首次登录系统">4.1 首次登录系统</h3><p>略</p><h3 id="命令行模式下命令的执行">4.2 命令行模式下命令的执行</h3><h4 id="开始执行命令">4.2.1 开始执行命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">命令一般格式</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">command</span> [-options] parameter1 parameter2 ...</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  命令      选项       参数</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">示例：查看home目录下所有文件（包括隐藏文件 -a）及其属性（-l）</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -al ~</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span>        -al     ~</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -a -l ~</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看日期和时间</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">date</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看语言语系</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">locale</span><br></code></pre></td></tr></table></figure><blockquote><p>番外：</p><p><strong>如何使用Windows ssh 连接远程CentOS主机？</strong></p><p><em>CentOS 端：</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看本机是否安装SSH软件包</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash"> rpm -qa | grep ssh</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果没有安装SSH</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yum install openssh-server</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">开启SSH服务</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">service sshd start</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看22号端口是否开启</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">netstat -ntpl | grep 22</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改服务器端断开连接时长</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">vi /etc/ssh/sshd_config</span> <br>找到<br><span class="hljs-meta prompt_">#</span><span class="language-bash">ClientAliveInterval 0</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">ClientAliveCountMax 3</span><br>修改为<br>ClientAliveInterval 60<br>ClientAliveCountMax 5<br>然后重启sshd服务<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl restart sshd</span><br></code></pre></td></tr></table></figure><p><em>Windows 端：</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh username@hostname(hostIP)</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">命令 用户名@主机名或者IP地址</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">然后输入密码即可连接远程主机</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="基础命令的操作">4.2.2 基础命令的操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">date</span><span class="hljs-comment"># 查看时间日期</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">cal<span class="hljs-comment"># 查看日历（calender）</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">bc<span class="hljs-comment"># 计算器</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">date</span> 具体</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">date</span> +%Y/%m/%d<span class="hljs-comment"># 以 year/month/day 格式输出 如“2021/03/22”</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">date</span> +%H:%M<span class="hljs-comment"># 以 hour:minute 格式输出 如“23:49”</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">cal 具体</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">cal year<span class="hljs-comment"># 显示 year 年的日历</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">cal [month] [year]<span class="hljs-comment"># 显示某年某月日历</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">bc 简单计算器</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">bc<span class="hljs-comment"># 支持 + - * / ^ %quit 退出计算器</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">bc 默认输出整数  scale = n 使输出小数点后 n 位</span><br></code></pre></td></tr></table></figure><h4 id="重要的几个热键-tabctrl-cctrl-d">4.2.3 重要的几个热键[Tab]、[Ctrl]-c、[Ctrl]-d</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">Tab 键</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">命令补全</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ca[Tab][Tab]<span class="hljs-comment"># 输入 ca 后按两次 Tab 键，终端输出以 ca 为前缀的命令</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出如下：</span><br>cacertdir_rehash     cache_restore        ca-legacy            cancel               cat<br>cache_check          cache_writeback      calibrate_ppa        cancel.cups          catchsegv<br>cache_dump           cagent_tools         caller               capsh                catman<br>cache_metadata_size  cairo-sphinx         canberra-boot        captoinfo<br>cache_repair         cal                  canberra-gtk-play    case<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">文件补齐</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -al .bash[Tab][Tab]<span class="hljs-comment"># 自动补齐文件名</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出如下</span><br>.bash_history  .bash_logout   .bash_profile  .bashrc<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">选项/参数补齐</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">date</span> --[Tab][Tab]<span class="hljs-comment"># 自动补齐参数</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出如下</span><br>--date        --help        --reference=  --rfc-3339=   --universal<br>--date=       --iso-8601    --rfc-2822    --set=        --version<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">[Ctrl]-c</span><br>作用：终端正在运行中的命令<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">[Ctrl]-d</span><br>作用：<br>1、相当于 exit 命令<br>2、代表键盘输入结束（End Of File）<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">[Shift] + &#123;[Page UP][Page Down]&#125;</span><br>作用：用于命令行输出的翻页<br></code></pre></td></tr></table></figure><h3 id="linux-系统的在线求助-man-page-和-info-page">4.3 Linux系统的在线求助 man page 和 info page</h3><h4 id="命令的---help-求助说明">4.3.1 命令的 --help 求助说明</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">date</span> --<span class="hljs-built_in">help</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查询已经使用过的命令选项</span><br></code></pre></td></tr></table></figure><h4 id="man-page">4.3.2 man page</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">man <span class="hljs-built_in">date</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">man 为 manual(操作说明)的缩写</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">按下 空格键 翻页；q 退出</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">向下查找词语： 输入 “/word” ，然后按 Enter 键，即可查找 “word”</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">向上查找词语： 输入 “?word” ，然后按 Enter 键，即可查找 “word”</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看 man 的帮助</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">man man</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看系统中和 man 命令有关的说明文件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">man -f man</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">whatis [命令或文件]<span class="hljs-comment"># 等价于上面 man -f ...</span></span><br>man (7)              - 格式化手册页的宏<br>man (1)              - 格式化并显示在线帮助手册页<br>man (1p)             - display system documentation<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">man 1 man<span class="hljs-comment"># 根据上面输出查看指定说明文件</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">找到系统中说明文件，只有有 man 关键字就将该说明列出来</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">man -k man</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">apropos [命令或文件]<span class="hljs-comment"># 相当于 man -k ...</span></span><br></code></pre></td></tr></table></figure><h4 id="info-page">4.3.3 info page</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">info info</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">按 N 、 P 、 U 到下一个、上一个、上一层的节点</span><br></code></pre></td></tr></table></figure><h3 id="超简单的文本编辑器nano">4.4 超简单的文本编辑器：nano</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">nano file.txt<span class="hljs-comment"># 打开 或者 创建 文件</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">打开 nano 之后下面的 <span class="hljs-string">&quot;^X&quot;</span> 代表 Ctrl + X 键，完成一定功能</span><br></code></pre></td></tr></table></figure><h3 id="正确的关机方法">4.5 正确的关机方法</h3><ol type="1"><li><p>观察系统的使用状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">who</span>  <span class="hljs-comment"># 查看当前谁在线</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">netstat -a<span class="hljs-comment"># 查看网络的联机状态</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ps -aux<span class="hljs-comment"># 查看后台进程</span></span><br></code></pre></td></tr></table></figure></li><li><p>通知在线用户关机的时刻</p></li><li><p>正确使用关机命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">sync</span><span class="hljs-comment"># 将数据同步写入硬盘中mingl</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">shutdown<span class="hljs-comment"># 常用的关机命令</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重新启动、关机</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">reboot</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">halt</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">poweroff</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">以 root 身份登录</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">su -</span><br></code></pre></td></tr></table></figure></li><li><p>shutdown 使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">shutdown [-krhc][时间] [警告信息]</span><br>-k: 不关机，只发送警告信息<br>-r: 将系统服务停掉之后就重新启动<br>-h: 将系统服务停掉之后，立即关机<br>-c: 取消已经在进行的 shutdown 命令内容<br>时间 : 指定系统关机时间。默认一分钟后自动进行<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">常用示例</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">shutdown -h now<span class="hljs-comment"># 立刻关机</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">shutdown -h 20:25<span class="hljs-comment"># 今天 20:25 关机 （或次日20:25关机）</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">shutdown -h +10<span class="hljs-comment"># 系统 10 分钟后自动关机</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">shutdown -r now<span class="hljs-comment"># 立刻重新启动</span></span><br></code></pre></td></tr></table></figure></li><li><p>reboot、 halt、 poweroff 使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">halt<span class="hljs-comment"># 系统停止，屏幕可能会保留系统已经停止的信息</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">poweroff<span class="hljs-comment"># 系统关机，屏幕空白</span></span><br></code></pre></td></tr></table></figure></li><li><p>实际使用管理工具 systemctl 关机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl [命令]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl reboot<span class="hljs-comment"># 系统重新启动</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl poweroff<span class="hljs-comment"># 系统关机</span></span><br></code></pre></td></tr></table></figure></li></ol><h2 id="linux-的文件权限与目录配置">5. Linux 的文件权限与目录配置</h2><h3 id="用户与用户组">5.1 用户与用户组</h3><ol type="1"><li><p>文件拥有者的三个层次：</p><blockquote><ol type="1"><li>文件所有者( User )：</li><li>用户组( Group )：每个用户可以有多个用户组的支持</li><li>其他人( Others )：</li></ol></blockquote></li><li><p>系统上所有账号相关信息记录在文件： /etc/passwd （可用 cat/etc/passwd 命令查看文件内容）</p></li><li><p>密码记录在： /etc/shadow 文件内</p></li><li><p>组名记录在： /etc/group 文件内</p></li></ol><h3 id="linux-文件权限概念">5.2 Linux 文件权限概念</h3><h4 id="linux-文件属性">5.2.1 Linux 文件属性</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">su -<span class="hljs-comment"># 切换到 root 权限</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -al<span class="hljs-comment"># list 查看文件名及相关属性</span></span><br>总用量 104<br>dr-xr-x---. 16 root root 4096 3月  22 23:14 .<br>dr-xr-xr-x. 20 root root 4096 3月  31 20:50 ..<br>-rw-------   1 root root 1955 3月  31 20:50 .bash_history<br>-rw-r--r--.  1 root root   18 12月 29 2013 .bash_logout<br>-rw-r--r--.  1 root root  176 12月 29 2013 .bash_profile<br>-rw-r--r--.  1 root root  176 12月 29 2013 .bashrc<br>drwxr-xr-x   9 root root 4096 3月  22 23:14 .cache<br>drwxr-xr-x  13 root root 4096 3月  22 23:14 .config<br>-rw-r--r--.  1 root root  100 12月 29 2013 .cshrc<br>drwx------   3 root root 4096 3月  22 23:13 .dbus<br>-rw-------   1 root root   16 3月  22 23:13 .esd_auth<br>-rw-------   1 root root  310 3月  22 23:13 .ICEauthority<br>drwx------   3 root root 4096 3月  22 23:13 .local<br>drwxr-xr-x   2 root root 4096 3月   8 22:34 .pip<br>-rw-r--r--   1 root root   73 3月   8 22:34 .pydistutils.cfg<br>drwx------   2 root root 4096 1月  21 2019 .ssh<br>-rw-r--r--.  1 root root  129 12月 29 2013 .tcshrc<br>-rw-------   1 root root  508 3月   8 22:37 .viminfo<br>-rw-------   1 root root    0 3月  22 23:14 .Xauthority<br><br>各字段解释如下：<br>-rw-------   1 root root    0 3月  22 23:14 .Xauthority<br>[1][2] [3]  [4]    [5]    [6]         [7]<br><br></code></pre></td></tr></table></figure><p>各字段含义解释如下：</p><ol type="1"><li><p>文件类型权限：共有<strong>10个字符</strong>，第一个字符代表该文件是<strong>目录</strong>，<strong>文件</strong>，或<strong>链接文件</strong> 等</p><blockquote><p>第一个字符含义说明：</p><p>d ：目录（directory）</p><p>- ：文件</p><p>l ：链接文件（link file）</p><p>b ：设备文件里面的可供存储的周边设备（可按块随机读写的设备）</p><p>c ：设备文件里面的串行端口设备，如键盘、鼠标（一次性读写的设备）</p><p>剩余字符，3个一组，均为 [rwx] 的组合，r 代表可读（read），w代表可写（write），x代表可执行（execute）。这三个权限的位置不会改变，若无权限，则为减号 [-]。</p><p>第一组为：<strong>文件拥有者</strong> 可具备的权限</p><p>第二组为：加入此用户组之账号的权限</p><p>第三组为：非本人且没有加入本用户组的其他账户的权限</p></blockquote></li><li><p>链接数：表示有多少个文件名链接到此节点（ inode），即记录有多少个文件名链接到相同的 inode 号码</p></li><li><p>文件拥有者：表示文件（或目录）拥有者的账号</p></li><li><p>文件所属用户组：表示文件的所属用户组</p></li><li><p>文件大小：文件的容量大小，默认单位为字节 Bytes</p></li><li><p>文件最后被修改的时间：文件的创建时间或者最近修改时间（若修改时间据现在太久，则只显示年份）。如果要显示完整的时间格式，则需要使用<code>ls -l --full-time</code> 命令</p></li><li><p>文件名：这个文件名，若文件名之前多一个 <code>.</code>，则代表该文件为隐藏文件</p></li></ol><h4 id="如何修改文件属性与权限">5.2.2 如何修改文件属性与权限</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">修改文件所属用户组 (change group)</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chgrp</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chgrp</span> [-R] dirName/fileName</span><br>-R : 进行递归修改，即将目录下子目录及文件都更新成为这个用户组<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改文件拥有者 (change own)</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chown</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chown</span> [-R] 账号名称 dirName/fileName</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chown</span> [-R] 账号名称:用户组名称 dirName/fileName</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">复制文件后修改文件所有者示例：</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cp</span> 源文件 目标文件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chown</span> 账号名称 目标文件名</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改文件的权限</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1.数字类型修改文件权限</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">各权限对应数字如下：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">r ： 4</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">w ： 2</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">x ： 1</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">则 rwx = 4 + 2 + 1 = 4    rw- = 4 + 2 + 0 = 6</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> [-R] xyz 文件或目录</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">其中 xyz 为数字，例如：666 、 777、 640 等</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">示例：将一个 shell 文件修改为可执行,非拥有者用户可以执行、查看但不可以修改</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> 755 fileName.sh</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2.符号类型修改文件权限</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">格式</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> [u | g | o | a] [+ | - | =] [r | w | x] [dirName | fileName]</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">含义：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">u ：user   g ： group   o ： others  a ： all</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">+ ：加入    - ： 移除    = ： 设置</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">rwx ： 读写执行</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">例：</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> u=rwx,go=rx .bashrc</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> u=rwx,g=rx,o=r fileName</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> a+w fileName<span class="hljs-comment"># 令 fileName 对所有人都可以写</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> a-x fileName<span class="hljs-comment"># 去除所有人执行权限</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">给某文件添加执行权限</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> a+x fileName</span><br></code></pre></td></tr></table></figure><h4 id="目录与文件的权限意义">5.2.3 目录与文件的权限意义</h4><blockquote><p>对 <strong>文件</strong> ：</p><p>r ： 读取文件实际内容</p><p>w： 编辑、修改、新增文件内容（不能删除该文件）</p><p>e ： 文件可以被系统执行 （与文件名无关）</p><p>对 <strong>目录</strong> ：</p><p>r ： 读取目录结构列表 （可以使用 ls 命令查看目录内容列表）</p><p>w ：可以改动目录结构列表，即建立新文件与目录、删除已经存在文件和目录、重命名文件和目录、移动该目录内文件和目录位置（与该目录下文件名的变动有关）</p><p>x ： 代表用户能否进入该目录成为工作目录，工作目录及当前所在的目录</p><p><strong>能不能进入目录，只与该目录执行权限有关</strong></p><p><strong>要开放目录给任何人浏览时，应该开放 r 和 x 权限， w权限不可随便给 </strong></p><p>要读一个文件时，至少应具备该文件所在目录 r 和 x 权限。</p></blockquote><h4 id="linux-文件种类与扩展名">5.2.4 Linux 文件种类与扩展名</h4><ol type="1"><li><p>文件种类：</p><ol type="1"><li>常规文件（regular file）：<code>ls -al</code> 命令输出的第一个字符<code>-</code> ，如 <code>-rwxrwxrwx</code> 。<ul><li>纯文本文件（ASCII）：</li><li>二进制文件（binary）：可执行文件等</li><li>数据文件（date）：有些程序在运行时会读取某些特定格式的文件，这些文件被称为数据文件。</li></ul></li><li>目录（directory）：第一个属性为 <code>d</code> 。</li><li>链接文件（link）：第一个属性为 <code>l</code> ，如<code>lrwxrwxrwx</code> ，类似于 Windows 下快捷方式 。</li><li>设备与设备文件（device）：与系统周边及存储等相关的一些文件，通常集中在<code>/dev</code> 目录下，又可分为：<ul><li>区块（block）设备文件：第一个属性为 <code>d</code>，可供系统随机存取的接口设备 。</li><li>字符（character）设备文件：一些串行端口的接口设备，如键盘、鼠标等，特色：一次性读取，不能够截断输出，第一个属性为<code>c</code> 。</li></ul></li><li>数据接口文件（sockets）：用于网络上的数据交换，第一个属性为<code>s</code> ，通常可在 <code>/run</code> 或 <code>/tmp</code>这些目录中可看到这种文件类型 。</li><li>数据输送文件（FIFO，pipe）：主要目的：用于解决多个进程同时读写一个文件所造成的的错误问题，即管道，第一个属性为<code>p</code></li></ol></li><li><p>Linux 文件扩展名：Linux下文件无所谓文件扩展名，扩展名只能用来大概了解文件是什么类型。</p><blockquote><p><strong>常用文件扩展名</strong></p><ol type="1"><li>*.sh ：脚本或批处理文件</li><li>*.Z、*.tar、、*.tar.gz、*.zip、*.tgz ：压缩文件</li><li>、*.html、*.php ：网页相关文件</li></ol></blockquote></li><li><p>Linux 文件名长度限制：单一文件或目录的最大允许文件名为 255字节</p></li><li><p>Linux 文件名的限制：</p><blockquote><p>不能包含以下字符：</p><p>* ? &gt; &lt; ; &amp; ! [ ] | \ ' " ` ( ) { } - +</p></blockquote></li></ol><h3 id="linux-目录配置">5.3 Linux 目录配置</h3><h4 id="linux-目录配置的依据-fhs">5.3.1 Linux 目录配置的依据 —— FHS</h4><p>FHS（Filesystem HierarchyStandard）：规定每个特定目录下应该放置什么数据</p><hr /><table><thead><tr class="header"><th style="text-align: left;"></th><th style="text-align: center;">可分享</th><th style="text-align: center;">不可分享</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">不变（static）</td><td style="text-align: center;">/usr （软件存放处）</td><td style="text-align: center;">/etc （配置文件）</td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: center;">/opt （第三方辅助软件）</td><td style="text-align: center;">/boot （启动与内核文件）</td></tr><tr class="odd"><td style="text-align: left;">可变动（variable）</td><td style="text-align: center;">/var/mail （用户邮箱）</td><td style="text-align: center;">/var/run （程序相关）</td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: center;">/var/spool/news （新闻组）</td><td style="text-align: center;">/var/lock （程序相关）</td></tr></tbody></table><blockquote><p>FHS 仅针对三个目录规定应该放置什么数据：</p><p>/ （root ，根目录）：与启动系统有关</p><p>/usr （Unix software resource）：与软件安装 / 执行有关</p><p>/var （variable）：与系统运行过程有关</p></blockquote><p>FHS 具体要求：图片来源：<ahref="https://zh.wikipedia.org/zh-hans/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86">维基百科：文件系统层次结构标准</a></p><figure><imgsrc="https://raw.githubusercontent.com/UnpureRationalist/Pictures/main/FHS.png"alt="FHS" /><figcaption aria-hidden="true">FHS</figcaption></figure><h4 id="目录树">5.3.2 目录树</h4><p><imgsrc="https://raw.githubusercontent.com/UnpureRationalist/Pictures/main/image-20210407000259422.png" /></p><h4 id="绝对路径与相对路径">5.3.3 绝对路径与相对路径</h4><p>略</p><h4 id="centos-的观察">5.3.4 CentOS 的观察</h4><p>Linux Standard Base（LSB）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">uname</span> -r<span class="hljs-comment"># 查看内核版本</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">uname</span> -m<span class="hljs-comment"># 查看操作系统架构版本</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看 LSB 标准</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yum install redhat-lsb<span class="hljs-comment"># 安装软件</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">lsb_relase -a<span class="hljs-comment"># 查看 LSB 标准</span></span><br>LSB Version:    :core-4.1-amd64:core-4.1-noarch:cxx-4.1-amd64:cxx-4.1-noarch:desktop-4.1-amd64:desktop-4.1-noarch:languages-4.1-amd64:languages-4.1-noarch:printing-4.1-amd64:printing-4.1-noarch<br>Distributor ID: CentOS<br>Description:    CentOS Linux release 7.5.1804 (Core)<br>Release:        7.5.1804<br>Codename:       Core<br></code></pre></td></tr></table></figure><h2 id="linux-文件与目录管理">6. Linux 文件与目录管理</h2><h3 id="目录与路径">6.1 目录与路径</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">pwd</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> [-p]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">rmdir</span> [-p]</span><br></code></pre></td></tr></table></figure><p>显示环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">给 PATH 环境变量添加路径：</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;PATH&#125;</span>:/root&quot;</span></span><br></code></pre></td></tr></table></figure><h3 id="文件与目录管理">6.2 文件与目录管理</h3><p><code>ls</code> 命令常用选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">-a ：全部的文件，连同隐藏文件（开头为 . 的文件）一起列出来<br>-d ：仅列出目录本身，而不是列出目录内的文件数据<br>-h ：将文件大小以人类较易读的方式（例如 GB, KB等等）列出来<br>-l ：长数据串行出，包含文件的属性与权限等等数据<br>-i ：列出 inode 号码<br></code></pre></td></tr></table></figure><p>其他命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cp</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mv</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">rm</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">basename</span>  <span class="hljs-comment"># 获取路径的文件名</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">dirname</span><span class="hljs-comment"># 获取路径的目录名</span></span><br></code></pre></td></tr></table></figure><h3 id="文件内容查看">6.3 文件内容查看</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">tac</span>   <span class="hljs-comment"># 从最后一行开始显示文件内容</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">nl</span><span class="hljs-comment"># 同时输出行号</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">more<span class="hljs-comment"># 一页一页显示文件内容</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">less<span class="hljs-comment"># 与 more 类似，但可以向前翻页</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">head</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">tail</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">od</span><span class="hljs-comment"># 以二进制形式读取文件内容</span></span><br></code></pre></td></tr></table></figure><h3 id="文件与目录的默认权限与隐藏权限">6.4文件与目录的默认权限与隐藏权限</h3><p>umask：指定目前用户在建立文件或目录时的默认权限，具体指要被拿掉的权限。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">umask</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">umask</span> -S</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置 <span class="hljs-built_in">umask</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">umask</span> 002</span><br></code></pre></td></tr></table></figure><p>文件的隐藏属性：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">chattr<span class="hljs-comment"># 配置文件隐藏属性</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">lsattr<span class="hljs-comment"># 显示文件隐藏属性</span></span><br></code></pre></td></tr></table></figure><p>查看文件类型命令：<code>file</code></p><h3 id="命令与文件的查找">6.5 命令与文件的查找</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">which</span> [-a] 命令名</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">wnereis [-bmsu] 文件或目录名</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">locate [-ir] keyword</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">updatedb<span class="hljs-comment"># 更新数据库</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">find [PATH] [option] [action]</span><br></code></pre></td></tr></table></figure><h2 id="linux-磁盘与文件系统管理">7. Linux 磁盘与文件系统管理</h2><h3 id="文件系统的简单操作">7.1 文件系统的简单操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">df</span><span class="hljs-comment"># 列出文件系统的整体磁盘使用量</span></span><br>-h : 以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示<br>-i : 不用磁盘容量，而以 inode 的数量来显示<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">du</span><span class="hljs-comment"># 查看文件系统的磁盘使用量</span></span><br>-h : 同上<br>-s : 仅列出总量，而不列出每个各别的目录占用容量<br></code></pre></td></tr></table></figure><p>链接：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ln</span> [-sf] 源文件 目标文件</span><br>-s ：有 -s 选项为符号链接；否则为硬链接<br>-f : 目标文件存在时，就主动的将目标文件直接删除后再创建<br></code></pre></td></tr></table></figure><h3 id="磁盘的分区格式化检验与挂载">7.2磁盘的分区、格式化、检验与挂载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gdisk 设备名称</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">mount [-t 文件系统] UUID=<span class="hljs-string">&#x27;&#x27;</span> 挂载点</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">umount [-fn] 设备文件名或挂载点</span><br></code></pre></td></tr></table></figure><h2 id="文件与文件系统的压缩">8. 文件与文件系统的压缩</h2><h3 id="linux-系统常见的压缩命令">8.1 Linux 系统常见的压缩命令</h3><blockquote><p><em>.Z compress 程序压缩的文件； </em>.zip zip 程序压缩的文件；<em>.gz gzip 程序压缩的文件； </em>.bz2 bzip2 程序压缩的文件； <em>.xzxz 程序压缩的文件； </em>.tar tar 程序打包的数据，并没有压缩过；<em>.tar.gz tar 程序打包的文件，其中并且经过 gzip 的压缩 </em>.tar.bz2tar 程序打包的文件，其中并且经过 bzip2 的压缩 *.tar.xz tar程序打包的文件，其中并且经过 xz 的压缩</p></blockquote><p>gzip 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gzip[-cdtv<span class="hljs-comment">#] 文件名</span></span><br>-c：将压缩的数据输出到屏幕上，可通过数据流重导向来处理；<br>-d：解压缩的参数；<br>-t：可以用来检验一个压缩文件的一致性,看看文件有无错误；<br>-v：可以显示出原文件/压缩文件的压缩比等信息；<br><span class="hljs-meta prompt_">-#</span><span class="language-bash">：<span class="hljs-comment">#为数字的意思，代表压缩等级，-1最快，但是压缩比最差、-9最慢，但是压缩比最好！默认是-6</span></span><br></code></pre></td></tr></table></figure><h3 id="打包命令tar">8.2 打包命令：tar</h3><p>最简单的使用 tar 就只要记忆下面的方式即可：</p><ul><li>压　缩：tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称</li><li>查　询：tar -jtv -f filename.tar.bz2</li><li>解压缩：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录</li></ul><h2 id="vim-程序编辑器">9. vim 程序编辑器</h2><h3 id="vi-的使用">9.1 vi 的使用</h3><p>三种模式：</p><ul><li>一般命令模式</li><li>编辑模式</li><li>命令行模式</li></ul><p><imgsrc="https://linux.vbird.org/linux_basic/centos7/0310vi//centos7_vi-mode.gif" /></p><h3 id="vim-的额外功能">9.2 vim 的额外功能</h3><ul><li>可视区块：以列为单位编辑</li><li>多文件编辑</li><li>多窗口功能</li></ul><h2 id="认识与学习-bash">10. 认识与学习 BASH</h2><h3 id="认识-bash-这个-shell">10.1 认识 BASH 这个 SHELL</h3><p><imgsrc="https://linux.vbird.org/linux_basic/centos7/0320bash//0320bash_1.jpg" /></p><p>快捷键：</p><table><thead><tr class="header"><th style="text-align: center;">组合键</th><th style="text-align: center;">功能与示范</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">[ctrl]+u/[ctrl]+k</td><td style="text-align: center;">分别是从游标处向前删除指令串([ctrl]+u)及向后删除指令串([ctrl]+k)。</td></tr><tr class="even"><td style="text-align: center;">[ctrl]+a/[ctrl]+e</td><tdstyle="text-align: center;">分别是让游标移动到整个指令串的最前面([ctrl]+a)或最后面([ctrl]+e)。</td></tr></tbody></table><h3 id="shell-的变量功能">10.2 Shell 的变量功能</h3><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span><span class="hljs-comment"># PATH 即为变量，使用时签名需加上 $</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者：</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;PATH&#125;</span><span class="hljs-comment"># recommend</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;MAIL&#125;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;HOME&#125;</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置变量值</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">var_name=value</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">取消设置变量</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">unset</span> var_name</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">export</span> var_name<span class="hljs-comment"># 以export来使变量变成环境变量</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">read</span> [-pt] var_name<span class="hljs-comment"># 读取键盘输入的变量值</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">declare</span> [-aixr] var_name</span><br>选项与参数：<br>-a ：将后面名为variable 的变数定义成为阵列(array) 类型<br>-i ：将后面名为variable 的变数定义成为整数数字(integer) 类型<br>-x ：用法与export 一样，就是将后面的variable 变成环境变数；<br>-r ：将变数设定成为readonly 类型，该变数不可被更改内容，也不能unset<br></code></pre></td></tr></table></figure><h3 id="命令别名与历史">10.3 命令别名与历史</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">alias</span> lm=<span class="hljs-string">&#x27;ls -al | more&#x27;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">unalias</span> lm</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">history</span> [n]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">history</span> [-c]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">history</span> [-raw] histfiles</span><br>选项与参数：<br>n  ：数字，意思是『要列出最近的 n 条命令列表』的意思！<br>-c ：将目前的shell 中的所有history 内容全部消除<br>-a ：将目前新增的history 指令新增入histfiles 中，若没有加histfiles ，<br>      则预设写入~/.bash_history<br>-r ：将histfiles 的内容读到目前这个shell 的history 记忆中；<br>-w ：将目前的history 记忆内容写入histfiles 中<br></code></pre></td></tr></table></figure><h3 id="bash-shell-的操作环境">10.4 Bash shell 的操作环境</h3><p>命令查找顺序：</p><ol type="1"><li>以相对/绝对路径执行指令，例如『 /bin/ls 』或『 ./ls 』；</li><li>由alias 找到该指令来执行；</li><li>由bash 内建的(builtin) 指令来执行；</li><li>透过$PATH 这个变量的顺序搜寻到的第一个指令来执行。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">source</span> ~/.bashrc<span class="hljs-comment"># 读入环境配置文件</span></span><br></code></pre></td></tr></table></figure><h3 id="数据流重定向">10.5 数据流重定向</h3><ol type="1"><li>标准输入(stdin) ：代码为0 ，使用&lt; 或&lt;&lt; ；</li><li>标准输出(stdout)：代码为1 ，使用&gt; 或&gt;&gt; ；</li><li>标准错误输出(stderr)：代码为2 ，使用2&gt; 或2&gt;&gt; ；</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">find /home -name .bashrc 2&gt; /dev/null<span class="hljs-comment"># dev/null 垃圾桶黑洞装置与特殊写法</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">command1; command2; command3<span class="hljs-comment"># ; 依次连续执行多条命令</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">cmd1 &amp;&amp; cmd2</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">cmd1 || cmd2</span><br></code></pre></td></tr></table></figure><table><thead><tr class="header"><th style="text-align: left;">指令下达情况</th><th style="text-align: left;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">cmd1 &amp;&amp; cmd2</td><td style="text-align: left;">1. 若cmd1执行完毕且正确执行($?=0)，则开始执行cmd2。 2. 若cmd1执行完毕且为错误($?≠0)，则cmd2 不执行。</td></tr><tr class="even"><td style="text-align: left;">cmd1 || cmd2</td><td style="text-align: left;">1. 若cmd1 执行完毕且正确执行($?=0)，则cmd2不执行。 2. 若cmd1 执行完毕且为错误($?≠0)，则开始执行cmd2。</td></tr></tbody></table><h3 id="管道命令">10.6 管道命令</h3><ul><li>管道命令仅会处理standard output，对于standard error output会予以忽略</li><li>管道命令必须要能够接受来自前一个指令的资料成为standard input继续处理才行。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">split</span> [-bl] file PREFIX</span><br>选项与参数：<br>-b ：后面可接欲分割成的档案大小，可加单位，例如b, k, m 等；<br>-l ：以行数来进行分割。<br>PREFIX ：代表前置字元的意思，可作为分割档案的前导文字。<br></code></pre></td></tr></table></figure><h2 id="正则表达式与文件格式化处理">11. 正则表达式与文件格式化处理</h2><h3 id="基础正则表达式">11.1 基础正则表达式</h3><table><thead><tr class="header"><th>特殊符号</th><th>代表意义</th></tr></thead><tbody><tr class="odd"><td>[:alnum:]</td><td>代表英文大小写字元及数字，亦即0-9, A-Z, a-z</td></tr><tr class="even"><td>[:alpha:]</td><td>代表任何英文大小写字元，亦即A-Z, a-z</td></tr><tr class="odd"><td>[:blank:]</td><td>代表空白键与[Tab] 按键两者</td></tr><tr class="even"><td>[:cntrl:]</td><td>代表键盘上面的控制按键，亦即包括CR, LF, Tab, Del 等等</td></tr><tr class="odd"><td>[:digit:]</td><td>代表数字而已，亦即0-9</td></tr><tr class="even"><td>[:graph:]</td><td>除了空白字元(空白键与[Tab] 按键) 外的其他所有按键</td></tr><tr class="odd"><td>[:lower:]</td><td>代表小写字元，亦即a-z</td></tr><tr class="even"><td>[:print:]</td><td>代表任何可以被列印出来的字元</td></tr><tr class="odd"><td>[:punct:]</td><td>代表标点符号(punctuation symbol)，亦即：" ' ? ! ; : # $</td></tr><tr class="even"><td>[:upper:]</td><td>代表大写字元，亦即A-Z</td></tr><tr class="odd"><td>[:space:]</td><td>任何会产生空白的字元，包括空白键, [Tab], CR 等等</td></tr><tr class="even"><td>[:xdigit:]</td><td>代表16 进位的数字类型，因此包括： 0-9, A-F, a-f 的数字与字元</td></tr></tbody></table><ul><li>查找特定字符串</li><li>利用中括号 <code>[]</code> 来查找集合字符</li><li>行首和行尾字符 <code>^$</code></li><li>任意一个字符 <code>.</code> 与重复字符 <code>*</code></li><li>限定连续 RE 字符范围 <code>&#123;&#125;</code>（需使用转义字符<code>\</code>）</li></ul><p>基础的正规表示法特殊字符汇整如下：</p><table><thead><tr class="header"><th>E 字符</th><th>意义与范例</th></tr></thead><tbody><tr class="odd"><td>^word</td><td>意义：待搜寻的字串(word)在行首！ <br/>范例：搜寻行首为#开始的那一行，并列出行号<br/>grep -n '^#' regular_express.txt</td></tr><tr class="even"><td>word$</td><td>意义：待搜寻的字串(word)在行尾！ <br/>范例：将行尾为!的那一行列印出来，并列出行号<br/>grep -n '!$' regular_express.txt</td></tr><tr class="odd"><td>.</td><td>意义：代表『一定有一个任意字元』的字符！<br/>范例：搜寻的字串可以是(eve) (eae) (eee) (ee)， 但不能仅有(ee)！亦即e 与e 中间『一定』仅有一个字元，而空白字元也是字元！<br/>grep -n'ee' regular_express.txt</td></tr><tr class="even"><td>\</td><td>意义：透过shell 的跳脱字符，将特殊符号的特殊意义去除！<br/>范例：搜寻含有单引号' 的那一行！<br/>grep -n 'regular_express.txt</td></tr><tr class="odd"><td>*</td><td>意义：重复零个到无穷多个的前一个RE 字符 <br/>范例：找出含有(es)(ess) (esss) 等等的字串，注意，因为* 可以是0 个，所以es也是符合带搜寻字串。另外，因为* 为重复『前一个RE 字符』的符号，因此，在* 之前必须要紧接着一个RE 字符喔！例如任意字元则为『.*』！<br/>grep -n 'ess*' regular_express.txt</td></tr><tr class="even"><td>[list]</td><td>意义：字元集合的RE 字符，里面列出想要撷取的字元！<br/>范例：搜寻含有(gl) 或(gd) 的那一行，需要特别留意的是，在[]当中『谨代表一个待搜寻的字元』， 例如『 a[afl]y』代表搜寻的字串可以是aay, afy, aly 即[afl] 代表a 或f 或l的意思！<br/>grep -n 'g[ld]' regular_express.txt</td></tr><tr class="odd"><td>[n1-n2]</td><td>意义：字元集合的RE 字符，里面列出想要撷取的字元范围！<br/>范例：搜寻含有任意数字的那一行！需特别留意，在字元集合[] 中的减号-是有特殊意义的，他代表两个字元之间的所有连续字元！但这个连续与否与ASCII编码有关，因此，你的编码需要设定正确(在 bash 当中，需要确定LANG与LANGUAGE 的变数是否正确！) 例如所有大写字元则为[AZ]<br/>grep -n '[AZ]'regular_express.txt</td></tr><tr class="even"><td>[^list]</td><td>意义：字元集合的RE 字符，里面列出不要的字串或范围！<br/>范例：搜寻的字串可以是(oog) (ood) 但不能是(oot) ，那个^ 在[]内时，代表的意义是『反向选择』的意思。例如，我不要大写字元，则为[^AZ]。但是，需要特别注意的是，如果以grep-n [^AZ] regular_express.txt来搜寻，却发现该档案内的所有行都被列出，为什么？因为这个[^AZ]是『非大写字元』的意思， 因为每一行均有非大写字元，例如第一行的"OpenSource" 就有p,e,n,o.... 等等的小写字<br/>grep -n 'oo[^t]'regular_express.txt</td></tr><tr class="odd"><td>{n,m}</td><td>意义：连续n 到m 个的『前一个RE 字符』 <br/>意义：若为{n} 则是连续n个的前一个RE 字符， <br/>意义：若是{n,} 则是连续n 个以上的前一个RE字符！ <br/>范例：在g 与g 之间有2 个到3 个的o存在的字串，亦即(goog)(gooog)<br/>grep -n 'go\{2,3\}g'regular_express.txt</td></tr></tbody></table><h3 id="扩展正则表达式">11.2 扩展正则表达式</h3><table><thead><tr class="header"><th>RE 字符</th><th>意义与范例</th></tr></thead><tbody><tr class="odd"><td>+</td><td>意义：重复『一个或一个以上』的前一个RE 字符 <br/>范例：搜寻(god)(good) (goood)... 等等的字串。那个o+ 代表『一个以上的o』所以，底下的执行成果会将第1, 9, 13 行列出来。<br/>egrep -n 'go+d'regular_express.txt</td></tr><tr class="even"><td>?</td><td>意义：『零个或一个』的前一个RE 字符 <br/>范例：搜寻(gd) (god)这两个字串。那个o? 代表『空的或1 个o 』所以，上面的执行成果会将第13, 14行列出来。有没有发现到，这两个案例( 'go+d' 与'go?d' )的结果集合与'go*d'相同？想想看，这是为什么喔！<br/>egrep -n 'go?d'regular_express.txt</td></tr><tr class="odd"><td>|</td><td>意义：用或( or )的方式找出数个字串 <br/>范例：搜寻gd 或good这两个字串，注意，是『或』！所以，第1,9,14这三行都可以被列印出来喔！那如果还想要找出dog 呢？<br/>egrep -n'gd|good' regular_express.txt egrep -n 'gd|good|dog'regular_express.txt</td></tr><tr class="even"><td>()</td><td>意义：找出『群组』字串 范<br/>例：搜寻(glad) 或(good)这两个字串，因为g 与d 是重复的，所以， 我就可以将la 与oo 列于( )当中，并以| 来分隔开来，就可以啦！<br/>egrep -n 'g(la|oo)d'regular_express.txt</td></tr><tr class="odd"><td>()+</td><td>意义：多个重复群组的判别 <br/>范例：将『AxyzxyzxyzxyzC』用echo叫出，然后再使用如下的方法搜寻一下！<br/>echo 'AxyzxyzxyzxyzC' | egrep'A(xyz)+C'<br/>上面的例子意思是说，我要找开头是A 结尾是C，中间有一个以上的"xyz" 字串的意思</td></tr></tbody></table><h2 id="学习-shell-脚本">12. 学习 shell 脚本</h2><h3 id="什么是-shell-脚本">12.1 什么是 shell 脚本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">This program shows <span class="hljs-string">&quot;Hello World!&quot;</span> <span class="hljs-keyword">in</span> your screen.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/16 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br>echo -e &quot;Hello World! \a \n&quot;<br>exit 0<br></code></pre></td></tr></table></figure><p>良好的script 撰写习惯，在每个script 的档头处记录好：</p><ul><li>script 的功能；</li><li>script 的版本资讯；</li><li>script 的作者与联络方式；</li><li>script 的版权宣告方式；</li><li>script 的History (历史纪录)；</li><li>script 内较特殊的指令，使用『绝对路径』的方式来下达；</li><li>script 运作时需要的环境变量预先声明与设置。</li></ul><h3 id="简单的-shell-脚本练习">12.2 简单的 shell 脚本练习</h3><p>处理用户输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">User inputs his first name and last name. Program shows his full name.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/16 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>read -p &quot;Please input your first name: &quot; firstname       # 提示使用者输入<br>read -p &quot;Please input your last name: &quot; lastname        # 提示使用者输入<br>echo -e &quot;\nYour full name is: $&#123;firstname&#125; $&#123;lastname&#125;&quot; # 结果由屏幕输出<br></code></pre></td></tr></table></figure><p>随日期变化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program creates three files, <span class="hljs-built_in">which</span> named by user<span class="hljs-string">&#x27;s input and date command.</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">History:</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">2015/07/16 VBird First release</span></span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">1. 让使用者输入档案名称，并取得fileuser 这个变数；</span></span> <br>echo -e &quot;I will use &#x27;touch&#x27; command to create 3 files.&quot; # 纯粹显示资讯<br>read -p &quot;Please input your filename: &quot; fileuser          # 提示使用者输入<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">2. 为了避免使用者随意按Enter ，利用变数功能分析档名是否有设定？</span></span><br>filename=$&#123;fileuser:-&quot;filename&quot;&#125;            # 开始判断有否设定档名<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">3. 开始利用date 指令来取得所需要的档名了；</span></span> <br>date1=$(date --date=&#x27;2 days ago&#x27; +%Y%m%d)   # 前两天的日期<br>date2=$(date --date=&#x27;1 days ago&#x27; +%Y%m%d)   # 前一天的日期<br>date3=$(date +%Y%m%d)                       # 今天的日期<br>file1=$&#123;filename&#125;$&#123;date1&#125;                   # 底下三行在设定档名<br>file2=$&#123;filename&#125;$&#123;date2&#125;<br>file3=$&#123;filename&#125;$&#123;date3&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">4. 将档名建立吧！</span></span><br>touch &quot;$&#123;file1&#125;&quot;                            # 底下三行在建立档案<br>touch &quot;$&#123;file2&#125;&quot;<br>touch &quot;$&#123;file3&#125;&quot;<br></code></pre></td></tr></table></figure><p>数值运算：简单的加减乘除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">User inputs 2 <span class="hljs-built_in">integer</span> numbers; program will cross these two numbers.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/16 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br>echo -e &quot;You SHOULD input 2 numbers, I will multiplying them! \n&quot;<br>read -p &quot;first number: &quot; firstnu<br>read -p &quot;second number: &quot; secnu<br>total=$(($&#123;firstnu&#125;*$&#123;secnu&#125;))<br>echo -e &quot;\nThe result of $&#123;firstnu&#125; x $&#123;secnu&#125; is ==&gt; $&#123;total&#125;&quot;<br></code></pre></td></tr></table></figure><p>计算含小数点数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;123.123*55.9&quot;</span> | bc</span><br></code></pre></td></tr></table></figure><p>计算 Pi</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">User input a scale number to calculate pi number.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/16 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br>echo -e &quot;This program will calculate pi value. \n&quot;<br>echo -e &quot;You should input a float number to calculate pi value.\n&quot;<br>read -p &quot;The scale number (10~10000) ? &quot; checking<br>num=$&#123;checking:-&quot;10&quot;&#125;            # 开始判断有否有输入数值<br>echo -e &quot;Starting calculate pi value. Be patient.&quot;<br>time echo &quot;scale=$&#123;num&#125;; 4*a(1)&quot; | bc -lq<br></code></pre></td></tr></table></figure><h3 id="善用判断式">12.3 善用判断式</h3><table><thead><tr class="header"><th>测试的标志</th><th>代表意义</th></tr></thead><tbody><tr class="odd"><td>1. 关于某个文件名的『文件类型』判断，如test -e filename表示存在否</td><td></td></tr><tr class="even"><td>-e</td><td>该『文件名』是否存在？(常用)</td></tr><tr class="odd"><td>-f</td><td>该『文件名』是否存在且为文件(file)？(常用)</td></tr><tr class="even"><td>-d</td><td>该『文件名』是否存在且为目录(directory)？(常用)</td></tr><tr class="odd"><td>-b</td><td>该『文件名』是否存在且为一个block device 设备？</td></tr><tr class="even"><td>-c</td><td>该『文件名』是否存在且为一个character device 设备？</td></tr><tr class="odd"><td>-S</td><td>该『文件名』是否存在且为一个Socket 文件？</td></tr><tr class="even"><td>-p</td><td>该『文件名』是否存在且为一个FIFO (pipe) 文件？</td></tr><tr class="odd"><td>-L</td><td>该『文件名』是否存在且为一个链接文件？</td></tr><tr class="even"><td>2. 关于档案的权限检测，如test -r filename 表示可读否(但root权限常有例外)</td><td></td></tr><tr class="odd"><td>-r</td><td>检测该文件名是否存在且具有『可读』的权限？</td></tr><tr class="even"><td>-w</td><td>检测该文件名是否存在且具有『可写』的权限？</td></tr><tr class="odd"><td>-x</td><td>检测该文件名是否存在且具有『可执行』的权限？</td></tr><tr class="even"><td>-u</td><td>检测该文件名是否存在且具有『SUID』的属性？</td></tr><tr class="odd"><td>-g</td><td>检测该文件名是否存在且具有『SGID』的属性？</td></tr><tr class="even"><td>-k</td><td>检测该文件名是否存在且具有『Sticky bit』的属性？</td></tr><tr class="odd"><td>-s</td><td>检测该文件名是否存在且为『非空白文件』？</td></tr><tr class="even"><td>3. 两个档案之间的比较，如： test file1 -nt file2</td><td></td></tr><tr class="odd"><td>-nt</td><td>(newer than)判断file1 是否比file2 新</td></tr><tr class="even"><td>-ot</td><td>(older than)判断file1 是否比file2 旧</td></tr><tr class="odd"><td>-ef</td><td>判断file1 与file2 是否为同一档案，可用在判断hard link的判定上。主要意义在判定，两个档案是否均指向同一个inode</td></tr><tr class="even"><td>4. 关于两个整数之间的判定，例如test n1 -eq n2</td><td></td></tr><tr class="odd"><td>-eq</td><td>两数值相等(equal)</td></tr><tr class="even"><td>-ne</td><td>两数值不等(not equal)</td></tr><tr class="odd"><td>-gt</td><td>n1 大于n2 (greater than)</td></tr><tr class="even"><td>-lt</td><td>n1 小于n2 (less than)</td></tr><tr class="odd"><td>-ge</td><td>n1 大于等于n2 (greater than or equal)</td></tr><tr class="even"><td>-le</td><td>n1 小于等于n2 (less than or equal)</td></tr><tr class="odd"><td>5. 判定字符串的数据</td><td></td></tr><tr class="even"><td>test -z string</td><td>判定字串是否为0 ？若string 为空字串，则为true</td></tr><tr class="odd"><td>test -n string</td><td>判定字串是否非为0 ？若string 为空字串，则为false。 注： -n亦可省略</td></tr><tr class="even"><td>test str1 == str2</td><td>判定str1 是否等于str2 ，若相等，则回传true</td></tr><tr class="odd"><td>test str1 != str2</td><td>判定str1 是否不等于str2 ，若相等，则回传false</td></tr><tr class="even"><td>6. 多重条件判定，例如： test -r filename -a -x filename</td><td></td></tr><tr class="odd"><td>-a</td><td>(and)两状况同时成立！例如test -r file -a -x file，则file 同时具有r与 x 权限时，才回传true。</td></tr><tr class="even"><td>-o</td><td>(or)两状况任何一个成立！例如test -r file -o -x file，则file 具有r 或x 权限时，就可回传true。</td></tr><tr class="odd"><td>!</td><td>反相状态，如test ! -x file ，当file 不具有x 时，回传true</td></tr></tbody></table><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">User input a filename, program will check the flowing:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1.) exist? 2.) file/directory? 3.) file permissions</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/16 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 让使用者输入档名，并且判断使用者是否真的有输入字串？</span><br>echo -e &quot;Please input a filename, I will check the filename&#x27;s type and permission. \n\n&quot;<br>read -p &quot;Input a filename : &quot; filename<br>test -z $&#123;filename&#125; &amp;&amp; echo &quot;You MUST input a filename.&quot; &amp;&amp; exit 0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 判断档案是否存在？若不存在则显示讯息并结束脚本</span><br>test ! -e $&#123;filename&#125; &amp;&amp; echo &quot;The filename &#x27;$&#123;filename&#125;&#x27; DO NOT exist&quot; &amp;&amp; exit 0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">3. 开始判断档案类型与属性</span><br>test -f $&#123;filename&#125; &amp;&amp; filetype=&quot;regulare file&quot;<br>test -d $&#123;filename&#125; &amp;&amp; filetype=&quot;directory&quot;<br>test -r $&#123;filename&#125; &amp;&amp; perm=&quot;readable&quot;<br>test -w $&#123;filename&#125; &amp;&amp; perm=&quot;$&#123;perm&#125; writable&quot;<br>test -x $&#123;filename&#125; &amp;&amp; perm=&quot;$&#123;perm&#125; executable&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">4. 开始输出资讯！</span><br>echo &quot;The filename: $&#123;filename&#125; is a $&#123;filetype&#125;&quot;<br>echo &quot;And the permissions for you are : $&#123;perm&#125;&quot;<br></code></pre></td></tr></table></figure><p>使用中括号 <code>[]</code> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">This program shows the user<span class="hljs-string">&#x27;s choice</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">History:</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">2015/07/16 VBird First release</span></span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>read -p &quot;Please input (Y/N): &quot; yn<br>[ &quot;$&#123;yn&#125;&quot; == &quot;Y&quot; -o &quot;$&#123;yn&#125;&quot; == &quot;y&quot; ] &amp;&amp; echo &quot;OK, continue&quot; &amp;&amp; exit 0<br>[ &quot;$&#123;yn&#125;&quot; == &quot;N&quot; -o &quot;$&#123;yn&#125;&quot; == &quot;n&quot; ] &amp;&amp; echo &quot;Oh, interrupt!&quot; &amp;&amp; exit 0<br>echo &quot;I don&#x27;t know what your choice is&quot; &amp;&amp; exit 0<br></code></pre></td></tr></table></figure><p>shell 脚本的默认变量（<code>$0</code> <code>$1</code> ...）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program shows the script name, parameters...</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/16 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>echo &quot;The script name is ==&gt; $&#123;0&#125;&quot;<br>echo &quot;Total parameter number is ==&gt; $#&quot;<br>[ &quot;$#&quot; -lt 2 ] &amp;&amp; echo &quot;The number of parameter is less than 2. Stop here.&quot; &amp;&amp; exit 0<br>echo &quot;Your whole parameter is ==&gt; &#x27;$@&#x27;&quot;<br>echo &quot;The 1st parameter ==&gt; $&#123;1&#125;&quot;<br>echo &quot;The 2nd parameter ==&gt; $&#123;2&#125;&quot;<br></code></pre></td></tr></table></figure><h3 id="条件判断式">12.4 条件判断式</h3><h4 id="if...then">12.4.1 if...then</h4><p>单层、简单条件判断式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">if [条件判断式]; then<br>当条件判断式成立时，可以进行的指令工作内容；<br>fi<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">This program shows the user<span class="hljs-string">&#x27;s choice</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">History:</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">2015/07/16 VBird First release</span></span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>read -p &quot;Please input (Y/N): &quot; yn<br><br>if [ &quot;$&#123;yn&#125;&quot; == &quot;Y&quot; ] || [ &quot;$&#123;yn&#125;&quot; == &quot;y&quot; ]; then<br>echo &quot;OK, continue&quot;<br>exit 0<br>fi<br>if [ &quot;$&#123;yn&#125;&quot; == &quot;N&quot; ] || [ &quot;$&#123;yn&#125;&quot; == &quot;n&quot; ]; then<br>echo &quot;Oh, interrupt!&quot;<br>exit 0<br>fi<br>echo &quot;I don&#x27;t know what your choice is&quot; &amp;&amp; exit 0<br></code></pre></td></tr></table></figure><p>多重、复杂条件判断式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">一个条件判断，分成功进行与失败进行(<span class="hljs-keyword">else</span>)</span> <br>if [条件判断式]; then<br>当条件判断式成立时，可以进行的指令工作内容；<br>else<br>当条件判断式不成立时，可以进行的指令工作内容；<br>fi<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">多个条件判断(<span class="hljs-keyword">if</span> ... <span class="hljs-keyword">elif</span> ... <span class="hljs-keyword">elif</span> ... <span class="hljs-keyword">else</span>) 分多种不同情况执行</span><br>if [条件判断式一]; then<br>当条件判断式一成立时，可以进行的指令工作内容；<br>elif [条件判断式二]; then<br>当条件判断式二成立时，可以进行的指令工作内容；<br>else<br>当条件判断式一与二均不成立时，可以进行的指令工作内容；<br>fi<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">This program shows the user<span class="hljs-string">&#x27;s choice</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">History:</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">2015/07/16 VBird First release</span></span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>read -p &quot;Please input (Y/N): &quot; yn<br><br>if [ &quot;$&#123;yn&#125;&quot; == &quot;Y&quot; ] || [ &quot;$&#123;yn&#125;&quot; == &quot;y&quot; ]; then<br>echo &quot;OK, continue&quot;<br>elif [ &quot;$&#123;yn&#125;&quot; == &quot;N&quot; ] || [ &quot;$&#123;yn&#125;&quot; == &quot;n&quot; ]; then<br>echo &quot;Oh, interrupt!&quot;<br>else<br>echo &quot;I don&#x27;t know what your choice is&quot;<br>fi<br></code></pre></td></tr></table></figure><p>从命令行获取用户输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Check <span class="hljs-variable">$1</span> is equal to <span class="hljs-string">&quot;hello&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/16 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>if [ &quot;$&#123;1&#125;&quot; == &quot;hello&quot; ]; then<br>echo &quot;Hello, how are you ?&quot;<br>elif [ &quot;$&#123;1&#125;&quot; == &quot;&quot; ]; then<br>echo &quot;You MUST input parameters, ex&gt; &#123;$&#123;0&#125; someword&#125;&quot;<br>else<br>echo &quot;The only parameter is &#x27;hello&#x27;, ex&gt; &#123;$&#123;0&#125; hello&#125;&quot;<br>fi<br></code></pre></td></tr></table></figure><p>检测服务端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Using netstat and grep to detect WWW,SSH,FTP and Mail services.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/16 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 先作一些告知的动作而已～</span><br>echo &quot;Now, I will detect your Linux server&#x27;s services!&quot;<br>echo -e &quot;The www, ftp, ssh, and mail(smtp) will be detected! \n&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 开始进行一些测试的工作，并且也输出一些资讯啰！</span><br>testfile=/dev/shm/netstat_checking.txt<br>netstat -tuln &gt; $&#123;testfile&#125;           # 先转存资料到记忆体当中！不用一直执行netstat <br>testing=$(grep &quot;:80 &quot; $&#123;testfile&#125;)    # 侦测看port 80 在否？<br>if [ &quot;$&#123;testing&#125;&quot; != &quot;&quot; ]; then<br>echo &quot;WWW is running in your system.&quot;<br>fi<br>testing=$(grep &quot;:22 &quot; $&#123;testfile&#125;)    # 侦测看port 22 在否？<br>if [ &quot;$&#123;testing&#125;&quot; != &quot;&quot; ]; then<br>echo &quot;SSH is running in your system.&quot;<br>fi<br>testing=$(grep &quot;:21 &quot; $&#123;testfile&#125;)    # 侦测看port 21 在否？<br>if [ &quot;$&#123;testing&#125;&quot; != &quot;&quot; ]; then<br>echo &quot;FTP is running in your system.&quot;<br>fi<br>testing=$(grep &quot;:25 &quot; $&#123;testfile&#125;)    # 侦测看port 25 在否？<br>if [ &quot;$&#123;testing&#125;&quot; != &quot;&quot; ]; then<br>echo &quot;Mail is running in your system.&quot;<br>fi<br></code></pre></td></tr></table></figure><p>计算距离指定日期剩余天数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">You input your demobilization <span class="hljs-built_in">date</span>, I calculate how many days before you demobilize.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/16 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 告知使用者这支程式的用途，并且告知应该如何输入日期格式？</span><br>echo &quot;This program will try to calculate :&quot;<br>echo &quot;How many days before your demobilization date...&quot;<br>read -p &quot;Please input your demobilization date (YYYYMMDD ex&gt;20150716): &quot; date2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 测试一下，这个输入的内容是否正确？利用正规表示法啰～</span> <br>date_d=$(echo $&#123;date2&#125; |grep &#x27;[0-9]\&#123;8\&#125;&#x27;)    # 看看是否有八个数字<br>if [ &quot;$&#123;date_d&#125;&quot; == &quot;&quot; ]; then<br>echo &quot;You input the wrong date format....&quot;<br>exit 1<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3. 开始计算日期啰～</span> <br>declare -i date_dem=$(date --date=&quot;$&#123;date2&#125;&quot; +%s)       # 退伍日期秒数<br>declare -i date_now=$(date +%s)                         # 现在日期秒数<br>declare -i date_total_s=$(($&#123;date_dem&#125;-$&#123;date_now&#125;))    # 剩余秒数统计<br>declare -i date_d=$(($&#123;date_total_s&#125;/60/60/24))         # 转为日数<br>if [ &quot;$&#123;date_total_s&#125;&quot; -lt &quot;0&quot; ]; then                  # 判断是否已退伍<br>echo &quot;You had been demobilization before: &quot; $((-1*$&#123;date_d&#125;)) &quot; ago&quot;<br>else<br>declare -i date_h=$(($(($&#123;date_total_s&#125;-$&#123;date_d&#125;*60*60*24))/60/60))<br>echo &quot;You will demobilize after $&#123;date_d&#125; days and $&#123;date_h&#125; hours.&quot;<br>fi<br></code></pre></td></tr></table></figure><h4 id="case...esac">12.4.2 case...esac</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">case $变数名称 in    &lt;==关键字为case ，还有变数前有钱字号<br>  &quot;第一个变数内容&quot; )    &lt;==每个变数内容建议用双引号括起来，关键字则为小括号)<br>程式段<br>;;             &lt;==每个类别结尾使用两个连续的分号来处理！<br>  &quot;第二个变数内容&quot; )<br>程式段<br>;; <br>  * )                   &lt;==最后一个变数内容都会用* 来代表所有其他值<br>不包含第一个变数内容与第二个变数内容的其他程式执行段<br>exit 1<br>;; <br>esac<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Show <span class="hljs-string">&quot;Hello&quot;</span> from <span class="hljs-variable">$1</span>.... by using <span class="hljs-keyword">case</span> .... <span class="hljs-keyword">esac</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/16 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>case $&#123;1&#125; in<br>  &quot;hello&quot;)<br>echo &quot;Hello, how are you ?&quot;<br>;;<br>  &quot;&quot;)<br>echo &quot;You MUST input parameters, ex&gt; &#123;$&#123;0&#125; someword&#125;&quot;<br>;;<br>  *)    # 其实就相当于万用字元，0~无穷多个任意字元之意！<br>echo &quot;Usage $&#123;0&#125; &#123;hello&#125;&quot;<br>;;<br>esac<br></code></pre></td></tr></table></figure><h4 id="function">12.4.3 function</h4><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">function fname () &#123;<br>程序段<br>&#125;<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Use <span class="hljs-keyword">function</span> to repeat information.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/17 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>function printit()&#123;<br>echo -n &quot;Your choice is &quot;      # 加上-n 可以不断行继续在同一行显示<br>&#125;<br><br>echo &quot;This program will print your selection !&quot;<br>case $&#123;1&#125; in<br>  &quot;one&quot;)<br>printit ; echo $&#123;1&#125; | tr &#x27;az&#x27; &#x27;AZ&#x27;   # 将参数做大小写转换！<br>;;<br>  &quot;two&quot;)<br>printit ; echo $&#123;1&#125; | tr &#x27;az&#x27; &#x27;AZ&#x27;<br>;;<br>  &quot;three&quot;)<br>printit ; echo $&#123;1&#125; | tr &#x27;az&#x27; &#x27;AZ&#x27;<br>;;<br>  *)<br>echo &quot;Usage $&#123;0&#125; &#123;one|two|three&#125;&quot;<br>;;<br>esac<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Use <span class="hljs-keyword">function</span> to repeat information.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/17 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>function printit()&#123;<br>echo &quot;Your choice is $&#123;1&#125;&quot;    # 这个$1 必须要参考底下指令的下达<br>&#125;<br><br>echo &quot;This program will print your selection !&quot;<br>case $&#123;1&#125; in<br>  &quot;one&quot;)<br>printit 1   # 请注意， printit 指令后面还有接参数！<br>;;<br>  &quot;two&quot;)<br>printit 2<br>;;<br>  &quot;three&quot;)<br>printit 3<br>;;<br>  *)<br>echo &quot;Usage $&#123;0&#125; &#123;one|two|three&#125;&quot;<br>;;<br>esac<br></code></pre></td></tr></table></figure><h3 id="循环">12.5 循环</h3><h4 id="while-do-doneuntil-do-done不定循环">12.5.1 while do done、untildo done（不定循环）</h4><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">while [ condition ]   &lt;==中括号内的状态就是判断式<br>do             &lt;==do 是循环的开始！<br>程式段落<br>done<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">until [ condition ]<br>do<br>程式段落<br>done<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Repeat question until user input correct answer.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/17 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>while [ &quot;$&#123;yn&#125;&quot; != &quot;yes&quot; -a &quot;$&#123;yn&#125;&quot; != &quot;YES&quot; ]<br>do<br>read -p &quot;Please input yes/YES to stop this program: &quot; yn<br>done<br>echo &quot;OK! you input the correct answer.&quot;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Repeat question until user input correct answer.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/17 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>until [ &quot;$&#123;yn&#125;&quot; == &quot;yes&quot; -o &quot;$&#123;yn&#125;&quot; == &quot;YES&quot; ]<br>do<br>read -p &quot;Please input yes/YES to stop this program: &quot; yn<br>done<br>echo &quot;OK! you input the correct answer.&quot;<br></code></pre></td></tr></table></figure><p>示例：(计算1+2+3+....+100)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Use loop to calculate <span class="hljs-string">&quot;1+2+3+...+100&quot;</span> result.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/17 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>s=0   # 这是加总的数值变数<br>i=0   # 这是累计的数值，亦即是1, 2, 3....<br>while [ &quot;$&#123;i&#125;&quot; != &quot;100&quot; ]<br>do<br>i=$(($i+1))    # 每次i 都会增加1 <br>s=$(($s+$i))   # 每次都会求和一次<br>done<br>echo &quot;The result of &#x27;1+2+3+...+100&#x27; is ==&gt; $s&quot;<br></code></pre></td></tr></table></figure><h4 id="for...do...done固定循环">12.5.2 for...do...done（固定循环）</h4><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for var in con1 con2 con3 ...<br>do<br>程式段<br>done<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Using <span class="hljs-keyword">for</span> .... loop to <span class="hljs-built_in">print</span> 3 animals</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/17 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>for animal in dog cat elephant<br>do<br>echo &quot;There are $&#123;animal&#125;s.... &quot;<br>done<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Use ping <span class="hljs-built_in">command</span> to check the network<span class="hljs-string">&#x27;s PC state.</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">History</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">2015/07/17 VBird first release</span></span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br>network=&quot;192.168.1&quot;               # 先定义一个网域的前面部分！<br>for sitenu in $(seq 1 100)        # seq 为sequence(连续) 的缩写之意<br>do<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">底下的程式在取得ping 的回传值是正确的还是失败的！</span></span><br>        ping -c 1 -w 1 $&#123;network&#125;.$&#123;sitenu&#125; &amp;&gt; /dev/null &amp;&amp; result=0 || result=1<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">开始显示结果是正确的启动(UP) 还是错误的没有连通(DOWN)</span></span><br>        if [ &quot;$&#123;result&#125;&quot; == 0 ]; then<br>                echo &quot;Server $&#123;network&#125;.$&#123;sitenu&#125; is UP.&quot;<br>        else<br>                echo &quot;Server $&#123;network&#125;.$&#123;sitenu&#125; is DOWN.&quot;<br>        fi<br>done<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">User input <span class="hljs-built_in">dir</span> name, I find the permission of files.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/17 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 先看看这个目录是否存在啊？</span><br>read -p &quot;Please input a directory: &quot; dir<br>if [ &quot;$&#123;dir&#125;&quot; == &quot;&quot; -o ! -d &quot;$&#123;dir&#125;&quot; ]; then<br>echo &quot;The $&#123;dir&#125; is NOT exist in your system.&quot;<br>exit 1<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 开始测试档案啰～</span> <br>filelist=$(ls $&#123;dir&#125;)         # 列出所有在该目录下的档案名称<br>for filename in $&#123;filelist&#125;<br>do<br>perm=&quot;&quot;<br>test -r &quot;$&#123;dir&#125;/$&#123;filename&#125;&quot; &amp;&amp; perm=&quot;$&#123;perm&#125; readable&quot;<br>test -w &quot;$&#123;dir&#125;/$&#123;filename&#125;&quot; &amp;&amp; perm=&quot;$&#123;perm&#125; writable&quot;<br>test -x &quot;$&#123;dir&#125;/$&#123;filename&#125;&quot; &amp;&amp; perm=&quot;$&#123;perm&#125; executable&quot;<br>echo &quot;The file $&#123;dir&#125;/$&#123;filename&#125;&#x27;s permission is $&#123;perm&#125; &quot;<br>done<br></code></pre></td></tr></table></figure><h4 id="for...do...done-的数值处理">12.5.3 for...do...done的数值处理</h4><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for ((初始值;限制值;赋值运算))<br>do<br>程式段<br>done<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Try <span class="hljs-keyword">do</span> calculate 1+2+....+<span class="hljs-variable">$&#123;your_input&#125;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/17 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>read -p &quot;Please input a number, I will count for 1+2+...+your_input: &quot; nu<br><br>s=0<br>for (( i=1; i&lt;=$&#123;nu&#125;; i=i+1 ))<br>do<br>s=$(($&#123;s&#125;+$&#123;i&#125;))<br>done<br>echo &quot;The result of &#x27;1+2+3+...+$&#123;nu&#125;&#x27; is ==&gt; $&#123;s&#125;&quot;<br></code></pre></td></tr></table></figure><h4 id="搭配随机数和数组的实验">12.5.4 搭配随机数和数组的实验</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Try <span class="hljs-keyword">do</span> tell you what you may eat.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/17 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>eat[1]=&quot;卖当当汉堡&quot;        # 写下你所收集到的店家！<br>eat[2]=&quot;肯爷爷炸鸡&quot;<br>eat[3]=&quot;彩虹日式便当&quot;<br>eat[4]=&quot;越油越好吃大雅&quot;<br>eat[5]=&quot;想不出吃啥学餐&quot;<br>eat[6]=&quot;太师父便当&quot;<br>eat[7]=&quot;池上便当&quot;<br>eat[8]=&quot;怀念火车便当&quot;<br>eat[9]=&quot;一起吃泡面&quot;<br>eatnum=9                   # 需要输入有几个可用的餐厅数！<br><br>check=$(( $&#123;RANDOM&#125; * $&#123;eatnum&#125; / 32767 + 1 ))<br>echo &quot;your may eat $&#123;eat[$&#123;check&#125;]&#125;&quot;<br></code></pre></td></tr></table></figure><h3 id="shell-脚本的跟踪与调试">12.6 shell 脚本的跟踪与调试</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sh [-nvx] scripts.sh</span><br>选项与参数：<br>-n ：不要执行script，仅查询语法的问题；<br>-v ：再执行script 前，先将scripts 的内容输出到萤幕上；<br>-x ：将使用到的script 内容显示到萤幕上，这是很有用的参数！<br><br>范例一：测试dir_perm.sh 有无语法的问题？<br>[dmtsai@study ~]$ sh -n dir_perm.sh <br><span class="hljs-meta prompt_"># </span><span class="language-bash">若语法没有问题，则不会显示任何资讯！</span><br><br>范例二：将show_animal.sh 的执行过程全部列出来～ <br>[dmtsai@study ~]$ sh -x show_animal.sh <br>+ PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:/root/bin<br>+ export PATH<br>+ for animal in dog cat elephant<br>+ echo &#x27;There are dogs.... &#x27;<br>There are dogs....<br>+ for animal in dog cat elephant<br>+ echo &#x27;There are cats.... &#x27;<br>There are cats....<br>+ for animal in dog cat elephant<br>+ echo &#x27;There are elephants.... &#x27;<br>There are elephants....<br></code></pre></td></tr></table></figure><h2 id="linux-账号管理与-acl-权限设置">13. Linux 账号管理与 ACL权限设置</h2><h3 id="账号管理">13.2 账号管理</h3><p>用户管理：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">useradd [-u UID] [-g 初始群组] [-G 次要群组] [-mM]\ </span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">[-c 说明栏] [-d 家目录绝对路径] [-s shell] 使用者帐号名</span><br>选项与参数：<br>-u ：后面接的是UID ，是一组数字。直接指定一个特定的UID 给这个帐号；<br>-g ：后面接的那个群组名称就是我们上面提到的initial group 啦～<br>      该群组的GID 会被放置到/etc/passwd 的第四个栏位内。<br>-G ：后面接的群组名称则是这个帐号还可以加入的群组。<br>      这个选项与参数会修改/etc/group 内的相关资料喔！<br>-M ：强制！不要建立使用者家目录！(系统帐号预设值)<br>-m ：强制！要建立使用者家目录！(一般帐号预设值)<br>-c ：这个就是/etc/passwd 的第五栏的说明内容啦～可以随便我们设定的啦～<br>-d ：指定某个目录成为家目录，而不要使用预设值。务必使用绝对路径！<br>-r ：建立一个系统的帐号，这个帐号的UID 会有限制(参考/etc/login.defs)<br>-s ：后面接一个shell ，若没有指定则预设是/bin/bash 的啦～<br>-e ：后面接一个日期，格式为『YYYY-MM-DD』此项目可写入shadow 第八栏位，<br>      亦即帐号失效日的设定项目啰；<br>-f ：后面接shadow 的第七栏位项目，指定密码是否会失效。0为立刻失效，<br>      -1 为永远不失效(密码只会过期而强制于登入时重新设定而已。)<br><br>范例一：完全参考预设值建立一个使用者，名称为vbird1 <br>[root@study ~]# useradd vbird1 <br>[root@study ~]# ll -d /home/vbird1<br>drwx------. 3 vbird1 vbird1 74 Jul 20 21:50 /home/vbird1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">预设会建立使用者家目录，且权限为700 ！这是重点！</span><br><br>[root@study ~]# grep vbird1 /etc/passwd /etc/shadow /etc/group<br>/etc/passwd:vbird1:x:1003:1004::/home/vbird1:/bin/bash<br>/etc/shadow:vbird1:!!:16636:0:99999:7:::<br>/etc/group:vbird1:x:1004:      &lt;==预设会建立一个与帐号一模一样的群组名<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">passwd [--stdin] [帐号名称]   &lt;==所有人均可使用来改自己的密码</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">passwd [-l] [-u] [--stdin] [-S] \ </span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">  [-n 日数] [-x 日数] [-w 日数] [-i 日数] 帐号 &lt;==root 功能</span><br>选项与参数：<br>--stdin ：可以透过来自前一个管线的资料，作为密码输入，对shell script 有帮助！<br>-l ：是Lock 的意思，会将/etc/shadow 第二栏最前面加上! 使密码失效；<br>-u ：与-l 相对，是Unlock 的意思！<br>-S ：列出密码相关参数，亦即shadow 档案内的大部分资讯。<br>-n ：后面接天数，shadow 的第4 栏位，多久不可修改密码天数<br>-x ：后面接天数，shadow 的第5 栏位，多久内必须要更动密码<br>-w ：后面接天数，shadow 的第6 栏位，密码过期前的警告天数<br>-i ：后面接天数，shadow 的第7 栏位，密码失效天数<br><br>范例一：请root 给予vbird2 密码<br><span class="hljs-meta prompt_"># </span><span class="language-bash">passwd vbird2</span><br>Changing password for user vbird2.<br>New UNIX password: &lt;==这里直接输入新的密码，萤幕不会有任何反应<br>BAD PASSWORD: The password is shorter than 8 characters &lt;==密码太简单或过短的错误！<br>Retype new UNIX password:   &lt;==再输入一次同样的密码<br>passwd: all authentication tokens updated successfully .   &lt;==竟然还是成功修改了！<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">usermod [-cdegGlsuLU] username</span><br>选项与参数：<br>-c ：后面接帐号的说明，即/etc/passwd 第五栏的说明栏，可以加入一些帐号的说明。<br>-d ：后面接帐号的家目录，即修改/etc/passwd 的第六栏；<br>-e ：后面接日期，格式是YYYY-MM-DD 也就是在/etc/shadow 内的第八个栏位资料啦！<br>-f ：后面接天数，为shadow 的第七栏位。<br>-g ：后面接初始群组，修改/etc/passwd 的第四个栏位，亦即是GID 的栏位！<br>-G ：后面接次要群组，修改这个使用者能够支援的群组，修改的是/etc/group 啰～<br>-a ：与-G 合用，可『增加次要群组的支援』而非『设定』喔！<br>-l ：后面接帐号名称。亦即是修改帐号名称， /etc/passwd 的第一栏！<br>-s ：后面接Shell 的实际档案，例如/bin/bash 或/bin/csh 等等。<br>-u ：后面接UID 数字啦！即/etc/passwd 第三栏的资料；<br>-L ：暂时将使用者的密码冻结，让他无法登入。其实仅改/etc/shadow 的密码栏。<br>-U ：将/etc/shadow 密码栏的! 拿掉，解冻啦！<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">userdel [-r] username</span><br>选项与参数：<br>-r ：连同使用者的家目录也一起删除<br><br>范例一：删除vbird2 ，连同家目录一起删除<br><span class="hljs-meta prompt_"># </span><span class="language-bash">userdel -r vbird2</span><br></code></pre></td></tr></table></figure><p>用户组管理：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">groupadd [-g gid] [-r] 群组名称</span><br>选项与参数：<br>-g ：后面接某个特定的GID ，用来直接给予某个GID ～<br>-r ：建立系统群组啦！与/etc/login.defs 内的GID_MIN 有关。<br><br>范例一：新建一个群组，名称为group1 <br><span class="hljs-meta prompt_"># </span><span class="language-bash">groupadd group1</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">grep group1 /etc/group /etc/gshadow</span> <br>/etc/group:group1:x: 1503 :<br>/etc/gshadow:group1:!::<br><span class="hljs-meta prompt_"># </span><span class="language-bash">群组的GID 也是会由1000 以上最大GID+1 来决定！</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">groupmod [-g gid] [-n group_name] 群组名</span><br>选项与参数：<br>-g ：修改既有的GID 数字；<br>-n ：修改既有的群组名称<br><br>范例一：将刚刚上个指令建立的group1 名称改为mygroup ， GID 为201 <br><span class="hljs-meta prompt_"># </span><span class="language-bash">groupmod -g 201 -n mygroup group1</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">grep mygroup /etc/group /etc/gshadow</span> <br>/etc/group:mygroup:x: 201 :<br>/etc/gshadow:mygroup:!::<br></code></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># groupdel [groupname]</span><br><br>范例一：将刚刚的mygroup 删除！<br><span class="hljs-comment"># groupdel mygroup</span><br><br>范例二：若要删除vbird1 这个群组的话？<br><span class="hljs-comment"># groupdel vbird1</span><br>groupdel: cannot remove the primary <span class="hljs-keyword">group</span> <span class="hljs-title">of</span> <span class="hljs-keyword">user</span> <span class="hljs-title">&#x27;vbird1</span>&#x27;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">关于系统管理员(root)做的动作：</span> <br>[root@study ~]# gpasswd groupname <br>[root@study ~]# gpasswd [-A user1,...] [-M user3,...] groupname <br>[root@study ~]# gpasswd [-rR] groupname<br>选项与参数：<br>    ：若没有任何参数时，表示给予groupname 一个密码(/etc/gshadow)<br>-A ：将groupname 的主控权交由后面的使用者管理(该群组的管理员)<br>-M ：将某些帐号加入这个群组当中！<br>-r ：将groupname 的密码移除<br>-R ：让groupname 的密码栏失效<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">关于群组管理员(Group administrator)做的动作：</span> <br>[someone@study ~]$ gpasswd [-ad] user groupname<br>选项与参数：<br>-a ：将某位使用者加入到groupname 这个群组当中！<br>-d ：将某位使用者移除出groupname 这个群组当中。<br><br>范例一：建立一个新群组，名称为testgroup 且群组交由vbird1 管理： <br>[root@study ~]# groupadd testgroup   &lt;==先建立群组<br>[root@study ~]# gpasswd testgroup   &lt;==给这个群组一个密码吧！<br>Changing the password for group testgroup<br>New Password:<br>Re-enter new password:<br><span class="hljs-meta prompt_"># </span><span class="language-bash">输入两次密码就对了！</span><br>[root@study ~]# gpasswd -A vbird1 testgroup   &lt;==加入群组管理员为vbird1 <br>[root@study ~]# grep testgroup /etc/group /etc/gshadow<br>/etc/group:testgroup:x:1503:<br>/etc/gshadow:testgroup: $6$MnmChP3D$mrUn.Vo.buDjObMm8F2emTkvGSeuWikhRzaKHxpJ...:vbird1: <br><span class="hljs-meta prompt_"># </span><span class="language-bash">很有趣吧！此时vbird1 则拥有testgroup 的主控权喔！身份有点像板主啦！</span><br><br>范例二：以vbird1 登入系统，并且让他加入vbird1, vbird3 成为testgroup 成员<br>[vbird1@study ~]$ id<br>uid=1003(vbird1) gid=1004(vbird1) groups=1004(vbird1) ...<br><span class="hljs-meta prompt_"># </span><span class="language-bash">看得出来，vbird1 尚未加入testgroup 群组喔！</span><br><br>[vbird1@study ~]$ gpasswd -a vbird1 testgroup <br>[vbird1@study ~]$ gpasswd -a vbird3 testgroup <br>[vbird1@study ~]$ grep testgroup /etc/group <br>testgroup:x:1503: vbird1,vbird3<br></code></pre></td></tr></table></figure><h3 id="用户身份切换">13.4 用户身份切换</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">su [-lm] [-c 指令] [username]</span><br>选项与参数：<br>- ：单纯使用- 如『 su - 』代表使用login-shell 的变数档案读取方式来登入系统；<br>      若使用者名称没有加上去，则代表切换为root 的身份。<br>-l ：与- 类似，但后面需要加欲切换的使用者帐号！也是login-shell 的方式。<br>-m ：-m 与-p 是一样的，表示『使用目前的环境设定，而不读取新使用者的设定档』<br>-c ：仅进行一次指令，所以-c 后面可以加上指令<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell">范例一：假设你原本是dmtsai 的身份，想要使用non-login shell 的方式变成root <br>[ dmtsai @study ~]$ su        &lt;==注意提示字元，是dmtsai 的身份喔！<br>Password:                   &lt;==这里输入root 的密码喔！<br>[root@study dmtsai ]# id     &lt;==提示字元的目录是dmtsai 喔！<br>uid=0(root) gid=0(root) groups=0(root) context=unconf....   &lt;==确实是root 的身份！<br>[root@study dmtsai]# env | grep &#x27;dmtsai&#x27; <br>USER=dmtsai                                          &lt;==竟然还是dmtsai 这家伙！<br>PATH=...:/home/dmtsai/.local/bin:/home/dmtsai/bin    &lt;==这个影响最大！ <br>MAIL=/var/spool/mail/dmtsai                          &lt;==收到的mailbox 是vbird1<br>PWD=/home/dmtsai                                     &lt;==并非root 的家目录<br>LOGNAME=dmtsai<br><span class="hljs-meta prompt_"># </span><span class="language-bash">虽然你的UID 已经是具有root 的身份，但是看到上面的输出讯息吗？</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">还是有一堆变数为原本dmtsai 的身份，所以很多资料还是无法直接利用。</span><br>[root@study dmtsai]# exit    &lt;==这样可以离开su 的环境<br><br><br>范例二：使用login shell 的方式切换为root 的身份并观察变数<br>[dmtsai@study ~]$ su - <br>Password:    &lt;==这里输入root 的密码喔！<br>[root@study ~]# env | grep root<br>USER=root<br>MAIL=/var/spool/mail/root<br>PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin<br>PWD=/root<br>HOME=/root<br>LOGNAME=root<br><span class="hljs-meta prompt_"># </span><span class="language-bash">了解差异了吧？下次变换成为root 时，记得最好使用su - 喔！</span><br>[root@study ~]# exit    &lt;==这样可以离开su 的环境<br></code></pre></td></tr></table></figure><p>sudo：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# sudo [-b] [-u 新使用者帐号]<br>选项与参数：<br>-b ：将后续的指令放到背景中让系统自行执行，而不与目前的shell 产生影响<br>-u ：后面可以接欲切换的使用者，若无此项则代表切换身份为root 。<br><br>范例一：你想要以sshd 的身份在/tmp 底下建立一个名为mysshd 的档案<br>[root@study ~]# sudo -u sshd touch /tmp/mysshd <br>[root@study ~]# ll /tmp/mysshd <br>-rw-r--r--. 1 sshd sshd 0 Jul 21 23:37 /tmp/mysshd<br><span class="hljs-meta prompt_"> # </span><span class="language-bash">特别留意，这个档案的权限是由sshd 所建立的情况喔！</span><br><br>范例二：你想要以vbird1 的身份建立~vbird1/www 并于其中建立index.html 档案<br>[root@study ~]# sudo -u vbird1 sh -c &quot;mkdir ~vbird1/www; cd ~vbird1/www; \ <br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">  <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;This is index.html file&#x27;</span> &gt; index.html<span class="hljs-string">&quot;</span></span> <br>[root@study ~]# ll -a ~vbird1/www<br>drwxr-xr-x. 2 vbird1 vbird1 23 Jul 21 23:38 .<br>drwx------. 6 vbird1 vbird1 4096 Jul 21 23:38 ..<br>-rw-r--r--. 1 vbird1 vbird1 24 Jul 21 23:38 index.html<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">要注意，建立者的身份是vbird1 ，且我们使用sh -c &quot;</span>一串指令<span class="hljs-string">&quot; 来执行的！</span></span><br></code></pre></td></tr></table></figure><h2 id="磁盘配额quota与高级文件系统管理">14.磁盘配额（Quota）与高级文件系统管理</h2><p>略</p><h2 id="计划任务crontab">15. 计划任务（crontab）</h2><h3 id="什么是计划任务">15.1 什么是计划任务</h3><ul><li><strong>at</strong>：at是个可以处理仅执行一次就结束排程的指令，不过要执行at 时， 必须要有atd这个服务的支援才行。在某些新版的distributions 中，atd可能预设并没有启动，那么at 这个指令就会失效</li><li><strong>crontab</strong>：crontab这个指令所设定的工作将会循环的一直进行下去！可循环的时间为分钟、小时、每周、每月或每年等。crontab除了可以使用指令执行外，亦可编辑/etc/crontab 来支援。至于让crontab可以生效的服务则是crond 这个服务</li></ul><h3 id="仅执行一次的计划任务">15.2 仅执行一次的计划任务</h3><p>需先启动 atd 服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# systemctl restart atd   # 重新启动atd 这个服务<br>[root@study ~]# systemctl enable atd   # 让这个服务开机就自动启动<br>[root@study ~]# systemctl status atd   # 查阅一下atd 目前的状态<br>atd.service - Job spooling tools<br>   Loaded: loaded (/usr/lib/systemd/system/atd.service; enabled )        # 是否开机启动<br>   Active: active (running) since Thu 2015-07-30 19:21:21 CST; 23s ago # 是否正在运作中<br> Main PID: 26503 (atd)<br>   CGroup: /system.slice/atd.service<br>           └─26503 /usr/sbin/atd -f<br><br>Jul 30 19:21:21 study.centos.vbird systemd[1]: Starting Job spooling tools...<br>Jul 30 19:21:21 study.centos.vbird systemd[1]: Started Job spooling tools.<br></code></pre></td></tr></table></figure><p>使用 at这个指令来产生所要运作的工作，并将这个工作以文本文件的方式写入/var/spool/at/ 目录内，该工作便能等待atd 这个服务的取用与执行了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# at [-mldv] TIME <br>[root@study ~]# at -c 任务号码<br>选项与参数：<br>-m ：当at 的工作完成后，即使没有输出讯息，亦以email 通知使用者该工作已完成。<br>-l ：at -l 相当于atq，列出目前系统上面的所有该使用者的at 计划；<br>-d ：at -d 相当于atrm ，可以取消一个在at 计划中的工作；<br>-v ：可以使用较明显的时间格式列出at 计划中的工作列表；<br>-c ：可以列出后面接的该项工作的实际指令内容。<br><br>TIME：时间格式，这里可以定义出『什么时候要进行at 这项计划』的时间，格式有：<br>  HH:MM ex&gt; 04:00<br>在今日的HH:MM 时刻进行，若该时刻已超过，则明天的HH:MM 进行此工作。<br>  HH:MM YYYY-MM-DD ex&gt; 04:00 2015-07-30<br>强制规定在某年某月的某一天的特殊时刻进行该工作！<br>  HH:MM[am|pm] [Month] [Date] ex&gt; 04pm July 30<br>也是一样，强制在某年某月某日的某时刻进行！<br>  HH:MM[am|pm] + number [minutes|hours|days|weeks]<br><span class="hljs-meta prompt_">ex&gt; </span><span class="language-bash">now + 5 minutes ex&gt; 04pm + 3 days</span><br>就是说，在某个时间点『再加几个时间后』才进行。<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell">范例一：再过五分钟后，将/root/.bashrc 寄给root 自己<br>[root@study ~]# at now + 5 minutes   &lt;==记得单位要加s 喔！<br><span class="hljs-meta prompt_">at&gt; </span><span class="language-bash">/bin/mail -s <span class="hljs-string">&quot;testing at job&quot;</span> root &lt; /root/.bashrc</span> <br><span class="hljs-meta prompt_">at&gt; </span><span class="language-bash">&lt;EOT&gt;    &lt;==这里输入[ctrl] + d 就会出现&lt;EOF&gt; 的字样！代表结束！</span><br>job 2 at Thu Jul 30 19:35:00 2015<br><span class="hljs-meta prompt_"># </span><span class="language-bash">上面这行资讯在说明，第2 个at 工作将在2015/07/30 的19:35 进行！</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">而执行at 会进入所谓的at shell 环境，让你下达多重指令等待运作！</span><br><br>范例二：将上述的第2 项工作内容列出来查阅<br>[root@study ~]# at -c 2 <br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/sh                &lt;==就是透过bash shell 的啦！</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">atrun uid=0 gid=0</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">mail root 0</span><br>umask 22<br>....(中间省略许多的环境变数项目)....<br>cd /etc/cron\.d || &#123;<br>         echo &#x27;Execution directory inaccessible&#x27; &gt;&amp;2<br>         exit 1<br>&#125;<br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;SHELL:-/bin/sh&#125; &lt;&lt; <span class="hljs-string">&#x27;marcinDELIMITER410efc26&#x27;</span></span><br>/bin/mail -s &quot;testing at job&quot; root &lt; /root/.bashrc     # 这一行最重要！<br>marcinDELIMITER410efc26 <br><span class="hljs-meta prompt_"># </span><span class="language-bash">你可以看到指令执行的目录(/root)，还有多个环境变数与实际的指令内容啦！</span><br><br>范例三：由于机房预计于2015/08/05 停电，我想要在2015/08/04 23:00 关机？<br>[root@study ~]# at 23:00 2015-08-04 <br><span class="hljs-meta prompt_">at&gt; </span><span class="language-bash">/bin/sync</span> <br><span class="hljs-meta prompt_">at&gt; </span><span class="language-bash">/bin/sync</span> <br><span class="hljs-meta prompt_">at&gt; </span><span class="language-bash">/sbin/shutdown -h now</span><br><span class="hljs-meta prompt_">at&gt; </span><span class="language-bash">&lt;EOT&gt;</span><br>job 3 at Tue Aug 4 23:00:00 2015<br><span class="hljs-meta prompt_"># </span><span class="language-bash">您瞧瞧！at 还可以在一个工作内输入多个指令呢！不错吧！</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# atq <br>[root@study ~]# atrm (jobnumber)<br><br>范例一：查询目前主机上面有多少的at 工作排程？<br>[root@study ~]# atq<br>3 Tue Aug 4 23:00:00 2015 a root<br><span class="hljs-meta prompt_"># </span><span class="language-bash">上面说的是：『在2015/08/04 的23:00 有一项工作，该项工作指令下达者为</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">root』而且，该项工作的工作号码(jobnumber) 为3 号喔！</span><br><br>范例二：将上述的第3 个工作移除！<br>[root@study ~]# atrm 3 <br>[root@study ~]# atq <br><span class="hljs-meta prompt_"># </span><span class="language-bash">没有任何资讯，表示该工作被移除了！</span><br></code></pre></td></tr></table></figure><h3 id="循环执行的计划任务">15.3 循环执行的计划任务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# crontab [-u username] [-l|-e|-r]<br>选项与参数：<br>-u ：只有root 才能进行这个任务，亦即帮其他使用者建立/移除crontab 工作排程；<br>-e ：编辑crontab 的工作内容<br>-l ：查阅crontab 的工作内容<br>-r ：移除所有的crontab 的工作内容，若仅要移除一项，请用-e 去编辑。<br><br>范例一：用dmtsai 的身份在每天的12:00 发信给自己<br>[dmtsai@study ~]$ crontab -e <br><span class="hljs-meta prompt_"># </span><span class="language-bash">此时会进入vi 的编辑画面让您编辑工作！注意到，每项工作都是一行。</span><br>0 12 * * * mail -s &quot;at 12:00&quot; dmtsai &lt; /home/dmtsai/.bashrc <br><span class="hljs-meta prompt_">#</span><span class="language-bash">分时日月周|&lt;==============指令串========================&gt;|</span><br></code></pre></td></tr></table></figure><p>每项工作(每行) 的格式都是具有六个栏位，这六个栏位的意义为：</p><table><thead><tr class="header"><th style="text-align: center;">代表意义</th><th style="text-align: center;">分钟</th><th style="text-align: center;">小时</th><th style="text-align: center;">日期</th><th style="text-align: center;">月份</th><th style="text-align: center;">周</th><th style="text-align: center;">命令</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">数字范围</td><td style="text-align: center;">0-59</td><td style="text-align: center;">0-23</td><td style="text-align: center;">1-31</td><td style="text-align: center;">1-12</td><td style="text-align: center;">0-7</td><td style="text-align: center;">需要执行的命令</td></tr></tbody></table><p>特殊字符：</p><table><thead><tr class="header"><th>特殊字符</th><th>代表意义</th></tr></thead><tbody><tr class="odd"><td>*(星号)</td><td>代表任何时刻都接受的意思！举例来说，范例一内那个日、月、周都是* ，就代表着『不论何月、何日的礼拜几的12:00 都执行后续指令』的意思！</td></tr><tr class="even"><td>,(逗号)</td><td>代表分隔时段的意思。举例来说，如果要下达的工作是3:00 与6:00时，就会是：0 3,6 * * * command时间参数还是有五栏，不过第二栏是3,6，代表3 与6 都适用！</td></tr><tr class="odd"><td>-(减号)</td><td>代表一段时间范围内，举例来说， 8 点到12 点之间的每小时的20分都进行一项工作：20 8-12 * * * command仔细看到第二栏变成8-12喔！代表8,9,10,11,12 都适用的意思！</td></tr><tr class="even"><td>/n(斜线)</td><td>那个n 代表数字，亦即是『每隔n单位间隔』的意思，例如每五分钟进行一次，则： <em>/5 </em> * * *command很简单吧！用* 与/5 来搭配，也可以写成0-59/5 ，相同意思！</td></tr></tbody></table><p>注意：『如果只是要删除某个crontab 的工作项目，那么请使用crontab -e来重新编辑即可！』如果使用-r 的参数，是会将所有的 crontab资料内容都删掉的！</p><h3 id="可唤醒停机期间的工作任务">15.4 可唤醒停机期间的工作任务</h3><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# anacron [-sfn] [job].. <br>[root@study ~]# anacron -u [job]..<br>选项与参数：<br>-s ：开始一连续的执行各项工作(job)，会依据时间记录档的资料判断是否进行；<br>-f ：强制进行，而不去判断时间记录档的时间戳记；<br>-n ：立刻进行未进行的任务，而不延迟(delay) 等待时间；<br>-u ：仅更新时间记录档的时间戳记，不进行任何工作。<br>job ：由/etc/anacrontab 定义的各项工作名称。<br></code></pre></td></tr></table></figure><h2 id="进程管理与-selinux-初探">16. 进程管理与 SELinux 初探</h2><p>kill：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# kill -signal %jobnumber <br>[root@study ~]# kill -l<br>选项与参数：<br>-l ：这个是L 的小写，列出目前kill 能够使用的讯号(signal) 有哪些？<br>signal ：代表给予后面接的那个工作什么样的指示啰！用man 7 signal 可知：<br>  -1 ：重新读取一次参数的设定档(类似reload)；<br>  -2 ：代表与由键盘输入[ctrl]-c 同样的动作；<br>  -9 ：立刻强制删除一个工作；<br>  -15：以正常的程序方式终止一项工作。与-9 是不一样的。<br><br>范例一：找出目前的bash 环境下的背景工作，并将该工作『强制删除』。<br>[root@study ~]# jobs<br>[1]+ Stopped vim ~/.bashrc<br>[2] Stopped find / -print<br>[root@study ~]# kill -9 %2; jobs<br>[1]+ Stopped vim ~/.bashrc<br>[2]    Killed                   find / -print<br><span class="hljs-meta prompt_"> # </span><span class="language-bash">再过几秒你再下达<span class="hljs-built_in">jobs</span> 一次，就会发现2 号工作不见了！因为被移除了！</span><br><br>范例二：找出目前的bash 环境下的背景工作，并将该工作『正常终止』掉。<br>[root@study ~]# jobs<br>[1]+ Stopped vim ~/.bashrc<br>[root@study ~]# kill -SIGTERM %1 <br><span class="hljs-meta prompt_"># </span><span class="language-bash">-SIGTERM 与-15 是一样的！您可以使用<span class="hljs-built_in">kill</span> -l 来查阅！</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">不过在这个案例中， vim 的工作无法被结束喔！因为他无法透过<span class="hljs-built_in">kill</span> 正常终止的意思！</span><br></code></pre></td></tr></table></figure><table><thead><tr class="header"><th>代号</th><th>名称</th><th>内容</th></tr></thead><tbody><tr class="odd"><td>1</td><td>SIGHUP</td><td>启动被终止的程序，可让该PID 重新读取自己的设定档，类似重新启动</td></tr><tr class="even"><td>2</td><td>SIGINT</td><td>相当于用键盘输入[ctrl]-c 来中断一个程序的进行</td></tr><tr class="odd"><td>9</td><td>SIGKILL</td><td>代表强制中断一个程序的进行，如果该程序进行到一半，那么尚未完成的部分可能会有『半产品』产生，类似vim会有.filename.swp保留下来。</td></tr><tr class="even"><td>15</td><td>SIGTERM</td><td>以正常的结束程序来终止该程序。由于是正常的终止，所以后续的动作会将他完成。不过，如果该程序已经发生问题，就是无法使用正常的方法终止时，输入这个signal 也是没有用的。</td></tr><tr class="odd"><td>19</td><td>SIGSTOP</td><td>相当于用键盘输入[ctrl]-z 来暂停一个程序的进行</td></tr></tbody></table><p>killall：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">root@study ~</span>]<span class="hljs-meta"># killall [-iIe] [command name]</span><br>选项与参数：<br>-i ：interactive 的意思，互动式的，若需要删除时，会出现提示字元给使用者；<br>-e ：exact 的意思，表示『后面接的command name 要一致』，但整个完整的指令<br>      不能超过<span class="hljs-number">15</span> 个字元。<br>-I ：指令名称(可能含参数)忽略大小写。<br><br>范例一：给予rsyslogd 这个指令启动的PID 一个SIGHUP 的讯号<br>[<span class="hljs-meta">root@study ~</span>]<span class="hljs-meta"># killall -1 rsyslogd </span><br><span class="hljs-meta"># 如果用ps aux 仔细看一下，若包含所有参数，则/usr/sbin/rsyslogd -n 才是最完整的！</span><br><br>范例二：强制终止所有以httpd 启动的程序(其实并没有此程序在系统内) <br>[<span class="hljs-meta">root@study ~</span>]<span class="hljs-meta"># killall -9 httpd</span><br><br>范例三：依次询问每个bash 程式是否需要被终止运作！<br>[<span class="hljs-meta">root@study ~</span>]<span class="hljs-meta"># killall -i -9 bash </span><br><span class="hljs-function">Signal <span class="hljs-title">bash</span>(<span class="hljs-params"><span class="hljs-number">13888</span></span>) ? (<span class="hljs-params">y/N</span>) n  &lt;</span>==这个不杀！<br><span class="hljs-function">Signal <span class="hljs-title">bash</span>(<span class="hljs-params"><span class="hljs-number">13928</span></span>) ? (<span class="hljs-params">y/N</span>) n  &lt;</span>==这个不杀！<br><span class="hljs-function">Signal <span class="hljs-title">bash</span>(<span class="hljs-params"><span class="hljs-number">13970</span></span>) ? (<span class="hljs-params">y/N</span>) n  &lt;</span>==这个不杀！<br><span class="hljs-function">Signal <span class="hljs-title">bash</span>(<span class="hljs-params"><span class="hljs-number">14836</span></span>) ? (<span class="hljs-params">y/N</span>) y  &lt;</span>==这个杀掉！<br><span class="hljs-meta"># 具有互动的功能！可以询问你是否要删除bash 这个程式。要注意，若没有-i 的参数，</span><br><span class="hljs-meta"># 所有的bash 都会被这个root 给杀掉！包括root 自己的bash 喔！^_^</span><br></code></pre></td></tr></table></figure><p>ps 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# ps aux  &lt;==观察系统所有的程序资料<br>[root@study ~]# ps -lA  &lt;==也是能够观察所有系统的资料<br>[root@study ~]# ps axjf  &lt;==连同部分程序树状态<br>选项与参数：<br>-A ：所有的process 均显示出来，与-e 具有同样的效用；<br>-a ：不与terminal 有关的所有process ；<br>-u ：有效使用者(effective user) 相关的process ；<br>x ：通常与a 这个参数一起使用，可列出较完整资讯。<br>输出格式规划：<br>l ：较长、较详细的将该PID 的的资讯列出；<br>j ：工作的格式(jobs format)<br>-f ：做一个更为完整的输出。<br></code></pre></td></tr></table></figure><p>top 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# top [-d 数字] | top [-bnp]<br>选项与参数：<br>-d ：后面可以接秒数，就是整个程序画面更新的秒数。预设是5 秒；<br>-b ：以批次的方式执行top ，还有更多的参数可以使用喔！<br>      通常会搭配资料流重导向来将批次的结果输出成为档案。<br>-n ：与-b 搭配，意义是，需要进行几次top 的输出结果。<br>-p ：指定某些个PID 来进行观察监测而已。<br>在top 执行过程当中可以使用的按键指令：<br>? ：显示在top 当中可以输入的按键指令；<br>P ：以CPU 的使用资源排序显示；<br>M ：以Memory 的使用资源排序显示；<br>N ：以PID 来排序喔！<br>T ：由该Process 使用的CPU 时间累积(TIME+) 排序。<br>k ：给予某个PID 一个讯号(signal)<br>r ：给予某个PID 重新制订一个nice 值。<br>q ：离开top 软体的按键。<br></code></pre></td></tr></table></figure><p>pstree 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# pstree [-A|U] [-up]<br>选项与参数：<br>-A ：各程序树之间的连接以ASCII 字元来连接；<br>-U ：各程序树之间的连接以万国码的字元来连接。在某些终端介面下可能会有错误；<br>-p ：并同时列出每个process 的PID；<br>-u ：并同时列出每个process 的所属帐号名称。<br><br>范例一：列出目前系统上面所有的程序树的相关性： <br>[root@study ~]# pstree -A <br>systemd-+-ModemManager---2*[&#123;ModemManager&#125;]        # 这行是ModenManager 与其子程序<br>        |-NetworkManager---3*[&#123;NetworkManager&#125;]    # 前面有数字，代表子程序的数量！<br>....(中间省略).... <br>        |-sshd---sshd---sshd---bash---bash---sudo---su---bash---pstree &lt;==我们指令执行的相依性<br>....(底下省略).... <br><span class="hljs-meta prompt_"># </span><span class="language-bash">注意一下，为了节省版面，所以鸟哥已经删去很多程序了！</span><br><br>范例二：承上题，同时秀出PID 与users <br>[root@study ~]# pstree -Aup<br>systemd(1)-+-ModemManager(745)-+-&#123;ModemManager&#125;(785)<br>           | `-&#123;ModemManager&#125;(790)<br>           |-NetworkManager(870)-+-&#123;NetworkManager&#125;(907)<br>           | |-&#123;NetworkManager&#125;(911)<br>           | `-&#123;NetworkManager&#125;(914)<br>....(中间省略).... <br>           |-sshd(1326)---sshd(13923)---sshd(13927, dmtsai )---bash(13928)---bash(13970)---<br> ....(底下省略).... <br><span class="hljs-meta prompt_"># </span><span class="language-bash">在括号() 内的即是PID 以及该程序的owner 喔！一般来说，如果该程序的所有人与父程序同，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">就不会列出，但是如果与父程序不一样，那就会列出该程序的拥有者！看上面13927 就转变成dmtsai 了</span><br></code></pre></td></tr></table></figure><p>free 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">free [-b|-k|-m|-g|-h] [-t] [-s N -c N]</span><br>选项与参数：<br>-b ：直接输入free 时，显示的单位是Kbytes，我们可以使用b(bytes), m(Mbytes)<br>      k(Kbytes), 及g(Gbytes) 来显示单位喔！也可以直接让系统自己指定单位(-h)<br>-t ：在输出的最终结果，显示实体记忆体与swap 的总量。<br>-s ：可以让系统每几秒钟输出一次，不间断的一直输出的意思！对于系统观察挺有效！<br>-c ：与-s 同时处理～让free 列出几次的意思～<br><br>范例一：显示目前系统的记忆体容量<br>[root@study ~]# free -m<br>              total used free shared buff/cache available<br>Mem: 2848 346 1794 8 706 2263<br>Swap: 1023 0 1023<br></code></pre></td></tr></table></figure><p>netstat 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# netstat -[atunlp]<br>选项与参数：<br>-a ：将目前系统上所有的连线、监听、Socket 资料都列出来<br>-t ：列出tcp 网路封包的资料<br>-u ：列出udp 网路封包的资料<br>-n ：不以程序的服务名称，以埠号(port number) 来显示；<br>-l ：列出目前正在网路监听(listen) 的服务；<br>-p ：列出该网路服务的程序PID<br><br>范例一：列出目前系统已经建立的网路连线与unix socket 状态<br>[root@study ~]# netstat <br>Active Internet connections (w/o servers)  &lt;==与网路较相关的部分<br>Proto Recv-Q Send-Q Local Address Foreign Address State<br>tcp 0 0 172.16.15.100:ssh 172.16.220.234:48300 ESTABLISHED<br>Active UNIX domain sockets (w/o servers)   &lt;==与本机的程序自己的相关性(非网路)<br>Proto RefCnt Flags Type State I-Node Path<br>unix 2 [ ] DGRAM 1902 @/org/freedesktop/systemd1/notify<br>unix 2 [ ] DGRAM 1944 /run/systemd/shutdownd<br>....(中间省略)....<br>unix 3 [ ] STREAM CONNECTED 25425 @/tmp/.X11-unix/X0<br>unix 3 [ ] STREAM CONNECTED 28893<br>unix 3 [ ] STREAM CONNECTED 21262<br><br>范例二：找出目前系统上已在监听的网路连线及其PID <br>[root@study ~]# netstat -tulnp<br>Active Internet connections (only servers)<br>Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name<br>tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 1326/sshd<br>tcp 0 0 127.0.0.1:25 0.0.0.0:* LISTEN 2349/master<br>tcp6 0 0 :::22 :::* LISTEN       1326/sshd<br>tcp6 0 0 ::1:25 :::* LISTEN 2349/master<br>udp 0 0 0.0.0.0:123 0.0.0.0:* 751/chronyd<br>udp 0 0 127.0.0.1:323 0.0.0.0:* 751/chronyd<br>udp 0 0 0.0.0.0:57808 0.0.0.0:* 743/avahi-daemon: r<br>udp 0 0 0.0.0.0:5353 0.0.0.0:* 743/avahi-daemon: r<br>udp6 0 0 :::123 :::* 751/chronyd<br>udp6 0 0 ::1:323 :::* 751/chronyd<br><span class="hljs-meta prompt_"># </span><span class="language-bash">除了可以列出监听网路的介面与状态之外，最后一个栏位还能够显示此服务的</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">PID 号码以及程序的指令名称喔！例如上头的1326 就是该PID</span><br><br>范例三：将上述的0.0.0.0:57808 那个网路服务关闭的话？<br>[root@study ~]# kill -9 743 <br>[root@study ~]# killall -9 avahi-daemon<br></code></pre></td></tr></table></figure><p>dmesg 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">范例一：输出所有的核心开机时的资讯<br>[root@study ~]# dmesg | more<br><br>范例二：搜寻开机的时候，硬碟的相关资讯为何？<br>[root@study ~]# dmesg | grep -i vda<br>[ 0.758551] vda: vda1 vda2 vda3 vda4 vda5 vda6 vda7 vda8 vda9<br>[ 3.964134] XFS (vda2): Mounting V4 Filesystem<br>....(底下省略)....<br></code></pre></td></tr></table></figure><p>vmstat 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# vmstat [-a] [延迟[总计侦测次数]]  &lt;==CPU/记忆体等资讯<br>[root@study ~]# vmstat [-fs]                       &lt;==记忆体相关<br>[root@study ~]# vmstat [-S 单位]                   &lt;==设定显示数据的单位<br>[root@study ~]# vmstat [-d]                        &lt;==与磁碟有关<br>[root@study ~]# vmstat [-p 分割槽]                 &lt;==与磁碟有关<br>选项与参数：<br>-a ：使用inactive/active(活跃与否) 取代buffer/cache 的记忆体输出资讯；<br>-f ：开机到目前为止，系统复制(fork) 的程序数；<br>-s ：将一些事件(开机至目前为止) 导致的记忆体变化情况列表说明；<br>-S ：后面可以接单位，让显示的资料有单位。例如K/M 取代bytes 的容量；<br>-d ：列出磁碟的读写总量统计表<br>-p ：后面列出分割槽，可显示该分割槽的读写总量统计表<br><br>范例一：统计目前主机CPU 状态，每秒一次，共计三次！<br>[root@study ~]# vmstat 1 3<br>procs ------------memory---------- ---swap-- -----io---- -system-- ------cpu-----<br> rb swpd free buff cache si so bi bo in cs us sy id wa st<br> 1 0 0 1838092 1504 722216 0 0 4 1 6 9 0 0 100 0 0<br> 0 0 0 1838092 1504 722200 0 0 0 0 13 23 0 0 100 0 0<br> 0 0 0 1838092 1504 722200 0 0 0 0 25 46 0 0 100 0 0<br></code></pre></td></tr></table></figure><p>fuser：借由文件（或唔见系统）找出正在使用该文件的进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# fuser [-umv] [-k [i] [-signal]] file/dir<br>选项与参数：<br>-u ：除了程序的PID 之外，同时列出该程序的拥有者；<br>-m ：后面接的那个档名会主动的上提到该档案系统的最顶层，对umount 不成功很有效！<br>-v ：可以列出每个档案与程序还有指令的完整相关性！<br>-k ：找出使用该档案/目录的PID ，并试图以SIGKILL 这个讯号给予该PID；<br>-i ：必须与-k 配合，在删除PID 之前会先询问使用者意愿！<br>-signal：例如-1 -15 等等，若不加的话，预设是SIGKILL (-9) 啰！<br><br>范例一：找出目前所在目录的使用PID/所属帐号/权限为何？<br>[root@study ~]# fuser -uv .<br>                     USER PID ACCESS COMMAND<br>/root: root 13888 ..c.. (root)bash<br>                     root 31743 ..c.. (root)bash<br>                     <br><br>范例二：找到所有使用到/proc 这个档案系统的程序吧！<br>[root@study ~]# fuser -uv /proc<br>/proc: root kernel mount (root)/proc<br>                     rtkit 768 .rc.. (rtkit)rtkit-daemon<br><span class="hljs-meta prompt_"># </span><span class="language-bash">资料量还不会很多，虽然这个目录很繁忙～没关系！我们可以继续这样作，看看其他的程序！</span><br><br>[root@study ~]# fuser -mvu /proc<br>                     USER PID ACCESS COMMAND<br>/proc: root kernel mount (root)/proc<br>                     root 1 f.... (root)systemd<br>                     root 2 ...e. (root)kthreadd<br>.....(底下省略)..... <br><span class="hljs-meta prompt_"># </span><span class="language-bash">有这几支程序在进行/proc 档案系统的存取喔！这样清楚了吗？</span><br><br>范例三：找到所有使用到/home 这个档案系统的程序吧！<br>[root@study ~]# echo $$ <br>31743   # 先确认一下，自己的bash PID 号码吧！<br>[root@study ~]# cd /home <br>[root@study home]# fuser -muv .<br>                     USER PID ACCESS COMMAND<br>/home: root kernel mount (root)/home<br>                     dmtsai 31535 ..c.. (dmtsai)bash<br>                     root 31571 ..c.. (root)passwd<br>                     root 31737 ..c.. (root)sudo<br>                     root       31743 ..c.. (root)bash     # 果然，自己的PID 在啊！<br>[root@study home]# cd ~ <br>[root@study ~]# umount /home<br>umount: /home: target is busy.<br>        (In some cases useful info about processes that use<br>         the device is found by lsof(8) or fuser(1))<br><span class="hljs-meta prompt_"># </span><span class="language-bash">从fuser 的结果可以知道，总共有五只process 在该目录下运作，那即使root 离开了/home，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">当然还是无法umount 的！那要怎办？哈哈！可以透过如下方法一个一个删除～</span> <br>[root@study ~]# fuser -mki /home <br>/home: 31535c 31571c 31737c   # 你会发现， PID 跟上面查到的相同！<br>Kill process 31535 ? (y/N) # 这里会问你要不要删除！当然不要乱删除啦！通通取消！<br></code></pre></td></tr></table></figure><p>lsof：列出被进程所使用的文件名称</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# lsof [-aUu] [+d]<br>选项与参数：<br>-a ：多项资料需要『同时成立』才显示出结果时！<br>-U ：仅列出Unix like 系统的socket 档案类型；<br>-u ：后面接username，列出该使用者相关程序所开启的档案；<br>+d ：后面接目录，亦即找出某个目录底下已经被开启的档案！<br><br>范例一：列出目前系统上面所有已经被开启的档案与装置： <br>[root@study ~]# lsof<br>COMMAND PID TID USER FD TYPE DEVICE SIZE/OFF NODE NAME<br>systemd 1 root cwd DIR 253,0 4096 128 /<br>systemd 1 root rtd DIR 253,0 4096 128 /<br>systemd 1 root txt REG 253,0 1230920 967763 /usr/lib/systemd/systemd<br>....(底下省略).... <br><span class="hljs-meta prompt_"># </span><span class="language-bash">注意到了吗？是的，在预设的情况下， lsof 会将目前系统上面已经开启的</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">档案全部列出来～所以，画面多的吓人啊！您可以注意到，第一个档案systemd 执行的</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">地方就在根目录，而根目录，嘿嘿！所在的inode 也有显示出来喔！</span><br><br>范例二：仅列出关于root 的所有程序开启的socket 档案<br>[root@study ~]# lsof -u root -a -U<br>COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME<br>systemd 1 root 3u unix 0xffff8800b7756580 0t0 13715 socket<br>systemd 1 root 7u unix 0xffff8800b7755a40 0t0 1902 @/org/freedesktop/systemd1/notify<br>systemd 1 root 9u unix 0xffff8800b7756d00 0t0 1903 /run/systemd/private<br>.....(中间省略).....<br>Xorg 4496 root 1u unix 0xffff8800ab107480 0t0 25981 @/tmp/.X11-unix/X0<br>Xorg 4496 root 3u unix 0xffff8800ab107840 0t0 25982 /tmp/.X11-unix/X0<br>Xorg 4496 root 16u unix 0xffff8800b7754f00 0t0 25174 @/tmp/.X11-unix/X0<br>.....(底下省略)..... <br><span class="hljs-meta prompt_"># </span><span class="language-bash">注意到那个-a 吧！如果你分别输入lsof -u root 及lsof -U ，会有啥资讯？</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用lsof -u root -U 及lsof -u root -a -U ，呵呵！都不同啦！</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-a 的用途就是在解决同时需要两个项目都成立时啊！^_^</span><br><br>范例三：请列出目前系统上面所有的被启动的周边装置<br>[root@study ~]# lsof +d /dev<br>COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME<br>systemd 1 root 0u CHR 1,3 0t0 1028 /dev/null<br>systemd 1 root 1u CHR 1,3 0t0 1028 /dev/null<br><span class="hljs-meta prompt_"># </span><span class="language-bash">看吧！因为装置都在/dev 里面嘛！所以啰，使用搜寻目录即可啊！</span><br><br>范例四：秀出属于root 的bash 这支程式所开启的档案<br>[root@study ~]# lsof -u root | grep bash<br>ksmtuned 781 root txt REG 253,0 960384 33867220 /usr/bin/bash<br>bash 13888 root cwd DIR 253,0 4096 50331777 /root<br>bash 13888 root rtd DIR 253,0 4096 128 /<br>bash 13888 root txt REG 253,0 960384 33867220 /usr/bin/bash<br>bash 13888 root mem REG 253,0 106065056 17331169 /usr/lib/locale/locale-archive<br>....(底下省略)....<br></code></pre></td></tr></table></figure><h2 id="认识系统服务daemon">17. 认识系统服务（daemon）</h2><h3 id="什么是-daemon-与服务service">17.1 什么是 daemon与服务（service）</h3><p>完成 service 的程序称为 daemon。</p><ul><li>/usr/lib/systemd/system/：每个服务最主要的启动脚本设定，有点类似以前的/etc/init.d底下的档案；</li><li>/run/systemd/system/：系统执行过程中所产生的服务脚本，这些脚本的优先序要比/usr/lib/systemd/system/高！</li><li>/etc/systemd/system/：管理员依据主机系统的需求所建立的执行脚本，其实这个目录有点像以前/etc/rc.d/rc5.d/Sxx之类的功能！执行优先序又比/run/systemd/system/ 高喔！</li></ul><p>常见的 systemd 服务类型：</p><table><thead><tr class="header"><th>扩展名</th><th>主要服务功能</th></tr></thead><tbody><tr class="odd"><td>.service</td><td>一般服务类型(serviceunit)：主要是系统服务，包括服务器本身所需要的本机服务以及网路服务等，比较经常被使用到的服务大多是这种类型！所以，这也是最常见的类型了！</td></tr><tr class="even"><td>.socket</td><td>内部程序资料交换的插槽服务(socket unit)：主要是IPC (Inter-processcommunication) 的传输讯息插槽档(socket file)功能。这种类型的服务通常在监控讯息传递的插槽档，当有透过此插槽档传递讯息来说要连结服务时，就依据当时的状态将该用户的要求传送到对应的daemon，若daemon 尚未启动，则启动该daemon 后再传送用户的要求。使用socket类型的服务一般是比较不会被用到的服务，因此在开机时通常会稍微延迟启动的时间(因为比较没有这么常用嘛！)。一般用于本机服务比较多，例如我们的图形界面很多的软体都是透过socket来进行本机程序资料交换的行为。(这与早期的xinetd 这个super daemon有部份的相似喔！)</td></tr><tr class="odd"><td>.target</td><td>执行环境类型(target unit)：其实是一群unit的集合，例如上面表格中谈到的multi-user.target其实就是一堆服务的集合～也就是说， 选择执行multi-user.target就是执行一堆其他.service 或/及.socket 之类的服务就是了！</td></tr><tr class="even"><td>.mount .automount</td><td>档案系统挂载相关的服务(automount unit / mountunit)：例如来自网路的自动挂载、NFS档案系统挂载等与档案系统相关性较高的程序管理。</td></tr><tr class="odd"><td>.path</td><td>侦测特定档案或目录类型(pathunit)：某些服务需要侦测某些特定的目录来提供伫列服务，例如最常见的列印服务，就是透过侦测列印伫列目录来启动列印功能！这时就得要.path的服务类型支援了！</td></tr><tr class="even"><td>.timer</td><td>循环执行的服务(timer unit)：这个东西有点类似anacrontab喔！不过是由systemd 主动提供的，比anacrontab 更加有弹性！</td></tr></tbody></table><h3 id="通过-systemctl-管理服务">17.2 通过 systemctl 管理服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# systemctl [command] [unit] <br>command 主要有：<br>start ：立刻启动后面接的unit<br>stop ：立刻关闭后面接的unit<br>restart ：立刻关闭后启动后面接的unit，亦即执行stop 再start 的意思<br>reload ：不关闭后面接的unit 的情况下，重新载入设定档，让设定生效<br>enable ：设定下次开机时，后面接的unit 会被启动<br>disable ：设定下次开机时，后面接的unit 不会被启动<br>status ：目前后面接的这个unit 的状态，会列出有没有正在执行、开机预设执行否、登录等资讯等！<br>is-active ：目前有没有正在运作中<br>is-enabled：开机时有没有预设要启用这个unit<br><br>范例一：看看目前atd 这个服务的状态为何？<br>[root@study ~]# systemctl status atd.service<br>atd.service - Job spooling tools<br>   Loaded: loaded (/usr/lib/systemd/system/atd.service; enabled)<br>   Active: active (running) since Mon 2015-08-10 19:17:09 CST; 5h 42min ago<br> Main PID: 1350 (atd)<br>   CGroup: /system.slice/atd.service<br>           └─1350 /usr/sbin/atd -f<br><br>Aug 10 19:17:09 study.centos.vbird systemd[1]: Started Job spooling tools.<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重点在第二、三行喔～</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Loaded：这行在说明，开机的时候这个unit 会不会启动，enabled 为开机启动，disabled 开机不会启动</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Active：现在这个unit 的状态是正在执行(running) 或没有执行(dead)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">后面几行则是说明这个unit 程序的PID 状态以及最后一行显示这个服务的登录档资讯！</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">登录档资讯格式为：『时间』 『讯息发送主机』 『哪一个服务的讯息』 『实际讯息内容』</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">所以上面的显示讯息是：这个atd 预设开机就启动，而且现在正在运作的意思！</span><br><br>范例二：正常关闭这个atd 服务<br>[root@study ~]# systemctl stop atd.service <br>[root@study ~]# systemctl status atd.service<br>atd.service - Job spooling tools<br>   Loaded: loaded (/usr/lib/systemd/system/atd.service; enabled )<br>    Active: inactive (dead) since Tue 2015-08-11 01:04:55 CST; 4s ago<br>  Process: 1350 ExecStart=/usr/sbin/atd -f $OPTS (code=exited, status=0/SUCCESS)<br> Main PID: 1350 (code=exited, status=0/SUCCESS)<br><br>Aug 10 19:17:09 study.centos.vbird systemd[1]: Started Job spooling tools.<br>Aug 11 01:04:55 study.centos.vbird systemd[1]: Stopping Job spooling tools...<br>Aug 11 01:04:55 study.centos.vbird systemd[1]: Stopped Job spooling tools. <br><span class="hljs-meta prompt_"># </span><span class="language-bash">目前这个unit 下次开机还是会启动，但是现在是没在运作的状态中！同时，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">最后两行为新增加的登录讯息，告诉我们目前的系统状态喔！</span><br></code></pre></td></tr></table></figure><p>查看系统上所有服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# systemctl [command] [--type=TYPE] [--all] <br>command:<br>    list-units ：依据unit 列出目前有启动的unit。若加上--all 才会列出没启动的。<br>    list-unit-files ：依据/usr/lib/systemd/system/ 内的档案，将所有档案列表说明。<br>--type=TYPE：就是之前提到的unit type，主要有service, socket, target 等<br><br>范例一：列出系统上面有启动的unit <br>[root@study ~]# systemctl<br>UNIT LOAD ACTIVE SUB DESCRIPTION<br>proc-sys-fs-binfmt_mis... loaded active waiting Arbitrary Executable File Formats File System<br>sys-devices-pc...:0:1:... loaded active plugged QEMU_HARDDISK<br>sys-devices-pc...0:1-0... loaded active plugged QEMU_HARDDISK<br>sys-devices-pc...0:0-1... loaded active plugged QEMU_DVD-ROM<br>.....(中间省略).....<br>vsftpd.service loaded active running Vsftpd ftp daemon<br>.....(中间省略).....<br>cups.socket loaded failed failed CUPS Printing Service Sockets<br>.....(中间省略).....<br>LOAD = Reflects whether the unit definition was properly loaded.<br>ACTIVE = The high-level unit activation state, ie generalization of SUB.<br>SUB = The low-level unit activation state, values depend on unit type.<br><br>141 loaded units listed. Pass --all to see loaded but inactive units, too.<br>To show all installed unit files use &#x27;systemctl list-unit-files&#x27;. <br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出的项目中，主要的意义是：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">UNIT ：项目的名称，包括各个unit 的类别(看副档名)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">LOAD ：开机时是否会被载入，预设systemctl 显示的是有载入的项目而已喔！</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">ACTIVE ：目前的状态，须与后续的SUB 搭配！就是我们用systemctl status 观察时，active 的项目！</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">DESCRIPTION ：详细描述啰</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">cups 比较有趣，因为刚刚被我们玩过，所以ACTIVE 竟然是failed 的喔！被玩死了！^_^</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">另外，systemctl 都不加参数，其实预设就是list-units 的意思！</span><br><br>范例二：列出所有已经安装的unit 有哪些？<br>[root@study ~]# systemctl list-unit-files<br>UNIT FILE STATE<br>proc-sys-fs-binfmt_misc.automount static<br>dev-hugepages.mount static<br>dev-mqueue.mount static<br>proc-fs-nfsd.mount static<br>.....(中间省略).....<br>systemd-tmpfiles-clean.timer static<br><br>336 unit files listed.<br></code></pre></td></tr></table></figure><p>查看网络端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# netstat -tlunp<br>Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name<br>tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 1340/sshd<br>tcp 0 0 127.0.0.1:25 0.0.0.0:* LISTEN 2387/master<br>tcp6 0 0 :::555 :::* LISTEN 29113/vsftpd<br>tcp6 0 0 :::22 :::* LISTEN 1340/sshd<br>tcp6 0 0 ::1:25 :::* LISTEN 2387/master<br>udp 0 0 0.0.0.0:5353 0.0.0.0:* 750/avahi-daemon: r<br>udp 0 0 0.0.0.0:36540 0.0.0.0:* 750/avahi-daemon: r<br></code></pre></td></tr></table></figure><h3 id="systemctl-针对-service-类型的配置文件">17.3 systemctl 针对service 类型的配置文件</h3><p>systemctl 配置文件设置项目简介：（以 <code>sshd.service</code>文件为例）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# cat /usr/lib/systemd/system/sshd.service <br>[Unit]            # 这个项目与此unit 的解释、执行服务相依性有关<br>Description=OpenSSH server daemon<br>After=network.target sshd-keygen.service<br>Wants=sshd-keygen.service<br><br>[Service]         # 这个项目与实际执行的指令参数有关<br>EnvironmentFile=/etc/sysconfig/sshd<br>ExecStart=/usr/sbin/sshd -D $OPTIONS<br>ExecReload=/bin/kill -HUP $MAINPID<br>KillMode=process<br>Restart=on-failure<br>RestartSec=42s<br><br>[Install]         # 这个项目说明此unit 要挂载哪个target 底下<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><p>可分为三个部分：</p><ul><li>[Unit]： unit 本身的说明，以及与其他相依daemon的设定，包括在什么服务之后才启动此unit 之类的设定值；</li><li>[Service], [Socket], [Timer], [Mount], [Path]..：不同的unit type就得要使用相对应的设定项目。我们拿的是sshd.service来当范本，所以这边就使用[Service]来设定。这个项目内主要在规范服务启动的脚本、环境设定档档名、重新启动的方式等等。</li><li>[Install]：这个项目就是将此unit 安装到哪个target 里面去的意思！</li></ul><p>具体设置参数含义：</p><table><thead><tr class="header"><th style="text-align: center;">[Unit] 部分</th><th></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">设定参数</td><td>参数意义说明</td></tr><tr class="even"><td style="text-align: center;">Description</td><td>就是当我们使用systemctl list-units时，会输出给管理员看的简易说明！当然，使用systemctl status输出的此服务的说明，也是这个项目！</td></tr><tr class="odd"><td style="text-align: center;">Documentation</td><td>这个项目在提供管理员能够进行进一步的文件查询的功能！提供的文件可以是如下的资料：<br/>Documentation=http://www...<br/>Documentation=man:sshd(8)<br/>Documentation=file:/etc/ssh/sshd_config</td></tr><tr class="even"><td style="text-align: center;">After</td><td>说明此unit 是在哪个daemon启动之后才启动的意思！基本上仅是说明服务启动的顺序而已，并没有强制要求里头的服务一定要启动后此unit才能启动。以sshd.service 的内容为例，该档案提到After后面有network.target 以及sshd-keygen.service，但是若这两个unit没有启动而强制启动sshd.service 的话， 那么sshd.service应该还是能够启动的！这与Requires 的设定是有差异的喔！</td></tr><tr class="odd"><td style="text-align: center;">Before</td><td>与After的意义相反，是在什么服务启动前最好启动这个服务的意思。不过这仅是规范服务启动的顺序，并非强制要求的意思。</td></tr><tr class="even"><td style="text-align: center;">Requires</td><td>明确的定义此unit 需要在哪个daemon启动后才能够启动！就是设定相依服务啦！如果在此项设定的前导服务没有启动，那么此unit就不会被启动！</td></tr><tr class="odd"><td style="text-align: center;">Wants</td><td>与Requires 刚好相反，规范的是这个unit之后最好还要启动什么服务比较好的意思！不过，并没有明确的规范就是了！主要的目的是希望建立让使用者比较好操作的环境。因此，这个Wants后面接的服务如果没有启动，其实不会影响到这个unit 本身！</td></tr><tr class="even"><td style="text-align: center;">Conflicts</td><td>代表冲突的服务！亦即这个项目后面接的服务如果有启动，那么我们这个unit本身就不能启动！我们unit有启动，则此项目后的服务就不能启动！反正就是冲突性的检查啦！</td></tr></tbody></table><table><thead><tr class="header"><th style="text-align: center;">[Service] 部分</th><th></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">设定参数</td><td>参数意义说明</td></tr><tr class="even"><td style="text-align: center;">Type</td><td>说明这个daemon 启动的方式，会影响到ExecStart喔！一般来说，有底下几种类型<br/>simple：预设值，这个daemon主要由ExecStart接的指令串来启动，启动后常驻于记忆体中。<br/>forking：由ExecStart启动的程序透过spawns 延伸出其他子程序来作为此daemon的主要服务。原生的父程序在启动结束后就会终止运作。传统的unit服务大多属于这种项目，例如httpd 这个WWW 服务，当httpd的程序因为运作过久因此即将终结了，则systemd会再重新生出另一个子程序持续运作后，再将父程序删除。据说这样的效能比较好！！<br/>oneshot：与simple类似，不过这个程序在工作完毕后就结束了，不会常驻在记忆体中。<br/>dbus：与simple类似，但这个daemon 必须要在取得一个D-Bus的名称后，才会继续运作！因此设定这个项目时，通常也要设定BusName=才行！<br/>idle：与simple 类似，意思是，要执行这个daemon必须要所有的工作都顺利执行完毕后才会执行。这类的daemon通常是开机到最后才执行即可的服务！比较重要的项目大概是simple, forking与oneshot了！毕竟很多服务需要子程序(forking)，而有更多的动作只需要在开机的时候执行一次(oneshot)，例如档案系统的检查与挂载啊等等的。</td></tr><tr class="odd"><td style="text-align: center;">EnvironmentFile</td><td>可以指定启动脚本的环境设定档！例如sshd.service的设定档写入到/etc/sysconfig/sshd 当中！你也可以使用Environment=后面接多个不同的Shell 变数来给予设定！</td></tr><tr class="even"><td style="text-align: center;">ExecStart</td><td>就是实际执行此daemon 的指令或脚本程式。你也可以使用ExecStartPre(之前) 以及ExecStartPost (之后)两个设定项目来在实际启动服务前，进行额外的指令行为。但是你得要特别注意的是，指令串仅接受『指令参数参数...』的格式，不能接受&lt;,&gt;, &gt;&gt;, |, &amp; 等特殊字符，很多的bash语法也不支援喔！所以，要使用这些特殊的字符时，最好直接写入到指令脚本里面去！不过，上述的语法也不是完全不能用，亦即，若要支援比较完整的bash语法，那你得要使用Type=oneshot 才行喔！其他的Type才不能支援这些字符。</td></tr><tr class="odd"><td style="text-align: center;">ExecStop</td><td>与systemctl stop 的执行有关，关闭此服务时所进行的指令。</td></tr><tr class="even"><td style="text-align: center;">ExecReload</td><td>与systemctl reload 有关的指令行为</td></tr><tr class="odd"><td style="text-align: center;">Restart</td><td>当设定Restart=1 时，则当此daemon服务终止后，会再次的启动此服务。举例来说，如果你在tty2使用文字界面登入，操作完毕后登出，基本上，这个时候tty2就已经结束服务了。但是你会看到萤幕又立刻产生一个新的tty2的登入画面等待你的登入！那就是Restart 的功能！除非使用systemctl强制将此服务关闭，否则这个服务会源源不绝的一直重复产生！</td></tr><tr class="even"><td style="text-align: center;">RemainAfterExit</td><td>当设定为RemainAfterExit=1 时，则当这个daemon所属的所有程序都终止之后，此服务会再尝试启动。这对于Type=oneshot的服务很有帮助！</td></tr><tr class="odd"><td style="text-align: center;">TimeoutSec</td><td>若这个服务在启动或者是关闭时，因为某些缘故导致无法顺利『正常启动或正常结束』的情况下，则我们要等多久才进入『强制结束』的状态！</td></tr><tr class="even"><td style="text-align: center;">KillMode</td><td>可以是process, control-group, none 的其中一种，如果是process则daemon 终止时，只会终止主要的程序(ExecStart接的后面那串指令)，如果是control-group 时， 则由此daemon所产生的其他control-group 的程序，也都会被关闭。如果是none的话，则没有程序会被关闭喔！</td></tr><tr class="odd"><td style="text-align: center;">RestartSec</td><td>与Restart有点相关性，如果这个服务被关闭，然后需要重新启动时，大概要sleep多少时间再重新启动的意思。预设是100ms (毫秒)。</td></tr></tbody></table><table><thead><tr class="header"><th style="text-align: center;">[Install] 部分</th><th></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">设定参数</td><td>参数意义说明</td></tr><tr class="even"><td style="text-align: center;">WantedBy</td><td>这个设定后面接的大部分是*.target unit ！意思是，这个unit本身是附挂在哪一个target unit 底下的！一般来说，大多的服务性质的unit都是附挂在multi-user.target 底下！</td></tr><tr class="odd"><td style="text-align: center;">Also</td><td>当目前这个unit 本身被enable 时，Also 后面接的unit 也请enable的意思！也就是具有相依性的服务可以写在这里呢！</td></tr><tr class="even"><td style="text-align: center;">Alias</td><td>进行一个连结的别名的意思！当systemctl enable相关的服务时，则此服务会进行连结档的建立！以multi-user.target为例，这个家伙是用来作为预设操作环境default.target 的规划，因此当你设定用成default.target时，这个/etc/systemd/system/default.target就会连结到/usr/lib/systemd/system/multi-user.target 啰！</td></tr></tbody></table><p>示例：建立自己的备份服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# vim /backups/backup.sh <br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>source=&quot;/etc /home /root /var/lib /var/spool/&#123;cron,at,mail&#125;&quot;<br>target=&quot;/backups/backup-system-$(date +%Y-%m-%d).tar.gz&quot;<br>[ ! -d /backups ] &amp;&amp; mkdir /backups<br>tar -zcvf $&#123;target&#125; $&#123;source&#125; &amp;&gt; /backups/backup.log<br><br>[root@study ~]# chmod a+x /backups/backup.sh <br>[root@study ~]# ll /backups/backup.sh <br>-rwxr-xr-x . 1 root root 220 Aug 13 01:57 /backups/backup.sh<br><span class="hljs-meta prompt_"> # </span><span class="language-bash">记得要有可执行的权限才可以喔！</span><br> <br> <br>[root@study ~]# vim /etc/systemd/system/backup.service <br>[Unit]<br>Description=backup my server<br>Requires=atd.service<br><br>[Service]<br>Type=simple<br>ExecStart=/bin/bash -c &quot; echo /backups/backup.sh | at now&quot;<br><br>[Install]<br>WantedBy=multi-user.target <br><span class="hljs-meta prompt_"># </span><span class="language-bash">因为ExecStart 里面有用到at 这个指令，因此， atd.service 就是一定要的服务！</span><br><br>[root@study ~]# systemctl daemon-reload <br>[root@study ~]# systemctl start backup.service <br>[root@study ~]# systemctl status backup.service<br>backup.service - backup my server<br>   Loaded: loaded (/etc/systemd/system/backup.service; disabled)<br>   Active: inactive (dead)<br><br>Aug 13 07:50:31 study.centos.vbird systemd[1]: Starting backup my server...<br>Aug 13 07:50:31 study.centos.vbird bash[20490]: job 8 at Thu Aug 13 07:50:00 2015<br>Aug 13 07:50:31 study.centos.vbird systemd[1]: Started backup my server.<br><span class="hljs-meta prompt_"># </span><span class="language-bash">为什么Active 是inactive 呢？这是因为我们的服务仅是一个简单的script 啊！</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">因此执行完毕就完毕了，不会继续存在记忆体中喔！</span><br></code></pre></td></tr></table></figure><h2 id="认识与分析日志文件">18. 认识与分析日志文件</h2><p>略</p><h2 id="启动流程模块管理与-loader">19. 启动流程、模块管理与 Loader</h2><h3 id="linux-启动流程分析">19.1 Linux 启动流程分析</h3><ol type="1"><li><p>载入BIOS的硬体信息与进行自我检测（自检），并根据设置取得第一个可启动的设备；</p></li><li><p>读取并执行第一个启动设备内MBR 的启动引导程序(bootLoader，亦即是grub2, spfdisk 等程序)；</p></li><li><p>依据boot loader 的设置载入Kernel ，Kernel会开始检测硬体与加载驱动程序；</p></li><li><p>在硬体驱动成功后，Kernel 会主动调用systemd程序，并以default.target 流程启动；</p><ul><li><p>systemd 执行sysinit.target 初始化系统及basic.target准备操作系统；</p></li><li><p>systemd 启动multi-user.target 下的本机与服务器服务；</p></li><li><p>systemd 执行multi-user.target 下的/etc/rc.d/rc.local文件；</p></li><li><p>systemd 执行multi-user.target 下的getty.target及登录服务；</p></li><li><p>systemd 执行graphical 需要的服务</p></li></ul></li></ol><h2 id="基础系统设置与备份策略">20. 基础系统设置与备份策略</h2><p>略</p><h2 id="软件安装源代码与-tarball">21. 软件安装：源代码与 Tarball</h2><h3 id="开放源代码的软件安装与升级简介">21.1开放源代码的软件安装与升级简介</h3><p>通过 configure 与 make 进行编译示意图：</p><p><imgsrc="https://linux.vbird.org/linux_basic/centos7/0520source//make_configure.gif" /></p><h3 id="使用传统程序语言进行编译的简单示例">21.2使用传统程序语言进行编译的简单示例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 编辑主程式：</span> <br>[root@study ~]# vim thanks.c <br><span class="hljs-meta prompt_">#</span><span class="language-bash">include &lt;stdio.h&gt;</span><br>int main(void)<br>&#123;<br>        printf(&quot;Hello World\n&quot;);<br>        thanks_2();<br>&#125; <br><span class="hljs-meta prompt_"># </span><span class="language-bash">上面的thanks_2(); 那一行就是呼叫副程式啦！</span><br><br>[root@study ~]# vim thanks_2.c <br><span class="hljs-meta prompt_">#</span><span class="language-bash">include &lt;stdio.h&gt;</span><br>void thanks_2(void)<br>&#123;<br>        printf(&quot;Thank you!\n&quot;);<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 开始将原始码编译成为可执行的binary file ：</span> <br>[root@study ~]# gcc -c thanks.c thanks_2.c <br>[root@study ~]# ll thanks*<br>-rw-r--r--. 1 root root 75 Sep 4 11:43 thanks_2.c<br>-rw-r--r--. 1 root root 1496 Sep 4 11:43 thanks_2.o   &lt;==编译产生的！<br>-rw-r--r--. 1 root root 91 Sep 4 11:42 thanks.c<br>-rw-r--r--. 1 root root 1560 Sep 4 11:43 thanks.o     &lt;==编译产生的！<br><br>[root@study ~]# gcc -o thanks thanks.o thanks_2.o <br>[root@study ~]# ll thanks* <br>-rwxr-xr-x. 1 root root 8572 Sep 4 11:44 thanks     &lt;==最终结果会产生这玩意儿<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3. 执行一下这个档案：</span> <br>[root@study ~]# ./thanks<br>Hello World<br>Thank you!<br></code></pre></td></tr></table></figure><p>加入链接选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# vim sin.c <br><span class="hljs-meta prompt_">#</span><span class="language-bash">include &lt;stdio.h&gt;</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">include &lt;math.h&gt;</span><br>int main(void)<br>&#123;<br>        float value;<br>        value = sin ( 3.14 / 2 );<br>        printf(&quot;%f\n&quot;,value);<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">编译</span><br>[root@study ~]# gcc sin.c <br><span class="hljs-meta prompt_"># </span><span class="language-bash">新的GCC 会主动将函数抓进来给你用，所以只要加上include &lt;math.h&gt; 就好了！</span><br><br>[root@study ~]# gcc sin.c -lm -L/lib -L/lib64   &lt;==重点在-lm <br>[root@study ~]# ./a.out                          &lt;==尝试执行新档案！<br>1.000000<br></code></pre></td></tr></table></figure><p>特别注意，使用gcc 编译时所加入的那个-lm是有意义的，他可以拆开成两部份来看：</p><ul><li>-l ：是『加入某个函式库(library)』的意思，</li><li>m ：则是libm.so 这个函式库，其中， lib 与副档名(.a或.so)不需要写</li></ul><p>所以-lm 表示使用libm.so (或libm.a) 这个函式库的意思～至于那个-L后面接的路径呢？这表示： 『我要的函式库libm.so 请到/lib 或/lib64里面搜寻！』</p><p>gcc 简易用法（编译、参数和链接）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">仅将原始码编译成为目标档，并不制作连结等功能：</span> <br>[root@study ~]# gcc -c hello.c <br><span class="hljs-meta prompt_"># </span><span class="language-bash">会自动的产生hello.o 这个档案，但是并不会产生binary 执行档。</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在编译的时候，依据作业环境给予最佳化执行速度</span><br>[root@study ~]# gcc -O hello.c -c <br><span class="hljs-meta prompt_"># </span><span class="language-bash">会自动的产生hello.o 这个档案，并且进行最佳化喔！</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在进行binary file 制作时，将连结的函式库与相关的路径填入</span><br>[root@study ~]# gcc sin.c -lm -L/lib -I/usr/include <br><span class="hljs-meta prompt_"># </span><span class="language-bash">这个指令较常下达在最终连结成binary file 的时候，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-lm 指的是libm.so 或libm.a 这个函式库档案；</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-L 后面接的路径是刚刚上面那个函式库的搜寻目录；</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-I 后面接的是原始码内的include 档案之所在目录。</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将编译的结果输出成某个特定档名</span><br>[root@study ~]# gcc -o hello hello.c <br><span class="hljs-meta prompt_"># </span><span class="language-bash">-o 后面接的是要输出的binary file 档名</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在编译的时候，输出较多的讯息说明</span><br>[root@study ~]# gcc -o hello hello.c -Wall <br><span class="hljs-meta prompt_"># </span><span class="language-bash">加入-Wall 之后，程式的编译会变的较为严谨一点，所以警告讯息也会显示出来！</span><br></code></pre></td></tr></table></figure><p>我们通常称 -Wall 或者-O这些非必要的参数为旗标(FLAGS)，因为我们使用的是C程式语言，所以有时候也会简称这些旗标为 CFLAGS</p><h3 id="用-make-进行宏编译">21.3 用 make 进行宏编译</h3><p>有以下源文件：</p><ul><li>main.c ：主要的目的是让使用者输入角度资料与呼叫其他三支副程式；</li><li>haha.c ：输出一堆有的没有的讯息而已；</li><li>sin_value.c ：计算使用者输入的角度(360) sin 数值；</li><li>cos_value.c ：计算使用者输入的角度(360) cos 数值。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 先进行目标档的编译，最终会有四个*.o 的档名出现：</span> <br>[root@study ~]# gcc -c main.c <br>[root@study ~]# gcc -c haha.c <br>[root@study ~]# gcc -c sin_value.c <br>[root@study ~]# gcc -c cos_value.c<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 再进行连结成为执行档，并加入libm 的数学函式，以产生main 执行档：</span> <br>[root@study ~]# gcc -o main main.o haha.o sin_value.o cos_value.o -lm<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3. 本程式的执行结果，必须输入姓名、360 度角的角度值来计算：</span> <br>[root@study ~]# ./main <br>Please input your name: VBird   &lt;==这里先输入名字<br>Please enter the degree angle (ex&gt; 90): 30    &lt;==输入以360 度角为主的角度<br>Hi, Dear VBird, nice to meet you.     &lt;==这三行为输出的结果喔！<br>The Sin is: 0.50<br>The Cos is: 0.87<br></code></pre></td></tr></table></figure><p>使用 make 编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 先编辑makefile 这个规则档，内容只要作出main 这个执行档</span><br>[root@study ~]# vim makefile <br>main: main.o haha.o sin_value.o cos_value.o<br>gcc -o main main.o haha.o sin_value.o cos_value.o -lm <br><span class="hljs-meta prompt_"># </span><span class="language-bash">注意：第二行的gcc 之前是&lt;tab&gt; 按键产生的空格喔！</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 尝试使用makefile 制订的规则进行编译的行为：</span> <br>[root@study ~]# rm -f main *.o    &lt;==先将之前的目标档去除<br>[root@study ~]# make<br>cc -c -o main.o main.c<br>cc -c -o haha.o haha.c<br>cc -c -o sin_value.o sin_value.c<br>cc -c -o cos_value.o cos_value.c<br>gcc -o main main.o haha.o sin_value.o cos_value.o -lm<br><span class="hljs-meta prompt_"># </span><span class="language-bash">此时make 会去读取makefile 的内容，并根据内容直接去给他编译相关的档案啰！</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3. 在不删除任何档案的情况下，重新执行一次编译的动作：</span> <br>[root@study ~]# make<br>make: `main&#x27; is up to date.<br><span class="hljs-meta prompt_"># </span><span class="language-bash">看到了吧！是否很方便呢！只会进行更新(update) 的动作而已。</span><br></code></pre></td></tr></table></figure><p>make 优点：</p><ul><li>简化编译时所需要下达的指令；</li><li>若在编译完成之后，修改了某个原始码档案，则make仅会针对被修改了的档案进行编译，其他的 object file 不会被更动；</li><li>最后可以依照相依性来更新(update) 执行档。</li></ul><p>基本的 makefile 规则：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">目标(target): 目标文件1 目标文件2</span><br>&lt;tab&gt; gcc -o 欲建立的执行文件 目标文件1 目标文件2<br></code></pre></td></tr></table></figure><p><strong>命令行必须要以tab 按键作为开头</strong>，他的规则基本上是这样的：</p><ul><li>在makefile 当中的# 代表注解；</li><li>&lt;tab&gt; 需要在命令行(例如gcc 这个编译器指令) 的第一个字符；</li><li>目标(target) 与依赖文件(就是目标文件)之间需以『:』隔开。</li></ul><p>示例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 1. 先编辑makefile 来建立新的规则，此规则的标的名称为clean ： </span><br>[root@study ~]<span class="hljs-comment"># vi makefile</span><br><span class="hljs-section">main: main.o haha.o sin_value.o cos_value.o</span><br>gcc -o main main.o haha.o sin_value.o cos_value.o -lm<br><span class="hljs-section">clean:</span><br>rm -f main main.o haha.o sin_value.o cos_value.o<br><br><span class="hljs-comment"># 2. 以新的目标(clean) 测试看看执行make 的结果： </span><br>[root@study ~]<span class="hljs-comment"># make clean   &lt;==就是这里！透过make 以clean 为标的</span><br>rm -rf main main.o haha.o sin_value.o cos_value.o<br></code></pre></td></tr></table></figure><p>如此一来，我们的makefile 里面就具有至少两个标的，分别是main 与clean，如果我们想要建立main 的话，输入『makemain』，如果想要清除有的没的，输入『make clean』即可。</p><p>使用变量：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile">[root@study ~]<span class="hljs-comment"># vi makefile </span><br>LIBS = -lm<br>OBJS = main.o haha.o sin_value.o cos_value.o<br><span class="hljs-section">main: $&#123;OBJS&#125;</span><br>        gcc -o main $&#123;OBJS&#125; $&#123;LIBS&#125;<br><span class="hljs-section">clean:</span><br>        rm -f main $&#123;OBJS&#125;<br></code></pre></td></tr></table></figure><p>与 bash shell 脚本的语法有点不同，变量的基本语法为：</p><ol type="1"><li>变量与变量内容以『=』隔开，同时两边可以具有空格；</li><li>变量左边不可以有&lt;tab&gt; ，例如上面范例的第一行LIBS左边不可以是&lt;tab&gt;；</li><li>变量与变量内容在『=』两边不能具有『:』；</li><li>在习惯上，变量最好是以『大写字母』为主；</li><li>运用变量时，以${变量} 或$(变量) 使用；</li><li>在该shell 的环境变量是可以被套用的，例如提到的CFLAGS 这个变数！</li><li>在命令行模式也可以设置变量。</li></ol><p>设置 <code>CFLAGS</code> 环境变量两种方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">方式 1</span><br>[root@study ~]# CFLAGS=&quot;-Wall&quot; make clean main <br><span class="hljs-meta prompt_"># </span><span class="language-bash">这个动作在上make 进行编译时，会去取用CFLAGS 的变数内容！</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">方式 2</span><br>[root@study ~]# vi makefile<br>LIBS = -lm<br>OBJS = main.o haha.o sin_value.o cos_value.o<br>CFLAGS = -Wall<br>main: $&#123;OBJS&#125;<br>gcc -o main $&#123;OBJS&#125; $&#123;LIBS&#125;<br>clean:<br>rm -f main $&#123;OBJS&#125;<br></code></pre></td></tr></table></figure><p>环境变量使用规则（优先级）：</p><ol type="1"><li>make 命令行后面加上的环境变量为优先；</li><li>makefile 里面指定的环境变量第二；</li><li>shell 原本具有的环境变量第三。</li></ol><p><code>$@</code>：代表目前的目标(target) ，故 makefile 也可写成</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile">[root@study ~]<span class="hljs-comment"># vi makefile</span><br>LIBS = -lm<br>OBJS = main.o haha.o sin_value.o cos_value.o<br>CFLAGS = -Wall<br><span class="hljs-section">main: $&#123;OBJS&#125;</span><br>gcc -o <span class="hljs-variable">$@</span> $&#123;OBJS&#125; $&#123;LIBS&#125;    &lt;==那个<span class="hljs-variable">$@</span> 就是main ！<br><span class="hljs-section">clean:</span><br>rm -f main $&#123;OBJS&#125;<br></code></pre></td></tr></table></figure><h2 id="软件安装-rpmsrpm-与-yum">22. 软件安装 RPM、SRPM 与 YUM</h2><h3 id="rpm-软件管理程序rpm">22.1 RPM 软件管理程序：rpm</h3><p>rpm 安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# rpm -ivh package_name<br>选项与参数：<br>-i ：install 的意思<br>-v ：察看更细部的安装资讯画面<br>-h ：以安装资讯列显示安装进度<br><br>范例一：安装原版光碟上的rp-pppoe 软体<br>[root@study ~]# rpm -ivh /mnt/Packages/rp-pppoe-3.11-5.el7.x86_64.rpm<br>Preparing... ################################# [100%]<br>Updating / installing...<br>   1:rp-pppoe-3.11-5.el7 ################################# [100%]<br><br>范例二、一口气安装两个以上的软体时： <br>[root@study ~]# rpm -ivh a.i386.rpm b.i386.rpm *.rpm <br><span class="hljs-meta prompt_"># </span><span class="language-bash">后面直接接上许多的软体档案！</span><br><br>范例三、直接由网路上面的某个档案安装，以网址来安装： <br>[root@study ~]# rpm -ivh http://website.name/path/pkgname.rpm<br></code></pre></td></tr></table></figure><p>强制安装选项：</p><table><thead><tr class="header"><th>可下达的选项</th><th>代表意义</th></tr></thead><tbody><tr class="odd"><td>--nodeps</td><td>使用时机：当发生软体属性相依问题而无法安装，但你执意安装时 危险性：软体会有相依性的原因是因为彼此会使用到对方的机制或功能，如果强制安装而不考虑软体的属性相依，则可能会造成该软体的无法正常使用！</td></tr><tr class="even"><td>--replacefiles</td><td>使用时机：如果在安装的过程当中出现了『某个档案已经被安装在你的系统上面』的资讯，又或许出现版本不合的讯息(confilctingfiles) 时，可以使用这个参数来直接覆盖档案。 危险性：覆盖的动作是无法复原的！所以，你必须要很清楚的知道被覆盖的档案是真的可以被覆盖喔！否则会欲哭无泪！</td></tr><tr class="odd"><td>--replacepkgs</td><td>使用时机： 重新安装某个已经安装过的软体！如果你要安装一堆RPM软体档案时，可以使用rpm -ivh *.rpm ，但若某些软体已经安装过了，此时系统会出现『某软体已安装』的资讯，导致无法继续安装。此时可使用这个选项来重复安装喔！</td></tr><tr class="even"><td>--force</td><td>使用时机：这个参数其实就是--replacefiles 与--replacepkgs的综合体！</td></tr><tr class="odd"><td>--test</td><td>使用时机： 想要测试一下该软体是否可以被安装到使用者的Linux环境当中，可找出是否有属性相依的问题。范例为： rpm -ivh pkgname.i386.rpm--test</td></tr><tr class="even"><td>--justdb</td><td>使用时机： 由于RPM资料库破损或者是某些缘故产生错误时，可使用这个选项来更新软体在资料库内的相关资讯。</td></tr><tr class="odd"><td>--nosignature</td><td>使用时机： 想要略过数位签章的检查时，可以使用这个选项。</td></tr><tr class="even"><td>--prefix 新路径</td><td>使用时机：要将软体安装到其他非正规目录时。举例来说，你想要将某软体安装到/usr/local而非正规的/bin, /etc 等目录， 就可以使用『 --prefix /usr/local』来处理了。</td></tr><tr class="odd"><td>--noscripts</td><td>使用时机：不想让该软体在安装过程中自行执行某些系统指令。 说明： RPM的优点除了可以将档案放置到定位之外，还可以自动执行一些前置作业的指令，例如资料库的初始化。如果你不想要让RPM帮你自动执行这一类型的指令，就加上他吧！</td></tr></tbody></table><p>rpm 升级与更新：</p><table><thead><tr class="header"><th>-Uvh</th><th>后面接的软体即使没有安装过，则系统将予以直接安装；若后面接的软体有安装过旧版，则系统自动更新至新版；</th></tr></thead><tbody><tr class="odd"><td>-Fvh</td><td>如果后面接的软体并未安装到你的Linux系统上，则该软体不会被安装；亦即只有已安装至你 Linux系统内的软体会被『升级』！</td></tr></tbody></table><p>rpm 查询：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# rpm -qa                               &lt;==已安装软体<br>[root@study ~]# rpm -q[licdR] 已安装的软体名称       &lt;==已安装软体<br>[root@study ~]# rpm -qf 存在于系统上面的某个档名     &lt;==已安装软体<br>[root@study ~]# rpm -qp[licdR] 未安装的某个档案名称  &lt;==查阅RPM档案<br>选项与参数：<br>查询已安装软体的资讯：<br>-q ：仅查询，后面接的软体名称是否有安装；<br>-qa ：列出所有的，已经安装在本机Linux 系统上面的所有软体名称；<br>-qi ：列出该软体的详细资讯(information)，包含开发商、版本与说明等；<br>-ql ：列出该软体所有的档案与目录所在完整档名(list)；<br>-qc ：列出该软体的所有设定档(找出在/etc/ 底下的档名而已)<br>-qd ：列出该软体的所有说明档(找出与man 有关的档案而已)<br>-qR ：列出与该软体有关的相依软体所含的档案(Required 的意思)<br>-qf ：由后面接的档案名称，找出该档案属于哪一个已安装的软体；<br>-q --scripts：列出是否含有安装后需要执行的脚本档，可用以debug 喔！<br>查询某个RPM 档案内含有的资讯：<br>-qp[icdlR]：注意-qp 后面接的所有参数以上面的说明一致。但用途仅在于找出<br>    某个RPM 档案内的资讯，而非已安装的软体资讯！注意！<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs shell">范例一：找出你的Linux 是否有安装logrotate 这个软体？<br>[root@study ~]# rpm -q logrotate<br>logrotate-3.8.6-4.el7.x86_64<br>[root@study ~]# rpm -q logrotating<br>package logrotating is not installed<br><span class="hljs-meta prompt_"># </span><span class="language-bash">注意到，系统会去找是否有安装后面接的软体名称。注意，不必要加上版本喔！</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">至于显示的结果，一看就知道有没有安装啦！</span><br><br>范例二：列出上题当中，属于该软体所提供的所有目录与档案： <br>[root@study ~]# rpm -ql logrotate<br>/etc/cron.daily/logrotate<br>/etc/logrotate.conf<br>....(以下省略).... <br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以看出该软体到底提供了多少的档案与目录，也可以追踪软体的资料。</span><br><br>范例三：列出logrotate 这个软体的相关说明资料： <br>[root@study ~]# rpm -qi logrotate <br>Name : logrotate                           # 软体名称<br>Version : 3.8.6                               # 软体的版本<br>Release : 4.el7                               # 释出的版本<br>Architecture: x86_64                              # 编译时所针对的硬体等级<br>Install Date: Mon 04 May 2015 05:52:36 PM CST     # 这个软体安装到本系统的时间<br>Group : System Environment/Base             # 软体是放再哪一个软体群组中<br>Size : 102451                              # 软体的大小<br>License : GPL+                                # 释出的授权方式<br>Signature : RSA/SHA256, Fri 04 Jul 2014 11:34:56 AM CST, Key ID 24c6a8a7f4a80eb5<br>Source RPM : logrotate-3.8.6-4.el7.src.rpm       # 这就是SRPM 的档名<br>Build Date : Tue 10 Jun 2014 05:58:02 AM CST     # 软体编译打包的时间<br>Build Host : worker1.bsys.centos.org             # 在哪一部主机上面编译的<br>Relocations : (not relocatable)   <br>Packager : CentOS BuildSystem &lt;http://bugs.centos.org&gt;<br>Vendor : CentOS<br>URL : https://fedorahosted.org/logrotate/<br>Summary : Rotates, compresses, removes and mails system log files<br>Description :                                     # 这个是详细的描述！<br>The logrotate utility is designed to simplify the administration of<br>log files on a system which generates a lot of log files. Logrotate<br>allows for the automatic rotation compression, removal and mailing of<br>log files. Logrotate can be set to handle a log file daily, weekly,<br>monthly or when the log file gets to a certain size. Normally,<br>logrotate runs as a daily cron job.<br><br>Install the logrotate package if you need a utility to deal with the<br>log files on your system.<br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出该软体的information (资讯)，里面的资讯可多著呢，包括了软体名称、</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">版本、开发商、SRPM档案名称、打包次数、简单说明资讯、软体打包者、</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装日期等等！如果想要详细的知道该软体的资料，用这个参数来了解一下</span><br><br>范例四：分别仅找出logrotate 的设定档与说明档<br>[root@study ~]# rpm -qc logrotate <br>[root@study ~]# rpm -qd logrotate<br><br>范例五：若要成功安装logrotate ，他还需要什么档案的帮忙？<br>[root@study ~]# rpm -qR logrotate<br>/bin/sh<br>config(logrotate) = 3.8.6-4.el7<br>coreutils &gt;= 5.92<br>....(以下省略)....<br><span class="hljs-meta prompt_"># </span><span class="language-bash">由这里看起来，呵呵～还需要很多档案的支援才行喔！</span><br><br>范例六：由上面的范例五，找出/bin/sh 是那个软体提供的？<br>[root@study ~]# rpm -qf /bin/sh<br>bash-4.2.46-12.el7.x86_64<br><span class="hljs-meta prompt_"># </span><span class="language-bash">这个参数后面接的可是『档案』呐！不像前面都是接软体喔！</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这个功能在查询系统的某个档案属于哪一个软体所有的。</span><br><br>范例七：假设我有下载一个RPM 档案，想要知道该档案的需求档案，该如何？<br>[root@study ~]# rpm -qpR filename.i386.rpm <br><span class="hljs-meta prompt_"># </span><span class="language-bash">加上-qpR ，找出该档案需求的资料！</span><br></code></pre></td></tr></table></figure><p>rpm 卸载与重建数据库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 找出与pam 有关的软体名称，并尝试移除pam 这个软体：</span> <br>[root@study ~]# rpm -qa | grep pam<br>fprintd-pam-0.5.0-4.0.el7_0.x86_64<br>pam-1.1.8-12.el7.x86_64<br>gnome-keyring-pam-3.8.2-10.el7.x86_64<br>pam-devel-1.1.8-12.el7.x86_64<br>pam_krb5-2.4.8-4.el7.x86_64<br>[root@study ~]# rpm -e pam <br>error: Failed dependencies:   &lt;==这里提到的是相依性的问题<br>        libpam.so.0()(64bit) is needed by (installed) systemd-libs-208-20.el7.x86_64<br>        libpam.so.0()(64bit) is needed by (installed) libpwquality-1.2.3-4.el7.x86_64<br>....(以下省略)....<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 若仅移除pam-devel 这个之前范例安装上的软体呢？</span><br>[root@study ~]# rpm -e pam-devel   &lt;==不会出现任何讯息！<br>[root@study ~]# rpm -q pam-devel<br>package pam-devel is not installed<br><br>[root@study ~]# rpm --rebuilddb    &lt;==重建数据库<br></code></pre></td></tr></table></figure><h3 id="yum-在线升级功能">22.2 YUM 在线升级功能</h3><p>查询：yum [list|info|search|provides|whatprovides] 参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# yum [option] [查询工作项目] [相关参数]<br>选项与参数：<br>[option]：主要的选项，包括有：<br>  -y ：当yum 要等待使用者输入时，这个选项可以自动提供yes 的回应；<br>  --installroot=/some/path ：将该软体安装在/some/path 而不使用预设路径<br>[查询工作项目] [相关参数]：这方面的参数有：<br>  search ：搜寻某个软体名称或者是描述(description) 的重要关键字；<br>  list ：列出目前yum 所管理的所有的软体名称与版本，有点类似rpm -qa；<br>  info ：同上，不过有点类似rpm -qai 的执行结果；<br>  provides：从档案去搜寻软体！类似rpm -qf 的功能！<br><br>范例一：搜寻磁碟阵列(raid) 相关的软体有哪些？<br>[root@study ~]# yum search raid <br>Loaded plugins: fastestmirror, langpacks       # yum 系统自己找出最近的yum server <br>Loading mirror speeds from cached hostfile     # 找出速度最快的那一部yum server <br> * base: ftp.twaren.net                        # 底下三个软体库，且来源为该伺服器！<br> * extras: ftp.twaren.net<br> * updates: ftp.twaren.net<br>....(前面省略)....<br>dmraid-events-logwatch.x86_64 : dmraid logwatch-based email reporting<br>dmraid-events.x86_64 : dmevent_tool (Device-mapper event tool) and DSO<br>iprutils.x86_64 : Utilities for the IBM Power Linux RAID adapters<br>mdadm.x86_64 : The mdadm program controls Linux md devices (software RAID arrays)<br>....(后面省略)....<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在冒号(:) 左边的是软体名称，右边的则是在RPM 内的name 设定(软体名)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">瞧！上面的结果，这不就是与RAID 有关的软体吗？如果想了解mdadm 的软体内容呢？</span><br><br>范例二：找出mdadm 这个软体的功能为何<br>[root@study ~]# yum info mdadm <br>Installed Packages        &lt;==这说明该软体是已经安装的了<br>Name : mdadm       &lt;==这个软体的名称<br>Arch : x86_64      &lt;==这个软体的编译架构<br>Version : 3.3.2       &lt;==此软体的版本<br>Release : 2.el7       &lt;==释出的版本<br>Size : 920 k       &lt;==此软体的档案总容量<br>Repo : installed   &lt;==软体库回报说已安装的<br>From repo : anaconda<br>Summary : The mdadm program controls Linux md devices (software RAID arrays)<br>URL : http://www.kernel.org/pub/linux/utils/raid/mdadm/<br>License : GPLv2+<br>Description : The mdadm program is used to create, manage, and monitor Linux MD (software<br>            : RAID) devices. As such, it provides similar functionality to the raidtools<br>            : package. However, mdadm is a single program, and it can perform<br>            : almost all functions without a configuration file, though a configuration<br>            : file can be used to help with some common tasks.<br><span class="hljs-meta prompt_"># </span><span class="language-bash">不要跟我说，上面说些啥？自己找字典翻一翻吧！拜托拜托！</span><br><br>范例三：列出yum 伺服器上面提供的所有软体名称<br>[root@study ~]# yum list <br>Installed Packages    &lt;==已安装软体<br>GConf2.x86_64 3.2.6-8.el7 @anaconda<br>LibRaw.x86_64 0.14.8-5.el7.20120830git98d925 @base<br>ModemManager.x86_64 1.1.0-6.git20130913.el7 @anaconda<br>....(中间省略).... <br>Available Packages    &lt;==还可以安装的其他软体<br>389-ds-base.x86_64 1.3.3.1-20.el7_1 updates<br>389-ds-base-devel.x86_64 1.3.3.1-20.el7_1 updates<br>389-ds-base-libs.x86_64 1.3.3.1-20.el7_1 updates<br>....(底下省略)....<br><span class="hljs-meta prompt_"># </span><span class="language-bash">上面提供的意义为：『 软体名称版本在那个软体库内』</span><br><br>范例四：列出目前伺服器上可供本机进行升级的软体有哪些？<br>[root@study ~]# yum list updates   &lt;==一定要是update s喔！<br>Updated Packages<br>NetworkManager.x86_64 1:1.0.0-16.git20150121.b4ea599c.el7_1 updates<br>NetworkManager-adsl.x86_64 1:1.0.0-16.git20150121.b4ea599c.el7_1 updates<br>....(底下省略)....<br><span class="hljs-meta prompt_"># </span><span class="language-bash">上面就列出在那个软体库内可以提供升级的软体与版本！</span><br><br>范例五：列出提供passwd 这个档案的软体有哪些<br>[root@study ~]# yum provides passwd<br>passwd-0.79-4.el7.x86_64 : An utility for setting or changing passwords using PAM<br>Repo : base<br><br>passwd-0.79-4.el7.x86_64 : An utility for setting or changing passwords using PAM<br>Repo : @anaconda<br><span class="hljs-meta prompt_"># </span><span class="language-bash">找到啦！就是上面的这个软体提供了passwd 这个程式！</span><br></code></pre></td></tr></table></figure><p>安装/升级：yum [install|update] 软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# yum [option] [安装与升级的工作项目] [相关参数]<br>选项与参数：<br>  install ：后面接要安装的软体！<br>  update ：后面接要升级的软体，若要整个系统都升级，就直接update 即可<br><br>范例一：将前一个练习找到的未安装的pam-devel 安装起来<br>[root@study ~]# yum install pam-devel <br>Loaded plugins: fastestmirror, langpacks     # 首先的5 行在找出最快的yum server<br>Loading mirror speeds from cached hostfile<br> * base: ftp.twaren.net<br> * extras: ftp.twaren.net<br> * updates: ftp.twaren.net<br>Resolving Dependencies                       # 接下来先处理『属性相依』的软体问题<br><span class="hljs-meta prompt_">--&gt; </span><span class="language-bash">Running transaction check</span><br><span class="hljs-meta prompt_">---&gt; </span><span class="language-bash">Package pam-devel.x86_64 0:1.1.8-12.el7_1.1 will be installed</span><br><span class="hljs-meta prompt_">--&gt; </span><span class="language-bash">Processing Dependency: pam(x86-64) = 1.1.8-12.el7_1.1 <span class="hljs-keyword">for</span> package: pam-devel-</span><br>       1.1.8-12.el7_1.1.x86_64<br><span class="hljs-meta prompt_">--&gt; </span><span class="language-bash">Running transaction check</span><br><span class="hljs-meta prompt_">---&gt; </span><span class="language-bash">Package pam.x86_64 0:1.1.8-12.el7 will be updated</span><br><span class="hljs-meta prompt_">---&gt; </span><span class="language-bash">Package pam.x86_64 0:1.1.8-12.el7_1.1 will be an update</span><br><span class="hljs-meta prompt_">--&gt; </span><span class="language-bash">Finished Dependency Resolution</span><br>Dependencies Resolved<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">由上面的检查发现到pam 这个软体也需要同步升级，这样才能够安装新版pam-devel 喔！</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">至于底下则是一个总结的表格显示！</span><br>==========================================================================================<br> Package Arch Version Repository Size<br>==========================================================================================<br>Installing:<br> pam-devel x86_64 1.1.8-12.el7_1.1 updates 183 k<br>Updating for dependencies:<br> pam x86_64 1.1.8-12.el7_1.1 updates 714 k<br><br>Transaction Summary<br>==========================================================================================<br>Install 1 Package                           # 要安装的是一个软体<br>Upgrade ( 1 Dependent package)   # 因为相依属性问题，需要额外加装一个软体！<br><br>Total size: 897 k<br>Total download size: 183 k                   # 总共需要下载的容量！<br>Is this ok [y/d/N]: y    # 你得要自己决定是否要下载与安装！当然是y 啊！<br>Downloading packages:                        # 开始下载啰！<br>warning: /var/cache/yum/x86_64/7/updates/packages/pam-devel-1.1.8-12.el7_1.1.x86_64.rpm:<br>         Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEY<br>Public key for pam-devel-1.1.8-12.el7_1.1.x86_64.rpm is not installed<br>pam-devel-1.1.8-12.el7_1.1.x86_64.rpm | 183 kB 00:00:00<br>Retrieving key from file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7<br>Importing GPG key 0xF4A80EB5:<br> Userid : &quot;CentOS-7 Key (CentOS 7 Official Signing Key) &lt;security@centos.org&gt;&quot;<br> Fingerprint: 6341 ab27 53d7 8a78 a7c2 7bb1 24c6 a8a7 f4a8 0eb5<br> Package : centos-release-7-1.1503.el7.centos.2.8.x86_64 (@anaconda)<br> From : /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7<br>Is this ok [y/N]: y   # 只有在第一次安装才会出现这个项目『确定要安装数位签章』才能继续！<br>Running transaction check<br>Running transaction test<br>Transaction test succeeded<br>Running transaction<br>Warning: RPMDB altered outside of yum.<br>  Updating : pam-1.1.8-12.el7_1.1.x86_64 1/3<br>  Installing : pam-devel-1.1.8-12.el7_1.1.x86_64 2/3<br>  Cleanup : pam-1.1.8-12.el7.x86_64 3/3<br>  Verifying : pam-1.1.8-12.el7_1.1.x86_64 1/3<br>  Verifying : pam-devel-1.1.8-12.el7_1.1.x86_64 2/3<br>  Verifying : pam-1.1.8-12.el7.x86_64 3/3<br><br>Installed:<br>  pam-devel.x86_64 0:1.1.8-12.el7_1.1<br><br>Dependency Updated:<br>  pam.x86_64 0:1.1.8-12.el7_1.1<br><br>Complete!<br></code></pre></td></tr></table></figure><p>删除：yum [remove] 软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# yum remove pam-devel<br>Loaded plugins: fastestmirror, langpacks<br>Resolving Dependencies    &lt;==同样的，先解决属性相依的问题<br><span class="hljs-meta prompt_">--&gt; </span><span class="language-bash">Running transaction check</span><br><span class="hljs-meta prompt_">---&gt; </span><span class="language-bash">Package pam-devel.x86_64 0:1.1.8-12.el7_1.1 will be erased</span><br><span class="hljs-meta prompt_">--&gt; </span><span class="language-bash">Finished Dependency Resolution</span><br><br>Dependencies Resolved<br><br>==========================================================================================<br> Package Arch Version Repository Size<br>==========================================================================================<br>Removing:<br> pam-devel x86_64 1.1.8-12.el7_1.1 @updates 528 k<br><br>Transaction Summary<br>==========================================================================================<br>Remove 1 Package        # 还好！没有相依属性的问题，仅移除一个软体！<br><br>Installed size: 528 k<br>Is this ok [y/N]: y<br>Downloading packages:<br>Running transaction check<br>Running transaction test<br>Transaction test succeeded<br>Running transaction<br>  Erasing : pam-devel-1.1.8-12.el7_1.1.x86_64 1/1<br>  Verifying : pam-devel-1.1.8-12.el7_1.1.x86_64 1/1<br><br>Removed:<br>  pam-devel.x86_64 0:1.1.8-12.el7_1.1<br><br>Complete!<br></code></pre></td></tr></table></figure><h2 id="x-window-设置介绍">23. X Window 设置介绍</h2><p>略</p><h2 id="linux-内核编译与管理">24. Linux 内核编译与管理</h2><p>略</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>命令行</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux 命令行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一文读懂 C++ 运算符重载</title>
    <link href="/2023/02/19/%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82-C-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    <url>/2023/02/19/%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82-C-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<p>运算符重载是 C++语言的一个特性，利用运算符重载能够写出更加简洁的代码，对外封装类的实现细节。本文介绍运算符重载相关知识点。</p><p>谈到运算符重载，还需要从 “<strong>函数重载</strong>”说起。函数重载是指函数名相同，但函数参数类型、参数数量不同（返回类型相同）的函数。比如实现某种数据类型向string 类型运算的函数： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 函数重载示例</span><br><span class="hljs-function">string <span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-type">double</span> d)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-type">float</span> d)</span></span>;<br><span class="hljs-comment">// 等等</span><br></code></pre></td></tr></table></figure> 这就是典型的函数重载。</p><p>运算符重载本质上也是函数重载，它们可以看做函数名为<code>operator+</code>、<code>operator-</code>、<code>operator*</code>、<code>operator++</code>、<code>operator&lt;&lt;</code>等等的函数。重载即体现在函数名相同，但函数参数类型不同。当然，一些运算符也允许参数数量不同的重载，典型的就是函数调用运算符<code>operator()</code>的重载。</p><p>利用函数重载可以实现更好的封装，同时提高代码的简洁度。例如，我们要实现一个大整数类，用于支持高精度运算，如果没有运算符重载，我们只能按照如下方式实现：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BigNum</span>&#123;<br>    <span class="hljs-comment">// 相关数据成员声明</span><br>&#125;；<br><span class="hljs-function">BigNum <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">const</span> BigNum &amp;,<span class="hljs-type">const</span> BigNum &amp;)</span></span>;  <span class="hljs-comment">// 加法   </span><br><span class="hljs-function">BigNum <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-type">const</span> BigNum &amp;,<span class="hljs-type">const</span> BigNum &amp;)</span></span>;  <span class="hljs-comment">// 减法   </span><br><span class="hljs-function">BigNum <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-type">const</span> BigNum &amp;,<span class="hljs-type">const</span> BigNum &amp;)</span></span>;  <span class="hljs-comment">// 乘法   </span><br><span class="hljs-function">BigNum <span class="hljs-title">div</span><span class="hljs-params">(<span class="hljs-type">const</span> BigNum &amp;,<span class="hljs-type">const</span> BigNum &amp;)</span></span>;  <span class="hljs-comment">// 除法   </span><br><span class="hljs-function">BigNum <span class="hljs-title">mod</span><span class="hljs-params">(<span class="hljs-type">const</span> BigNum &amp;,<span class="hljs-type">const</span> BigNum &amp;)</span></span>;  <span class="hljs-comment">// 取模   </span><br></code></pre></td></tr></table></figure> 进行函数调用时，则是以下形式： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">BigNum n1, n2, n3;<br>n3 = <span class="hljs-built_in">add</span>(n1, n2);  <span class="hljs-comment">// 显式函数调用</span><br></code></pre></td></tr></table></figure>利用运算符重载，则实现方式如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BigNum</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 相关数据成员</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">friend</span> BigNum <span class="hljs-keyword">operator</span>+ (<span class="hljs-type">const</span> BigNum&amp;, <span class="hljs-type">const</span> BigNum &amp;);    <span class="hljs-comment">// 加法  </span><br>    <span class="hljs-keyword">friend</span> BigNum <span class="hljs-keyword">operator</span>- (<span class="hljs-type">const</span> BigNum&amp;, <span class="hljs-type">const</span> BigNum &amp;);    <span class="hljs-comment">// 减法  </span><br>    <span class="hljs-keyword">friend</span> BigNum <span class="hljs-keyword">operator</span>* (<span class="hljs-type">const</span> BigNum&amp;, <span class="hljs-type">const</span> BigNum &amp;);    <span class="hljs-comment">// 乘法  </span><br>    <span class="hljs-comment">// 略</span><br>&#125;;<br><span class="hljs-comment">// 进行加法运算</span><br>BigNum n1, n2, n3;<br>n3 = n1 + n2;  <span class="hljs-comment">// 直接使用 + 运算符即可，相当于调用 operator+ 函数</span><br></code></pre></td></tr></table></figure>由上面两种实现方式和调用方式，不难看出运算符重载的优点：封装与简洁（对使用者而言的简洁，对类的设计者而言工作量增加）。</p><p>知道了上面的基础知识，我们正式进入 C++运算符重载的主题，重点介绍运算符重载的语法特点和一些需要注意的问题。（下文以<em>TypeName</em> 代表自定义类型名，如上面的 <em>BigNum</em> ）</p><h2 id="重载输出运算符">1. 重载输出运算符 &lt;&lt;</h2><p>输入输出运算符的重载是为了更加方便的输入/输出数据。其语法规则如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 类内声明友元</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 相关成员定义 略</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt; (ostream &amp;, <span class="hljs-type">const</span> TypeName &amp;);    <br>&#125;;<br><span class="hljs-comment">// 类外定义函数</span><br>ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt; (ostream &amp;os, <span class="hljs-type">const</span> TypeName &amp;temp)<br>&#123;<br>    <span class="hljs-comment">// 具体实现 略</span><br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>注意点如下：</p><ol type="1"><li>形参 1 ：<strong>ostream &amp;类型</strong>，非 const 引用</li><li>形参 2 ：<strong>const 引用类型</strong>。const是因为输出运算符一般不应该改变对象的的状态；使用引用类型是处于性能与效率的考虑，减少调用时对象的拷贝，从而提高程序运行效率</li><li>返回类型： <strong>ostream 引用</strong>，这是为了能够连续输出</li><li>一般定义为友元</li></ol><h2 id="重载输入运算符">2. 重载输入运算符 &gt;&gt;</h2><p>输入运算符与输出运算符比较相似，其语法规则如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 类内声明友元与上面输出运算符类似 此处略</span><br><span class="hljs-comment">// 类外实现如下</span><br>istream &amp; <span class="hljs-keyword">operator</span>&gt;&gt; (istream &amp;is, TypeName &amp;temp) <br>&#123;<br>    <span class="hljs-comment">// 具体实现 略</span><br>    <span class="hljs-keyword">return</span> is;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>注意点如下：</p><ol type="1"><li>形参 1 ：<strong>istream &amp;类型</strong>, 同样是非 const引用类型</li><li>形参 2 ：<strong>非 const 引用</strong>，之所以是非 const是因为输入一般要改变对象内部状态；之所以是引用类型是因为要改变形参对象本身</li><li>返回类型：与输出运算符重载类型，返回引用，目的是能够连续输入</li><li>一般定义为友元</li></ol><h2 id="重载算术和关系运算符">3. 重载算术和关系运算符</h2><p>实际上，算术和关系运算符重载有两种实现方法，即重载是定义为成员函数还是定义为非成员函数（友元）。以加法为例说明如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 方法 1 ：非成员函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 类内声明</span><br>    <span class="hljs-keyword">friend</span> TypeName <span class="hljs-keyword">operator</span>+ (<span class="hljs-type">const</span> TypeName &amp;, <span class="hljs-type">const</span> TypeName &amp;);   <br>&#125;;<br><span class="hljs-comment">// 类外定义</span><br>TypeName <span class="hljs-keyword">operator</span>+ (<span class="hljs-type">const</span> TypeName &amp;lop, <span class="hljs-type">const</span> TypeName &amp;rop)<br>&#123;<br>    <span class="hljs-comment">// 略</span><br>&#125;<br><br><span class="hljs-comment">// 方法 2： 成员函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    TypeName <span class="hljs-keyword">operator</span>+ (<span class="hljs-type">const</span> TypeName &amp;rop)<br>    &#123;<br>        <span class="hljs-comment">// 略</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>一般情况下，这两种方式差别不大，但是当类含有一个接收普通类型的构造函数时，第一种实现方法更好，这是因为非成员函数允许对左侧或者右侧的运算对象进行类型转换（即调用构造函数由普通类型构造类的对象）；而成员函数方式只允许对右侧运算对象进行类型转换。按照《C++Primer 第五版》一书的说法，推荐以非成员函数方式实现。</p><h3 id="算术运算符">3.1 算术运算符</h3><p>我们以加法为例介绍算术运算符重载。语法规则如下：(实际上这段代码和上面方法1 代码相同) <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 类内声明</span><br>    <span class="hljs-keyword">friend</span> TypeName <span class="hljs-keyword">operator</span>+ (<span class="hljs-type">const</span> TypeName &amp;, <span class="hljs-type">const</span> TypeName &amp;);   <br>&#125;;<br><span class="hljs-comment">// 类外定义</span><br>TypeName <span class="hljs-keyword">operator</span>+ (<span class="hljs-type">const</span> TypeName &amp;lop, <span class="hljs-type">const</span> TypeName &amp;rop)<br>&#123;<br>    <span class="hljs-comment">// 略</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p>注意点如下：</p><ol type="1"><li>参数类型：两个形参都为 <strong>const &amp;类型</strong>,这是因为算术运算符不改变运算对象本身；同时引用减少拷贝提高效率</li><li>返回值类型：返回一个经算术运算后生成的临时对象</li></ol><h3 id="关系运算符">3.2 关系运算符</h3><p>关系运算符很多，包括：<code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code>共6 种。它们的实现方式同样推荐方法 1，即以非成员函数方式实现。它们的参数类型都是 <strong>const引用类型</strong> ，返回值都是 <strong>bool 类型</strong>。</p><p>这 6种关系运算符实际上存在逻辑上的转换关系，因此在实际编程中，往往采用如下方式实现这些运算符重载：</p><ul><li>首先实现 <code>==</code> 运算符</li><li>利用 <code>==</code> 实现 <code>!=</code> 运算符，即<code>a != b</code> 相当于 <code>!(a == b)</code></li><li>实现 <code>&lt;</code> 运算符</li><li>实现 <code>&gt;</code> 运算符</li><li>利用 <code>&lt;</code> 和 <code>==</code> 实现 <code>&lt;=</code>运算符，即 <code>a &lt;= b</code> 相当于<code>(a &lt; b || a == b)</code> (当然，也可以用<code>!(a &gt; b)</code> 实现)</li><li>利用 <code>&gt;</code> 和 <code>==</code> 实现 <code>&gt;=</code>运算符，即 <code>a &gt;= b</code> 相当于<code>(a &gt; b || a == b)</code> (当然，也可以用<code>!(a &lt; b)</code> 实现)</li></ul><p>实际上，除了上述实现方式也有其他方法，如 <code>a == b</code> 相当于<code>!( (a&gt;b) || (a&lt;b) )</code>，其他运算符也有另外实现方式，只须符合逻辑规则即可，这里不赘述。</p><p>下面以 <code>==</code> 为例给出语法规则： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 类内声明</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>== (<span class="hljs-type">const</span> TypeName &amp;, <span class="hljs-type">const</span> TypeName &amp;);   <br>&#125;;<br><span class="hljs-comment">// 类外定义</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>== (<span class="hljs-type">const</span> TypeName &amp;lop, <span class="hljs-type">const</span> TypeName &amp;rop)<br>&#123;<br>    <span class="hljs-comment">// 略</span><br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="重载赋值运算符">4. 重载赋值运算符</h2><p>赋值运算符分为两种，一为普通的赋值运算符<code>=</code>；二为复合赋值运算符，如<code>+=</code>、<code>-=</code>等。其中，普通赋值运算符又分为拷贝赋值和移动赋值，它们实际上更应该归类与类的拷贝控制。公众号此前写过文章介绍类的拷贝控制，其中包括拷贝赋值和移动赋值运算符介绍：<ahref="https://mp.weixin.qq.com/s/Q80xH9ZlLbgXCpXTmrNUYQ">《浅谈 C++类的拷贝控制》</a>。普通赋值运算符的重载必须为类的成员函数。此外，赋值运算符的也可以重载其它参数类型，如C++ 标准库提供的初始化列表类型<code>initializer_list&lt;TypeName&gt;</code>，不过其不是本文重点，相关资料请自行查阅。</p><p>下面重点介绍复合赋值运算符的重载。复合赋值运算符不是必须定义为类的成员，但是绝大多数情况下，最好定义为类的成员函数。其语法规则如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">TypeName &amp; <span class="hljs-keyword">operator</span>+= (<span class="hljs-type">const</span> TypeName &amp;rop)<br>&#123;<br>    <span class="hljs-comment">// 具体实现 略</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>注意点如下：</p><ol type="1"><li>形参类型：<strong>const 引用类型</strong></li><li>返回值类型：<strong>引用类型</strong>，这是为了与 C++内置与普通数据成员的复合赋值运算符保持一致的特性，即返回引用类型，在代码中体现为<code>return *this</code></li><li>所有复合赋值运算符都应该定义在类内部，作为成员函数</li></ol><h2 id="重载下标运算符">5. 重载下标运算符 [ ]</h2><p>下标运算符必须是成员函数。其语法规则如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 不完全正确版本</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 略</span><br><span class="hljs-keyword">public</span>:<br>    ReturnType &amp; <span class="hljs-keyword">operator</span>[] (<span class="hljs-type">int</span> i)<br>    &#123;<br>        <span class="hljs-comment">// 略</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 代码中<code>ReturnType</code> 代表返回类型，一般取决于类内部数据成员类型。以C++ 提供的 <code>vector</code> 为例，<code>vector&lt;T&gt;</code>类型的下标运算符返回类型为<code>T &amp;</code>。这样我们就可以通过下标运算符修改数据成员。</p><p>注意点如下：</p><ol type="1"><li>参数类型：一般为整型，代表下标</li><li>返回值类型：一般返回<strong>引用类型</strong></li><li>对于 const 类型数据，其下标运算符应该返回 <strong>const引用类型</strong>。因此，在类中应该定义下标运算符的 const 和非 const两个版本重载函数，代码如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 正确版本</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 略</span><br><span class="hljs-keyword">public</span>:<br>    ReturnType &amp; <span class="hljs-keyword">operator</span>[] (<span class="hljs-type">int</span> i)  <span class="hljs-comment">// 非 const  </span><br>    &#123;<br>        <span class="hljs-comment">// 略</span><br>    &#125;<br>    <span class="hljs-comment">// const 类型重载</span><br>    <span class="hljs-type">const</span> ReturnType &amp; <span class="hljs-keyword">operator</span>[] (<span class="hljs-type">int</span> i) <span class="hljs-type">const</span>  <br>    &#123;<br>        <span class="hljs-comment">// 略</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="重载递增和递减运算符---">6. 重载递增和递减运算符 ++ --</h2><p>递增递减运算符分前置和后置两个版本，它们一般应该定义为类的成员。前置与后置版本二者差别较大，下面以<code>++</code> 运算符为例分别介绍。</p><h3 id="前置版本递增递减运算符">6.1 前置版本递增/递减运算符</h3><p>前置版本递增运算符重载语法规则如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    TypeName &amp; <span class="hljs-keyword">operator</span>++ ()<br>    &#123;<br>        <span class="hljs-comment">// 具体实现</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><p>注意点如下：</p><ol type="1"><li>无参函数</li><li>返回值类型：<strong>引用类型</strong>，代码中<code>return *this</code> 体现</li></ol><h3 id="后置版本递增递减运算符">6.2 后置版本递增/递减运算符</h3><p>后置版本递增运算符重载语法规则如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    TypeName <span class="hljs-keyword">operator</span>++ (<span class="hljs-type">int</span>)<br>    &#123;<br>        <span class="hljs-comment">// 具体实现</span><br>        <span class="hljs-keyword">return</span> 自增前的对象;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><p>注意点如下：</p><ol type="1"><li>参数类型： <code>int</code> ，不过，这个 <code>int</code>放在函数形参列表只是为了区分前置与后置， <code>int</code>形参在函数内部不需要用到，因此也不必给出标识符</li><li>返回值类型：<strong>普通类型</strong>，返回递增/递减前保存的临时对象</li><li><strong>后置版本一般利用前置版本实现</strong>，示例代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    TypeName &amp; <span class="hljs-keyword">operator</span>++ ()<br>    &#123;<br>        <span class="hljs-comment">// 具体实现</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <br>    TypeName <span class="hljs-keyword">operator</span>++ (<span class="hljs-type">int</span>)<br>    &#123;<br>        TypeName temp = *<span class="hljs-keyword">this</span>;<br>        ++*<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 调用前置版本++</span><br>        <span class="hljs-keyword">return</span> temp;  <span class="hljs-comment">// 返回递增前保存的临时对象</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h2 id="重载成员访问运算符--">7. 重载成员访问运算符 -&gt; *</h2><p>成员访问运算符包括两个：对于指针的 <code>-&gt;</code> 以及对于对象的<code>*</code> 。<code>-&gt;</code> 必须是类的成员；<code>*</code>通常是类的成员，但并非必须如此。它们的重载函数通常定义为 const的，语法规则如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ReturnType1 <span class="hljs-keyword">operator</span>* () <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-comment">// 具体实现</span><br>        <span class="hljs-comment">// 可返回任意类型</span><br>    &#125;<br>    <br>    ReturnType2 <span class="hljs-keyword">operator</span>-&gt; () <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-comment">// 具体实现</span><br>        <span class="hljs-comment">// 必须返回类的指针或者自定义了箭头运算符的某个类的对象  </span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>成员访问运算符重载一般用的比较少，这里仅做简要介绍。实际中需要用到时，可进一步参考相关资料，并根据类的需求和操作，定义合适的重载方法。</p><h2 id="重载函数调用运算符">8. 重载函数调用运算符 ( )</h2><p>函数调用运算符的重载相对比较特殊。理论上，我们可以重载任意多个函数调用运算符，只要保证这些重载之间不发生冲突即可。函数调用运算符必须是成员函数。定义了函数调用运算符的类的对象称为<strong>函数对象</strong>。举一个例子如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> a &gt; b;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure> 定义了上面的类后，我们可以显式地调用函数： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TypeName obj;<br><span class="hljs-type">bool</span> b = <span class="hljs-built_in">obj</span>(<span class="hljs-number">12</span>, <span class="hljs-number">15</span>);<br></code></pre></td></tr></table></figure>12 比 15 小，因此上述代码中 b 应该为 false。</p><p>不过，函数对象更为常用的是作为函数参数提供给标准库函数，典型的如 sort函数： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">22</span>,<span class="hljs-number">343</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-232</span>,<span class="hljs-number">-23423</span>&#125;;<br><span class="hljs-type">int</span> n = <span class="hljs-built_in">sizeof</span>(a)/<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>);<br><span class="hljs-built_in">sort</span>(a, a+n, <span class="hljs-built_in">TypeName</span>());<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n; ++i)<br>    cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span>;<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure> 将 <code>TypeName()</code>临时对象作为函数参数传递给 <code>sort</code>函数，就能够实现自定义规则排序。上面代码将数组降序排序，而<code>sort</code> 函数默认为升序排序。</p><p>值得一提的是，C++ 中提供的 lambda表达式，实际上都转换为类，这个类重载了函数调用运算符，参数类型即为lambda 表达式的参数类型。这样，调用 lambda表达式就转换为调用函数对象的函数调用运算符。</p><h2 id="重载类型转换运算符">9. 重载类型转换运算符</h2><p>类型转换运算符的重载更为特殊，是类的一种特殊成员函数，其语法规则如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">type</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 具体实现</span><br>&#125;<br></code></pre></td></tr></table></figure> 其中， <code>type</code> 表示目标转换类型。</p><p>类型转换运算符一般很少使用，在实际编程中也应该谨慎使用。若定义不当，可能产生错误或者意料之外的结果。一般而言，类定义向<code>bool</code> 类型的转换规则就足够了，而且该转换函数最好定义为<code>explicit</code> 的。</p><hr /><p>以上就是本文全部内容。不过这些并不是对运算符重载的全面介绍，想了解更深入详细的知识，仍需阅读相关书籍。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>运算符重载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Nginx(GitHub Pages) 与 Hexo 搭建个人博客</title>
    <link href="/2023/02/18/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/02/18/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>本文介绍使用 Nginx（或者 GitHub Pages） 与 Hexo搭建个人博客的主要步骤。</p><p>在正文开始之前，先介绍上面提到的几个工具的功能：</p><ul><li><a href="https://nginx.org/en/">Nginx</a>：充当 Web服务器的角色，在个人博客中，其主要功能是在公网服务器上提供 HTTP 或 HTTPS服务，让用户能够访问你的博客网站。</li><li><a href="https://pages.github.com/">GitHubPages</a>：在没有个人公网服务器时，使用 GitHub Pages同样可以达到搭建个人博客的目的。具体而言，GitHub Pages 就是一个特殊的GitHub 仓库，你可以在这个仓库内放一些 HTML、CSS 和 JS文件等，从而搭建个人网站。</li><li><a href="https://hexo.io/zh-cn/">Hexo</a>：Hexo是一个静态博客框架，使用它可以搭建博客网站，让用户专注于博客内容，而不需要熟悉CSS 和 Javascript等前端内容。使用官方以及许多开源作者提供的主题，即可快速的构建美观的网页，而博客内容使用Markdown 编写即可。</li></ul><p>下面，介绍具体步骤。</p><h2 id="本地安装-node.js">1. 本地安装 Node.js</h2><p>Node.js 官网为：https://nodejs.org/en/download/，打开链接，根据本地环境，选择合适的安装文件下载。Windows 平台与 Mac平台选择二进制 installer 文件，安装时只需要点下一步即可。</p><p>Linux 平台安装稍微复杂些，推荐以下两种安装方式，可任选其一：</p><ul><li>源代码编译安装，无需配置 bash，但是编译耗时，<ahref="https://cloud.tencent.com/developer/article/1938607">参考</a></li><li>二进制文件下载安装，需要配置 bash 环境，<ahref="https://cloud.tencent.com/developer/article/1772306">参考</a></li></ul><p>安装完成后，在命令行输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm -v<br>$ node -v<br></code></pre></td></tr></table></figure><p>若都有输出，说明安装成功。</p><h2 id="本地安装-hexo-并初始化博客环境">2. 本地安装 Hexo并初始化博客环境</h2><p>Hexo 安装命令参考<ahref="https://hexo.io/zh-cn/">官网</a>即可，具体如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install hexo-cli -g<br>$ hexo init blog<br>$ <span class="hljs-built_in">cd</span> blog<br>$ npm install<br>$ hexo server<br></code></pre></td></tr></table></figure><p>关于 Hexo 的更多信息，可参考官方文档：<ahref="https://hexo.io/zh-cn/docs/">文档 | Hexo</a> 。</p><p>为了让你的博客网站更加符合你的审美，可以选择一个合适的主题 <ahref="https://hexo.io/themes/">Themes | Hexo</a> 。本博客网站使用的是Fluid，其 GitHub 仓库地址为：<ahref="https://github.com/fluid-dev/hexo-theme-fluid">fluid-dev/hexo-theme-fluid:一款 Material Design 风格的 Hexo 主题 / An elegant Material-Design themefor Hexo (github.com)</a> ，官方文档地址为：<ahref="https://hexo.fluid-dev.com/docs/guide/">配置指南 | Hexo Fluid用户手册 (fluid-dev.com)</a>。</p><p>仔细阅读 Hexo 官方文档与你选择的主题的官方文档，根据自己的喜好配置好yml 文件，搭建个人博客的路途就走完了一半。</p><p>下面，我们要解决的问题是：如何让互联网上的广大用户能够访问你的博客网站？</p><p>3、4 小节提供了两种方式，可根据自己的具体情况选择。</p><h2 id="建立-github-pages-仓库">3. 建立 GitHub Pages 仓库</h2><p>首先，在 GitHub上建立一个仓库。这个仓库的命名有点讲究，举例说明如下：</p><p>我的 GitHub 个人主页地址为：https://github.com/UnpureRationalist，其中，<code>UnpureRationalist</code> 表示我的用户名。</p><p>打开 GitHub 并选择创建仓库选项，将仓库命名为<code>用户名.github.io</code>，比如我的仓库命名则是：<code>UnpureRationalist.github.io</code>，并设置仓库为公开可见。</p><p>然后，在该仓库上传一个名为 <code>index.html</code>的文件，参考文件内容如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Example<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello World.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在浏览器输入链接 <code>用户名.github.io</code>，如我的博客地址为：<code>UnpureRationalist.github.io</code>，然后，浏览器即可显示 <code>index.html</code>文件的内容（可能需要等待一会）。</p><p>利用此仓库，我们就可以让其他用户访问自己的博客网站。</p><h2 id="服务器安装-nginx">4. 服务器安装 Nginx</h2><p>对于拥有个人云服务器的用户来说，可以直接在个人服务器上安装 Nginx服务，将个人博客搭建在自己的服务器上。</p><p>首先，我们需要在服务器上安装 Nginx，这里以 Ubuntu系统为例，步骤如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo apt update<br>$ sudo apt install nginx<br>$ sudo systemectl <span class="hljs-built_in">enable</span> nginx<span class="hljs-comment"># 设置 nginx 开机启动</span><br>$ sudo systemctl start nginx<span class="hljs-comment"># 启动 nginx 服务</span><br></code></pre></td></tr></table></figure><p>注意，为了让 Nginx 正常工作，需要在服务器的安全组设置中开放 80 or/and443 端口，以让 HTTP or/and HTTPS服务正常工作，具体参考自己使用的服务器提供商。</p><p>如果要使用 HTTPS 服务，则需要对 Nginx进行一定的配置，具体参考链接：https://cloud.tencent.com/document/product/400/35244。</p><h2 id="配置-hexo-实现自动部署">5. 配置 Hexo 实现自动部署</h2><p>经过上面的步骤，我们在本地有了一个存放个人博客的目录；在云端有了公网用户能够访问的目录。因此，我们只需要使用Git 或 scp 等工具，将 Hexo 生成的 public 目录下的所有文件和文件夹上传到GitHub 仓库或者服务器 Web服务根目录下即可。但是，手动进行这些操作有些麻烦，我们可以使用 Hexo提供的功能实现一条命令部署。详情参考链接：<ahref="https://hexo.io/zh-cn/docs/one-command-deployment">部署 | Hexo</a>。</p><p>具体而言，就是在 <code>_config.yml</code>配置文件中进行适当的配置，然后运行如下命令即可将个人博客部署到云端：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo deploy<br></code></pre></td></tr></table></figure><p>不过，在本人实际使用过程中，发现一键部署功能不太好用，GitHub Pages有时由于网络原因无法部署成功；部署到云服务器上则会报错。因此，本人使用Hexo 提供的功能部署到 GitHub Pages；对于服务器，则使用朴实无华的<code>scp</code>命令进行手动同步。如果读者有更好的自动部署方式，欢迎交流讨论。</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/02/18/hello-world/"/>
    <url>/2023/02/18/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h2 id="测试公式">测试公式</h2><p><span class="math display">\[E=mc^2\]</span></p><p><span class="math display">\[\sigma(z_i) = \frac{e^{z_{i}}}{\sum_{j=1}^K e^{z_{j}}} \ \ \ for\i=1,2,\dots,K\]</span></p><p><span class="math display">\[L_{\delta}=    \left\{\begin{matrix}        \frac{1}{2}(y - \hat{y})^{2} &amp; if \left | (y -\hat{y})  \right | &lt; \delta\\        \delta ((y - \hat{y}) - \frac1 2 \delta) &amp; otherwise    \end{matrix}\right.\]</span></p><p><span class="math display">\[\epsilon \sim \mathcal{N}(0, \textbf{I})\]</span></p><p><span class="math display">\[\vec{z} \sim \mathcal{N}(\vec{\mu}, \sigma^2 \textbf{I})\]</span></p><p><span class="math display">\[\sum_{i=1}^{D}|x_i-y_i|\]</span></p><p><span class="math display">\[Accuracy = \frac{TP+TN}{TP+TN+FP+FN}\]</span></p><p><span class="math display">\[Precision = \frac{TP}{TP+FP}\]</span></p><p><span class="math display">\[Recall = \frac{TP}{TP+FN}\]</span></p><p><span class="math display">\[F1 = \frac{2*Precision*Recall}{Precision+Recall} =\frac{2*TP}{2*TP+FP+FN}\]</span></p><h2 id="测试代码">测试代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> net<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> face_alignment <span class="hljs-keyword">import</span> align<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><br>adaface_models = &#123;<br>    <span class="hljs-string">&#x27;ir_50&#x27;</span>:<span class="hljs-string">&quot;pretrained/adaface_ir50_ms1mv2.ckpt&quot;</span>,<br>&#125;<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_pretrained_model</span>(<span class="hljs-params">architecture=<span class="hljs-string">&#x27;ir_50&#x27;</span></span>):<br>    <span class="hljs-comment"># load model and pretrained statedict</span><br>    <span class="hljs-keyword">assert</span> architecture <span class="hljs-keyword">in</span> adaface_models.keys()<br>    model = net.build_model(architecture)<br>    statedict = torch.load(adaface_models[architecture])[<span class="hljs-string">&#x27;state_dict&#x27;</span>]<br>    model_statedict = &#123;key[<span class="hljs-number">6</span>:]:val <span class="hljs-keyword">for</span> key, val <span class="hljs-keyword">in</span> statedict.items() <span class="hljs-keyword">if</span> key.startswith(<span class="hljs-string">&#x27;model.&#x27;</span>)&#125;<br>    model.load_state_dict(model_statedict)<br>    model.<span class="hljs-built_in">eval</span>()<br>    <span class="hljs-keyword">return</span> model<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">to_input</span>(<span class="hljs-params">pil_rgb_image</span>):<br>    np_img = np.array(pil_rgb_image)<br>    brg_img = ((np_img[:,:,::-<span class="hljs-number">1</span>] / <span class="hljs-number">255.</span>) - <span class="hljs-number">0.5</span>) / <span class="hljs-number">0.5</span><br>    tensor = torch.tensor([brg_img.transpose(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)]).<span class="hljs-built_in">float</span>()<br>    <span class="hljs-keyword">return</span> tensor<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br><br>    model = load_pretrained_model(<span class="hljs-string">&#x27;ir_50&#x27;</span>)<br>    feature, norm = model(torch.randn(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">112</span>,<span class="hljs-number">112</span>))<br><br>    test_image_path = <span class="hljs-string">&#x27;face_alignment/test_images&#x27;</span><br>    features = []<br>    <span class="hljs-keyword">for</span> fname <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(os.listdir(test_image_path)):<br>        path = os.path.join(test_image_path, fname)<br>        aligned_rgb_img = align.get_aligned_face(path)<br>        bgr_tensor_input = to_input(aligned_rgb_img)<br>        feature, _ = model(bgr_tensor_input)<br>        features.append(feature)<br><br>    similarity_scores = torch.cat(features) @ torch.cat(features).T<br>    <span class="hljs-built_in">print</span>(similarity_scores)<br>    <br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span><br>&#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode *left;<br>    TreeNode *right;<br>    <span class="hljs-built_in">TreeNode</span>() : <span class="hljs-built_in">val</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x, TreeNode *left, TreeNode *right) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(left), <span class="hljs-built_in">right</span>(right) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode *root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;TreeNode *&gt; s;<br>        TreeNode *p = root;<br>        <span class="hljs-keyword">while</span> (p || !s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span> (p)<br>            &#123;<br>                s.<span class="hljs-built_in">push</span>(p);<br>                p = p-&gt;left;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                TreeNode *temp = s.<span class="hljs-built_in">top</span>();<br>                s.<span class="hljs-built_in">pop</span>();<br>                res.<span class="hljs-built_in">push_back</span>(temp-&gt;val);<br>                p = temp-&gt;right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode *root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;TreeNode *&gt; s;<br>        TreeNode *p = root;<br>        <span class="hljs-keyword">while</span> (p || !s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">while</span> (p)<br>            &#123;<br>                s.<span class="hljs-built_in">push</span>(p);<br>                p = p-&gt;left;<br>            &#125;<br>            TreeNode *temp = s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            res.<span class="hljs-built_in">push_back</span>(temp-&gt;val);<br>            p = temp-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
