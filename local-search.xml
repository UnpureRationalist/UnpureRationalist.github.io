<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>浅谈 C++ 类的拷贝控制</title>
    <link href="/2024/01/14/%E6%B5%85%E8%B0%88-C-%E7%B1%BB%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/"/>
    <url>/2024/01/14/%E6%B5%85%E8%B0%88-C-%E7%B1%BB%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>在 C++语言的学习过程中，类的拷贝控制是一个较为繁杂的知识点。虽然它的难度不是很大，但是细节很多，需要理解记忆。本文介绍C++类的拷贝控制基本内容，即：拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符、析构函数这5 个函数的写法。</p><p>为了便于介绍，我们自己实现一个简单的 string 类，命名为<code>String</code>。它只包含一个私有的数据成员：<code>char *data</code>，关键函数成员包括：两个构造函数和五大拷贝控制函数。</p><p>类的定义（部分辅助函数在类内定义，下文介绍）如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT(message) \</span><br><span class="hljs-meta">  std::cout &lt;&lt; message &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;:\t&quot;</span> &lt;&lt; __FUNCTION__ &lt;&lt; std::endl</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">error</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">copy_str</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span> <span class="hljs-keyword">noexcept</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">release_memory</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>;<br><br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">String</span>() = <span class="hljs-keyword">default</span>;<br><br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">String</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)</span> <span class="hljs-keyword">noexcept</span></span>;<br><br>  <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String &amp;) <span class="hljs-keyword">noexcept</span>;  <span class="hljs-comment">// 拷贝构造函数</span><br><br>  String &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String &amp;) <span class="hljs-keyword">noexcept</span>;  <span class="hljs-comment">// 拷贝赋值运算符</span><br><br>  <span class="hljs-built_in">String</span>(String &amp;&amp;) <span class="hljs-keyword">noexcept</span>;  <span class="hljs-comment">// 移动构造函数</span><br><br>  String &amp;<span class="hljs-keyword">operator</span>=(String &amp;&amp;) <span class="hljs-keyword">noexcept</span>;  <span class="hljs-comment">// 移动赋值运算符</span><br><br>  ~<span class="hljs-built_in">String</span>() <span class="hljs-keyword">noexcept</span>;  <span class="hljs-comment">// 析构函数</span><br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">char</span> *data&#123;<span class="hljs-literal">nullptr</span>&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>构造函数与拷贝构造相关的 5 个函数都应该声明为 <code>noexcept</code>，以让编译器更好地进行编译优化。同时这也意味着：一般情况下，构造函数、析构函数、拷贝/移动相关的函数都不应该抛出异常，一旦这些函数运行时出错，将直接退出程序。</p><h2 id="构造函数">1. 构造函数</h2><p>为了介绍五大拷贝控制函数，需要先看类的两个构造函数。</p><p>首先是默认构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">String</span>() = <span class="hljs-keyword">default</span>;<br></code></pre></td></tr></table></figure><p>注意，这里在类内直接初始化数据成员：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">char</span> *data&#123;<span class="hljs-literal">nullptr</span>&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>而不是在默认构造函数中使用如下形式初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">String</span>() : data&#123;<span class="hljs-literal">nullptr</span>&#125; &#123;&#125;<br></code></pre></td></tr></table></figure><p>因为前一种形式直接对数据成员进行初始化，代码具有更好的局部性和可读性。C++Core Guideline 推荐采用前一种写法。</p><p>第二个构造函数接收一个 <code>const char *</code>类型指针，动态申请内存并从参数中拷贝构造字符串。代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">String::<span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s) <span class="hljs-keyword">noexcept</span> &#123;<br>  <span class="hljs-built_in">PRINT</span>(<span class="hljs-string">&quot;构造函数&quot;</span>);<br>  <span class="hljs-built_in">copy_str</span>(s);<br>&#125;<br></code></pre></td></tr></table></figure><p>构造函数中包括一个用于追踪函数调用的宏，打印函数调用信息，以及真正执行构造的<code>copy_str</code> 函数，其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">error</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cerr &lt;&lt; <span class="hljs-string">&quot;Error!&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">copy_str</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">nullptr</span>) &#123;<br>      data = <span class="hljs-literal">nullptr</span>;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> length = <span class="hljs-built_in">strlen</span>(s);<br>    data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[length + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span> (data != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-built_in">strcpy</span>(data, s);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">error</span>();<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>函数内进行动态内存分配及字符串拷贝，并处理可能出现的内存不足错误。</p><p>接下来正式进入拷贝控制的内容。</p><h2 id="析构函数">2. 析构函数</h2><p>先从最简单的析构函数开始：</p><p>析构函数的声明形式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">~<span class="hljs-built_in">ClassName</span>() <span class="hljs-keyword">noexcept</span> &#123;  <span class="hljs-comment">/* 函数体 */</span>  &#125;<br></code></pre></td></tr></table></figure><p>析构函数一般进行类的资源释放，对于本 <code>String</code> 类，需要释放<code>data</code> 指针对应的内存，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">String::~<span class="hljs-built_in">String</span>() <span class="hljs-keyword">noexcept</span> &#123;<br>  <span class="hljs-built_in">PRINT</span>(<span class="hljs-string">&quot;析构函数&quot;</span>);<br>  <span class="hljs-built_in">release_memory</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>析构函数内调用 <code>release_memory</code>函数释放动态分配的内存：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">release_memory</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (data != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">delete</span>[] data;<br>      data = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><em>何时调用析构函数：</em></p><ol type="1"><li>变量离开作用域时</li><li>当一个对象被销毁时，其成员被销毁</li><li>容器（标准库容器以及数组）被销毁时，其元素被销毁</li><li>动态分配对象被 <code>delete</code> 时</li><li>对于临时对象，当创建它的完整表达式结束时被销毁</li></ol><h2 id="拷贝构造函数">3. 拷贝构造函数</h2><p>拷贝构造函数声明形式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">ClassName</span>(<span class="hljs-type">const</span> ClassName &amp;s) <span class="hljs-keyword">noexcept</span> &#123;  <span class="hljs-comment">/* 函数体 */</span>   &#125;<br></code></pre></td></tr></table></figure><p><em>注意点：</em></p><ol type="1"><li>拷贝构造函数是构造函数，<strong>无返回类型</strong></li><li>拷贝构造函数的参数类型为 <strong>const 引用类型</strong></li><li>拷贝构造函数一般需要动态申请内存，进行深拷贝工作，对于本<code>String</code> 类，需要申请内存，并从参数字符串中拷贝数据</li></ol><p><code>String</code> 类的拷贝构造函数实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">String::<span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String &amp;s) <span class="hljs-keyword">noexcept</span> &#123;<br>  <span class="hljs-built_in">PRINT</span>(<span class="hljs-string">&quot;拷贝构造函数&quot;</span>);<br>  <span class="hljs-built_in">copy_str</span>(s.data);<br>&#125;<br></code></pre></td></tr></table></figure><p><em>何时调用拷贝构造函数：</em></p><ol type="1"><li>用 = 定义变量时</li><li>将一个对象作为实参传递给一个非引用类型的形参（函数调用以值传递）</li><li>从一个返回类型为非引用类型的函数返回一个对象（函数返回）</li><li>用花括号列表初始化一个数组中的元素或者一个聚合类中的成员</li></ol><h2 id="拷贝赋值运算符">4. 拷贝赋值运算符</h2><p>拷贝赋值运算符声明形式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ClassName &amp; <span class="hljs-keyword">operator</span>= (<span class="hljs-type">const</span> ClassName &amp;s) <span class="hljs-keyword">noexcept</span> &#123;  <span class="hljs-comment">/* 函数体 */</span>   &#125;<br></code></pre></td></tr></table></figure><p><em>注意点：</em></p><ol type="1"><li>拷贝赋值运算符是一种运算符重载，可以看作名字为：<code>operator=</code>的函数，其 <strong>参数类型为 const引用类型</strong>，<strong>返回类型为引用类型</strong></li><li>拷贝赋值运算符一般需要执行析构函数和构造函数的功能</li><li>需要考虑自赋值情况，即：<code>a = a</code>，确保自赋值情况拷贝赋值运算符正确执行。为了保证自赋值正确执行，一般采取：先申明临时变量，然后将参数拷贝到临时变量，最后将临时变量拷贝到本对象的步骤</li></ol><p><code>String</code> 类的拷贝赋值运算符实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">String &amp;String::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String &amp;s) <span class="hljs-keyword">noexcept</span> &#123;<br>  <span class="hljs-built_in">PRINT</span>(<span class="hljs-string">&quot;拷贝赋值运算符&quot;</span>);<br>  <span class="hljs-built_in">release_memory</span>();<br>  <span class="hljs-built_in">copy_str</span>(s.data);<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>何时调用拷贝赋值运算符：</em></p><ol type="1"><li>赋值符号右侧为一个左值时</li></ol><h2 id="移动构造函数">5. 移动构造函数</h2><p>移动构造函数声明形式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-built_in">ClassName</span>(ClassName &amp;&amp;s) <span class="hljs-keyword">noexcept</span> &#123;  <span class="hljs-comment">/* 函数体 */</span>   &#125;<br></code></pre></td></tr></table></figure><p><em>注意点：</em></p><ol type="1"><li>移动构造函数属于构造函数，无返回类型。其<strong>参数类型为右值引用</strong>，<strong>不取const 类型</strong></li><li>移动构造函数的特性在于“移动”，它一般执行“浅拷贝”，即不需要动态申请内存，而是将<code>s</code> 的动态内存指针赋值给本对象的指针，然后将 <code>s</code>的指针赋值为空</li></ol><p><code>String</code> 类的移动构造函数实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">String::<span class="hljs-built_in">String</span>(String &amp;&amp;s) <span class="hljs-keyword">noexcept</span> &#123;<br>  <span class="hljs-built_in">PRINT</span>(<span class="hljs-string">&quot;移动构造函数&quot;</span>);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;s)  <span class="hljs-comment">// 排除自赋值情况</span><br>  &#123;<br>    data = s.data;     <span class="hljs-comment">// 直接赋值 不申请内存</span><br>    s.data = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// 将赋值运算符右侧对象指针置为空</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>何时调用移动构造函数：</em></p><ol type="1"><li>显式地从一个右值进行构造时，例如：利用标准库 <code>move</code>函数返回一个右值进行构造</li><li>利用移动迭代器构造时</li></ol><h2 id="移动赋值运算符">6. 移动赋值运算符</h2><p>移动赋值运算符声明形式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>ClassName &amp;<span class="hljs-keyword">operator</span>= (ClassName &amp;&amp;s) <span class="hljs-keyword">noexcept</span> &#123;  <span class="hljs-comment">/* 函数体 */</span>   &#125;<br></code></pre></td></tr></table></figure><p><em>注意点：</em></p><ol type="1"><li>移动赋值运算符同样是一种运算符重载，其返回类型为类的引用类型，参数类型为类的右值引用，<strong>不是const 类型</strong></li><li>移动赋值运算符特性同样在“移动”二字，它不执行拷贝，执行的动作一般拷贝析构本对象原有的动态内存，然后将参数对象动态内存指针赋值给本对象内指针，最后将参数对象指针赋值为空。正因为该函数需要改变参数，因此不声明为<code>const</code> 类型</li></ol><p><code>String</code> 类移动赋值运算符实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">String &amp;String::<span class="hljs-keyword">operator</span>=(String &amp;&amp;s) <span class="hljs-keyword">noexcept</span> &#123;<br>  <span class="hljs-built_in">PRINT</span>(<span class="hljs-string">&quot;移动赋值运算符&quot;</span>);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;s)  <span class="hljs-comment">// 排除自赋值情况</span><br>  &#123;<br>    <span class="hljs-built_in">release_memory</span>();<br>    data = s.data;     <span class="hljs-comment">// 直接赋值 不申请内存</span><br>    s.data = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// 将赋值运算符右侧对象指针置为空</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>何时调用移动赋值运算符：</em></p><ol type="1"><li>赋值符号右侧为一个右值时</li></ol><h2 id="运行结果">7. 运行结果</h2><p><strong>完整测试函数：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT(message) \</span><br><span class="hljs-meta">  std::cout &lt;&lt; message &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot;:\t&quot;</span> &lt;&lt; __FUNCTION__ &lt;&lt; std::endl</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">error</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cerr &lt;&lt; <span class="hljs-string">&quot;Error!&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">copy_str</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">nullptr</span>) &#123;<br>      data = <span class="hljs-literal">nullptr</span>;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> length = <span class="hljs-built_in">strlen</span>(s);<br>    data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[length + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span> (data != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-built_in">strcpy</span>(data, s);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">error</span>();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">release_memory</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (data != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">delete</span>[] data;<br>      data = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>  &#125;<br><br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">String</span>() = <span class="hljs-keyword">default</span>;<br><br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">String</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)</span> <span class="hljs-keyword">noexcept</span></span>;<br><br>  <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String &amp;) <span class="hljs-keyword">noexcept</span>;  <span class="hljs-comment">// 拷贝构造函数</span><br><br>  String &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String &amp;) <span class="hljs-keyword">noexcept</span>;  <span class="hljs-comment">// 拷贝赋值运算符</span><br><br>  <span class="hljs-built_in">String</span>(String &amp;&amp;) <span class="hljs-keyword">noexcept</span>;  <span class="hljs-comment">// 移动构造函数</span><br><br>  String &amp;<span class="hljs-keyword">operator</span>=(String &amp;&amp;) <span class="hljs-keyword">noexcept</span>;  <span class="hljs-comment">// 移动赋值运算符</span><br><br>  ~<span class="hljs-built_in">String</span>() <span class="hljs-keyword">noexcept</span>;  <span class="hljs-comment">// 析构函数</span><br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">char</span> *data&#123;<span class="hljs-literal">nullptr</span>&#125;;<br>&#125;;<br><br>String::<span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s) <span class="hljs-keyword">noexcept</span> &#123;<br>  <span class="hljs-built_in">PRINT</span>(<span class="hljs-string">&quot;构造函数&quot;</span>);<br>  <span class="hljs-built_in">copy_str</span>(s);<br>&#125;<br><br>String::~<span class="hljs-built_in">String</span>() <span class="hljs-keyword">noexcept</span> &#123;<br>  <span class="hljs-built_in">PRINT</span>(<span class="hljs-string">&quot;析构函数&quot;</span>);<br>  <span class="hljs-built_in">release_memory</span>();<br>&#125;<br><br>String::<span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String &amp;s) <span class="hljs-keyword">noexcept</span> &#123;<br>  <span class="hljs-built_in">PRINT</span>(<span class="hljs-string">&quot;拷贝构造函数&quot;</span>);<br>  <span class="hljs-built_in">copy_str</span>(s.data);<br>&#125;<br><br>String &amp;String::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String &amp;s) <span class="hljs-keyword">noexcept</span> &#123;<br>  <span class="hljs-built_in">PRINT</span>(<span class="hljs-string">&quot;拷贝赋值运算符&quot;</span>);<br>  <span class="hljs-built_in">release_memory</span>();<br>  <span class="hljs-built_in">copy_str</span>(s.data);<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br>String::<span class="hljs-built_in">String</span>(String &amp;&amp;s) <span class="hljs-keyword">noexcept</span> &#123;<br>  <span class="hljs-built_in">PRINT</span>(<span class="hljs-string">&quot;移动构造函数&quot;</span>);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;s)  <span class="hljs-comment">// 排除自赋值情况</span><br>  &#123;<br>    data = s.data;     <span class="hljs-comment">// 直接赋值 不申请内存</span><br>    s.data = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// 将赋值运算符右侧对象指针置为空</span><br>  &#125;<br>&#125;<br><br>String &amp;String::<span class="hljs-keyword">operator</span>=(String &amp;&amp;s) <span class="hljs-keyword">noexcept</span> &#123;<br>  <span class="hljs-built_in">PRINT</span>(<span class="hljs-string">&quot;移动赋值运算符&quot;</span>);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;s)  <span class="hljs-comment">// 排除自赋值情况</span><br>  &#123;<br>    <span class="hljs-built_in">release_memory</span>();<br>    data = s.data;     <span class="hljs-comment">// 直接赋值 不申请内存</span><br>    s.data = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// 将赋值运算符右侧对象指针置为空</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  String s1;                   <span class="hljs-comment">// 默认构造函数</span><br>  <span class="hljs-function">String <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-string">&quot;I&#x27;m String.\n&quot;</span>)</span></span>;  <span class="hljs-comment">// 由字符串构造</span><br><br>  String s3 = s2;            <span class="hljs-comment">// 拷贝构造函数</span><br>  s1 = s2;                   <span class="hljs-comment">// 拷贝赋值运算符</span><br>  <span class="hljs-function">String <span class="hljs-title">s4</span><span class="hljs-params">(std::move(s1))</span></span>;  <span class="hljs-comment">// 移动构造函数</span><br>  s2 = <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;hhh&quot;</span>);        <span class="hljs-comment">// 移动赋值运算符</span><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;-----------------&quot;</span> &lt;&lt; std::endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><p>在 ubuntu 22.04 上使用 11.4.0 版本的 GCC 编译器，使用编译命令<code>g++ test.cpp -o test</code> 编译运行，运行结果如下：</p><center><img src="/2024/01/14/%E6%B5%85%E8%B0%88-C-%E7%B1%BB%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/image-20240115141151453.png" class="" title="运行结果"></center><p>根据输出结果，可以追踪到各个函数在什么时候被调用。</p><p><br></p><p><br></p><p><strong>参考文献</strong></p><ul><li>《C++ Primer 第五版》 第 13 章 拷贝控制</li><li>《C++ Core Guidelines 解析》第 5 章 类和类层次结构</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>拷贝控制</tag>
      
      <tag>构造函数</tag>
      
      <tag>析构函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何实现学术论文？</title>
    <link href="/2024/01/13/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87%EF%BC%9F/"/>
    <url>/2024/01/13/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>译者注：</p><p>本文译自 <ahref="https://www.elastic.co/search-labs/blog/articles/implementing-academic-papers-lessons-learned-from-elasticsearch-and-lucene">Implementingacademic papers: lessons learned from Elasticsearch and Lucene</a>，作者：<ahref="https://www.elastic.co/search-labs/author/julie-tibshirani">JulieTibshirani</a>。本文主要讨论了如何将学术论文中的前沿研究成果引入到实际的软件系统中，讨论了在此过程中需要注意的一些问题。</p><p>译者：<a href="https://arcsin2.cloud/about">arcsin2</a></p></blockquote><p>在开发 Elasticsearch时，我们偶尔会遇到一些重要的问题，它们没有简单或既定的解决方法。这时，会很自然地会问：“有没有学术论文解决了这个问题？”。有时候，学术工作会成为灵感的来源。我们可能会看到一篇提出新算法或数据结构的论文，然后想：“这会非常有用！”以下是 Elasticsearch 和 Apache Lucene 如何融入学术工作的几个例子：</p><ul><li><a href="https://research.google/pubs/pub40671/">HyperLogLog++</a>for <ahref="https://www.elastic.co/guide/en/elasticsearch/reference/7.15/search-aggregations-metrics-cardinality-aggregation.html">cardinalityaggregations</a></li><li><ahref="https://www.usenix.org/system/files/conference/nsdi15/nsdi15-paper-suresh.pdf">C3algorithm</a> for <ahref="https://www.elastic.co/blog/improving-response-latency-in-elasticsearch-with-adaptive-replica-selection">adaptivereplica selection</a></li><li><a href="https://arxiv.org/abs/1603.09320">Hierarchical NavigableSmall World Graphs (HNSW)</a> for nearest vector search in Lucene</li><li><ahref="https://jmlr.csail.mit.edu/papers/volume17/15-308/15-308.pdf">MICstatistic</a> to <ahref="https://github.com/elastic/ml-cpp/pull/488">improve machinelearning classification</a></li><li><a href="http://engineering.nyu.edu/~suel/papers/bmw.pdf">Block-maxWAND</a> for <ahref="https://www.elastic.co/blog/faster-retrieval-of-top-hits-in-elasticsearch-with-block-max-wand">fastertop-hits retrieval in Lucene</a></li><li>... and <ahref="https://www.elastic.co/guide/en/elasticsearch/reference/7.15/query-dsl-combined-fields-query.html">many</a><ahref="https://github.com/elastic/elasticsearch/blob/b2a9328890b23e7ccf6c66a3b13d6d65e453a3dd/server/src/main/java/org/elasticsearch/search/sort/BucketedSort.java#L302-L323">more</a></li></ul><p>对于开发数据密集型系统的工程师来说，学术论文是一种宝贵的资源。但实现这些论文可能会令人生畏且容易出错——算法描述通常很复杂，并且经常省略重要的实用细节。并且测试是一个真正的挑战，例如：我们如何彻底测试一个其输出紧密依赖于数据集的机器学习算法？</p><p>本文分享了在软件应用中实现学术论文的策略。它借鉴了 Elasticsearch 和Lucene的实例，希望帮助其他工程师从我们的经验中学习。阅读这些策略时，您可能会想：“但这不过是软件开发而已！”确实如此：作为工程师，我们已经有了正确的实践和工具，只需要适应新的挑战。</p><h2 id="像评估软件依赖一样评估论文">1. 像评估软件依赖一样评估论文</h2><p>添加新的软件依赖需要仔细评估：如果依赖的包不正确、运行缓慢或不安全，我们的项目也可能受到影响。在引入依赖之前，开发者要确保评估其质量。</p><p>当你考虑实现学术论文时，这同样适用。人们可能会认为发表在学术论文上的算法一定是正确且表现良好的。但是，即使通过了审查程序，学术论文也可能存在问题：</p><ul><li>正确性证明依赖于不切实际的假设；</li><li>“实验”部分显示了比基线更好的性能，但这只适用于特定的数据集；</li></ul><p>即使论文质量很高，它的方法也可能不适合你的项目。</p><p>当考虑是否要“依赖”一篇学术论文时，提出我们对软件包会问的同样问题是很有帮助的：</p><ul><li>这个库是否被广泛使用并且经过了“实战测试”？→是否有其他包实现了这篇论文，并且对它们来说运行良好吗？</li><li>是否有性能基准测试？这些基准看起来准确和公正吗？→论文中包含了现实世界的实验吗？这些实验设计得好吗？</li><li>是否有足够大的性能提升，以接受算法的复杂性？→论文是否与一个强大的基线方法进行了比较？它比基线方法表现好多少？</li><li>这种方法是否能很好地集成到我们的系统中？→算法的假设和权衡是否符合我们的用例？</li></ul><p>不知何故，当一个软件包与其竞争对手发布性能比较时，该软件包总是最快的！如果由第三方设计基准，它们可能会更加公平。同样的现象也适用于学术论文。如果一种算法不仅在原始论文中表现良好，而且在其他论文中作为强基线出现，那么它很可能是可靠的。</p><h2 id="创造性地进行测试">2. 创造性地进行测试</h2><p>学术论文中的算法通常比我们日常遇到的算法具有更复杂的行为。也许它是一个近似算法，为了提高速度而牺牲准确性。或者它是一种机器学习方法，它处理大量数据集，并产生（有时是意想不到的）输出。如果我们不能简单地描述这些算法的行为，我们该如何为它们编写测试呢？</p><h3 id="关注不变性">2.1 关注不变性</h3><p>在设计单元测试时，通常我们会以示例为基础进行思考：如果我们给算法这个示例输入，它应该产生那个输出。不幸的是，对于大多数数学算法来说，基于示例的测试并不能充分覆盖它们的行为。</p><p>让我们考虑一下 C3 算法，Elasticsearch使用它来确定哪个节点应该处理搜索请求。它使用一个微妙的公式对每个节点进行排名，这个公式考虑了节点的先前服务和响应时间，以及它的队列大小。仅仅测试几个例子并不能真正验证我们是否正确理解了这个公式。退一步考虑测试不变性是有帮助的：如果服务时间增加，节点的排名会降低吗？如果队列大小为0，那么排名是否如论文中所说的由响应时间决定?</p><p>关注不变性可以在许多常见情况下有所帮助：</p><ul><li>方法是否应该是顺序无关的？如果是，那么以不同的顺序传递输入数据应该产生相同的输出。</li><li>算法中的某个步骤是否产生类别概率？如果是，那么这些概率应该加起来等于1。</li><li>函数是否关于原点对称？如果是，那么改变输入的符号应该只是改变输出的符号。</li></ul><p>当我们最初实现 C3算法时，我们在公式中犯了一个错误，不小心用响应时间的倒数代替了响应时间。这意味着速度较慢的节点可能会被排名更高！在修复这个问题时，我们确保添加了<ahref="https://github.com/elastic/elasticsearch/pull/70283">不变性检查</a>，以防止未来的错误。</p><h3 id="与参考实现比较">2.2 与参考实现比较</h3><p>作者可能随论文一起发布了算法的实现。（如果论文包含实验，这种情况尤其可能，因为许多期刊要求作者发布代码以便重现结果。）你可以将你的方法与这个参考实现进行对比测试，以确保你没有遗漏算法的重要细节。</p><p>在开发 Lucene 的 HNSW实现用于最近邻搜索时，我们对比了论文作者提供的<ahref="https://issues.apache.org/jira/browse/LUCENE-9937">参考库</a>进行了测试。我们让Lucene和这个库都运行在同一个数据集上，比较了它们的结果准确性以及它们执行的计算次数。当这些数字非常接近时，我们知道Lucene 忠实地实现了该算法。</p><p>当将一个算法集成到系统中时，你通常需要进行修改或扩展，比如将其扩展到多个核心，或者添加启发式方法以提高性能。最好是首先实现一个“普通”版本，然后与参考实现进行对比测试，再进行增量式的更改。这样你可以确信在进行定制之前已经捕捉到了所有关键部分。</p><h3 id="与现有算法对决">2.3 与现有算法对决</h3><p>本小节提出了测试不变量的另一个想法：将算法的输出与更简单、更容易理解的算法的输出进行比较。以Lucene 中的 block-max WAND算法为例，该算法通过跳过不可能出现在顶部结果中的文档来加速文档检索。虽然很难精确描述block-max WAND在每种情况下应该如何表现，但我们确实知道应用它不应该改变顶部结果！因此，我们的测试可以生成几个随机搜索查询，然后分别在<ahref="https://github.com/apache/lucene/blob/main/lucene/core/src/test/org/apache/lucene/search/TestWANDScorer.java#L669">应用和不应用WAND 优化</a>的情况下运行它们，并检查它们的结果是否始终匹配。</p><p>这些测试的一个重要方面是它们<ahref="https://www.elastic.co/blog/elasticsearch-testing-qa-increasing-coverage-randomizing-test-runs">生成随机输入</a>来进行比较。这可以帮助测试到你可能没有想到的情况，并揭示出意外的问题。例如，Lucene的 BM25F 评分的随机比较测试帮助<ahref="https://issues.apache.org/jira/browse/LUCENE-10039">捕捉到了微妙边缘情况下的错误</a>。给算法提供随机输入的想法与模糊测试（<ahref="https://en.wikipedia.org/wiki/Fuzzing">fuzzing</a>）的概念密切相关，这是计算机安全中常用的一种测试技术。</p><p>Elasticsearch 和 Lucene经常使用这种测试方法。如果你看到一个测试提到了两种算法之间的“对决”（TestDuelingAnalyzers,testDuelTermsQuery...），那么你就知道这种策略正在发挥作用。</p><h2 id="使用论文的术语">3. 使用论文的术语</h2><p>当其他开发者使用你的代码时，他们需要查阅论文来理解其细节。Elasticsearch的 <ahref="https://github.com/elastic/elasticsearch/blob/4f22f437ee50cacb94b37b457be1da0b8ba0e8ce/server/src/main/java/org/elasticsearch/search/aggregations/metrics/HyperLogLogPlusPlus.java#L24-L39">HyperLogLog++实现中的注释</a>很好地说明了这一点：“试图在没有阅读论文的情况下理解这个类的功能被认为是冒险的。”这个方法注释也树立了一个好榜样。它包含了指向学术论文的链接，并突出显示了算法在原始描述中所做的修改。</p><p>由于开发者将基于论文来理解代码，因此使用与论文完全相同的术语是有帮助的。由于数学符号简洁，这可能导致一些通常不会被认为是“良好风格”的名称，但在论文的上下文中却非常清晰。学术论文中的公式是你在Elasticsearch 中遇到像 <ahref="https://github.com/elastic/elasticsearch/blob/4f22f437ee50cacb94b37b457be1da0b8ba0e8ce/server/src/main/java/org/elasticsearch/node/ResponseCollectorService.java#L151">rS和 muBarSInverse</a> 这样神秘变量名的少数情况之一。</p><h2 id="邮件联系论文作者">4. 邮件联系论文作者</h2><p>当你在研究一篇难懂的论文时，你可能会花费数小时去琢磨一个公式，不确定是自己理解错了还是论文中存在打字错误。如果是开源项目，你可以在GitHub或StackOverflow上提问。但对于学术论文，你可以向哪里求助呢？作者们似乎很忙，可能会被你的邮件惹恼。</p><p>相反，许多学者喜欢听到他们的想法被付诸实践，并乐于通过电子邮件回答问题。如果你在他们熟悉的产品上工作，他们甚至可能会在他们的网站上列出这个应用！</p><p>学术界也越来越多地使用软件开发中的许多相同工具来公开讨论论文。如果一篇论文附带了软件包，你可能会<ahref="https://github.com/facebookresearch/faiss/issues/1928">在 GitHub上找到关于常见问题的解答</a>。像“理论计算机科学”和“交叉验证”这样的 StackExchange 社区也包含了<ahref="https://cstheory.stackexchange.com/questions/49296/problem-in-the-paper-stable-minimum-space-partitioning-in-linear-time">关于热门论文的详细讨论</a>。一些会议也开始在线发布所有论文审稿意见。这些评审包含了<ahref="https://openreview.net/forum?id=H1eA7AEtvS">与作者的来回讨论</a>，可以揭示关于方法的有用见解。</p><h2 id="未完待续">5. 未完待续</h2><p>本文聚焦于选择学术论文并正确实施的基本要点，但并未涵盖实际部署算法的所有方面。例如，如果算法只是复杂系统中的一个组件，我们如何确保对组件的更改导致端到端的改进？如果整合算法需要大量修改或扩展，而这是原始论文没有涉及到的呢？这些都是我们希望在以后的文章中做更多分享的重要话题。</p>]]></content>
    
    
    <categories>
      
      <category>方法论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实现学术论文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 语言入门</title>
    <link href="/2024/01/08/Go-%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"/>
    <url>/2024/01/08/Go-%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>本文介绍学习 Go 语言一些学习材料，总结学习 Go时容易理解错误的一些概念，可用于已掌握 C++、Java等编程语言的程序员快速入门 Go。</p><h2 id="基础语法">1. 基础语法</h2><p>入门 Go 语言基础语法和关键语言概念的最佳材料是 Go语言官方提供的在线教程：</p><ul><li>英文版：<ahref="https://go.dev/tour/welcome/1">https://go.dev/tour/welcome/1</a></li><li>中文版：<ahref="https://tour.go-zh.org/welcome/1">https://tour.go-zh.org/welcome/1</a></li></ul><p>这一在线教程提供了文档+在线编程环境，可在浏览器中编辑和运行代码。同时，也穿插了一些小练习，能够在写代码中学习Go 语言。学习完该教程预估要几个小时，学习完后即可使用 Go语言编写自己的程序。</p><p>这一教程涵盖的内容大概包括：</p><ul><li>基本数据类型：<code>int</code>、<code>float64</code>、<code>string</code>等 Go语言支持的基本数据类型，以及定义变量、常量、函数内变量的语法等；</li><li>常用容器：包括 <code>slice</code>、<code>map</code>等数据结构，分别提供可变长数组、哈希等功能；</li><li>控制语句：<code>if</code> 、<code>for</code> 、<code>switch</code>等控制语句结构，尤其是 Go 语言提供的类似于<code>if expression; bool</code> 的语法；</li><li>函数与接口：Go语言中函数定义语法、多返回值、接口定义与实现、结构体方法等；</li><li>并发：介绍 Go语言提供的并发编程相关概念，包括：<code>goroutine</code>、<code>select</code>、<code>channel</code>等的使用。</li></ul><p>学习完这些内容后，该教程也指出了继续学习的方向，链接：<ahref="https://tour.go-zh.org/concurrency/11">https://tour.go-zh.org/concurrency/11</a>。</p><h2 id="值传递-or-引用传递">2. 值传递 or 引用传递？</h2><p>学习完 Go基础语法后，难免会遇到一个问题：为什么同样是语法上的以值传递，对<code>int</code> 等类型的修改不改变函数外参数；而对<code>map</code>、<code>slice</code>、<code>channel</code>的更改却会改变传递给函数的原参数。乍一看，这似乎类似于 Java语言中的机制：对基本类型以值传递；对对象类型引用传递。但是这一理解实际上是不对的，Go语言中只存在以值传递。看似 “引用传递” 实际上是 Go语言为了方便我们使用所做的一层隐藏或抽象。</p><p>对 Go 以值传递的介绍文章网上已有很多，这里贴两个链接供参考：</p><ul><li><ahref="https://zhuanlan.zhihu.com/p/542218435">Golang是值传递还是引用传递- 码农在新加坡的文章 - 知乎</a></li><li><a href="https://juejin.cn/post/7221730647043244090">【Go 进阶】Go语言到底是值传递，还是引用传递？</a></li></ul><p>简单来说就是：</p><ul><li>Go 语言函数传参只存在以值传递；</li><li><code>map</code>、<code>channel</code>等语言提供的功能，其本质上是调用 <code>make_xxx</code>函数并返回指针类型，语言隐藏了其实际上是指针的事实，从而方便程序员使用；</li><li><code>slice</code>更为特殊，其本质上是一个结构体，内部含有指向堆内存的指针，因此函数传递<code>slice</code>时，需要做结构体拷贝，但是由于指针实际上指向堆内存，通过下标访问<code>arr[i]</code> 并进行更改时，更改也对函数体外的原<code>slice</code> 可见。</li></ul><h2 id="并发编程">3. 并发编程</h2><p>Go 语言提供的 <code>goroutine</code> 和 <code>channel</code>提供了一种抽象层级更高的并发编程模型，而不是传统的面向锁、条件变量等的并发编程。个人认为，初次学习Go的并发编程时还是比较难理解的，尤其是思维方式的转变，从习惯的：共享数据结构（内存）+锁的并发编程，转向Go 语言的：如何定义消息和划分读写 <code>channel</code> 功能，以使用<code>goroutine</code> 和 <code>channel</code>进行并发编程。这是完全两种不同的思考方式，需要花费一定时间来转换。这里提供一些可参考的资料以学习Go 并发编程的惯用法：</p><ul><li><a href="https://www.youtube.com/watch?v=f6kdp27TYZs">Go并发模型</a>(<ahref="https://talks.go-zh.org/2012/concurrency.slide">幻灯片</a>) ：Go语言设计者之一关于 Go 并发编程模式的演讲视频；</li><li><a href="https://www.youtube.com/watch?v=QDDwwePbDtw">深入 Go并发模型</a>(<ahref="https://talks.go-zh.org/2013/advconc.slide">幻灯片</a>) ：Google的另一关于 Go 并发编程的演讲视频；</li><li><a href="https://go-zh.org/doc/codewalk/sharemem/">Codewalk:通过通信共享内存</a> ：通过通信来共享内存示例；</li><li><ahref="https://github.com/lotusirous/go-concurrency-patterns">lotusirous/go-concurrency-patterns:Concurrency patterns in Go (github.com)</a> ：收集了常用 Go并发编程模式的 GitHub 仓库。</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DB 论文阅读：Hierarchical Navigable Small World</title>
    <link href="/2024/01/03/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AHierarchical-Navigable-Small-World/"/>
    <url>/2024/01/03/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AHierarchical-Navigable-Small-World/</url>
    
    <content type="html"><![CDATA[<p>本文介绍向量近似最近邻（Approximate NearestNeighbor，ANN）的另一经典算法：HNSW（Hierarchical Navigable SmallWorld，HNSW）。HNSW 工业界使用最多的 ANN 算法之一，得到了Milvus、Elasticsearch、Fasis、pgvector 等系统或库的广泛支持。原文： <ahref="https://arxiv.org/ftp/arxiv/papers/1603/1603.09320.pdf">Efficientand robust approximate nearest neighbor search using HierarchicalNavigable Small World graphs</a> 。</p><p><strong>摘要</strong></p><p>本文提出了一种具有可控层次的基于可导航小世界图的近似 k近邻算法。所提出的解决方案完全基于图而无需任何额外的搜索结构，这些结构通常用于大多数邻近图技术的粗搜索阶段。HNSW逐步构建一个多层结构，由嵌套的接近图集合（层）组成，用于存储元素的子集。元素所在的最大层数是随机选择的，遵循指数衰减的概率分布。这允许生成类似于之前研究的可导航小世界（NSW）结构的图，同时额外具有按其特征距离尺度分离的连接。与NSW 相比，HNSW从上层开始搜索并利用尺度分离可以提高性能，实现对数复杂度。额在高召回率和高度聚集的数据情况下，使用启发式方法选择邻近图近邻显著提高了性能。性能评估表明，所提出的通用度量空间搜索索引能够明显优于之前开源的仅用于向量空间的方法。该索引结构与跳表相似，允许直接、平衡的分布式实现。</p><h2 id="动机">1. 动机</h2><p>由于 HNSW 是 NSW 的改进，因此首先需要分析 NSW 有什么问题。</p><p>NSW 在进行 ANN搜索时，采用贪心策略从一个节点跳转到下一个距离最近的邻居节点，这一寻找下一个节点的过程称为“路由”，和网络中的路由概念类似。NSW的贪心搜索算法可以分为两个阶段，即：</p><ul><li>zoom-out</li><li>zoom-in</li></ul><p>搜索算法的起始阶段是 zoom-out，从一个低度节点开始遍历图，直到：thecharacteristic radius of the node links length reaches the scale of thedistance to thequery。这句英文很关键，但是不太好翻译，不过其表达的意思就是：随着搜索过程的进行，从当前节点到其邻居节点的连接长度（即特征半径，characteristicradius）降低到与查询点到这些邻居节点的距离相当的程度。也即，当搜索过程中节点的连接长度降低到与查询点到这些节点的距离相近时，搜索算法会遇到问题，因为它可能会陷入到一个局部最小值，而不是继续向更远的节点扩展搜索范围。</p><p>这一问题可以通过直接从度数最大的顶点开始搜索解决，直接进入 zoom-in阶段。尽管在低维空间中，这样设置提供了更好的性能，但是 NSW查询算法仍然是 <span class="math inline">\(\log^{p}\)</span>（polylogarithmic，严谨定义参考：<ahref="https://en.wikipedia.org/wiki/Polylogarithmic_function">Polylogarithmicfunction</a> ）复杂度，即对数的次幂复杂度。</p><p>NSW 查询算法之所以是 <span class="math inline">\(\log^{p}\)</span>复杂度，是因为总的距离计算数大致与贪婪算法步数（跳数）的平均值乘以贪婪路径上节点度数（度数）的平均值成比例。平均跳数随数据集规模呈对数增长，平均度数也随数据集规模呈对数增长。因此，最终的算法复杂度是<span class="math inline">\(\log^{p}\)</span> 。</p><p>HNSW算法的思想是根据连接的长度尺度将连接分到不同层，然后在多层图上进行搜索。在这种情况下，我们可以独立于网络大小，仅评估每个元素所需的固定部分的连接，从而实现对数复杂度。在该数据结构中，查询从仅具有最长连接的最上层开始（zoom-in阶段）。算法贪婪地从上层遍历元素，直到达到局部最小值。之后，搜索切换到下一层（该层的连接较短），从上一层中的局部最小元素重新开始，然后重复这个过程。在所有层中，每个元素的最大连接数可以保持恒定，从而允许在可导航小世界网络中进行对数复杂度的路由扩展。搜索过程如下图所示：</p><center><img src="/2024/01/03/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AHierarchical-Navigable-Small-World/image-20240103170648753.png" class="" title="Illustration of the HNSW idea."></center><p>形成这种分层结构的一种方法是通过引入层来明确设置具有不同长度尺度的连接。对于每个元素，我们选择一个整数层级<spanclass="math inline">\(l\)</span>，该层级定义了元素所属的最大层。对于一个层中的所有元素，会逐步构建一个近似Delaunay 图的邻近图（即只包含“短”连接的图）。如果我们设置 <spanclass="math inline">\(l\)</span>的指数衰减概率（即遵循几何分布），我们将得到结构中预期层数的对数缩放。搜索过程是一个从顶层开始，以零层结束的迭代贪婪搜索。</p><p>如果我们将所有层的连接合并，结构就会变得类似于 NSW图（在这种情况下，<span class="math inline">\(l\)</span> 可以与 NSW中的节点度数相对应）。与 NSW 不同的是，HNSW的构建算法不需要在插入元素之前对元素进行洗牌——随机性是通过使用层级随机化来实现的，从而允许在数据分布暂时变化的情况下进行真正的增量索引（尽管由于构建过程只是部分确定性的，插入顺序的改变会轻微影响性能）。</p><p>在元素插入过程中，为了选择邻近图的连接，我们利用一种启发式方法，该方法考虑了候选元素之间的距离以创建多样化的连接，而不仅仅是选择最近的邻居。这种启发式方法从距离插入元素最近的候选元素开始检查，并仅当候选元素比任何已连接的候选元素更接近基础（插入的）元素时，才创建到该候选元素的连接。</p><p>当候选元素的数量足够大时，启发式方法允许获取精确的相对邻域图作为子图，这是一个仅使用节点间距离就可以推导出的Delaunay图的最小子图。相对邻域图允许即使在高度聚类的数据情况下也能轻松保持全局连接。如下图所示：</p><center><img src="/2024/01/03/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AHierarchical-Navigable-Small-World/image-20240103194034338.png" class="" title="Illustration of the heuristic used to select the graph neighbors  for  two  isolated  clusters."></center><p>注意，与精确的相对邻域图相比，启发式方法创建了额外的边，允许控制连接的数量，这对于搜索性能很重要。对于一维数据的情况，启发式方法允许通过仅使用元素间距离信息来获取精确的Delaunay 子图（在这种情况下与相对邻域图重合），从而使得从 HNSW直接过渡到一维概率跳表成为可能。</p><h2 id="算法描述">2. 算法描述</h2><h3 id="insert算法">2.1 INSERT算法</h3><p>插入算法伪代码如下：</p><center><img src="/2024/01/03/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AHierarchical-Navigable-Small-World/image-20240103195220090.png" class="" title="INSERT"></center><p>各个参数含义如下：</p><ul><li><span class="math inline">\(hnsw\)</span> ：HNSW 索引数据结构</li><li><span class="math inline">\(q\)</span> ：插入向量</li><li><span class="math inline">\(M\)</span> ：建立连接的数量</li><li><span class="math inline">\(M_{max}\)</span>：每层每个元素的最大连接数</li><li><span class="math inline">\(efConstruction\)</span>：动态候选列表的大小</li><li><span class="math inline">\(m_{L}\)</span>：用于层级生成的标准化因子</li></ul><p>算法主要执行流程如下：</p><ol type="1"><li>从顶层开始使用贪心算法遍历图，以找到该层距离插入元素 <spanclass="math inline">\(q\)</span> 最近的进入点 <spanclass="math inline">\(ep\)</span> ；</li><li>使用从前一层找到的最近邻作为进入点，继续从下一层搜索，并重复该过程。直到搜索到达小于等于<span class="math inline">\(l\)</span> 的层，插入算法进入第二阶段；</li><li>依次在剩余层，调用 <code>SEARCH-LAYER</code>函数获取候选列表，从候选列表中选择 <spanclass="math inline">\(M\)</span> 个邻居，可使用算法 3 或 算法 4；</li><li>当插入元件的连接在零层上建立时，插入过程终止。</li></ol><p>注意，第二阶段中调用的 <code>SEARCH-LAYER</code>函数相比第一阶段有以下不同：</p><ul><li><code>SEARCH-LAYER</code> 函数中的参数 <spanclass="math inline">\(ef\)</span> 从 1 改变为 <spanclass="math inline">\(efConstruction\)</span>，以控制贪心搜索的召回率；</li><li>在每一层上找到的最近邻也被用作插入元素连接的候选者。</li></ul><h3 id="search-layer-算法">2.2 SEARCH-LAYER 算法</h3><p>插入算法中用到的 <code>SEARCH-LAYER</code> 算法伪代码如下：</p><center><img src="/2024/01/03/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AHierarchical-Navigable-Small-World/image-20240103201014963.png" class="" title="SEARCH-LAYER"></center><p>参数含义如下：</p><ul><li><span class="math inline">\(q\)</span> ：查询元素</li><li><span class="math inline">\(ep\)</span> ：进入点</li><li><span class="math inline">\(ef\)</span> ：距离 <spanclass="math inline">\(q\)</span> 最近的元素数量，即 k 近邻中的 k</li><li><span class="math inline">\(l_{c}\)</span> ：层数</li></ul><p>该算法是 NSW 中贪心查询算法的改进，其与 NSW中查询算法不同点在于：</p><ul><li>进入点是固定的</li><li>搜索的质量是由一个不同的参数 <span class="math inline">\(ef\)</span>控制，而不是 NSW 的改变多重搜索的数量</li></ul><h3 id="select-neighbors-simple-算法">2.3 SELECT-NEIGHBORS-SIMPLE算法</h3><p>算法伪代码描述如下：</p><center><img src="/2024/01/03/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AHierarchical-Navigable-Small-World/image-20240103203613228.png" class="" title="SELECT-NEIGHBORS-SIMPLE"></center><p>该算法非常简单，参数及流程不再介绍。</p><h3 id="select-neighbors-heuristic-算法">2.4 SELECT-NEIGHBORS-HEURISTIC算法</h3><p>算法伪代码描述如下：</p><center><img src="/2024/01/03/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AHierarchical-Navigable-Small-World/image-20240103203653389.png" class="" title="SELECT-NEIGHBORS-HEURISTIC"></center><p>启发式算法的两个额外参数含义如下：</p><ul><li><span class="math inline">\(extendCandidates\)</span>：用于标识是否扩展候选集合的 <code>bool</code>值，仅对极度聚集的数据有用</li><li><span class="math inline">\(keepPrunedConnections\)</span>：标识每个元素是否使用固定数量的连接</li></ul><p>每层元素所能拥有的最大连接数由参数 <spanclass="math inline">\(M\)</span> 确定（最底层需额外参数 <spanclass="math inline">\(M_{max0}\)</span>单独指定）。如果一个节点在建立新连接时已经满了，那么它的扩展连接列表将通过用于选择邻居的相同算法进行缩减。</p><h3 id="k-nn-search-算法">2.5 K-NN-SEARCH 算法</h3><p>近似 k-ANN 查询算法伪代码如下：</p><center><img src="/2024/01/03/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AHierarchical-Navigable-Small-World/image-20240103205242367.png" class="" title="K-NN-SEARCH"></center><p>查询算法类似于 <span class="math inline">\(l = 0\)</span>的插入算法，与插入的不同之处在于在最底层找到的最近邻居(用作连接的候选者)现在作为搜索结果返回。查询质量由参数<span class="math inline">\(ef\)</span> 控制。</p><h3 id="构造参数的影响">2.6 构造参数的影响</h3><p>参数 <span class="math inline">\(m_{L}\)</span> 和 <spanclass="math inline">\(m_{max0}\)</span>用于维持图的可导航小世界属性，当对这两个参数设置不同值时得到具有不同特性的图：</p><ul><li><span class="math inline">\(m_{L} = 0, m_{max0} = M\)</span>时，产生有向 K-NN 图</li><li><span class="math inline">\(m_{L} = 0, m_{max0} = \infty\)</span>时，等价于 NSW</li><li><span class="math inline">\(m_{L} \gt 0\)</span> 时，HNSW</li></ul><p>为了实现可控层次结构的最佳性能优势，不同层之间邻居之间的重叠（即元素邻居中也属于其他层的比例）必须小。这需要减小参数<span class="math inline">\(m_{L}\)</span> ，但同时，减小 <spanclass="math inline">\(m_{L}\)</span>会增加每层贪婪搜索的平均跳数，给性能带来负面影响。因此，存在一个最优的<span class="math inline">\(m_L\)</span> 值。一个简单的最优 <spanclass="math inline">\(m_L\)</span> 选择是 <spanclass="math inline">\(1/\ln(M)\)</span>，这对应于跳表参数 <spanclass="math inline">\(p=1/M\)</span>，其中层之间有平均单个元素的重叠。</p><p>通过模拟实验，作者发现在低维数据上增加 <spanclass="math inline">\(m_L\)</span>会导致显著的性能提升，而在高维数据上，增加 <spanclass="math inline">\(m_L\)</span>的效果则不那么明显。此外，使用启发式方法选择图连接（而不是简单地连接到最近的邻居）可以显著提高性能，尤其是在低维数据、高召回率、中维数据和高度聚类数据的情况下。</p><p><span class="math inline">\(M_{max0}\)</span>参数也会显著影响搜索性能，尤其是在高召回率的情况下。作者通过模拟，推荐设置<span class="math inline">\(M_{max0} = 2 \times M\)</span> 。</p><p>参数 <span class="math inline">\(M\)</span> 的合理范围是 <spanclass="math inline">\([5, 48]\)</span> 。模拟表明较小的 <spanclass="math inline">\(M\)</span> 适用于较低的召回率 和/或低维数据；较大的 <span class="math inline">\(M\)</span> 适用于高召回率和/或 高维数据。该参数还影响占用的存储大小。</p><p><span class="math inline">\(efConstruction\)</span>参数值的选择比较直接。正如在 NSW中所建议的那样，它必须足够大，以便在构建过程中产生接近 1 的 K-ANNS召回(0.95对于大多数用例来说已经足够了)。这一参数可通过采样数据自动设置。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>读论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>近似最近邻</tag>
      
      <tag>ANN</tag>
      
      <tag>向量相似度检索</tag>
      
      <tag>K近邻</tag>
      
      <tag>索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DB 论文阅读：Approximate nearest neighbor algorithm based on navigable small world graphs</title>
    <link href="/2023/12/29/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AApproximate-nearest-neighbor-algorithm-based-on-navigable-small-world-graphs/"/>
    <url>/2023/12/29/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AApproximate-nearest-neighbor-algorithm-based-on-navigable-small-world-graphs/</url>
    
    <content type="html"><![CDATA[<p>本文介绍向量近似最近邻（Approximate NearestNeighbor，ANN）的一种经典算法：NSW（Navigable Small World，NSW），原文：<ahref="https://www.researchgate.net/profile/Yu-Malkov/publication/259126397_Approximate_nearest_neighbor_algorithm_based_on_navigable_small_world_graphs/links/63733c302f4bca7fd06030b8/Approximate-nearest-neighbor-algorithm-based-on-navigable-small-world-graphs.pdf">Approximatenearest neighbor algorithm based on navigable small world graphs</a>。</p><p><strong>摘要</strong></p><p>NSW 是一种用于度量空间的近似 K近邻算法。该算法基于图，每个向量构成顶点，向量之间的连接构成边。使用一种贪心算法的变体来进行K 近邻查询操作；插入算法基于查询操作并连接边。插入和查询操作时间复杂度为<spanclass="math inline">\({\log}^{2}(n)\)</span>。查询和插入操作可并行执行，且该索引数据结构可分布式。无需调整索引结构即可改变K 近邻查询正确性的概率。</p><h2 id="核心思想">1. 核心思想</h2><p>索引结构是一个可导航小世界图 <span class="math inline">\(G = (V,E)\)</span> ，向量集合 <span class="math inline">\(X\)</span>中的每个元素一一映射到顶点集合 <span class="math inline">\(V\)</span>。边集 <span class="math inline">\(E\)</span> 由索引构造算法决定。</p><p>相关名词含义：</p><ul><li>朋友（friends）：共享某条边的顶点集</li><li>顶点 <span class="math inline">\(v_i\)</span> 的朋友列表：与顶点<span class="math inline">\(v_i\)</span> 共享一条边的顶点列表</li></ul><p>图中的边有两个目的：</p><ul><li>部分边是短程连接，用来作为 Delaunay图的近似，以使用贪心搜索算法；</li><li>其余边是长程连接，用于实现对数级别复杂度的贪婪搜索。长程连负责构建图的可导航小世界属性。</li></ul><p>数据结构示意图如下：</p><center><img src="/2023/12/29/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AApproximate-nearest-neighbor-algorithm-based-on-navigable-small-world-graphs/image-20231229161552498.png" class="" title="数据结构示意图"></center><p>其中，蓝色圆表示图中顶点（数据集向量），绿色圆表示查询向量，黑色边是Delaunay 图的近似（短程连接），红色边是长程连接。箭头表示从进入点（entrypoint）的一个贪心搜索过程。</p><p>数据结构由顶点的逐个插入形成。对于每个新加入的元素，从结构中找到其最接近的邻居集合（Delaunay图的近似）。这个集合与插入元素相互连接。随着越来越多的元素被插入到结构中，之前作为短程连接的连接现在变成了长程连接，从而形成了一个可导航小世界图。</p><h2 id="查询算法">2. 查询算法</h2><h3 id="基本贪心查询算法">2.1 基本贪心查询算法</h3><p>该小节的算法用于近似最近邻查询，即只返回 1个查询结果。算法伪代码如下：</p><center><img src="/2023/12/29/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AApproximate-nearest-neighbor-algorithm-based-on-navigable-small-world-graphs/image-20231229163003622.png" class="" title="基本贪心查询算法"></center><p>算法接收两个参数：</p><ul><li><span class="math inline">\(q\)</span> ：表示查询向量</li><li><span class="math inline">\(v_{entry\_point}\)</span>：表示查询起始顶点，且 <span class="math inline">\(v_{entry\_point} \inV\)</span> ，即 <span class="math inline">\(v_{entry\_point}\)</span>是顶点集合 <span class="math inline">\(V\)</span> 的一个元素。</li></ul><p>执行流程如下：</p><p>从入口点开始，算法计算查询 <span class="math inline">\(q\)</span>到当前顶点的好友列表中每个顶点的距离，然后选择距离最小的顶点。如果查询与所选顶点之间的距离小于查询与当前元素之间的距离，那么算法会移动到所选顶点，它成为新的当前顶点。当算法达到一个局部最小值时停止，即：其好友列表中没有比该顶点更接近查询<span class="math inline">\(q\)</span> 的顶点。</p><p>注意，该算法并不保证返回最近邻结果，而是返回近似最近邻。</p><h3 id="k-近邻查询">2.2 K 近邻查询</h3><p>近似 K 近邻查询算法伪代码如下：</p><center><img src="/2023/12/29/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AApproximate-nearest-neighbor-algorithm-based-on-navigable-small-world-graphs/image-20231229164309519.png" class="" title="近似 K 近邻查询算法"><img src="/2023/12/29/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AApproximate-nearest-neighbor-algorithm-based-on-navigable-small-world-graphs/image-20231229164334787.png" class="" title="近似 K 近邻查询算法"></center><p>算法参数含义：</p><ul><li><span class="math inline">\(q\)</span> ：表示查询向量</li><li><span class="math inline">\(k\)</span> ：即 k 近邻</li><li><span class="math inline">\(m\)</span>：重复进行 <spanclass="math inline">\(m\)</span> 循环体</li></ul><p>伪代码中一些变量含义解释如下：</p><ul><li>创建一个<code>TreeSet</code>对象<code>tempRes</code>，用于存储临时结果。</li><li>创建一个<code>TreeSet</code>对象<code>candidates</code>，用于存储当前考虑的候选顶点。</li><li>创建一个<code>TreeSet</code>对象<code>visitedSet</code>，用于记录已访问过的顶点，以避免重复访问。</li><li>创建一个列表<code>result</code>，用于存储最终的 k 个最近邻居。</li></ul><p>算法主体中，外层循环即进行 <span class="math inline">\(m\)</span>次查询，以提高查询精度；内层循环对集合 <code>candidates</code>进行动态插入及遍历，直到满足 break 条件或遍历完 <code>candidates</code>结束内层循环。</p><h2 id="插入算法">3. 插入算法</h2><p>插入算法伪代码如下：</p><center><img src="/2023/12/29/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AApproximate-nearest-neighbor-algorithm-based-on-navigable-small-world-graphs/image-20231229171153499.png" class="" title="插入算法"></center><p>参数含义：</p><ul><li><span class="math inline">\(new\_object\)</span> ：插入元素</li><li><span class="math inline">\(f\)</span> ：表示进行 k 近邻查询时的参数k</li><li><span class="math inline">\(w\)</span>：表示调用<code>k-NNSearch</code> 算法时的参数 <spanclass="math inline">\(m\)</span></li></ul><p>该算法首先调用 <code>k-NNSearch</code> 返回近似 k近邻结果，然后将插入元素与近似最近邻结果互相连接边。从伪代码中也可以看出索引结构是无向图。</p><h3 id="参数选择">3.1 参数选择</h3><p>参数 <span class="math inline">\(w\)</span>决定了在构建算法中确定最近邻居的准确性（召回率）。作者建议设置足够大的<span class="math inline">\(w\)</span> ，以让召回率接近1（如：0.95~0.99）。小的召回率会增加错误连接的比例，这只会提高算法的复杂性，而实验表明，插入时召回率超过0.99 对搜索质量没有可测量的影响。测试还显示，对于最佳召回率，<spanclass="math inline">\(w\)</span>随着数据集大小的变化缓慢（对数）变化，因此，如果我们已经知道一个好的召回率的近似值<span class="math inline">\(w0\)</span>，我们可以首先使用大得多的 <spanclass="math inline">\(m\)</span>（例如，<span class="math inline">\(m =2\times w0 + 10\)</span>），假设 <span class="math inline">\(m\)</span>足够大，使得搜索结果真正是最近的 k 个邻居，然后增加 <spanclass="math inline">\(w\)</span>，并重复测试，直到达到一个高召回率（如：0.95~0.99）。操作的复杂度与数据集大小成对数关系，因此它不影响整体构建复杂度。</p><p>参数 <span class="math inline">\(f\)</span>决定了在插入新元素时，与新元素连接的最近邻居的数量。测试结果显示，对于维度在1~20 的欧式空间数据，<span class="math inline">\(f\)</span>的值应该大约是维度 <span class="math inline">\(d\)</span> 的 3倍，这样可以保持内存消耗与维度线性增长，同时保持较高的搜索召回率。小的<span class="math inline">\(f\)</span>能够减少单次搜索的复杂度，但是牺牲了召回质量。</p><h2 id="总结与问题">4. 总结与问题</h2><p>以上就是对 NSW关键的查询、插入算法的介绍。实验部分请参考原论文。在原论文中，作者还提出了可改进的方向，以降低复杂度和/或提高准确性：</p><ul><li><strong>更复杂的节点朋友选择算法</strong>：选择最近的邻居作为朋友并不是近似Delaunay图的最佳方法，因为这种方法只考虑了新元素与候选节点之间的距离，而忽略了候选节点之间的距离。</li><li><strong>更复杂的可导航小世界创建算法</strong></li><li><strong>更有效地管理多个搜索</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>读论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>近似最近邻</tag>
      
      <tag>ANN</tag>
      
      <tag>向量相似度检索</tag>
      
      <tag>K近邻</tag>
      
      <tag>索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DB 论文阅读：A Relational Model of Data for Large Shared Data Banks</title>
    <link href="/2023/12/25/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AA-Relational-Model-of-Data-for-Large-Shared-Data-Banks/"/>
    <url>/2023/12/25/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AA-Relational-Model-of-Data-for-Large-Shared-Data-Banks/</url>
    
    <content type="html"><![CDATA[<p>关系模型是现代数据库的理论基础。1969 和 1970 年，Codd 的两篇论文《Derivability, Redundancy and Consistency of Relations Stored in LargeData Banks》和《A Relational Model of Data for Large Shared DataBanks》提出了关系模型理论，为后续几十年数据库领域的发展提供了基础。</p><p>由于 1969 年的论文实际上就是《A Relational Model of Data for LargeShared Data Banks》的非正式版本，二者内容基本一致，所以本文仅介绍 1970年发表在 <em>Communications of the ACM</em> 上的正式论文《A RelationalModel of Data for Large Shared Data Banks》。</p><h2 id="背景介绍">1. 背景介绍</h2><p>要想理解关系模型为什么被提出，首先需要了解论文发表时的时代背景。</p><p>当时的数据库系统大多采用树形或网状结构，应用程序与数据库的物理存储结构紧密耦合，应用程序的开发者必须知道数据库中数据的物理存储结构，并在应用程序中实现相关逻辑进行数据访问。一旦数据库的物理存储结构发生变化，那么应用程序的相关代码也必须进行相应的改变。</p><p>这种应用和数据库紧密耦合的问题在论文中被统称为 “DataDependencies”，具体地，有以下 3 种迫切需要移除的数据依赖：</p><ul><li><p><strong>Ordering Dependence</strong></p><p>排序依赖指在某些系统中，数据元素的存储方式与硬件确定的地址顺序紧密相关。例如，一个存储零件记录的文件可能按照零件序列号升序存储。这些系统允许应用程序员假设记录的展示顺序与物理存储顺序一致。应用程序可能依赖于这一假设实现，这导致当需要更换物理存储顺序时，依赖于存储顺序的应用程序可能无法正确运行。</p></li><li><p><strong>Indexing Dependence</strong></p><p>索引通常被视为数据表示的性能导向组件，它通常能提高对查询和更新的响应，同时可能会减慢插入和删除操作的响应。从信息角度来看，索引是数据表示的冗余部分。索引依赖指应用程序和终端活动能否在索引的创建和销毁过程中保持不变，也即索引存在与否不影响应用的正常运行。</p></li><li><p><strong>Access Path Dependence</strong></p><p>访问路径依赖指许多现有的格式化数据系统为用户提供了树状文件或更一般的网络模型的数据。为这些系统开发的应用程序在树或网络结构发生变化时，逻辑上可能会受损。</p></li></ul><h2 id="关系模型">2. 关系模型</h2><p>为了解决已有系统的问题，Codd提出了关系模型，将数据的表示和数据的存储解耦。关系模型仅描述数据的逻辑结构，而不限制数据的物理存储结构。</p><h3 id="概念">2.1 概念</h3><p>在原论文中，关系是使用集合和笛卡尔积严格定义的：</p><p>给定集合 <span class="math inline">\(S_1, S_2, …, S_n\)</span>，<span class="math inline">\(R\)</span> 是 <spanclass="math inline">\(n\)</span> 个集合上的关系，如果 <spanclass="math inline">\(R\)</span> 是 <spanclass="math inline">\(n\)</span>元元组的集合，且元组的第一个元素来自集合 <spanclass="math inline">\(S_1\)</span> ，元组的第二个元素来自 <spanclass="math inline">\(S_2\)</span>，……，以此类推。用更简洁的形式表述，也就是 <spanclass="math inline">\(R\)</span> 是 <span class="math inline">\(S_1\times S_2 \times … \times S_n\)</span> 的子集。</p><p>据此，可以引出我们已经非常熟悉的概念，如：元组、表、列等等，在此不再介绍。</p><p>关系型模型的优点在于提供了一种描述数据的自然结构的方式，即只描述数据本身，而不涉及机器表示的额外结构。这为高级数据语言提供了基础，并有助于清晰评估当前格式化数据系统的逻辑限制。</p><h3 id="正规形式">2.2 正规形式</h3><p>2.1小节定义的关系允许含有非简单域，也就是允许某个列也是关系。当关系中含有非简单域时，需要更复杂的数据结构来存储。为了降低存储复杂度，可以将关系进行规范化。</p><p>Codd提出了一种称为规范化（Normalization）的过程，该过程从树状结构的顶部关系开始，通过插入父关系的主键来扩展每个直接下级关系。然后从父关系中删除所有非简单域，移除树的顶部节点，并在剩余的子树上重复这个过程。为了使规范化过程适用，非规范化的关系集合必须满足两个条件：非简单域之间的相互关系图必须是一系列树，且没有任何主键包含非简单域的组成部分。</p><p>原论文的例子可以帮助理解：</p><center><img src="/2023/12/25/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AA-Relational-Model-of-Data-for-Large-Shared-Data-Banks/image-20231225204945313.png" class="" title="关系的树形依赖结构"></center><center><img src="/2023/12/25/DB-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9AA-Relational-Model-of-Data-for-Large-Shared-Data-Banks/image-20231225204927954.png" class="" title="原始关系与规范化后关系"></center><h3 id="关系的操作">2.3 关系的操作</h3><p>此小节实际上就是关系代数的内容，讨论了如何使用运算符及运算符的组合对关系进行运算。</p><p>对关系代数的介绍可参考： <ahref="https://arcsin2.cloud/2023/09/05/%E4%BB%8E%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0%E5%88%B0-SQL/">从关系代数到SQL</a> ，本文不再介绍。</p><h3 id="冗余性">2.4 冗余性</h3><p>本小节讨论了数据库中数据冗余的概念，以及如何通过关系型数据模型来管理和减少冗余。</p><p>首先需要引入定义 <spanclass="math inline">\(θ\)</span>-<em>derivable</em> ：</p><p>给定关系的操作集合 <span class="math inline">\(\theta\)</span>，如果存在来自 <span class="math inline">\(\theta\)</span>的操作序列，能够从关系集合 <span class="math inline">\(S\)</span>中经过这些操作产生关系 <span class="math inline">\(R\)</span> ，则称<span class="math inline">\(R\)</span> 是可从 <spanclass="math inline">\(S\)</span> 中 <spanclass="math inline">\(θ\)</span>-<em>derivable</em> 的。</p><p>在此基础上引出强冗余性和弱冗余性的定义。</p><ul><li><p><strong>强冗余性</strong></p><p>当关系集中至少有一个关系可以通过其他关系的投影推导出来时，就存在强冗余。这意味着关系集中存在不必要的重复数据，一般需要重新设计关系模式以消除冗余。</p></li><li><p><strong>弱冗余性</strong></p><p>当关系集中存在一个关系，其投影不是从其他关系推导出来的，但始终是其他关系投影的某个连接的投影时，就存在弱冗余。这种冗余是固有的，通常与用户社区的逻辑需求相关，一般不需要消除。</p></li></ul><h3 id="一致性">2.5 一致性</h3><p>在本小节中，Codd 定义了数据一致性的概念，即在给定的一组关系（<spanclass="math inline">\(C\)</span>）、一组约束声明（<spanclass="math inline">\(Z\)</span>）和关系集的即时值（<spanclass="math inline">\(V\)</span>）的情况下，如果 <spanclass="math inline">\(V\)</span> 满足 <spanclass="math inline">\(Z\)</span> ，则称状态 （<spanclass="math inline">\(C, Z, V\)</span>） 是一致的，否则是不一致的。</p><p>为了保持系统的一致性，可在插入、删除或更新操作时检查可能的不一致性，以及定期进行一致性检查。</p><h2 id="总结">3. 总结</h2><p>以上就是对论文 《A Relational Model of Data for Large Shared DataBanks》主要内容的总结。本文章节与原论文章节并非一一对应，而是重新进行了组织，同时删除了个人认为不影响理解论文核心内容的章节，如原论文1.5 和 1.6 小节等，具体请参阅原论文。</p><p><br></p><p><br></p><p><strong>参考：</strong></p><ol type="1"><li><ahref="https://technology.amis.nl/wp-content/uploads/images/RJ599.pdf">Derivability,Redundancy and Consistency of Relations Stored in Large DataBanks</a></li><li><ahref="https://www.db.dobo.sk/wp-content/uploads/2015/11/Codd_1970_A_relational_model.pdf">ARelational Model of Data for Large Shared Data Banks</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>读论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>关系模型</tag>
      
      <tag>关系代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从关系代数到 SQL</title>
    <link href="/2023/09/05/%E4%BB%8E%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0%E5%88%B0-SQL/"/>
    <url>/2023/09/05/%E4%BB%8E%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0%E5%88%B0-SQL/</url>
    
    <content type="html"><![CDATA[<p>关系模型与关系代数是关系型数据库系统的基础，SQL是用户与数据库系统交互的媒介。本文简要介绍关系模型与关系代数的基本内容，从展示关系代数在SQL 中的对应语句。</p><h2 id="关系模型">1. 关系模型</h2><p>关系模型是对数据库系统的抽象，其用 “关系”来表示数据库，而隐藏数据在数据库系统内部是如何组织的。关系模型的核心原则是：</p><ul><li>以简单的数据结构(关系)存储数据库。</li><li>物理存储结构由 DBMS 实现决定。</li><li>通过高级语言访问数据，DBMS 负责找到最好的执行策略。</li></ul><p>关系模型具有几个关键概念：</p><ul><li>关系（relation）：关系是包含表示实体的属性关系的无序集合。</li><li>元组（tuple）：元组是关系中的一组属性值。</li></ul><h2 id="关系代数">2. 关系代数</h2><p>关系代数是用于操作关系模型的工具，以在数据库中进行查询等操作。关系代数的每个操作符接受一个或多个关系作为其输入，并输出一个新的关系。关系代数运算符根据输入的关系数量可分为单目运算符和双目运算符。最常用的操作有：</p><ul><li>选择（Select）：<span class="math inline">\(\sigma\)</span></li><li>投影（Projection）：<span class="math inline">\(\Pi\)</span></li><li>并集（Union）：<span class="math inline">\(\cup\)</span></li><li>交集（Intersection）：<span class="math inline">\(\cap\)</span></li><li>差集（Difference）：<span class="math inline">\(-\)</span></li><li>笛卡尔积（Product）：<spanclass="math inline">\(\times\)</span></li><li>连接（Join）：<span class="math inline">\(\bowtie\)</span></li><li>……</li></ul><h3 id="选择">2.1 选择</h3><p>含义：从关系中选择满足选择谓词的元组。谓词用来充当过滤器，仅保留满足谓词条件的元组。可以使用合取/析取合并多个谓词。</p><p>语法：<spanclass="math inline">\(\sigma_{predicate}(\text{R})\)</span></p><p>例子：<span class="math inline">\(\sigma_{{\text{a}\_\text{id}=\text{&#39;a2 &#39;}} \wedge {\text{ b}\_\text{id}&gt; \text{102}}}(\text{R})\)</span></p><p>SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> R<br><span class="hljs-keyword">WHERE</span> a_id<span class="hljs-operator">=</span><span class="hljs-string">&#x27;a2&#x27;</span> <span class="hljs-keyword">AND</span> b_id<span class="hljs-operator">&gt;</span><span class="hljs-number">102</span>;<br></code></pre></td></tr></table></figure><h3 id="投影">2.2 投影</h3><p>含义：用只包含指定属性的元组生成关系。可用于重新排列属性顺序和操作属性的值。</p><p>语法：<span class="math inline">\(\Pi_{\text{A1},\text{A2},...,\text{An} }(\text{R})\)</span></p><p>例子：<span class="math inline">\(\Pi_{\text{b}\_\text{id-100},\text{a}\_\text{id} }( \sigma_{\text{a}\_\text{id}=\text{&#39;a2&#39;} }(\text{R}) )\)</span></p><p>SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> b_id<span class="hljs-number">-100</span>, a_id<br><span class="hljs-keyword">FROM</span> R <span class="hljs-keyword">WHERE</span> a_id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a2&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="并集">2.3 并集</h3><p>含义：生成一个关系，其中包含只出现在一个或两个输入关系中的所有元组。</p><p>语法：<span class="math inline">\(\text{R} \cup \text{S}\)</span></p><p>SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">(<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> R)<br><span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span><br>(<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> S);<br></code></pre></td></tr></table></figure><h3 id="交集">2.4 交集</h3><p>含义：生成一个关系，该关系只包含出现在两个输入关系中的元组。</p><p>语法：<span class="math inline">\(\text{R} \cap \text{S}\)</span></p><p>SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">(<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> R)<br><span class="hljs-keyword">INTERSECT</span><br>(<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> S);<br></code></pre></td></tr></table></figure><h3 id="差集">2.5 差集</h3><p>含义：生成一个关系，其中只包含第一个输入关系中出现的元组，而不包含第二个输入关系中出现的元组。</p><p>语法：<span class="math inline">\(\text{R} - \text{S}\)</span></p><p>SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">(<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> R)<br><span class="hljs-keyword">EXCEPT</span><br>(<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> S);<br></code></pre></td></tr></table></figure><h3 id="笛卡尔积">2.6 笛卡尔积</h3><p>含义：生成包含来自输入关系的元组的所有可能组合的关系。</p><p>语法：<span class="math inline">\(\text{R} \times\text{S}\)</span></p><p>SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> R <span class="hljs-keyword">CROSS</span> <span class="hljs-keyword">JOIN</span> S;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> R, S;<br></code></pre></td></tr></table></figure><h3 id="连接">2.7 连接</h3><p>含义：生成一个包含元组的关系，该元组是两个具有一个或多个属性的共同值元组(每个输入关系一个)的组合。</p><p>语法：<span class="math inline">\(\text{R} \bowtie\text{S}\)</span></p><p>SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> R <span class="hljs-keyword">NATURAL</span> <span class="hljs-keyword">JOIN</span> S;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> R <span class="hljs-keyword">JOIN</span> S <span class="hljs-keyword">USING</span> (a_id, b_id);<br></code></pre></td></tr></table></figure><p>连接操作还可以附加谓词，相当于先做笛卡尔积再进行选择操作，见《Database System Concepts》一书解释：</p><img src="/2023/09/05/%E4%BB%8E%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0%E5%88%B0-SQL/image-20231222215127913.png" class="" title="连接+谓词&#x3D;&#x3D;笛卡尔积+选择"><p>这种形式相当于以下 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> R, S <span class="hljs-keyword">ON</span> R.a1<span class="hljs-operator">=</span>S.a2;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> R, S<br><span class="hljs-keyword">WHERE</span> R.a1<span class="hljs-operator">=</span>S.a2;<br></code></pre></td></tr></table></figure><h3 id="赋值">2.8 赋值</h3><p>含义：提供一种工具，更容易地表达复杂查询。</p><p>符号：<span class="math inline">\(\leftarrow\)</span></p><p>例子：</p><img src="/2023/09/05/%E4%BB%8E%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0%E5%88%B0-SQL/image-20231222221314760.png" class="" title="image-20231222221314760"><h3 id="重命名">2.9 重命名</h3><p>含义：用于给关系代数计算中间结果取名。</p><p>符号：<span class="math inline">\(\rho\)</span></p><p>语法：<span class="math inline">\(\rho_{\text{x} }(\text{E})\)</span>或 <span class="math inline">\(\rho_{\text{x} (\text{A1},\text{A2},...,\text{An} ) }(\text{E})\)</span></p><p>SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> T.name<br><span class="hljs-keyword">FROM</span> instructor <span class="hljs-keyword">AS</span> T, instructor <span class="hljs-keyword">AS</span> S<br><span class="hljs-keyword">WHERE</span> T.salary <span class="hljs-operator">&gt;</span> S.salary <span class="hljs-keyword">AND</span> S.dept name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Biology&#x27;</span>;<br><br><span class="hljs-keyword">SELECT</span> name <span class="hljs-keyword">AS</span> instructor_name, course_id<br><span class="hljs-keyword">FROM</span> instructor, teaches<br><span class="hljs-keyword">WHERE</span> instructor.ID <span class="hljs-operator">=</span> teaches.ID;<br></code></pre></td></tr></table></figure><h3 id="聚合">2.10 聚合</h3><p>含义：计算 AVG、MAX、MIN、SUM、COUNT 值</p><p>符号：<span class="math inline">\(\gamma\)</span></p><p>例子：<span class="math inline">\(_\text{A2} \gamma_{\textbf{average}\text{(A1)}} (R)\)</span> ，表示在关系 R 上，在 A2属性上分组，计算 A1 属性的平均值。</p><p>SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> dept_name, <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-keyword">AS</span> avg salary<br><span class="hljs-keyword">FROM</span> instructor<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> dept_name;<br></code></pre></td></tr></table></figure><p>更复杂的例子：</p><img src="/2023/09/05/%E4%BB%8E%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0%E5%88%B0-SQL/image-20231222223632496.png" class="" title="image-20231222223632496"><p><br></p><p><br></p><p><strong>参考：</strong></p><ol type="1"><li><ahref="https://15445.courses.cs.cmu.edu/fall2022/slides/01-introduction.pdf">CMU15-445/645 Fall 2022 Lecture #01: Course Overview &amp; RelationalModel</a></li><li><a href="https://codex.cs.yale.edu/avi/db-book/">Database SystemConcepts Seventh Edition</a></li><li><ahref="https://www.db.dobo.sk/wp-content/uploads/2015/11/Codd_1970_A_relational_model.pdf">ARelational Model of Data for Large Shared Data Banks</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>关系模型</tag>
      
      <tag>关系代数</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 网络编程基础 API</title>
    <link href="/2023/08/11/Linux%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%20API/"/>
    <url>/2023/08/11/Linux%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%20API/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文是《Linux高性能服务器编程》阅读记录，供以后查阅参考。推荐阅读原书。</p></blockquote><h2id="主机字节序和网络字节序转换函数">主机字节序和网络字节序转换函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">ntohl</span> <span class="hljs-params">(<span class="hljs-type">uint32_t</span> __netlong)</span>;<span class="hljs-comment">// network to host long</span><br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">ntohs</span> <span class="hljs-params">(<span class="hljs-type">uint16_t</span> __netshort)</span>;<span class="hljs-comment">// network to host short</span><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">htonl</span> <span class="hljs-params">(<span class="hljs-type">uint32_t</span> __hostlong)</span>;<br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">htons</span> <span class="hljs-params">(<span class="hljs-type">uint16_t</span> __hostshort)</span>;<br></code></pre></td></tr></table></figure><p>其中，<code>int32</code> 型函数通常用来转换 IP地址；<code>int16</code> 型函数通常用来转换端口号。</p><h2 id="ip-地址转换函数">IP 地址转换函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-comment">/* Convert Internet host address from numbers-and-dots notation in CP</span><br><span class="hljs-comment">   into binary data in network byte order.  */</span><br><span class="hljs-type">in_addr_t</span> <span class="hljs-title function_">inet_addr</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *__cp)</span>;<span class="hljs-comment">// 失败时返回 INADDR_NONE</span><br><br><span class="hljs-comment">/* Convert Internet host address from numbers-and-dots notation in CP</span><br><span class="hljs-comment">   into binary data and store the result in the structure INP.  */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">inet_aton</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *__cp, <span class="hljs-keyword">struct</span> in_addr *__inp)</span>;<br><br><span class="hljs-comment">/* Convert Internet number in IN to ASCII representation.  The return value</span><br><span class="hljs-comment">   is a pointer to an internal array containing the string.  */</span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">inet_ntoa</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> in_addr __in)</span>;<span class="hljs-comment">// 不可重入（如需要记录点分十进制 IP 地址，需拷贝到另外内存地址）</span><br></code></pre></td></tr></table></figure><h2 id="创建-socket">创建 socket</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-comment">/* Create a new socket of type TYPE in domain DOMAIN, using</span><br><span class="hljs-comment">   protocol PROTOCOL.  If PROTOCOL is zero, one is chosen automatically.</span><br><span class="hljs-comment">   Returns a file descriptor for the new socket, or -1 for errors.  */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">socket</span> <span class="hljs-params">(<span class="hljs-type">int</span> __domain, <span class="hljs-type">int</span> __type, <span class="hljs-type">int</span> __protocol)</span>;<br><span class="hljs-comment">// domain 参数可选值： PF_INET 表示 IPv4；PF_INET6 表示 IPv6</span><br><span class="hljs-comment">// type 参数可选值：SOCK_STREAM 表示 TCP；SOCK_UGRAM 表示 UDP</span><br><span class="hljs-comment">// type 一般都设置为 0</span><br></code></pre></td></tr></table></figure><h2 id="命名-socket">命名 socket</h2><p>服务端需要调用 <code>bind</code> 函数以给 socket 命名地址（IP地址、端口号等），定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-comment">/* Give the socket FD the local address ADDR (which is LEN bytes long).  */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">bind</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* __addr, <span class="hljs-type">socklen_t</span> __len)</span>;<br></code></pre></td></tr></table></figure><h2 id="监听-socket">监听 socket</h2><p>使用 <code>listen</code>函数创建监听队列以存放待处理的客户端连接：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-comment">/* Prepare to accept connections on socket FD.</span><br><span class="hljs-comment">   N connection requests will be queued before further requests are refused.</span><br><span class="hljs-comment">   Returns 0 on success, -1 for errors.  */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">listen</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fd, <span class="hljs-type">int</span> __n)</span>;<br></code></pre></td></tr></table></figure><h2 id="接受连接">接受连接</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-comment">/* Await a connection on socket FD.</span><br><span class="hljs-comment">   When a connection arrives, open a new socket to communicate with it,</span><br><span class="hljs-comment">   set *ADDR (which is *ADDR_LEN bytes long) to the address of the connecting</span><br><span class="hljs-comment">   peer and *ADDR_LEN to the address&#x27;s actual length, and return the</span><br><span class="hljs-comment">   new socket&#x27;s descriptor, or -1 for errors.</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">accept</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fd, <span class="hljs-keyword">struct</span> sockaddr *__addr, <span class="hljs-type">socklen_t</span> *__addr_len)</span>;<br></code></pre></td></tr></table></figure><h2 id="发起连接">发起连接</h2><p>客户端需要通过如下调用主动与服务器建立连接：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-comment">/* Open a connection on socket FD to peer at ADDR (which LEN bytes long).</span><br><span class="hljs-comment">   For connectionless socket types, just set the default address to send to</span><br><span class="hljs-comment">   and the only address from which to accept transmissions.</span><br><span class="hljs-comment">   Return 0 on success, -1 for errors.  */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">connect</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *__addr, <span class="hljs-type">socklen_t</span> __len)</span>;<br></code></pre></td></tr></table></figure><h2 id="关闭连接">关闭连接</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span>;<span class="hljs-comment">// 实际上该函数将 fd 引用计数减 1，只有当 fd 引用计数为 0 时，才真正关闭连接</span><br><br><span class="hljs-comment">// 可使用如下 shutdown 函数立即终止连接，而不是将 socket 引用计数减 1</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-comment">/* Shut down all or part of the connection open on socket FD.</span><br><span class="hljs-comment">   HOW determines what to shut down:</span><br><span class="hljs-comment">     SHUT_RD   = No more receptions;</span><br><span class="hljs-comment">     SHUT_WR   = No more transmissions;</span><br><span class="hljs-comment">     SHUT_RDWR = No more receptions or transmissions.</span><br><span class="hljs-comment">   Returns 0 on success, -1 for errors.  */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">shutdown</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fd, <span class="hljs-type">int</span> __how)</span>;<br></code></pre></td></tr></table></figure><h2 id="tcp-数据读写">TCP 数据读写</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-comment">/* Read N bytes into BUF from socket FD.</span><br><span class="hljs-comment">   Returns the number read or -1 for errors.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">recv</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fd, <span class="hljs-type">void</span> *__buf, <span class="hljs-type">size_t</span> __n, <span class="hljs-type">int</span> __flags)</span>;<br><br><span class="hljs-comment">/* Send N bytes of BUF to socket FD.  Returns the number sent or -1.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">send</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *__buf, <span class="hljs-type">size_t</span> __n, <span class="hljs-type">int</span> __flags)</span>;<br></code></pre></td></tr></table></figure><h2 id="udp-数据读写">UDP 数据读写</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><br><span class="hljs-comment">/* Read N bytes into BUF through socket FD.</span><br><span class="hljs-comment">   If ADDR is not NULL, fill in *ADDR_LEN bytes of it with tha address of</span><br><span class="hljs-comment">   the sender, and store the actual size of the address in *ADDR_LEN.</span><br><span class="hljs-comment">   Returns the number of bytes read or -1 for errors.</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">recvfrom</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fd, <span class="hljs-type">void</span> *__buf, <span class="hljs-type">size_t</span> __n,</span><br><span class="hljs-params"> <span class="hljs-type">int</span> __flags, <span class="hljs-keyword">struct</span> sockaddr* __addr,</span><br><span class="hljs-params"> <span class="hljs-type">socklen_t</span> * __addr_len)</span>;<br><br><br><span class="hljs-comment">/* Send N bytes of BUF on socket FD to peer at address ADDR (which is</span><br><span class="hljs-comment">   ADDR_LEN bytes long).  Returns the number sent, or -1 for errors.</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">sendto</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *__buf, <span class="hljs-type">size_t</span> __n,</span><br><span class="hljs-params">       <span class="hljs-type">int</span> __flags, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* __addr,</span><br><span class="hljs-params">       <span class="hljs-type">socklen_t</span> __addr_len)</span>;<br></code></pre></td></tr></table></figure><h2 id="通用数据读写函数">通用数据读写函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><br><span class="hljs-comment">/* Receive a message as described by MESSAGE from socket FD.</span><br><span class="hljs-comment">   Returns the number of bytes read or -1 for errors.</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">recvmsg</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fd, <span class="hljs-keyword">struct</span> msghdr *__message, <span class="hljs-type">int</span> __flags)</span>;<br><br><br><span class="hljs-comment">/* Send a message described MESSAGE on socket FD.</span><br><span class="hljs-comment">   Returns the number of bytes sent, or -1 for errors.</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">sendmsg</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> msghdr *__message, <span class="hljs-type">int</span> __flags)</span>;<br><br><span class="hljs-comment">// msghdr 结构体定义</span><br><span class="hljs-comment">/* Structure describing messages sent by</span><br><span class="hljs-comment">   `sendmsg&#x27; and received by `recvmsg&#x27;.  */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msghdr</span></span><br><span class="hljs-class">  &#123;</span><br>    <span class="hljs-type">void</span> *msg_name;<span class="hljs-comment">/* Address to send to/receive from.  */</span><br>    <span class="hljs-type">socklen_t</span> msg_namelen;<span class="hljs-comment">/* Length of address data.  */</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span> *<span class="hljs-title">msg_iov</span>;</span><span class="hljs-comment">/* Vector of data to send/receive into.  */</span><br>    <span class="hljs-type">size_t</span> msg_iovlen;<span class="hljs-comment">/* Number of elements in the vector.  */</span><br><br>    <span class="hljs-type">void</span> *msg_control;<span class="hljs-comment">/* Ancillary data (eg BSD filedesc passing). */</span><br>    <span class="hljs-type">size_t</span> msg_controllen;<span class="hljs-comment">/* Ancillary data buffer length.</span><br><span class="hljs-comment">   !! The type should be socklen_t but the</span><br><span class="hljs-comment">   definition of the kernel is incompatible</span><br><span class="hljs-comment">   with this.  */</span><br><br>    <span class="hljs-type">int</span> msg_flags;<span class="hljs-comment">/* Flags on received message.  */</span><br>  &#125;;<br><br><span class="hljs-comment">// iovoc 结构体定义</span><br><span class="hljs-comment">/* Structure for scatter/gather I/O.  */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span></span><br><span class="hljs-class">  &#123;</span><br>    <span class="hljs-type">void</span> *iov_base;<span class="hljs-comment">/* Pointer to data.  */</span><br>    <span class="hljs-type">size_t</span> iov_len;<span class="hljs-comment">/* Length of data.  */</span><br>  &#125;;<br></code></pre></td></tr></table></figure><h2 id="带外标记">带外标记</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-comment">/* Determine whether socket is at a out-of-band mark.  */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sockatmark</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fd)</span>;<br><span class="hljs-comment">// 判断下一个被读取到的数据是否是带外数据</span><br></code></pre></td></tr></table></figure><h2 id="地址信息函数">地址信息函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-comment">/* Put the local address of FD into *ADDR and its length in *LEN.  */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getsockname</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fd, <span class="hljs-keyword">struct</span> sockaddr* __addr, <span class="hljs-type">socklen_t</span> * __len)</span>;<br><br><span class="hljs-comment">/* Put the address of the peer connected to socket FD into *ADDR</span><br><span class="hljs-comment">   (which is *LEN bytes long), and its actual length into *LEN.  */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getpeername</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fd, <span class="hljs-keyword">struct</span> sockaddr* __addr, <span class="hljs-type">socklen_t</span> * __len)</span>;<br></code></pre></td></tr></table></figure><h2 id="socket-选项">socket 选项</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-comment">/* Put the current value for socket FD&#x27;s option OPTNAME at protocol level LEVEL</span><br><span class="hljs-comment">   into OPTVAL (which is *OPTLEN bytes long), and set *OPTLEN to the value&#x27;s</span><br><span class="hljs-comment">   actual length.  Returns 0 on success, -1 for errors.  */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getsockopt</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fd, <span class="hljs-type">int</span> __level, <span class="hljs-type">int</span> __optname,</span><br><span class="hljs-params">       <span class="hljs-type">void</span> * __optval,</span><br><span class="hljs-params">       <span class="hljs-type">socklen_t</span> * __optlen)</span>;<br><br><br><span class="hljs-comment">/* Set socket FD&#x27;s option OPTNAME at protocol level LEVEL</span><br><span class="hljs-comment">   to *OPTVAL (which is OPTLEN bytes long).</span><br><span class="hljs-comment">   Returns 0 on success, -1 for errors.  */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">setsockopt</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fd, <span class="hljs-type">int</span> __level, <span class="hljs-type">int</span> __optname,</span><br><span class="hljs-params">       <span class="hljs-type">const</span> <span class="hljs-type">void</span> *__optval, <span class="hljs-type">socklen_t</span> __optlen)</span>;<br><br><span class="hljs-comment">// level 参数指定要操作哪个协议的选项，如 IPv4、IPv6、TCP 等</span><br></code></pre></td></tr></table></figure><h2 id="so_reuseaddr-选项">SO_REUSEADDR 选项</h2><p>该选项可以让服务器程序强制使用被处于 TIME_WAIT 状态的连接占用的socket 地址，例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (argc &lt;= <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage: %s ip_address port_number\n&quot;</span>, basename(argv[<span class="hljs-number">0</span>]));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> port = atoi(argv[<span class="hljs-number">2</span>]);<br><br>    <span class="hljs-type">int</span> sock = socket(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    assert(sock &gt;= <span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> reuse = <span class="hljs-number">1</span>;<br>    setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="hljs-keyword">sizeof</span>(reuse));  <span class="hljs-comment">// set SO_REUSEADDR</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    bzero(&amp;address, <span class="hljs-keyword">sizeof</span>(address));<br>    address.sin_family = AF_INET;<br>    inet_pton(AF_INET, ip, &amp;address.sin_addr);<br>    address.sin_port = htons(port);<br>    <span class="hljs-type">int</span> ret = bind(sock, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;address, <span class="hljs-keyword">sizeof</span>(address));<br>    assert(ret != <span class="hljs-number">-1</span>);<br><br>    ret = listen(sock, <span class="hljs-number">5</span>);<br>    assert(ret != <span class="hljs-number">-1</span>);<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client</span>;</span><br>    <span class="hljs-type">socklen_t</span> client_addrlength = <span class="hljs-keyword">sizeof</span>(client);<br>    <span class="hljs-type">int</span> connfd = accept(sock, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;client, &amp;client_addrlength);<br>    <span class="hljs-keyword">if</span> (connfd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;errno is: %d\n&quot;</span>, errno);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-type">char</span> remote[INET_ADDRSTRLEN];<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connected with ip: %s and port: %d\n&quot;</span>,<br>               inet_ntop(AF_INET, &amp;client.sin_addr, remote, INET_ADDRSTRLEN), ntohs(client.sin_port));<br>        close(connfd);<br>    &#125;<br><br>    close(sock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="网络信息-api">网络信息 API</h2><h3 id="gethostbyname-和-gethostbyaddr">gethostbyname 和gethostbyaddr</h3><p><code>gethostbyname</code> 根据主机名称获取主机完整信息。其首先在本地<code>/etc/hosts</code> 配置文件查找主机，若没找到，访问 DNS 服务。</p><p><code>gethostbyaddr</code> 根据 IP 地址获取主机的完整信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netdb.h&gt;</span></span><br><br><span class="hljs-keyword">struct</span> hostent* <span class="hljs-title function_">gethostbyname</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name)</span>;<br><span class="hljs-keyword">struct</span> hostent* <span class="hljs-title function_">gethostbyaddr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* addr, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> type)</span>;<br><br><span class="hljs-comment">/* Description of data base entry for a single host.  */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hostent</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">char</span> *h_name;<span class="hljs-comment">/* Official name of host.  */</span><br>  <span class="hljs-type">char</span> **h_aliases;<span class="hljs-comment">/* Alias list.  */</span><br>  <span class="hljs-type">int</span> h_addrtype;<span class="hljs-comment">/* Host address type.  */</span><br>  <span class="hljs-type">int</span> h_length;<span class="hljs-comment">/* Length of address.  */</span><br>  <span class="hljs-type">char</span> **h_addr_list;<span class="hljs-comment">/* List of addresses from name server.  */</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="getservbyname-和-getservbyport">getservbyname 和getservbyport</h3><p><code>getservbyname</code> 根据名称获取某个服务完整信息；</p><p><code>getservbyport</code> 根据端口号获取某个服务完整信息。</p><p>两个函数实际上都通过读取 <code>/etc/services</code>文件来获取服务信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netdb.h&gt;</span></span><br><br><span class="hljs-keyword">struct</span> servent* <span class="hljs-title function_">getservbyname</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* proto)</span>;<br><span class="hljs-keyword">struct</span> servent* <span class="hljs-title function_">getservbyport</span><span class="hljs-params">(<span class="hljs-type">int</span> port, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* proto)</span>;<br><br><span class="hljs-comment">/* Description of data base entry for a single service.  */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">servent</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">char</span> *s_name;<span class="hljs-comment">/* Official service name.  */</span><br>  <span class="hljs-type">char</span> **s_aliases;<span class="hljs-comment">/* Alias list.  */</span><br>  <span class="hljs-type">int</span> s_port;<span class="hljs-comment">/* Port number.  */</span><br>  <span class="hljs-type">char</span> *s_proto;<span class="hljs-comment">/* Protocol to use.  */</span><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>socket</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是向量数据库？</title>
    <link href="/2023/08/03/%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F/"/>
    <url>/2023/08/03/%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>译者注：</p><p>本文译自 <ahref="https://www.pinecone.io/learn/vector-database/">What is a VectorDatabase?</a> ，作者：Roie Schwaber-Cohen。译文与原文基本相同，删除部分不影响理解向量数据库基本概念的内容。</p><p>译者：<a href="https://arcsin2.cloud/about">arcsin2</a></p></blockquote><p>随着人工智能的发展，出现了许多涉及大语言模型、生成式人工智能和语义搜索的应用程序。这些新应用都依赖于向量嵌入——一种包含语义信息、对人工智能在执行复杂任务时获取理解并保持长期记忆至关重要的数据表示类型。向量嵌入由人工智能模型生成，也就是数学中的向量，它们通常具有特定的维度，代表AI模型学习到的大量属性或特征。在人工智能和机器学习场景中，这些特征代表了对于理解数据的模式、关系和底层结构至关重要的不同维度，可以看作图片、文本等原始数据的压缩表示。</p><p>因此，我们需要一种专门的数据库——向量数据库来处理这种数据类型。向量数据库通过提供针对向量数据进行优化的存储和查询能力满足AI程序的需求。向量数据库具有传统数据库所具备的功能，而独立的向量索引库（如FAISS等向量搜索库）并不具备数据库的功能。向量数据库还专门处理向量嵌入，而传统的基于标量的数据库则不具备这种能力。</p><p>传统基于标量的数据库难以应对向量数据的复杂性和规模，无法进行实时分析。这就是向量数据库发挥作用的地方——它们被专门地设计来处理这种类型的数据，并提供性能、可扩展性和灵活性。</p><p>有了向量数据库，就能够给 AI应用添加高级功能，如：语义信息检索、长期记忆等。下图展示了向量数据库在这类应用中扮演的角色：</p><figure><imgsrc="https://cdn.sanity.io/images/vr8gru94/production/e88ebbacb848b09e477d11eedf4209d10ea4ac0a-1399x537.png"alt="Vector Database" /><figcaption aria-hidden="true">Vector Database</figcaption></figure><p>每个步骤含义分别为：</p><ol type="1"><li>首先，我们使用<strong>嵌入模型</strong>为我们想要索引的<strong>内容</strong>创建<strong>向量嵌入</strong>。</li><li>将<strong>向量嵌入</strong>插入到<strong>向量数据库</strong>中，并将其与创建该嵌入的原始<strong>内容</strong>进行关联。</li><li>当<strong>应用程序</strong>发出查询时，我们使用同样的<strong>嵌入模型</strong>为查询创建嵌入，并使用这些嵌入查询<strong>数据库</strong>中的<em>相似</em>向量嵌入。正如之前提到的，这些相似的嵌入与用于创建它们的原始<strong>内容</strong>相关联。</li></ol><h2 id="向量索引与向量数据库有什么不同">1.向量索引与向量数据库有什么不同？</h2><p>向量索引，如： <ahref="https://www.pinecone.io/learn/faiss/">FAISS</a>（Facebook AISimilaritySearch，FAISS），可以显著改善向量嵌入的检索，但它们缺乏任何数据库具有的功能。而向量数据库则是专门为<em>管理</em>向量嵌入而构建的，相比使用独立的向量索引，它具有以下优点：</p><ol type="1"><li><p><strong>数据管理：</strong>向量数据库提供了易于使用的数据存储功能，比如插入、删除和更新数据。这使得管理和维护向量数据比使用类似FAISS 这样的独立向量 <em>索引</em>更加简便，后者需要额外的工作来与存储解决方案进行集成。</p></li><li><p><strong>元数据存储和过滤：</strong>向量数据库可以存储与每个向量条目相关联的元数据。用户可以使用额外的元数据过滤器查询数据库，实现更精细化的查询。</p></li><li><p><strong>可扩展性：</strong>向量数据库被设计为随着数据量和用户需求的增长而扩展，更好地支持分布式和并行处理。独立的向量索引可能需要定制解决方案才能实现类似的可扩展性（比如在Kubernetes 集群或其他类似系统上部署和管理它们）。</p></li><li><p><strong>实时更新：</strong>向量数据库通常支持实时数据更新，允许动态地更改数据，而独立的向量索引可能需要进行完整的重新索引过程来纳入新数据，这可能耗时且计算成本高。</p></li><li><p><strong>备份：</strong>向量数据库处理定期备份数据库中存储的所有数据。</p></li><li><p><strong>生态系统集成：</strong>向量数据库更容易与数据处理生态系统的其他组件集成，例如 ETL 流水线（如Spark）、分析工具（如 <a href="https://www.tableau.com/">Tableau</a> 和<a href="https://segment.com/">Segment</a>）以及可视化平台（如 <ahref="https://grafana.com/">Grafana</a>），从而简化数据管理工作流程。它还可以轻松集成其他AI 相关工具，如 <ahref="https://python.langchain.com/en/latest/index.html">LangChain</a>、<ahref="https://gpt-index.readthedocs.io/">LlamaIndex</a> 和 <ahref="https://openai.com/blog/chatgpt-plugins">ChatGPT’s插件</a>。</p></li><li><p><strong>数据安全和访问控制：</strong>向量数据库通常提供内置的数据安全功能和访问控制机制，以保护敏感信息，而这些可能在独立的向量索引解决方案中不可用。</p></li></ol><p>简而言之，向量数据库通过解决独立向量索引的局限性（如可扩展性挑战、繁琐的集成过程以及缺乏实时更新和内置安全措施等），为处理向量嵌入提供了更优越的解决方案，确保了更有效和流畅的数据管理体验。</p><h2 id="向量数据库如何工作">2. 向量数据库如何工作？</h2><p>我们都或多或少知道传统数据库的工作方式：它们将字符串、数字和其他类型的标量数据存储在行和列中。另一方面，向量数据库操作的是向量，因此它的优化和查询方式有很大的不同。</p><p>在传统数据库中，我们通常查询数据库中的行，其中值通常与我们的查询完全匹配。在向量数据库中，我们使用相似性度量来找到与我们的查询<strong>最相似</strong>的向量。</p><p>向量数据库使用一系列不同的算法，所有这些算法都参与到近似最近邻（ApproximateNearestNeighbor，ANN）搜索中。这些算法通过哈希、量化或基于图的搜索来优化搜索过程。</p><p>这些算法被组装成一个流水线，用于快速准确地检索被查询向量的最近邻。由于向量数据库提供的是<strong>近似</strong>结果，我们需要在准确性和速度之间进行权衡。结果越准确，查询就越慢。然而，一个好的系统可以以超快的速度提供几乎完美的准确性。</p><p>以下是一个向量数据库的常见流水线：</p><figure><imgsrc="https://cdn.sanity.io/images/vr8gru94/production/ff9ba425d0c78d696372e0a43ce57851b4f1d4b7-1307x233.png"alt="Vector Database pipeline" /><figcaption aria-hidden="true">Vector Database pipeline</figcaption></figure><ol type="1"><li><p><strong>索引（Indexing）</strong>：向量数据库使用 PQ、LSH 或 HNSW等算法对向量进行索引（后文将对这些进行详细介绍）。这一步将向量映射到数据结构，以便实现更快速的检索。</p></li><li><p><strong>查询（Querying）</strong>：向量数据库将索引化的查询向量与数据集中的索引化向量进行比较，找到最近的邻居（应用该索引所使用的相似性度量）。</p></li><li><p><strong>后处理（PostProcessing）</strong>：在某些情况下，向量数据库从数据集中检索出最终的最近邻居，并对其进行后处理以返回最终结果。这一步可以包括使用不同的相似性度量对最近邻居进行重新排序。</p></li></ol><p>在接下来的部分中，我们将详细讨论这些算法，并解释它们如何对向量数据库的整体性能做出贡献。</p><h3 id="算法">2.1 算法</h3><p>有几种算法可以促进向量索引的创建。它们的共同目标是通过创建一个可以快速遍历的数据结构，实现快速查询。它们通常会将原始向量的表示转换为压缩形式，以优化查询过程。下面详细介绍。</p><h4 id="随机投影random-projection">2.1.1 随机投影（RandomProjection）</h4><p>随机投影背后的出发点是使用<strong>随机投影矩阵</strong>，将原始的高维向量压缩为低维向量。我们创建一个由随机数构成的矩阵。矩阵的大小将是我们想要的目标低维值。然后，我们计算输入向量与矩阵的点积，得到一个<strong>投影矩阵</strong>，其维度比我们的原始向量更少，但仍保持它们的相似性。</p><figure><imgsrc="https://cdn.sanity.io/images/vr8gru94/production/22dffa542410c1b542fcaeafcafc088ad278add5-1303x534.png"alt="Random Projection" /><figcaption aria-hidden="true">Random Projection</figcaption></figure><p>当我们查询时，我们使用同样的投影矩阵将查询向量投影到较低维空间。然后，我们将投影后的查询向量与数据库中的投影向量进行比较，找到最近邻居。由于数据的维度降低，搜索过程比在整个高维空间中搜索要快得多。</p><p>随机投影是一种近似方法，投影质量取决于投影矩阵的属性。一般来说，投影矩阵越随机，投影的质量就越好。但是生成一个真正随机的投影矩阵可能在计算上是昂贵的，特别是对于大型数据集而言。<ahref="https://www.pinecone.io/learn/locality-sensitive-hashing-random-projection/">了解更多关于随机投影的信息。</a></p><h4 id="乘积量化product-quantization">2.1.2 乘积量化（ProductQuantization）</h4><p>另一种构建索引的方法是乘积量化（ProductQuantization，PQ），这是一种用于高维向量（如向量嵌入）的 <em>有损</em>压缩技术。它将原始向量分解成较小的块，通过为每个块创建代表性的“码”来简化每个块的表示，然后将所有块重新组合在一起，这不会丢失对相似性操作至关重要的信息。PQ的过程可以分解为四个步骤：分割、训练、编码和查询。</p><figure><imgsrc="https://cdn.sanity.io/images/vr8gru94/production/791910350d7d2140dbe684b405ef5ee761c8fc6a-1060x720.png"alt="Product Quantization" /><figcaption aria-hidden="true">Product Quantization</figcaption></figure><ol type="1"><li><strong>分割</strong>： 将向量分割成片段。</li><li><strong>训练：</strong>我们为每个片段构建一个“码本”（codebook）。简而言之，该算法生成一个潜在的“码”池，可以分配给一个向量。实际上，这个“码本”由对向量的每个片段执行k-means 聚类所创建的聚类的中心点组成。对于 k-means聚类使用的值，我们的片段码本将包含与 k-means 聚类相同的值。</li><li><strong>编码：</strong>算法将为每个片段分配一个特定的码。实际上，在训练完成后，我们找到码本中最接近每个向量片段的值。我们的PQ 码将是对应码本中的值的标识符。我们可以使用任意数量的 PQ码，这意味着我们可以选择多个码本值来表示每个片段。</li><li><strong>查询：</strong>当我们查询时，算法将向量分解成子向量，并使用相同的码本进行量化。然后，它使用索引码来找到与查询向量最接近的向量。</li></ol><p>码本中代表性向量的数量是表示精度和搜索码本的计算成本之间的权衡。码本中代表性向量越多，子空间中向量的表示就越精确，但搜索码本的计算成本就越高。相比之下，码本中代表性向量越少，表示就越不准确，但计算成本也较低。<ahref="https://www.pinecone.io/learn/product-quantization/">了解更多关于PQ 的信息</a>。</p><h4 id="局部敏感哈希locality-sensitive-hashing">2.1.3局部敏感哈希（Locality-sensitive hashing）</h4><p>局部敏感哈希（Locality-SensitiveHashing，LSH）是一种用于近似最近邻搜索的索引技术。它在提供近似、有限的搜索结果的同时尽快提高搜索速度。LSH使用一组哈希函数将相似的向量映射到“桶”中，如下所示：</p><figure><imgsrc="https://cdn.sanity.io/images/vr8gru94/production/606382d0ca90a8d24f26780f5f9954123e37be91-575x603.png"alt="Locality-sensitive hashing" /><figcaption aria-hidden="true">Locality-sensitive hashing</figcaption></figure><p>为了找到给定查询向量的最近邻居，我们使用与将相似向量“分桶”到哈希表中相同的哈希函数。查询向量被哈希到特定的表格，然后与该表格中的其他向量进行比较，以找到最接近的匹配项。这种方法比搜索整个数据集要快得多，因为每个哈希表中的向量数量远远少于整个空间中的向量数量。</p><p>需要记住 LSH是一种近似方法，近似的质量取决于哈希函数的属性。通常情况下，使用的哈希函数越多，近似质量就越好。然而，使用大量哈希函数可能在计算上代价昂贵，并且对于大型数据集可能不可行。<ahref="https://www.pinecone.io/learn/locality-sensitive-hashing/">了解更多关于LSH 的信息</a>。</p><h4 id="层次导航小世界hierarchical-navigable-small-world-hnsw">2.1.4层次导航小世界（Hierarchical Navigable Small World, HNSW）</h4><p>层次导航小世界（Hierarchical Navigable Small World,HNSW）创建了一个层次化的类似树的结构，其中树的每个节点表示一组向量。节点之间的边表示向量之间的<strong>相似性</strong>。该算法首先创建一组节点，每个节点包含少量向量。这可以通过随机选择或使用k-means 等聚类算法对向量进行聚类来完成，其中每个聚类成为一个节点。</p><figure><imgsrc="https://cdn.sanity.io/images/vr8gru94/production/e06c4bb4c0095a1fb5b45b04acaa15663b6d6a96-734x696.png"alt="Hierarchical Navigable Small World (HNSW)" /><figcaption aria-hidden="true">Hierarchical Navigable Small World(HNSW)</figcaption></figure><p>然后，该算法检查每个节点的向量，并在该节点与具有与其最相似向量的节点之间绘制一条边。</p><figure><imgsrc="https://cdn.sanity.io/images/vr8gru94/production/63110626f18b50b5a15c48a8eea3c852ff64196b-496x467.png"alt="Hierarchical Navigable Small World (HNSW)" /><figcaption aria-hidden="true">Hierarchical Navigable Small World(HNSW)</figcaption></figure><p>当我们查询一个 HNSW索引时，它使用这个图来在树中导航，访问最有可能包含与查询向量最接近的向量的节点。<ahref="https://www.pinecone.io/learn/hnsw/">了解更多关于 HNSW的信息</a>。</p><h3 id="相似性度量similarity-measures">2.2 相似性度量（SimilarityMeasures）</h3><p>在之前讨论的算法基础上，我们需要了解相似性度量在向量数据库中的作用。这些度量是向量数据库比较和识别给定查询的最相关结果的基础。</p><p>相似性度量是一种数学方法，用于确定向量空间中两个向量的相似程度。在向量数据库中，相似性度量用于比较存储在数据库中的向量，并找到与给定查询向量最相似的向量。</p><p>可以使用多种相似性度量，包括：</p><ul><li><strong>余弦相似性（Cosinesimilarity）</strong>：衡量向量空间中两个向量之间夹角的余弦。它的取值范围从-1 到 1，其中 1 表示完全相同的向量，0 表示正交的向量，-1表示完全相反的向量。</li><li><strong>欧氏距离（Euclideandistance）</strong>：衡量向量空间中两个向量之间的直线距离。它的取值范围从0 到无穷大，其中 0 表示完全相同的向量，越大的值表示越不相似的向量。</li><li><strong>点积（Dotproduct）</strong>：衡量两个向量的大小和它们之间夹角的余弦的乘积。它的取值范围从负无穷到正无穷，其中正值表示指向相同方向的向量，0表示正交的向量，负值表示指向相反方向的向量。</li></ul><p>选择相似性度量将影响从向量数据库中获取的结果。还需要注意的是，每种相似性度量都有其优缺点，在选择时需要根据使用案例和要求做出正确的选择。<ahref="https://www.pinecone.io/learn/vector-similarity/">了解更多关于相似性度量的信息</a>。</p><h3 id="过滤filtering">2.3 过滤（Filtering）</h3><p>数据库中存储的每个向量都包含元数据。除了能够查询相似向量外，向量数据库还可以根据元数据查询对结果进行过滤。为此，向量数据库通常维护两个索引：一个向量索引和一个元数据索引。然后，它在进行向量搜索之前或之后执行元数据过滤，但在任何情况下，都会遇到导致查询过程减慢的困难。</p><figure><imgsrc="https://cdn.sanity.io/images/vr8gru94/production/fede570123cbdabff288da8900330d472834ceb8-1920x1220.png"alt="Post-filtering and Pre-filtering" /><figcaption aria-hidden="true">Post-filtering andPre-filtering</figcaption></figure><p>过滤过程可以在向量搜索之前或之后执行，但每种方法都有自己的挑战，可能会影响查询性能：</p><ul><li><strong>预过滤（Pre-filtering）：</strong>在这种方法中，元数据过滤是在向量搜索之前进行的。虽然这可以帮助减少搜索空间，但可能会导致系统忽略不符合元数据过滤条件的相关结果。此外，广泛的元数据过滤可能会因增加计算开销而减慢查询过程。</li><li><strong>后过滤（Post-filtering）：</strong>在这种方法中，元数据过滤是在向量搜索之后进行的。这可以确保考虑到所有相关结果，但也可能引入额外的开销，并在搜索完成后需要过滤掉不相关的结果，从而减慢查询过程。</li></ul><p>为了优化过滤过程，向量数据库使用各种技术，例如利用先进的索引方法进行元数据过滤或使用并行处理来加速过滤任务。在向量数据库中，平衡搜索性能和过滤准确性的权衡对于提供高效且相关的查询结果至关重要。<ahref="https://www.pinecone.io/learn/vector-search-filtering/">了解更多关于向量搜索过滤的信息</a>。</p><h3 id="数据库操作database-operations">2.4 数据库操作（DatabaseOperations）</h3><p>与向量索引不同，向量数据库配备了一组功能，使其更适合在高规模生产环境中使用。让我们对数据库操作涉及的组件进行一个总体概述。</p><figure><imgsrc="https://cdn.sanity.io/images/vr8gru94/production/d0adc44e56739a985cc198ea327fbb3d701f21e5-1094x984.png"alt="Database Operations" /><figcaption aria-hidden="true">Database Operations</figcaption></figure><h4 id="性能与容错性performance-and-fault-tolerance">2.4.1性能与容错性（Performance and Fault tolerance）</h4><p>性能和容错性密切相关。我们拥有的数据越多，就需要更多的节点，这同时也增加了错误和故障的可能。与其他类型的数据库一样，我们希望确保即使某些底层节点出现故障，查询也能尽快执行。这可能是由于硬件故障、网络故障或其他类型的技术错误。这种故障可能导致停机时间，甚至产生不正确的查询结果。</p><p>为了确保高性能和容错性，向量数据库使用分片和复制策略：</p><ol type="1"><li><strong>分片（Sharding）：</strong>将数据分布到多个节点。有不同的数据分片方法。例如，可以按照不同数据簇的相似性进行分片，以便将相似向量存储在同一分片中。当进行查询时，查询会被发送到所有分片，然后结果会被检索和合并。这被称为“scatter-gather” 模式。</li><li><strong>复制（Replication）：</strong>在不同节点上创建多个数据副本。这确保即使某个节点出现故障，其他节点也能够取而代之。有两种主要的一致性模型：<em>最终一致性</em>和<em>强一致性</em>。最终一致性允许在数据的不同副本之间存在临时的不一致性，这将提高可用性并减少延迟，但可能导致冲突甚至数据丢失。另一方面，强一致性要求在写操作被视为完成之前，所有数据副本都会得到更新。这种方法提供了更强的一致性，但可能导致更高的延迟。</li></ol><h4 id="监控monitoring">2.4.2 监控（Monitoring）</h4><p>为了有效地管理和维护向量数据库，我们需要一个强大的监控系统，跟踪数据库性能、健康状况和整体状态的重要方面。监控对于检测潜在问题、优化性能和确保生产运营的顺利进行至关重要。监控向量数据库的一些方面包括以下内容：</p><ol type="1"><li><strong>资源使用情况：</strong> 监控资源使用情况，如CPU、内存、磁盘空间和网络活动，这可以识别可能影响数据库性能的潜在问题或资源限制。</li><li><strong>查询性能：</strong>查询延迟、吞吐量和错误率可能表明需要解决的潜在系统性问题。</li><li><strong>系统健康：</strong>整体系统健康监控包括单个节点、复制过程和其他关键组件的状态。</li></ol><h4 id="访问控制access-control">2.4.3 访问控制（Access-control）</h4><p>访问控制是管理和监管用户对数据和资源的访问的过程。这是数据安全的重要组成部分，确保只有授权用户能够查看、修改或与存储在向量数据库中的敏感数据进行交互。</p><p>访问控制的重要性如下：</p><ol type="1"><li><strong>数据保护：</strong>由于人工智能应用通常涉及敏感和机密信息，实施严格的访问控制机制有助于防止未经授权的访问和潜在的数据泄漏。</li><li><strong>合规性：</strong>许多行业，如医疗保健和金融，受到严格的数据隐私法规的约束。实施适当的访问控制有助于组织遵守这些法规，保护其免受法律和财务后果。</li><li><strong>责任和审计：</strong>访问控制机制使组织能够维护向量数据库中用户活动的记录。这些信息对于审计目的至关重要，当发生安全漏洞时，它有助于追溯任何未经授权的访问或修改。</li><li><strong>可扩展性和灵活性：</strong>随着组织的成长和演变，其访问控制需求可能会发生变化。强大的访问控制系统允许无缝修改和扩展用户权限，确保在整个组织的成长过程中数据安全保持完整。</li></ol><h4 id="备份与收集backups-and-collections">2.4.4 备份与收集（Backups andcollections）</h4><p>当其他方法失效时，向量数据库提供了依赖定期创建备份的能力。这些备份可以存储在外部存储系统或云存储服务中，确保数据的安全性和可恢复性。在发生数据丢失或损坏的情况下，这些备份可以用来将数据库恢复到先前的状态，最大限度地减少停机时间并降低对整个系统的影响。使用Pinecone，用户可以选择备份特定的索引，并将它们保存为“集合”，这些集合可以在以后用来填充新的索引。</p><h4 id="api-and-sdks">2.4.5 API and SDKs</h4><p>这就是关键所在：与数据库进行交互的开发人员希望通过易于使用的 API来实现，并使用熟悉和舒适的工具集。通过提供用户友好的界面，向量数据库 API层简化了高性能向量搜索应用程序的开发。</p><p>除了 API 之外，向量数据库通常还会提供针对特定编程语言的SDK（软件开发工具包），用于封装 API。SDK使开发人员更轻松地在他们的应用程序中与数据库进行交互。这使得开发人员可以专注于他们的具体用例，比如语义文本搜索、生成问答、混合搜索、图像相似性搜索或产品推荐，而无需担心底层基础设施的复杂性。</p><h2 id="总结">3. 总结</h2><p>在自然语言处理（NLP）、计算机视觉和其他人工智能应用等领域，向量嵌入的指数增长导致了向量数据库的出现，它作为计算引擎使我们能够有效地与应用程序中的向量嵌入进行交互。</p><p>向量数据库是专门构建的数据库，专门用于解决在生产环境中管理向量嵌入时出现的问题。因此，它们相比传统基于标量的数据库和独立向量索引提供了显著的优势。</p><p>在本文中，我们回顾了向量数据库的关键方面，包括它的工作原理、所使用的算法以及使其在生产环境中运行的附加功能。我们希望这有助于您理解向量数据库的内部工作机制。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>向量数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>向量数据库</tag>
      
      <tag>Vector Database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 WSL 搭建 Linux 开发环境</title>
    <link href="/2023/07/31/%E4%BD%BF%E7%94%A8-WSL-%E9%85%8D%E7%BD%AE-Linux-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <url>/2023/07/31/%E4%BD%BF%E7%94%A8-WSL-%E9%85%8D%E7%BD%AE-Linux-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<p>如何方便、快捷地在 Windows 和 Linux 两个操作系统切换，以既能够使用Windows 的办公软件等，也能够使用 Linux的开发工具，是一个困扰不少程序员的问题。通常的解决方案有以下几种：</p><ul><li>双系统：系统之间切换必须关机并重启；能够使用最原汁原味且无性能损失的操作系统</li><li>虚拟机：方便系统之间切换；启动关闭较慢，虚拟机软件较沉重</li><li>远程开发机：原生 Linux 系统，通常硬件配置不错；需要网络</li></ul><p>上述方案结合实际需求和场景，往往能够满足日常需求。不过，随着微软推出适用于Linux 的 Windows 子系统（Windows Subsystem forLinux，WSL），我们也多了一个在 Windows 和 Linux之间更加无缝切换的选项。本文对如何使用 WSL 搭建 Linux C/C++开发环境做简要介绍。</p><h2 id="安装-wsl">1. 安装 WSL</h2><p>WSL 的安装非常简单，参考微软详细的 <ahref="https://learn.microsoft.com/zh-cn/windows/wsl/install">安装文档</a>即可。</p><p>同时，推荐阅读 WSL 的其他相关文档，对 WSL的基本概念及原理有大概的认识，并学习 WSL常用的命令。以下是供参考的文档：</p><ul><li><ahref="https://learn.microsoft.com/zh-cn/windows/wsl/basic-commands">WSL基本命令</a></li><li><ahref="https://learn.microsoft.com/zh-cn/windows/wsl/tutorials/wsl-vscode">WSL搭配 VS Code 使用指南</a></li><li><ahref="https://learn.microsoft.com/pdf?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fwindows%2Fwsl%2Ftoc.json">WSL官方中文 PDF文档</a>：提供了概念、安装、使用、开发环境搭建等一系列说明</li></ul><h2 id="更新软件源">2. 更新软件源</h2><p>Ubuntu 默认的软件源在国内访问很慢，本节以 Ubuntu 22.04配置阿里云源为例，介绍如何更新软件源。注意，不同的 Ubuntu版本，软件源的地址并不一致，请根据实际情况修改。</p><p>首先进行备份：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">cp</span> /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></code></pre></td></tr></table></figure><p>然后，编辑文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo vim /etc/apt/sources.list</span><br></code></pre></td></tr></table></figure><p>并用以下内容覆盖原本内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">deb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse<br></code></pre></td></tr></table></figure><p>保存并退出编辑，执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt update</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt upgrade</span><br></code></pre></td></tr></table></figure><p>完成包更新。</p><h2 id="安装-cc-开发工具">3. 安装 C/C++ 开发工具</h2><p>WSL 默认没有安装 gcc、g++、make 等 C/C++开发工具，需要我们手动安装。执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt install build-essential gdb</span><br></code></pre></td></tr></table></figure><p>执行完成后，将安装 gcc、g++、make 和 gdb 等开发工具。</p><p>然后，使用以下命令验证是否安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc --version</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">g++ --version</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make --version</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">gdb --version</span><br></code></pre></td></tr></table></figure><p>若正常输出版本号等信息，则安装成功。</p><p>至此，你已收获一个在 Windows 系统能够无缝切换并使用 Linux进行程序开发的环境。</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>Linux</category>
      
      <category>开发环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Windows Subsystem for Linux（WSL）</tag>
      
      <tag>Ubuntu</tag>
      
      <tag>开发环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小样本字体生成</title>
    <link href="/2023/07/01/%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90/"/>
    <url>/2023/07/01/%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90/</url>
    
    <content type="html"><![CDATA[<p>本文介绍 Few-shot Font Generation 的基本概念和两篇论文。</p><p>两篇论文为：</p><ul><li><ahref="https://openaccess.thecvf.com/content/CVPR2021/papers/Xie_DG-Font_Deformable_Generative_Networks_for_Unsupervised_Font_Generation_CVPR_2021_paper.pdf">DG-Font:Deformable Generative Networks for Unsupervised Font Generation</a></li><li><ahref="https://openaccess.thecvf.com/content/CVPR2023/papers/Wang_CF-Font_Content_Fusion_for_Few-Shot_Font_Generation_CVPR_2023_paper.pdf">CF-Font:Content Fusion for Few-shot Font Generation</a></li></ul><p>也可参考整理的 <a href="FFG.pdf">slides</a>。</p><h2 id="背景">1. 背景</h2><p>不同于英语，由 ASCII 码（8 位二进制，且仅使用其中 7位）即可表示绝大多数常用字母和符号。中日韩语言由上万个字组成，因此，想构建一个新字体往往涉及大量的工作，需要专业字体设计人员一个字一个字地设计。小样本字体生成（Few-shotFont Generation,FFG）就是在这样的背景下提出的，它希望在给定标准内容字体（通常为宋体或楷体）的情况下，使用少量的风格字（如自己的手写体或新设计字体），就可以由模型自动生成目标风格的其他字。这样，我们仅需花费少量精力设计几个风格字体，其余字由模型自动生成即可，大大降低劳动量。</p><p>在 GAN 提出后，FFG领域取得了许多不错的进展。目前的方法也大多基于生成对抗模型进行字体生成。此外，FFG领域的一个核心问题就是如何将文字的内容（content）与风格（style）解耦合，模型的不同分支能够分别学习到内容和风格的特征表示。在推理时，给定几个风格字体（称为：reference），风格编码器基于这些reference提取特征并进行平均，作为目标字体的风格特征向量。在已有的内容字体上的每个字轮流使用特征编码器提取内容特征，将内容特征与风格特征融合，输入解码器，即可生成目标字体。</p><p>下面，分别介绍两篇已有的工作。</p><h2 id="df-font">2. DF-Font</h2><p>本文的 motivation是：不同的字体之间，其笔画、偏旁等常常不在相同的位置，而是有一个区域变换。传统的卷积只能感知固定区域的像素并逐层提取语义信息；而变形卷积能够自动学习偏移量（offset），使卷积核的感受野不再局限于固定的区域，进而能够学习到更好的内容特征表示。下面介绍具体做法。</p><center><img src="/2023/07/01/%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90/image-20230701221526835.png" class="" title="image-20230701221526835"></center><p><br></p><p>由上面论文主图可以看出，模型整体分为生成器和判别器两个部分，即典型的GAN 结构。具体地，生成器包括两个分支：</p><ul><li>上面为 style encoder，给定字体图片，将生成图片的风格特征向量</li><li>下面为 contentencoder，给定字体图片，将生成图片的内容特征图；同时，后面紧跟着decoder，将内容和风格表示融合，生成目标字体图片</li><li>下面的内容表示及生成分支还有两个 FDSC模块，其应用了变形卷积，图示和具体介绍如下：</li></ul><center><img src="/2023/07/01/%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90/image-20230701222142980.png" class="" title="image-20230701222142980"></center><p>可变形卷积实际上由两个卷积核构成：</p><ul><li><p>第一个卷积核输入是 content encoder 的特征图 <spanclass="math inline">\(K_c\)</span> 以及后面 mixer 的特征图 <spanclass="math inline">\(K_s\)</span>；生成 offset 和 mask，即： <spanclass="math display">\[\Theta=f_\theta\left(K_s, K_c\right)\]</span> 其中，<span class="math inline">\(f_\theta\)</span>表示卷积层， <span class="math inline">\(\Theta=\left\{\Delta p_k,\Delta m_k\right.\)</span> <span class="math inline">\(|k=1, \cdots,|\mathcal{R} \mid\}\)</span> 为卷积层输出的 offset 和 mask，<spanclass="math inline">\(\mathcal{R}=\{(-1,-1),(-1,0),\cdots,(0,1),(1,1)\}\)</span> 表示普通卷积的 offset；</p></li><li><p>输出 offset 和 mask 后，后续的卷积层 <spanclass="math inline">\(f_{DC}\)</span> 将输出特征图 <spanclass="math inline">\(K_c^{\prime}\)</span> <spanclass="math display">\[K_c^{\prime}=f_{D C}\left(K_c, \Theta\right)\]</span> 此时，变形卷积 <span class="math inline">\(f_{DC}(\cdot)\)</span> 每个像素的计算公式可表示为： <spanclass="math display">\[K_c^{\prime}(p)=\sum_{k=1}^{\mathcal{R}} w\left(p_k\right) \cdotx\left(p+p_k+\Delta p_k\right) \cdot \Delta m_k\]</span></p></li></ul><p>然后，介绍损失函数设计，共有 4 个部分：</p><ul><li><p>对抗损失：即 GAN 的损失，用来保证生成逼真的图像：</p><center><img src="/2023/07/01/%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90/image-20230701223602085.png" class="" title="image-20230701223602085"></center></li><li><p>内容一致性损失：</p><center><img src="/2023/07/01/%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90/image-20230701223612919.png" class="" title="image-20230701223612919"></center></li><li><p>图像重构损失：</p><center><img src="/2023/07/01/%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90/image-20230701223620435.png" class="" title="image-20230701223620435"></center></li><li><p>偏移量归一化损失：</p><center><img src="/2023/07/01/%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90/image-20230701223627704.png" class="" title="image-20230701223627704"></center></li></ul><p>总损失表示为：</p><center><img src="/2023/07/01/%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90/image-20230701223642827.png" class="" title="image-20230701223642827"></center><p>然后是实验结果：</p><center><img src="/2023/07/01/%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90/image-20230701223940563.png" class="" title="image-20230701223940563"></center><center><img src="/2023/07/01/%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90/image-20230701224008919.png" class="" title="image-20230701224008919"></center><p><br></p><p>相比之前方法，本文方法在 unseen fonts 上所有指标表现最好；在 seenfonts 上，感知性指标表现最好，像素性指标则一般。</p><h2 id="cf-font">3. CF-Font</h2><p>本文是对上篇论文的改进，其主要贡献在于：提出了内容融合模块（ContentFusion Module），让模型学得更好的内容表示。此外，在 loss及风格特征向量的表示上也有改进，下面具体介绍。</p><center><img src="/2023/07/01/%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90/image-20230701224503851.png" class="" title="image-20230701224503851"></center><p><br></p><p>首先是主图，可以发现和前篇文章的确差不多。多出的是 Content FusionModule 和 Iterative Style-vector Refinement，下面分别介绍。</p><p>传统的内容字体选取由两种方式：</p><ul><li>对所有目标字体，都选取宋体作为 content font（下图黄色线）</li><li>对给定目标字体，从候选集合中选择与目标字体最接近的字体作为 contentfont（下图红色线）</li></ul><p>本文则提出了一种新方法，其从可选的 <spanclass="math inline">\(N\)</span>个字体中提取特征图，进行聚类，聚类中心设置为 <spanclass="math inline">\(M\)</span> 个，选择距离聚类中心最近的 <spanclass="math inline">\(M\)</span> 个字体作为基字体（basisfont）；然后，对于给定的目标字体，计算其与 basis fonts 的相似度，经过softmax函数后赋予权重；权重与基字体相乘并求和，得到全新的内容特征图表示方式，公式表示如下：</p><ol type="1"><li><p>聚类 <span class="math display">\[\begin{aligned}\boldsymbol{C}_i &amp; =f_{c e}\left(\boldsymbol{I}_i\right),{ }^1 \\\boldsymbol{d}_i &amp; =\left(d_{i 1}, d_{i 2}, \ldots, d_{i N}\right),\quad d_{i j}=\left\|\boldsymbol{C}_i-\boldsymbol{C}_j\right\|_1, \\\boldsymbol{e}_i &amp; =\sigma\left(\boldsymbol{d}_i\right), \\\mathcal{B} &amp;=\operatorname{Cluster}\left(M,\left\{\boldsymbol{e}_1,\boldsymbol{e}_2, \ldots, \boldsymbol{e}_N\right\}\right),\end{aligned}\]</span></p></li><li><p>计算权重 <span class="math display">\[\begin{aligned}\boldsymbol{d}_t^{\prime} &amp; =\left(d_{t 1}, d_{t 2}, \ldots, d_{tM}\right), \quad d_{tm}=\left\|\boldsymbol{C}_t-\boldsymbol{C}_m\right\|_1, \\\boldsymbol{w}_t &amp; =\sigma\left(-\boldsymbol{d}_t^{\prime} /\tau\right),\end{aligned}\]</span></p></li><li><p>得到新特征表示 <span class="math display">\[\boldsymbol{C}_t^{\prime}=\sum_{m \in \mathcal{B}} w_{t m} \cdot\boldsymbol{C}_m\]</span></p></li></ol><p>示意图如下：</p><center><img src="/2023/07/01/%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90/image-20230701225207555.png" class="" title="image-20230701225207555"></center><p>此外，提出了一个新的 loss，用来在 generated image 和 ground-truthimage 的投影分类后的分布施加限制：</p><center><img src="/2023/07/01/%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90/image-20230701225120502.png" class="" title="image-20230701225120502"></center><p><br></p><p>公式表示为： <span class="math display">\[\mathcal{L}_p(\boldsymbol{Y}, \hat{\boldsymbol{Y}})=\frac{1}{P}\sum_{p=1}^P \mathcal{L}_{1 d}\left(\phi_p(\boldsymbol{Y}),\phi_p(\hat{\boldsymbol{Y}})\right),\]</span> <span class="math inline">\(\mathcal{L}_{1 d}\)</span>表示两个分布之间的差异，可选用推土机距离或者 KL 散度，分布表示为： <spanclass="math display">\[\begin{aligned}\mathcal{L}_{p c-w d l}(\boldsymbol{Y}, \hat{\boldsymbol{Y}}) &amp;=\frac{1}{P}\sum_{p=1}^P\left\|\frac{\Lambda\left(\phi_p(\boldsymbol{Y})\right)}{\sum\phi_p(\boldsymbol{Y})}-\frac{\Lambda\left(\phi_p(\hat{\boldsymbol{Y}})\right)}{\sum\phi_p(\hat{\boldsymbol{Y}})}\right\| \\\mathcal{L}_{p c-k l}(\boldsymbol{Y}, \hat{\boldsymbol{Y}}) &amp;=\frac{1}{P} \sum_{p=1}^P \mathbf{KL}\left(\frac{\phi_p(\boldsymbol{Y})}{\sum\phi_p(\boldsymbol{Y})}-\frac{\phi_p(\hat{\boldsymbol{Y}})}{\sum\phi_p(\hat{\boldsymbol{Y}})}\right),\end{aligned}\]</span> 其余损失与上文相同，总损失函数表示为： <spanclass="math display">\[\begin{array}{r}\mathcal{L}=\mathcal{L}_{a d v}+\lambda_{\text {img}}\left(\mathcal{L}_{\text {img }}+\lambda_{\text {pll }}\mathcal{L}_{\text {pcl }}\right) \\+\lambda_{\text {cnt }} \mathcal{L}_{\text {cnt }}+\lambda_{\text{offset }} \mathcal{L}_{\text {offset }},\end{array}\]</span></p><p>在推理阶段，初始化风格特征向量为已有的几个 reference image特征向量的均值： <span class="math display">\[\boldsymbol{s}_t^{\prime}=\frac{1}{Q} \sum_{q=1}^Q f_{se}\left(\boldsymbol{I}_t^q\right)\]</span>然后，设置该特征向量为可学习的，并冻结模型其他部分的参数，使用重构损失微调大约10 个 epoch：</p><center><img src="/2023/07/01/%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90/image-20230701230455898.png" class="" title="image-20230701230455898"></center><p>使用最终微调后的特征向量作为推理时使用的风格特征向量。</p><p>最后是实验：</p><center><img src="/2023/07/01/%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90/image-20230701230621924.png" class="" title="image-20230701230621924"></center><center><img src="/2023/07/01/%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90/image-20230701230641799.png" class="" title="image-20230701230641799"></center><p><br></p><p>在绝大多数指标上，本文方法均超过已有方法。</p>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
      <category>读论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Few-shot Font Gereration</tag>
      
      <tag>FFG</tag>
      
      <tag>字体生成</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Git LFS管理大文件及GitHub LFS扩容</title>
    <link href="/2023/05/25/LFS%E6%89%A9%E5%AE%B9/"/>
    <url>/2023/05/25/LFS%E6%89%A9%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<p>在使用 Git管理代码库时，如果代码仓库中有含有大文件，则可能出现错误。特别是当上传代码库到GitHub 仓库时，由于 GitHub 有文件大小限制（100MB 以上文件 push失败；50MB 以上文件可以 push 成功，但是会有警告；且 GitHub 仅支持 1GB的免费容量；详情参考：<ahref="https://docs.github.com/zh/repositories/working-with-files/managing-large-files/about-large-files-on-github">https://docs.github.com/zh/repositories/working-with-files/managing-large-files/about-large-files-on-github</a>），因此必须使用Git Large File Storage（GitLFS）工具，对代码库进行适当的设置，以正常使用 Git进行版本控制及提交至远程仓库。本文介绍 Git LFS的安装及基本使用方法，并介绍如何扩大 GitHub LFS 存储容量。</p><h2 id="git-lfs-安装">1. Git LFS 安装</h2><p>Git LFS 的安装非常简单，具体参考官网：<ahref="https://git-lfs.com/">https://git-lfs.com/</a>，根据自己的操作系统等环境选择合适的安装方法。本文以 Ubuntu上安装为例介绍。</p><p>安装命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | sudo bash</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install git-lfs</span><br></code></pre></td></tr></table></figure><p>首先下载并运行脚本，对系统环境进行检查及更新；然后使用 apt 安装 GitLFS 即可。</p><p>详情参考：<ahref="https://github.com/git-lfs/git-lfs/blob/main/INSTALLING.md">https://github.com/git-lfs/git-lfs/blob/main/INSTALLING.md</a>。</p><h2 id="git-lfs-基本用法">2. Git LFS 基本用法</h2><p>安装完成后，使用 Git LFS 对代码库进行一些设置，即可正常管理大文件并push 到远程仓库。</p><p>首先，进入代码库根目录，然后运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git lfs install</span><br></code></pre></td></tr></table></figure><p>这条命令是为了让该仓库支持 LFS 存储。</p><p>然后，设置使用 Git LFS 追踪的文件类型，根据自己需求调整即可，这里以<code>pth</code> 文件为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git lfs track <span class="hljs-string">&quot;*.pth&quot;</span></span><br></code></pre></td></tr></table></figure><p>运行该命令后，将生成（或修改）仓库下的 <code>.gitattributes</code>文件，使用 <code>git add .gitattributes</code>命令将该文件添加到暂存区并提交：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add .gitattributes</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git commit -m <span class="hljs-string">&#x27;support LFS&#x27;</span></span><br></code></pre></td></tr></table></figure><p>注意，如果你是已经出现了提交错误然后才进行 Git LFS相关配置，需要先使用 <code>git reset HEAD~x</code> 命令撤销提交（命令中<code>x</code> 取值请根据自己实际情况调整），然后在重新执行<code>add</code> 及 <code>commit</code> 命令。</p><p>至此，即可继续使用 <code>git</code>命令进行开发，不会因为大文件而报错。</p><h2 id="github-lfs-扩容">3. GitHub LFS 扩容</h2><p>经过上述步骤后，在本地即可进行正常的分支管理等 <code>git</code>操作。但是，如果将大文件 push 到 GitHub仓库，则可能遇到类似以下内容的报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">batch response: This repository is over its data quota. Account responsible for LFS bandwidth should purchase more data packs to restore access.<br></code></pre></td></tr></table></figure><p>这是因为上传的文件总大小超过了 GitHub LFS的免费额度。如果想继续上传，需要对 GitHub 账号相关权限进行升级。</p><p>首先，进入 GitHub 设置页面并点击进入如下页面：</p><center><img src="/2023/05/25/LFS%E6%89%A9%E5%AE%B9/image-20230525221616086.png" class="" title="image-20230525221616086"></center><p>也可以直接访问：<a href="https://github.com/settings/billing">Billing(github.com)</a> 查看。</p><p>将该页面拉到下面，可以查看 Git LFS Data：</p><center><img src="/2023/05/25/LFS%E6%89%A9%E5%AE%B9/image-20230525221836887.png" class="" title="image-20230525221836887"></center><p>默认的存储和带宽都是 1GB（示例图片是升级后的容量）。</p><p>点击右上角的 <code>Edit</code> 按钮，并选择<code>Add more data packs</code> 即可进行 GitHub LFS 容量升级。</p><p>在升级之前，需要先设置好付款账户，按照 GitHub页面指引操作即可，这里推荐使用 PayPal。</p><p>PayPal 官网为：<a href="https://www.paypal.com/">PayPal</a>，打开官网后使用 GitHub注册使用的邮箱进行账号注册，并绑定银行卡即可。绑定银行卡时需要填写到期时间、CVC等信息，根据银行卡如实填写即可。以如下网络上图片为例：</p><center><img src="/2023/05/25/LFS%E6%89%A9%E5%AE%B9/image-20230525223008190.png" class="" title="image-20230525223008190"></center><p>CVC 指图片中的后 3 位数字，即：169。填写好完成 PayPal注册及银行卡绑定后，即可回到 GitHub 网页，在付款方式绑定页面选择 PayPal方式即可，GitHub 会自动检测使用 GitHub 注册邮箱注册的 PayPal账号并尝试绑定，出现提示信息后同意绑定即可。</p><p>绑定好 PayPal 账号后，确认升级 GitHub LFS 容量，即可顺利在 GitHub提交大文件。</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git LFS</tag>
      
      <tag>LFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C 语言拾遗</title>
    <link href="/2023/05/01/C-%E8%AF%AD%E8%A8%80%E6%8B%BE%E9%81%97/"/>
    <url>/2023/05/01/C-%E8%AF%AD%E8%A8%80%E6%8B%BE%E9%81%97/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作为第一门语言是 C++ 的程序员，一直觉得对 C语言的一些重要特性不清晰，对一些 C 程序惯用法也不了解。故借阅读 《C程序设计语言》 一书的机会，将相关曾经遗漏的知识整理如下。</p></blockquote><h2 id="extern-声明">1. extern 声明</h2><p><code>extern</code>关键字用于声明外部变量，注意声明与定义的不同：</p><ul><li>定义（define）：表示创建变量或分配存储单元</li><li>声明（declaration）：说明变量的性质，但并不分配存储单元</li></ul><p>当外部变量的定义出现在使用它的函数之前时，可以省略<code>extern</code> 声明；反之，必须有 <code>extern</code>声明（如：涉及多个源文件）。</p><p>Example：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> n = <span class="hljs-number">1</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> n;<span class="hljs-meta"># extern declaration</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>用 <code>static</code>关键字修饰外部变量或函数，可以将其后声明的对象的作用域限定为被编译文件的剩余部分，其他文件不能访问该对象。</p><p><code>static</code>也可用于声明内部变量：该变量仅能在某函数内使用但一直占据存储空间。</p><h2 id="宏">2. 宏</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 取消宏定义</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> getchar</span><br><br><br><span class="hljs-comment">// 调试打印宏</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> dprint(expr) printf(#expr <span class="hljs-string">&quot; = %g\n&quot;</span>, expr)</span><br><br>dprint(x/y);<br><br><span class="hljs-comment">// 宏将展开为：</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x/y&quot;</span> <span class="hljs-string">&quot; = %g\n&quot;</span>, x/y);<br><br><br><span class="hljs-comment">// 预处理器运算符 ##</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> paste(front, end) front ## end</span><br><br><span class="hljs-comment">// 宏调用 paste(name, 1) 的结果将创建符号 name1</span><br></code></pre></td></tr></table></figure><p>条件包含</p><p>example 1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(HDR)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HDR</span><br><br><span class="hljs-comment">/* hdr.h 文件内容 */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> HDR</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HDR</span><br><br><span class="hljs-comment">/* code here */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>example 2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> SYSTEM == SYSV</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HDR <span class="hljs-string">&quot;sysv.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> SYSTEM == BSD:</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HDR <span class="hljs-string">&quot;bsd.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> SYSTEM == MSDOS:</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HDR <span class="hljs-string">&quot;msdos.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span>:</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HDR <span class="hljs-string">&quot;default.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> HDR</span><br></code></pre></td></tr></table></figure><h2 id="union">3. union</h2><p><code>union</code>：在不同时刻保存不同类型和长度的对象的变量。</p><p>example：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">u_tag</span> &#123;</span><br>    <span class="hljs-type">int</span> ival;<br>    <span class="hljs-type">float</span> fval;<br>    <span class="hljs-type">char</span> *sval;<br>&#125; u;<br></code></pre></td></tr></table></figure><p><code>union</code> 实际上就是<code>struct</code>，它的所有成员相对与基地址的偏移量都为 0，此<code>struct</code>空间要大到足够容纳最宽的成员，并且，其对齐方式要适合于<code>union</code> 中所有类型的成员。</p><h2 id="位字段-bit-field">4. 位字段 bit-field</h2><p>example：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 定义位字段，&#x27;:&#x27; 后数字表示字段的宽度</span><br><span class="hljs-comment">// 字段作用与小整数类似，可以出现在算术表达式中</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> is_keyword : <span class="hljs-number">1</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> is_extern : <span class="hljs-number">1</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> is_static : <span class="hljs-number">1</span>;<br>&#125; flags;<br><br><span class="hljs-comment">// 设置字段值</span><br>flags.is_extern = flags.is_static = <span class="hljs-number">1</span>;<br>flags.is_extern = flags.is_static = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 位测试</span><br><span class="hljs-keyword">if</span> (flags.is_extern == <span class="hljs-number">0</span> &amp;&amp; flags.is_static ==<span class="hljs-number">0</span>)<br>    ...<br></code></pre></td></tr></table></figure><p>字段不是数组，且没有地址，不能对其使用 <code>&amp;</code>运算符。</p><h2 id="文件访问">5. 文件访问</h2><p>example：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c">FILE *fp = fopen(name, mode);<span class="hljs-comment">// 以指定 mode 打开文件；失败返回 NULL</span><br>fclose(fp);<span class="hljs-comment">// 关闭文件</span><br><br><span class="hljs-comment">// 从文件中返回下一个字符；若达到文件结尾或出错，返回 EOF</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getc</span><span class="hljs-params">(FILE *fp)</span>;<br><br><span class="hljs-comment">// 将字符 c 写入到 fp 指向的文件中，并返回写入的字符</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">putc</span><span class="hljs-params">(<span class="hljs-type">int</span> c, FILE *fp)</span>;<br><br><span class="hljs-comment">// 对文件的格式化输入输出</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fscanf</span><span class="hljs-params">(FILE *fp, <span class="hljs-type">char</span> *format, ...)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">fprintf</span><span class="hljs-params">(FILE *fp, <span class="hljs-type">char</span> *format, ...)</span>;<br><br><span class="hljs-comment">// 错误判断</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ferror</span><span class="hljs-params">(FILE *fp)</span>;<span class="hljs-comment">// 如果流 fp 中出现错误，则返回一个非 0 值</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">feof</span><span class="hljs-params">(FILE *fp)</span>;<span class="hljs-comment">// 如果文件到达文件结尾，返回一个非 0 值</span><br><br><span class="hljs-comment">// 行输入和行输出</span><br><span class="hljs-comment">// 从 fp 指向的文件中读取下一个输入行（包括换行符），并将它存放在 line 中。最多读取 maxline-1 个字符。正常结束返回 line；出错返回 NULL</span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">fgets</span><span class="hljs-params">(<span class="hljs-type">char</span> *line, <span class="hljs-type">int</span> maxline, FILE *fp)</span>;<br><span class="hljs-comment">// 将 line 写入 fp 指向的文件中。出错返回 EOF；否则返回一个非负值。</span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">fputs</span><span class="hljs-params">(<span class="hljs-type">char</span> *line, FILE *fp)</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>C</category>
      
    </categories>
    
    
    <tags>
      
      <tag>define</tag>
      
      <tag>extern</tag>
      
      <tag>union</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据集与样本难度度量</title>
    <link href="/2023/03/12/%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8E%E6%A0%B7%E6%9C%AC%E9%9A%BE%E5%BA%A6%E5%BA%A6%E9%87%8F/"/>
    <url>/2023/03/12/%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8E%E6%A0%B7%E6%9C%AC%E9%9A%BE%E5%BA%A6%E5%BA%A6%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<p>本文分享关于数据集与样本难度度量的论文，具体为：</p><ul><li><a href="https://arxiv.org/pdf/2002.10689">A Theory of UsableInformation Under Computational Constraints</a></li><li><ahref="https://proceedings.mlr.press/v162/ethayarajh22a/ethayarajh22a.pdf">UnderstandingDataset Difficulty with <spanclass="math inline">\(\mathcal{V}\)</span>-Usable Information</a></li></ul><p>主要内容来自于组会分享，slides 可<ahref="Dataset%20&amp;%20Example%20Difficulty.pdf">点此查看</a>。</p><h2 id="香农互信息">1. 香农互信息</h2><p>在概率论和信息论中，两个随机变量的互信息（MutualInformation，MI）度量了两个变量之间相互依赖的程度。具体来说，对于两个随机变量，MI是一个随机变量由于已知另一个随机变量而减少的“信息量”（单位通常为比特）。</p><p>离散随机变量 X 和 Y 的互信息可以计算为：</p><center><img src="/2023/03/12/%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8E%E6%A0%B7%E6%9C%AC%E9%9A%BE%E5%BA%A6%E5%BA%A6%E9%87%8F/image-20230312222959237.png" class="" title="离散变量香农互信息定义"></center><p>其中 p(x, y) 是 <em>X</em> 和 <em>Y</em> 的联合概率质量函数，而 p(x)和 p(y) 分别是 <em>X</em> 和 <em>Y</em> 的边缘概率质量函数。</p><p>互信息又可以等价地表示成：</p><center><img src="/2023/03/12/%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8E%E6%A0%B7%E6%9C%AC%E9%9A%BE%E5%BA%A6%E5%BA%A6%E9%87%8F/image-20230312223006884.png" class=""></center><p>但是，在机器学习场景下，香农互信息与我们目前的一些经验性认识存在冲突，比如下面图片展示的例子：</p><center><img src="/2023/03/12/%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8E%E6%A0%B7%E6%9C%AC%E9%9A%BE%E5%BA%A6%E5%BA%A6%E9%87%8F/image-20230312223134757.png" class="" title="明文与密文与标签的香农互信息相等"></center><p>在香农互信息理论下，<em>明文与标注的互信息</em> 和<em>密文与标注的互信息</em>相等。但是，对于我们人类而言，从明文能够轻易识别出标注；而不能够根据密文判断标注。即如下图所示：</p><center><img src="/2023/03/12/%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8E%E6%A0%B7%E6%9C%AC%E9%9A%BE%E5%BA%A6%E5%BA%A6%E9%87%8F/image-20230312223458019.png" class=""></center><p>为了解决这一冲突，作者提出了新的概念：考虑计算约束下的互信息。</p><h2 id="对香农互信息的扩展定义mathcalv-information">2.对香农互信息的扩展定义——<spanclass="math inline">\(\mathcal{V}\)</span>-Information</h2><p>首先，作者引入三个概念：</p><ol type="1"><li><p><strong>predictive family</strong></p><p>Let <span class="math inline">\(\Omega=\{f: \mathcal{X}\cup\{\varnothing\} \rightarrow \mathcal{P}(\mathcal{Y})\}\)</span>. Wesay that <span class="math inline">\(\mathcal{V} \subseteq\Omega\)</span> is a predictive family if it satisfies <spanclass="math display">\[\forall f \in \mathcal{V}, \forall P \in \operatorname{range}(f), \quad\exists f^{\prime} \in \mathcal{V}, \quad \text { s.t. } \quad \forall x\in \mathcal{X}, f^{\prime}[x]=P, f^{\prime}[\varnothing]=P\]</span></p></li><li><p><strong>predictive conditional <spanclass="math inline">\(\mathcal{V}\)</span>-entropy</strong></p><p>Let <span class="math inline">\(X, Y\)</span> be two random variablestaking values in <span class="math inline">\(\mathcal{X} \times\mathcal{Y}\)</span>, and <spanclass="math inline">\(\mathcal{V}\)</span> be a predictive family. Thenthe predictive conditional <spanclass="math inline">\(\mathcal{V}\)</span>-entropy is defined as <spanclass="math display">\[\begin{aligned}H_{\mathcal{V}}(Y \mid X) &amp; =\inf _{f \in \mathcal{V}}\mathbb{E}_{x, y \sim X, Y}[-\log f[x](y)] \\H_{\mathcal{V}}(Y \mid \varnothing) &amp; =\inf _{f \in \mathcal{V}}\mathbb{E}_{y \sim Y}[-\log f[\varnothing](y)]\end{aligned}\]</span> We additionally call <spanclass="math inline">\(H_{\mathcal{V}}(Y \mid \varnothing)\)</span> the<span class="math inline">\(\mathcal{V}\)</span>-entropy, and alsodenote it as <span class="math inline">\(H_{\mathcal{V}}(Y)\)</span>.</p></li><li><p><strong>predictive conditional <spanclass="math inline">\(\mathcal{V}\)</span>-information</strong></p><p>Let <span class="math inline">\(X, Y\)</span> be two random variablestaking values in <span class="math inline">\(\mathcal{X} \times\mathcal{Y}\)</span>, and <spanclass="math inline">\(\mathcal{V}\)</span> be a predictive family. Thepredictive <span class="math inline">\(\mathcal{V}\)</span>-informationfrom <span class="math inline">\(X\)</span> to <spanclass="math inline">\(Y\)</span> is defined as <spanclass="math display">\[I_{\mathcal{V}}(X \rightarrow Y)=H_{\mathcal{V}}(Y \mid\varnothing)-H_{\mathcal{V}}(Y \mid X)\]</span></p></li></ol><p><span class="math inline">\(\mathcal{V}\)</span>-information有以下一些性质：</p><ul><li><p>基本性质</p><p>Let <span class="math inline">\(Y\)</span> and <spanclass="math inline">\(X\)</span> be any random variables on <spanclass="math inline">\(\mathcal{Y}\)</span> and <spanclass="math inline">\(\mathcal{X}\)</span>, and <spanclass="math inline">\(\mathcal{V}\)</span> and <spanclass="math inline">\(\mathcal{U}\)</span> be any predictive families,then we have</p><ul><li>Monotonicity: If <span class="math inline">\(\mathcal{V} \subseteq\mathcal{U}\)</span>, then <spanclass="math inline">\(H_{\mathcal{V}}(Y) \geq H_{\mathcal{U}}(Y),H_{\mathcal{V}}(Y \mid X) \geq H_{\mathcal{U}}(Y \mid X)\)</span>.</li><li>Non-Negativity: <span class="math inline">\(I_{\mathcal{V}}(X\rightarrow Y) \geq 0\)</span>.</li><li>Independence: If <span class="math inline">\(X\)</span> isindependent of <span class="math inline">\(Y, I_{\mathcal{V}}(X\rightarrow Y)=I_{\mathcal{V}}(Y \rightarrow X)=0\)</span>.</li></ul></li><li><p>数据处理不等式（与香农互信息不同）</p><ul><li><strong>Shannon Mutual Information</strong>: Letting <spanclass="math inline">\(t: \mathcal{X} \rightarrow \mathcal{X}\)</span> beany function, <span class="math inline">\(t(X)\)</span> cannot havehigher mutual information with <span class="math inline">\(Y\)</span>than <span class="math inline">\(X: I(t(X) ; Y) \leq I(X ;Y)\)</span>.</li><li><strong><spanclass="math inline">\(\mathcal{V}\)</span>-Information</strong>:Denoting <span class="math inline">\(t\)</span> as the decryptionalgorithm and <span class="math inline">\(\mathcal{V}\)</span> as aclass of natural language processing functions, we have that: <spanclass="math inline">\(I_{\mathcal{V}}(t(X) \rightarrowY)&gt;I_{\mathcal{V}}(X \rightarrow Y) \approx 0\)</span>.</li></ul></li><li><p>不对称性（与香农互信息不同）</p><p>If <span class="math inline">\(\mathcal{V}\)</span> contains allpolynomial-time computable functions, then <spanclass="math inline">\(I_{\mathcal{V}}(X \rightarrow h(X)) \ggI_{\mathcal{V}}(h(X) \rightarrow X)\)</span> , where <spanclass="math inline">\(h: \mathcal{X} \rightarrow\mathcal{Y}\)</span>.</p></li></ul><p>根据 <span class="math inline">\(\mathcal{V}\)</span>-information的性质，我们就能够合理解释上面例子展示的问题，从而有：</p><center><img src="/2023/03/12/%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8E%E6%A0%B7%E6%9C%AC%E9%9A%BE%E5%BA%A6%E5%BA%A6%E9%87%8F/image-20230312225113429.png" class=""></center><p><br></p><p>上面介绍的是 <spanclass="math inline">\(\mathcal{V}\)</span>-Information的严格定义，但是在机器学习中，我们不存在真实的分布，而是仅有从分布上采样的有限大小的数据集。下面，作者要解决如何在有限大小的数据集上估计<span class="math inline">\(\mathcal{V}\)</span>-Information：</p><p>Let <span class="math inline">\(X, Y\)</span> be two random variablestaking values in <span class="math inline">\(\mathcal{X},\mathcal{Y}\)</span> and <spanclass="math inline">\(\mathcal{D}=\left\{\left(x_i,y_i\right)\right\}_{i=1}^N \sim X, Y\)</span> denotes the set of samplesdrawn from the joint distribution over <spanclass="math inline">\(\mathcal{X}\)</span> and <spanclass="math inline">\(\mathcal{Y} . \mathcal{V}\)</span> is a predictivefamily. The empirical <spanclass="math inline">\(\mathcal{V}\)</span>-information (under <spanclass="math inline">\(\mathcal{D}\)</span> ) is the following <spanclass="math inline">\(\mathcal{V}\)</span>-information under theempirical distribution defined via <spanclass="math inline">\(\mathcal{D}\)</span> : <spanclass="math display">\[\hat{I}_{\mathcal{V}}(X \rightarrow Y ; \mathcal{D})=\inf _{f \in\mathcal{V}} \frac{1}{|\mathcal{D}|} \sum_{y_i \in \mathcal{D}} \log\frac{1}{f[\varnothing]\left(y_i\right)}-\inf _{f \in \mathcal{V}}\frac{1}{|\mathcal{D}|} \sum_{x_i, y_i \in \mathcal{D}} \log\frac{1}{f\left[x_i\right]\left(y_i\right)}\]</span> Then we have the following PAC bound over the empirical <spanclass="math inline">\(\mathcal{V}\)</span>-information:</p><p>Assume <span class="math inline">\(\forall f \in \mathcal{V}, x \in\mathcal{X}, y \in \mathcal{Y}, \log f[x](y) \in[-B, B]\)</span>. Thenfor any <span class="math inline">\(\delta \in(0,0.5)\)</span>, withprobability at least <span class="math inline">\(1-2 \delta\)</span>, wehave: <span class="math display">\[\left|I_{\mathcal{V}}(X \rightarrow Y)-\hat{I}_{\mathcal{V}}(X\rightarrow Y ; \mathcal{D})\right| \leq 4\mathfrak{R}_{|\mathcal{D}|}\left(\mathcal{G}_{\mathcal{V}}\right)+2 B\sqrt{\frac{2 \log \frac{1}{\delta}}{|\mathcal{D}|}}\]</span> where we define the function family <spanclass="math inline">\(\mathcal{G}_{\mathcal{V}}=\{g \mid g(x, y)=\logf[x](y), f \in \mathcal{V}\}\)</span>, and <spanclass="math inline">\(\mathfrak{R}_N(\mathcal{G})\)</span> denotes theRademacher complexity of <spanclass="math inline">\(\mathcal{G}\)</span> with sample number <spanclass="math inline">\(N\)</span>.</p><h2 id="使用-mathcalv-information-评估数据集和样本难度">3. 使用 <spanclass="math inline">\(\mathcal{V}\)</span>-Information评估数据集和样本难度</h2><p>利用上面介绍的 <spanclass="math inline">\(\mathcal{V}\)</span>-Information工具并进行实验，能够发现一些有趣的现象。</p><center><img src="/2023/03/12/%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8E%E6%A0%B7%E6%9C%AC%E9%9A%BE%E5%BA%A6%E5%BA%A6%E9%87%8F/image-20230312225802256.png" class=""></center><ul><li>大模型 accuracy 与<spanclass="math inline">\(\mathcal{V}\)</span>-Usable Information都更高，因为提取更多的信息让识别更容易</li><li><span class="math inline">\(\mathcal{V}\)</span>-Information 相比accuracy 对过拟合更加敏感</li></ul><center><img src="/2023/03/12/%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8E%E6%A0%B7%E6%9C%AC%E9%9A%BE%E5%BA%A6%E5%BA%A6%E9%87%8F/image-20230312225854120.png" class=""></center><ul><li>提供了衡量不同数据集难度的方法</li></ul><p>然后，引入评估样本点 <spanclass="math inline">\(\mathcal{V}\)</span>-Information （Pointwise <spanclass="math inline">\(\mathcal{V}\)</span>-Information，PVI）的方法：</p><p>Given random variables <span class="math inline">\(X, Y\)</span> anda predictive family <span class="math inline">\(\mathcal{V}\)</span>,the pointwise <spanclass="math inline">\(\mathcal{V}\)</span>-information (PVI) of aninstance <span class="math inline">\((x, y)\)</span> is <spanclass="math display">\[\operatorname{PVI}(x \rightarrow y)=-\log _2 g[\varnothing](y)+\log _2g^{\prime}[x](y)\]</span> where <span class="math inline">\(g \in \mathcal{V}\)</span>s.t. <span class="math inline">\(\mathbb{E}[-\logg[\varnothing](Y)]=H_{\mathcal{V}}(Y)\)</span> and <spanclass="math inline">\(g^{\prime} \in \mathcal{V}\)</span> s.t. <spanclass="math inline">\(\mathbb{E}\left[-\logg^{\prime}[X](Y)\right]=H_{\mathcal{V}}(Y \mid X)\)</span>.</p><p>PVI is to <spanclass="math inline">\(\mathcal{V}\)</span>-information what PMI is toShannon information: <span class="math display">\[\begin{aligned}I(X ; Y) &amp; =\mathbb{E}_{x, y \sim P(X, Y)}[\operatorname{PMI}(x, y)]\\I_{\mathcal{V}}(X \rightarrow Y) &amp; =\mathbb{E}_{x, y \sim P(X,Y)}[\operatorname{PVI}(x \rightarrow y)]\end{aligned}\]</span></p><p>完整算法流程如下：</p><center><img src="/2023/03/12/%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8E%E6%A0%B7%E6%9C%AC%E9%9A%BE%E5%BA%A6%E5%BA%A6%E9%87%8F/image-20230312230205356.png" class=""></center><p><br></p><p>然后，利用 PVI 进行实验，同样可以观察到一些有趣的现象：</p><center><img src="/2023/03/12/%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8E%E6%A0%B7%E6%9C%AC%E9%9A%BE%E5%BA%A6%E5%BA%A6%E9%87%8F/image-20230312230304658.png" class=""></center><ul><li>PVI 最低的样本中存在不少标注错误</li></ul><center><img src="/2023/03/12/%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8E%E6%A0%B7%E6%9C%AC%E9%9A%BE%E5%BA%A6%E5%BA%A6%E9%87%8F/image-20230312230341812.png" class=""></center><ul><li>模型能够正确分类样本的 PVI 阈值在 0.5 左右</li></ul><p><br></p><p>此外，原论文中还展示了一些有趣的实验现象，这里不再赘述，具体请参阅原论文。</p>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
      <category>读论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dataset &amp; example difficulty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 22.04 安装 QEMU 流程</title>
    <link href="/2023/03/03/Ubuntu-22-04-%E5%AE%89%E8%A3%85-QEMU-%E6%B5%81%E7%A8%8B/"/>
    <url>/2023/03/03/Ubuntu-22-04-%E5%AE%89%E8%A3%85-QEMU-%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.qemu.org/download/">QEMU</a>官方网站已经提供了安装 QEMU 的教程，按照其内容，Ubuntu 平台仅需执行<code>sudo apt-get install qemu</code>命令即可。但是，在实际安装过程中遇到了错误且未能解决，于是采用源码方式安装。以QEMU 7.2.0 版本为例，介绍安装流程。</p><ol type="1"><li><p>下载源码并解压缩</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">wget https://download.qemu.org/qemu-7.2.0.tar.xz</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">tar xvJf qemu-7.2.0.tar.xz</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> qemu-7.2.0</span><br></code></pre></td></tr></table></figure></li><li><p>编译前预处理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./configure</span><br></code></pre></td></tr></table></figure></li><li><p>处理报错</p><p>执行上述命令后，可能会出现以下报错：</p><center><img src="/2023/03/03/Ubuntu-22-04-%E5%AE%89%E8%A3%85-QEMU-%E6%B5%81%E7%A8%8B/image-20230303200128068.png" class=""></center><p>报错原因是系统缺少 QEMU 需要的相关依赖。执行以下命令安装依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install ninja-build</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install zlib1g zlib1g-dev</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install libglib2.0-dev</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install libpixman-1-dev</span><br></code></pre></td></tr></table></figure><p>重新执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./configure</span><br></code></pre></td></tr></table></figure></li><li><p>make 编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make</span><br></code></pre></td></tr></table></figure><p>执行上述命令后，开始漫长的编译过程，请耐心等待。</p></li><li><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo make install</span><br></code></pre></td></tr></table></figure></li><li><p>验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">qemu-</span><br></code></pre></td></tr></table></figure><p>输入 <code>qemu-</code> 后按两次 TAB键，若出现类似下面的输出，则安装成功。</p><center><img src="/2023/03/03/Ubuntu-22-04-%E5%AE%89%E8%A3%85-QEMU-%E6%B5%81%E7%A8%8B/image-20230303214138504.png" class="" title="image-20230303214138504"></center></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>QEMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 博客无法显示图片解决方法</title>
    <link href="/2023/02/23/Hexo-%E5%8D%9A%E5%AE%A2%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <url>/2023/02/23/Hexo-%E5%8D%9A%E5%AE%A2%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>Hexo 官方提供了很多在 Markdown 中 <ahref="https://hexo.io/zh-cn/docs/asset-folders#使用-Markdown-嵌入图片">插入图片</a>的方式，其语法主要可分为两种：</p><ol type="1"><li><p>Markdown 原生支持的语法</p><p><code>![图片描述](图片路径)</code></p><p>其中，图片路径不可以使用相对于本地系统的绝对路径，例如：<code>C:/Users/admin/Pictures/a.jpg</code>，这样 Hexo在生成静态网页时无法正确解析图片，从而导致图片无法在网页正常显示。</p><p>正确的图片路径有以下两种形式：</p><ul><li><p>相对于博客的根目录：<code>/imgs/a.jpg</code>，使用这种方式需要在博客 <code>source</code> 目录下新建<code>imgs</code> 文件夹，并在 <code>imgs</code>文件夹中存放文章需要使用的图片。</p><p>例如，使用：<code>/imgs/0_0.jpg</code>语法，可显示如下图片：</p></li></ul><p><img src="/imgs/0_0.jpg" /></p><ul><li><p>相对于某篇博客的相对路径：<code>./article_1/a.jpg</code>。使用这种方式需要在 Hexo 配置文件 <code>_config.yaml</code> 将<code>post_asset_folder</code> 选项设为 <code>true</code> 。然后使用<code>hexo new xxx</code> 新建文章时，Hexo 便会在<code>source/_posts</code>目录下新建与文章同名的文件夹，然后将文章需要使用的图片放在该文件夹中，通过相对路径引用即可。</p><p>例如，使用：<code>Hexo-博客无法显示图片解决方法/0_1.jpg</code>语法，可显示如下图片：</p><img src="/2023/02/23/Hexo-%E5%8D%9A%E5%AE%A2%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/0_1.jpg" class=""></li></ul></li><li><p>Hexo 特有的 asset_img 标签语法</p><p>Hexo 推荐使用的图片引用方式如下：</p><p><code>&#123;% asset_img example.jpg This is an example image %&#125;</code></p><p>但是，这种语法无法在 Markdown编辑器中正常显示图片，会影响我们在编辑器中查看文章内容，个人不推荐这种方式。</p></li></ol><p>经过个人探索，得到以下比较好用的解决方法，能够同时在 Hexo 博客和Markdown 编辑器中正确显示图片。</p><p>首先，根据 Hexo 官方文档，在 <code>_config.yaml</code> 将<code>post_asset_folder</code> 选项设为 <code>true</code>。然后，安装插件 <code>hexo-image-link</code>，安装命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install hexo-image-link --save<br></code></pre></td></tr></table></figure><p>如果安装了 <code>hexo-asset-img</code> 插件，需要将其卸载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm uninstall --save hexo-asset-img<br></code></pre></td></tr></table></figure><p>然后，配置 Markdown 编辑器 Typora 如下：</p><img src="/2023/02/23/Hexo-%E5%8D%9A%E5%AE%A2%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/image-20230223101720679.png" class="" title="Typora 配置"><p>配置完成后，在 Typora 中粘贴图片时，Typora就会自动将图片保存到与文件名同名的目录下，并在 Markdown中使用相对路径引用图片。这样，我们就可以在 Hexo 博客和 Typora中同时看到图片。</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>鸟哥的 Linux 私房菜阅读笔记</title>
    <link href="/2023/02/20/%E9%B8%9F%E5%93%A5%E7%9A%84-Linux-%E7%A7%81%E6%88%BF%E8%8F%9C%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/02/20/%E9%B8%9F%E5%93%A5%E7%9A%84-Linux-%E7%A7%81%E6%88%BF%E8%8F%9C%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>写在前面：</strong></p><p>本文是阅读 《鸟哥的 Linux 私房菜：基础学习篇》一书的笔记，记录了个人认为的一些重点内容，供本人后续查阅参考。对于偏向于系统运维方面的内容，则未记录。</p><p>《鸟哥的 Linux 私房菜：基础学习篇》无疑是入门 Linux命令行的一本好书，但是在个人阅读过程中，发现本书部分内容更偏向于系统运维人员，而不是大多数的普通程序员。当然，技多不压身，不过，对于仅想了解与日常编程开发紧密相关的命令行内容的读者，不妨选择性地跳跃阅读本书，或者找一些更符合您需求的资料。</p></blockquote><h2 id="linux-是什么与如何学习">1. Linux 是什么与如何学习</h2><h3 id="linux-是什么">1.1 Linux 是什么</h3><ul><li>1991 年 Linus 编写</li><li>操作系统发展历程<ol type="1"><li>1969 年，<strong>批处理操作系统</strong></li><li><strong>分时操作系统</strong>， “Multics” 系统</li><li>1973 年，UNIX 正式诞生； 1977 年，BSD 诞生; 1979 年，SystemV，<em>引发商业纠纷</em></li><li>1984 年，Minix 系统开始编写 ； GNU （GNU's NotUnix）计划（斯托曼发起）与 FSF（Free SoftwareFoundation）基金会成立</li><li>1988 年，图形用户界面模式 XFree86 计划</li><li>1991 年，芬兰 Linus Torvalds 发布 Linux 内核</li></ol></li><li>常见的开放源代码的授权（<ahref="https://www.runoob.com/w3cnote/open-source-license.html">详细介绍</a>）<ol type="1"><li>Apache Lisense 2.0</li><li>BSD</li><li>GPL</li><li>MIT License</li><li>……</li></ol></li></ul><h3 id="托瓦兹的-linux-的发展">1.2 托瓦兹的 Linux 的发展</h3><ul><li><p>1994 年，Linux 内核正式版， Version 1.0</p></li><li><p>1996 年， 2.0 版</p></li><li><p>2011 年，3.0 版</p></li><li><p>2015 年 4 月，4.0 版</p></li><li><p>查看内核版本命令： <code>uname -r</code></p></li><li><p>Linux 发行版分类（按照包管理工具）</p><ol type="1"><li>RPM 方式管理：Red Hat、Fedora、SUSE 等</li><li>dpkg 方式管理：Debian、Ubuntu、B2D 等</li><li>其他：Gentoo</li></ol></li></ul><h3 id="linux-该如何学习">1.3 Linux 该如何学习</h3><ol type="1"><li>Linux 的安装与命令</li><li>Linux 操作系统的基础技能：用户用户组、权限的概念等</li><li>vi 文本编辑器</li><li>Shell 与 Shell 脚本的学习</li><li>软件管理</li><li>网络基础</li></ol><p>核心：<strong><em>实践 动手</em></strong></p><h2 id="主机规划与磁盘划分">2. 主机规划与磁盘划分</h2><h3 id="linux-与硬件的搭配">2.1 Linux 与硬件的搭配</h3><p>略</p><h3 id="磁盘分区">2.2 磁盘分区</h3><p>P69 - P82 略</p><h3 id="安装-linux-前的规划">2.3 安装 Linux 前的规划</h3><p>确定用途 -&gt; 磁盘分区</p><h2 id="安装-centos7.x">3. 安装 CentOS7.x</h2><p>略 见第 3 章</p><h2 id="首次登录与在线求助">4. 首次登录与在线求助</h2><h3 id="首次登录系统">4.1 首次登录系统</h3><p>略</p><h3 id="命令行模式下命令的执行">4.2 命令行模式下命令的执行</h3><h4 id="开始执行命令">4.2.1 开始执行命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">命令一般格式</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">command</span> [-options] parameter1 parameter2 ...</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  命令      选项       参数</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">示例：查看home目录下所有文件（包括隐藏文件 -a）及其属性（-l）</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -al ~</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span>        -al     ~</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -a -l ~</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看日期和时间</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">date</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看语言语系</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">locale</span><br></code></pre></td></tr></table></figure><blockquote><p>番外：</p><p><strong>如何使用Windows ssh 连接远程CentOS主机？</strong></p><p><em>CentOS 端：</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看本机是否安装SSH软件包</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash"> rpm -qa | grep ssh</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果没有安装SSH</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yum install openssh-server</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">开启SSH服务</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">service sshd start</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看22号端口是否开启</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">netstat -ntpl | grep 22</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改服务器端断开连接时长</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">vi /etc/ssh/sshd_config</span> <br>找到<br><span class="hljs-meta prompt_">#</span><span class="language-bash">ClientAliveInterval 0</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">ClientAliveCountMax 3</span><br>修改为<br>ClientAliveInterval 60<br>ClientAliveCountMax 5<br>然后重启sshd服务<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl restart sshd</span><br></code></pre></td></tr></table></figure><p><em>Windows 端：</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh username@hostname(hostIP)</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">命令 用户名@主机名或者IP地址</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">然后输入密码即可连接远程主机</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="基础命令的操作">4.2.2 基础命令的操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">date</span><span class="hljs-comment"># 查看时间日期</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">cal<span class="hljs-comment"># 查看日历（calender）</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">bc<span class="hljs-comment"># 计算器</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">date</span> 具体</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">date</span> +%Y/%m/%d<span class="hljs-comment"># 以 year/month/day 格式输出 如“2021/03/22”</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">date</span> +%H:%M<span class="hljs-comment"># 以 hour:minute 格式输出 如“23:49”</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">cal 具体</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">cal year<span class="hljs-comment"># 显示 year 年的日历</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">cal [month] [year]<span class="hljs-comment"># 显示某年某月日历</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">bc 简单计算器</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">bc<span class="hljs-comment"># 支持 + - * / ^ %quit 退出计算器</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">bc 默认输出整数  scale = n 使输出小数点后 n 位</span><br></code></pre></td></tr></table></figure><h4 id="重要的几个热键-tabctrl-cctrl-d">4.2.3 重要的几个热键[Tab]、[Ctrl]-c、[Ctrl]-d</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">Tab 键</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">命令补全</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ca[Tab][Tab]<span class="hljs-comment"># 输入 ca 后按两次 Tab 键，终端输出以 ca 为前缀的命令</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出如下：</span><br>cacertdir_rehash     cache_restore        ca-legacy            cancel               cat<br>cache_check          cache_writeback      calibrate_ppa        cancel.cups          catchsegv<br>cache_dump           cagent_tools         caller               capsh                catman<br>cache_metadata_size  cairo-sphinx         canberra-boot        captoinfo<br>cache_repair         cal                  canberra-gtk-play    case<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">文件补齐</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -al .bash[Tab][Tab]<span class="hljs-comment"># 自动补齐文件名</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出如下</span><br>.bash_history  .bash_logout   .bash_profile  .bashrc<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">选项/参数补齐</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">date</span> --[Tab][Tab]<span class="hljs-comment"># 自动补齐参数</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出如下</span><br>--date        --help        --reference=  --rfc-3339=   --universal<br>--date=       --iso-8601    --rfc-2822    --set=        --version<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">[Ctrl]-c</span><br>作用：终端正在运行中的命令<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">[Ctrl]-d</span><br>作用：<br>1、相当于 exit 命令<br>2、代表键盘输入结束（End Of File）<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">[Shift] + &#123;[Page UP][Page Down]&#125;</span><br>作用：用于命令行输出的翻页<br></code></pre></td></tr></table></figure><h3 id="linux-系统的在线求助-man-page-和-info-page">4.3 Linux系统的在线求助 man page 和 info page</h3><h4 id="命令的---help-求助说明">4.3.1 命令的 --help 求助说明</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">date</span> --<span class="hljs-built_in">help</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查询已经使用过的命令选项</span><br></code></pre></td></tr></table></figure><h4 id="man-page">4.3.2 man page</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">man <span class="hljs-built_in">date</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">man 为 manual(操作说明)的缩写</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">按下 空格键 翻页；q 退出</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">向下查找词语： 输入 “/word” ，然后按 Enter 键，即可查找 “word”</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">向上查找词语： 输入 “?word” ，然后按 Enter 键，即可查找 “word”</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看 man 的帮助</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">man man</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看系统中和 man 命令有关的说明文件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">man -f man</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">whatis [命令或文件]<span class="hljs-comment"># 等价于上面 man -f ...</span></span><br>man (7)              - 格式化手册页的宏<br>man (1)              - 格式化并显示在线帮助手册页<br>man (1p)             - display system documentation<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">man 1 man<span class="hljs-comment"># 根据上面输出查看指定说明文件</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">找到系统中说明文件，只有有 man 关键字就将该说明列出来</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">man -k man</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">apropos [命令或文件]<span class="hljs-comment"># 相当于 man -k ...</span></span><br></code></pre></td></tr></table></figure><h4 id="info-page">4.3.3 info page</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">info info</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">按 N 、 P 、 U 到下一个、上一个、上一层的节点</span><br></code></pre></td></tr></table></figure><h3 id="超简单的文本编辑器nano">4.4 超简单的文本编辑器：nano</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">nano file.txt<span class="hljs-comment"># 打开 或者 创建 文件</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">打开 nano 之后下面的 <span class="hljs-string">&quot;^X&quot;</span> 代表 Ctrl + X 键，完成一定功能</span><br></code></pre></td></tr></table></figure><h3 id="正确的关机方法">4.5 正确的关机方法</h3><ol type="1"><li><p>观察系统的使用状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">who</span>  <span class="hljs-comment"># 查看当前谁在线</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">netstat -a<span class="hljs-comment"># 查看网络的联机状态</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ps -aux<span class="hljs-comment"># 查看后台进程</span></span><br></code></pre></td></tr></table></figure></li><li><p>通知在线用户关机的时刻</p></li><li><p>正确使用关机命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">sync</span><span class="hljs-comment"># 将数据同步写入硬盘中mingl</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">shutdown<span class="hljs-comment"># 常用的关机命令</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重新启动、关机</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">reboot</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">halt</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">poweroff</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">以 root 身份登录</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">su -</span><br></code></pre></td></tr></table></figure></li><li><p>shutdown 使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">shutdown [-krhc][时间] [警告信息]</span><br>-k: 不关机，只发送警告信息<br>-r: 将系统服务停掉之后就重新启动<br>-h: 将系统服务停掉之后，立即关机<br>-c: 取消已经在进行的 shutdown 命令内容<br>时间 : 指定系统关机时间。默认一分钟后自动进行<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">常用示例</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">shutdown -h now<span class="hljs-comment"># 立刻关机</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">shutdown -h 20:25<span class="hljs-comment"># 今天 20:25 关机 （或次日20:25关机）</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">shutdown -h +10<span class="hljs-comment"># 系统 10 分钟后自动关机</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">shutdown -r now<span class="hljs-comment"># 立刻重新启动</span></span><br></code></pre></td></tr></table></figure></li><li><p>reboot、 halt、 poweroff 使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">halt<span class="hljs-comment"># 系统停止，屏幕可能会保留系统已经停止的信息</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">poweroff<span class="hljs-comment"># 系统关机，屏幕空白</span></span><br></code></pre></td></tr></table></figure></li><li><p>实际使用管理工具 systemctl 关机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl [命令]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl reboot<span class="hljs-comment"># 系统重新启动</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl poweroff<span class="hljs-comment"># 系统关机</span></span><br></code></pre></td></tr></table></figure></li></ol><h2 id="linux-的文件权限与目录配置">5. Linux 的文件权限与目录配置</h2><h3 id="用户与用户组">5.1 用户与用户组</h3><ol type="1"><li><p>文件拥有者的三个层次：</p><blockquote><ol type="1"><li>文件所有者( User )：</li><li>用户组( Group )：每个用户可以有多个用户组的支持</li><li>其他人( Others )：</li></ol></blockquote></li><li><p>系统上所有账号相关信息记录在文件： /etc/passwd （可用 cat/etc/passwd 命令查看文件内容）</p></li><li><p>密码记录在： /etc/shadow 文件内</p></li><li><p>组名记录在： /etc/group 文件内</p></li></ol><h3 id="linux-文件权限概念">5.2 Linux 文件权限概念</h3><h4 id="linux-文件属性">5.2.1 Linux 文件属性</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">su -<span class="hljs-comment"># 切换到 root 权限</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -al<span class="hljs-comment"># list 查看文件名及相关属性</span></span><br>总用量 104<br>dr-xr-x---. 16 root root 4096 3月  22 23:14 .<br>dr-xr-xr-x. 20 root root 4096 3月  31 20:50 ..<br>-rw-------   1 root root 1955 3月  31 20:50 .bash_history<br>-rw-r--r--.  1 root root   18 12月 29 2013 .bash_logout<br>-rw-r--r--.  1 root root  176 12月 29 2013 .bash_profile<br>-rw-r--r--.  1 root root  176 12月 29 2013 .bashrc<br>drwxr-xr-x   9 root root 4096 3月  22 23:14 .cache<br>drwxr-xr-x  13 root root 4096 3月  22 23:14 .config<br>-rw-r--r--.  1 root root  100 12月 29 2013 .cshrc<br>drwx------   3 root root 4096 3月  22 23:13 .dbus<br>-rw-------   1 root root   16 3月  22 23:13 .esd_auth<br>-rw-------   1 root root  310 3月  22 23:13 .ICEauthority<br>drwx------   3 root root 4096 3月  22 23:13 .local<br>drwxr-xr-x   2 root root 4096 3月   8 22:34 .pip<br>-rw-r--r--   1 root root   73 3月   8 22:34 .pydistutils.cfg<br>drwx------   2 root root 4096 1月  21 2019 .ssh<br>-rw-r--r--.  1 root root  129 12月 29 2013 .tcshrc<br>-rw-------   1 root root  508 3月   8 22:37 .viminfo<br>-rw-------   1 root root    0 3月  22 23:14 .Xauthority<br><br>各字段解释如下：<br>-rw-------   1 root root    0 3月  22 23:14 .Xauthority<br>[1][2] [3]  [4]    [5]    [6]         [7]<br><br></code></pre></td></tr></table></figure><p>各字段含义解释如下：</p><ol type="1"><li><p>文件类型权限：共有<strong>10个字符</strong>，第一个字符代表该文件是<strong>目录</strong>，<strong>文件</strong>，或<strong>链接文件</strong> 等</p><blockquote><p>第一个字符含义说明：</p><p>d ：目录（directory）</p><p>- ：文件</p><p>l ：链接文件（link file）</p><p>b ：设备文件里面的可供存储的周边设备（可按块随机读写的设备）</p><p>c ：设备文件里面的串行端口设备，如键盘、鼠标（一次性读写的设备）</p><p>剩余字符，3个一组，均为 [rwx] 的组合，r 代表可读（read），w代表可写（write），x代表可执行（execute）。这三个权限的位置不会改变，若无权限，则为减号 [-]。</p><p>第一组为：<strong>文件拥有者</strong> 可具备的权限</p><p>第二组为：加入此用户组之账号的权限</p><p>第三组为：非本人且没有加入本用户组的其他账户的权限</p></blockquote></li><li><p>链接数：表示有多少个文件名链接到此节点（ inode），即记录有多少个文件名链接到相同的 inode 号码</p></li><li><p>文件拥有者：表示文件（或目录）拥有者的账号</p></li><li><p>文件所属用户组：表示文件的所属用户组</p></li><li><p>文件大小：文件的容量大小，默认单位为字节 Bytes</p></li><li><p>文件最后被修改的时间：文件的创建时间或者最近修改时间（若修改时间据现在太久，则只显示年份）。如果要显示完整的时间格式，则需要使用<code>ls -l --full-time</code> 命令</p></li><li><p>文件名：这个文件名，若文件名之前多一个 <code>.</code>，则代表该文件为隐藏文件</p></li></ol><h4 id="如何修改文件属性与权限">5.2.2 如何修改文件属性与权限</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">修改文件所属用户组 (change group)</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chgrp</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chgrp</span> [-R] dirName/fileName</span><br>-R : 进行递归修改，即将目录下子目录及文件都更新成为这个用户组<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改文件拥有者 (change own)</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chown</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chown</span> [-R] 账号名称 dirName/fileName</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chown</span> [-R] 账号名称:用户组名称 dirName/fileName</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">复制文件后修改文件所有者示例：</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cp</span> 源文件 目标文件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chown</span> 账号名称 目标文件名</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改文件的权限</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1.数字类型修改文件权限</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">各权限对应数字如下：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">r ： 4</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">w ： 2</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">x ： 1</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">则 rwx = 4 + 2 + 1 = 4    rw- = 4 + 2 + 0 = 6</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> [-R] xyz 文件或目录</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">其中 xyz 为数字，例如：666 、 777、 640 等</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">示例：将一个 shell 文件修改为可执行,非拥有者用户可以执行、查看但不可以修改</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> 755 fileName.sh</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2.符号类型修改文件权限</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">格式</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> [u | g | o | a] [+ | - | =] [r | w | x] [dirName | fileName]</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">含义：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">u ：user   g ： group   o ： others  a ： all</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">+ ：加入    - ： 移除    = ： 设置</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">rwx ： 读写执行</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">例：</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> u=rwx,go=rx .bashrc</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> u=rwx,g=rx,o=r fileName</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> a+w fileName<span class="hljs-comment"># 令 fileName 对所有人都可以写</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> a-x fileName<span class="hljs-comment"># 去除所有人执行权限</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">给某文件添加执行权限</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> a+x fileName</span><br></code></pre></td></tr></table></figure><h4 id="目录与文件的权限意义">5.2.3 目录与文件的权限意义</h4><blockquote><p>对 <strong>文件</strong> ：</p><p>r ： 读取文件实际内容</p><p>w： 编辑、修改、新增文件内容（不能删除该文件）</p><p>e ： 文件可以被系统执行 （与文件名无关）</p><p>对 <strong>目录</strong> ：</p><p>r ： 读取目录结构列表 （可以使用 ls 命令查看目录内容列表）</p><p>w ：可以改动目录结构列表，即建立新文件与目录、删除已经存在文件和目录、重命名文件和目录、移动该目录内文件和目录位置（与该目录下文件名的变动有关）</p><p>x ： 代表用户能否进入该目录成为工作目录，工作目录及当前所在的目录</p><p><strong>能不能进入目录，只与该目录执行权限有关</strong></p><p><strong>要开放目录给任何人浏览时，应该开放 r 和 x 权限， w权限不可随便给 </strong></p><p>要读一个文件时，至少应具备该文件所在目录 r 和 x 权限。</p></blockquote><h4 id="linux-文件种类与扩展名">5.2.4 Linux 文件种类与扩展名</h4><ol type="1"><li><p>文件种类：</p><ol type="1"><li>常规文件（regular file）：<code>ls -al</code> 命令输出的第一个字符<code>-</code> ，如 <code>-rwxrwxrwx</code> 。<ul><li>纯文本文件（ASCII）：</li><li>二进制文件（binary）：可执行文件等</li><li>数据文件（date）：有些程序在运行时会读取某些特定格式的文件，这些文件被称为数据文件。</li></ul></li><li>目录（directory）：第一个属性为 <code>d</code> 。</li><li>链接文件（link）：第一个属性为 <code>l</code> ，如<code>lrwxrwxrwx</code> ，类似于 Windows 下快捷方式 。</li><li>设备与设备文件（device）：与系统周边及存储等相关的一些文件，通常集中在<code>/dev</code> 目录下，又可分为：<ul><li>区块（block）设备文件：第一个属性为 <code>d</code>，可供系统随机存取的接口设备 。</li><li>字符（character）设备文件：一些串行端口的接口设备，如键盘、鼠标等，特色：一次性读取，不能够截断输出，第一个属性为<code>c</code> 。</li></ul></li><li>数据接口文件（sockets）：用于网络上的数据交换，第一个属性为<code>s</code> ，通常可在 <code>/run</code> 或 <code>/tmp</code>这些目录中可看到这种文件类型 。</li><li>数据输送文件（FIFO，pipe）：主要目的：用于解决多个进程同时读写一个文件所造成的的错误问题，即管道，第一个属性为<code>p</code></li></ol></li><li><p>Linux 文件扩展名：Linux下文件无所谓文件扩展名，扩展名只能用来大概了解文件是什么类型。</p><blockquote><p><strong>常用文件扩展名</strong></p><ol type="1"><li>*.sh ：脚本或批处理文件</li><li>*.Z、*.tar、、*.tar.gz、*.zip、*.tgz ：压缩文件</li><li>、*.html、*.php ：网页相关文件</li></ol></blockquote></li><li><p>Linux 文件名长度限制：单一文件或目录的最大允许文件名为 255字节</p></li><li><p>Linux 文件名的限制：</p><blockquote><p>不能包含以下字符：</p><p>* ? &gt; &lt; ; &amp; ! [ ] | \ ' " ` ( ) { } - +</p></blockquote></li></ol><h3 id="linux-目录配置">5.3 Linux 目录配置</h3><h4 id="linux-目录配置的依据-fhs">5.3.1 Linux 目录配置的依据 —— FHS</h4><p>FHS（Filesystem HierarchyStandard）：规定每个特定目录下应该放置什么数据</p><hr /><table><thead><tr class="header"><th style="text-align: left;"></th><th style="text-align: center;">可分享</th><th style="text-align: center;">不可分享</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">不变（static）</td><td style="text-align: center;">/usr （软件存放处）</td><td style="text-align: center;">/etc （配置文件）</td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: center;">/opt （第三方辅助软件）</td><td style="text-align: center;">/boot （启动与内核文件）</td></tr><tr class="odd"><td style="text-align: left;">可变动（variable）</td><td style="text-align: center;">/var/mail （用户邮箱）</td><td style="text-align: center;">/var/run （程序相关）</td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: center;">/var/spool/news （新闻组）</td><td style="text-align: center;">/var/lock （程序相关）</td></tr></tbody></table><blockquote><p>FHS 仅针对三个目录规定应该放置什么数据：</p><p>/ （root ，根目录）：与启动系统有关</p><p>/usr （Unix software resource）：与软件安装 / 执行有关</p><p>/var （variable）：与系统运行过程有关</p></blockquote><p>FHS 具体要求：图片来源：<ahref="https://zh.wikipedia.org/zh-hans/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86">维基百科：文件系统层次结构标准</a></p><figure><imgsrc="https://raw.githubusercontent.com/UnpureRationalist/Pictures/main/FHS.png"alt="FHS" /><figcaption aria-hidden="true">FHS</figcaption></figure><h4 id="目录树">5.3.2 目录树</h4><p><imgsrc="https://raw.githubusercontent.com/UnpureRationalist/Pictures/main/image-20210407000259422.png" /></p><h4 id="绝对路径与相对路径">5.3.3 绝对路径与相对路径</h4><p>略</p><h4 id="centos-的观察">5.3.4 CentOS 的观察</h4><p>Linux Standard Base（LSB）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">uname</span> -r<span class="hljs-comment"># 查看内核版本</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">uname</span> -m<span class="hljs-comment"># 查看操作系统架构版本</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看 LSB 标准</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yum install redhat-lsb<span class="hljs-comment"># 安装软件</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">lsb_relase -a<span class="hljs-comment"># 查看 LSB 标准</span></span><br>LSB Version:    :core-4.1-amd64:core-4.1-noarch:cxx-4.1-amd64:cxx-4.1-noarch:desktop-4.1-amd64:desktop-4.1-noarch:languages-4.1-amd64:languages-4.1-noarch:printing-4.1-amd64:printing-4.1-noarch<br>Distributor ID: CentOS<br>Description:    CentOS Linux release 7.5.1804 (Core)<br>Release:        7.5.1804<br>Codename:       Core<br></code></pre></td></tr></table></figure><h2 id="linux-文件与目录管理">6. Linux 文件与目录管理</h2><h3 id="目录与路径">6.1 目录与路径</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">pwd</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> [-p]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">rmdir</span> [-p]</span><br></code></pre></td></tr></table></figure><p>显示环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">给 PATH 环境变量添加路径：</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;PATH&#125;</span>:/root&quot;</span></span><br></code></pre></td></tr></table></figure><h3 id="文件与目录管理">6.2 文件与目录管理</h3><p><code>ls</code> 命令常用选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">-a ：全部的文件，连同隐藏文件（开头为 . 的文件）一起列出来<br>-d ：仅列出目录本身，而不是列出目录内的文件数据<br>-h ：将文件大小以人类较易读的方式（例如 GB, KB等等）列出来<br>-l ：长数据串行出，包含文件的属性与权限等等数据<br>-i ：列出 inode 号码<br></code></pre></td></tr></table></figure><p>其他命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cp</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mv</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">rm</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">basename</span>  <span class="hljs-comment"># 获取路径的文件名</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">dirname</span><span class="hljs-comment"># 获取路径的目录名</span></span><br></code></pre></td></tr></table></figure><h3 id="文件内容查看">6.3 文件内容查看</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">tac</span>   <span class="hljs-comment"># 从最后一行开始显示文件内容</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">nl</span><span class="hljs-comment"># 同时输出行号</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">more<span class="hljs-comment"># 一页一页显示文件内容</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">less<span class="hljs-comment"># 与 more 类似，但可以向前翻页</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">head</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">tail</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">od</span><span class="hljs-comment"># 以二进制形式读取文件内容</span></span><br></code></pre></td></tr></table></figure><h3 id="文件与目录的默认权限与隐藏权限">6.4文件与目录的默认权限与隐藏权限</h3><p>umask：指定目前用户在建立文件或目录时的默认权限，具体指要被拿掉的权限。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">umask</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">umask</span> -S</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置 <span class="hljs-built_in">umask</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">umask</span> 002</span><br></code></pre></td></tr></table></figure><p>文件的隐藏属性：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">chattr<span class="hljs-comment"># 配置文件隐藏属性</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">lsattr<span class="hljs-comment"># 显示文件隐藏属性</span></span><br></code></pre></td></tr></table></figure><p>查看文件类型命令：<code>file</code></p><h3 id="命令与文件的查找">6.5 命令与文件的查找</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">which</span> [-a] 命令名</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">wnereis [-bmsu] 文件或目录名</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">locate [-ir] keyword</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">updatedb<span class="hljs-comment"># 更新数据库</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">find [PATH] [option] [action]</span><br></code></pre></td></tr></table></figure><h2 id="linux-磁盘与文件系统管理">7. Linux 磁盘与文件系统管理</h2><h3 id="文件系统的简单操作">7.1 文件系统的简单操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">df</span><span class="hljs-comment"># 列出文件系统的整体磁盘使用量</span></span><br>-h : 以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示<br>-i : 不用磁盘容量，而以 inode 的数量来显示<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">du</span><span class="hljs-comment"># 查看文件系统的磁盘使用量</span></span><br>-h : 同上<br>-s : 仅列出总量，而不列出每个各别的目录占用容量<br></code></pre></td></tr></table></figure><p>链接：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ln</span> [-sf] 源文件 目标文件</span><br>-s ：有 -s 选项为符号链接；否则为硬链接<br>-f : 目标文件存在时，就主动的将目标文件直接删除后再创建<br></code></pre></td></tr></table></figure><h3 id="磁盘的分区格式化检验与挂载">7.2磁盘的分区、格式化、检验与挂载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gdisk 设备名称</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">mount [-t 文件系统] UUID=<span class="hljs-string">&#x27;&#x27;</span> 挂载点</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">umount [-fn] 设备文件名或挂载点</span><br></code></pre></td></tr></table></figure><h2 id="文件与文件系统的压缩">8. 文件与文件系统的压缩</h2><h3 id="linux-系统常见的压缩命令">8.1 Linux 系统常见的压缩命令</h3><blockquote><p><em>.Z compress 程序压缩的文件； </em>.zip zip 程序压缩的文件；<em>.gz gzip 程序压缩的文件； </em>.bz2 bzip2 程序压缩的文件； <em>.xzxz 程序压缩的文件； </em>.tar tar 程序打包的数据，并没有压缩过；<em>.tar.gz tar 程序打包的文件，其中并且经过 gzip 的压缩 </em>.tar.bz2tar 程序打包的文件，其中并且经过 bzip2 的压缩 *.tar.xz tar程序打包的文件，其中并且经过 xz 的压缩</p></blockquote><p>gzip 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gzip[-cdtv<span class="hljs-comment">#] 文件名</span></span><br>-c：将压缩的数据输出到屏幕上，可通过数据流重导向来处理；<br>-d：解压缩的参数；<br>-t：可以用来检验一个压缩文件的一致性,看看文件有无错误；<br>-v：可以显示出原文件/压缩文件的压缩比等信息；<br><span class="hljs-meta prompt_">-#</span><span class="language-bash">：<span class="hljs-comment">#为数字的意思，代表压缩等级，-1最快，但是压缩比最差、-9最慢，但是压缩比最好！默认是-6</span></span><br></code></pre></td></tr></table></figure><h3 id="打包命令tar">8.2 打包命令：tar</h3><p>最简单的使用 tar 就只要记忆下面的方式即可：</p><ul><li>压　缩：tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称</li><li>查　询：tar -jtv -f filename.tar.bz2</li><li>解压缩：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录</li></ul><h2 id="vim-程序编辑器">9. vim 程序编辑器</h2><h3 id="vi-的使用">9.1 vi 的使用</h3><p>三种模式：</p><ul><li>一般命令模式</li><li>编辑模式</li><li>命令行模式</li></ul><p><imgsrc="https://linux.vbird.org/linux_basic/centos7/0310vi//centos7_vi-mode.gif" /></p><h3 id="vim-的额外功能">9.2 vim 的额外功能</h3><ul><li>可视区块：以列为单位编辑</li><li>多文件编辑</li><li>多窗口功能</li></ul><h2 id="认识与学习-bash">10. 认识与学习 BASH</h2><h3 id="认识-bash-这个-shell">10.1 认识 BASH 这个 SHELL</h3><p><imgsrc="https://linux.vbird.org/linux_basic/centos7/0320bash//0320bash_1.jpg" /></p><p>快捷键：</p><table><thead><tr class="header"><th style="text-align: center;">组合键</th><th style="text-align: center;">功能与示范</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">[ctrl]+u/[ctrl]+k</td><td style="text-align: center;">分别是从游标处向前删除指令串([ctrl]+u)及向后删除指令串([ctrl]+k)。</td></tr><tr class="even"><td style="text-align: center;">[ctrl]+a/[ctrl]+e</td><tdstyle="text-align: center;">分别是让游标移动到整个指令串的最前面([ctrl]+a)或最后面([ctrl]+e)。</td></tr></tbody></table><h3 id="shell-的变量功能">10.2 Shell 的变量功能</h3><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span><span class="hljs-comment"># PATH 即为变量，使用时签名需加上 $</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者：</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;PATH&#125;</span><span class="hljs-comment"># recommend</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;MAIL&#125;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;HOME&#125;</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置变量值</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">var_name=value</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">取消设置变量</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">unset</span> var_name</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">export</span> var_name<span class="hljs-comment"># 以export来使变量变成环境变量</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">read</span> [-pt] var_name<span class="hljs-comment"># 读取键盘输入的变量值</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">declare</span> [-aixr] var_name</span><br>选项与参数：<br>-a ：将后面名为variable 的变数定义成为阵列(array) 类型<br>-i ：将后面名为variable 的变数定义成为整数数字(integer) 类型<br>-x ：用法与export 一样，就是将后面的variable 变成环境变数；<br>-r ：将变数设定成为readonly 类型，该变数不可被更改内容，也不能unset<br></code></pre></td></tr></table></figure><h3 id="命令别名与历史">10.3 命令别名与历史</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">alias</span> lm=<span class="hljs-string">&#x27;ls -al | more&#x27;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">unalias</span> lm</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">history</span> [n]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">history</span> [-c]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">history</span> [-raw] histfiles</span><br>选项与参数：<br>n  ：数字，意思是『要列出最近的 n 条命令列表』的意思！<br>-c ：将目前的shell 中的所有history 内容全部消除<br>-a ：将目前新增的history 指令新增入histfiles 中，若没有加histfiles ，<br>      则预设写入~/.bash_history<br>-r ：将histfiles 的内容读到目前这个shell 的history 记忆中；<br>-w ：将目前的history 记忆内容写入histfiles 中<br></code></pre></td></tr></table></figure><h3 id="bash-shell-的操作环境">10.4 Bash shell 的操作环境</h3><p>命令查找顺序：</p><ol type="1"><li>以相对/绝对路径执行指令，例如『 /bin/ls 』或『 ./ls 』；</li><li>由alias 找到该指令来执行；</li><li>由bash 内建的(builtin) 指令来执行；</li><li>透过$PATH 这个变量的顺序搜寻到的第一个指令来执行。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">source</span> ~/.bashrc<span class="hljs-comment"># 读入环境配置文件</span></span><br></code></pre></td></tr></table></figure><h3 id="数据流重定向">10.5 数据流重定向</h3><ol type="1"><li>标准输入(stdin) ：代码为0 ，使用&lt; 或&lt;&lt; ；</li><li>标准输出(stdout)：代码为1 ，使用&gt; 或&gt;&gt; ；</li><li>标准错误输出(stderr)：代码为2 ，使用2&gt; 或2&gt;&gt; ；</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">find /home -name .bashrc 2&gt; /dev/null<span class="hljs-comment"># dev/null 垃圾桶黑洞装置与特殊写法</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">command1; command2; command3<span class="hljs-comment"># ; 依次连续执行多条命令</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">cmd1 &amp;&amp; cmd2</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">cmd1 || cmd2</span><br></code></pre></td></tr></table></figure><table><thead><tr class="header"><th style="text-align: left;">指令下达情况</th><th style="text-align: left;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">cmd1 &amp;&amp; cmd2</td><td style="text-align: left;">1. 若cmd1执行完毕且正确执行($?=0)，则开始执行cmd2。 2. 若cmd1执行完毕且为错误($?≠0)，则cmd2 不执行。</td></tr><tr class="even"><td style="text-align: left;">cmd1 || cmd2</td><td style="text-align: left;">1. 若cmd1 执行完毕且正确执行($?=0)，则cmd2不执行。 2. 若cmd1 执行完毕且为错误($?≠0)，则开始执行cmd2。</td></tr></tbody></table><h3 id="管道命令">10.6 管道命令</h3><ul><li>管道命令仅会处理standard output，对于standard error output会予以忽略</li><li>管道命令必须要能够接受来自前一个指令的资料成为standard input继续处理才行。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">split</span> [-bl] file PREFIX</span><br>选项与参数：<br>-b ：后面可接欲分割成的档案大小，可加单位，例如b, k, m 等；<br>-l ：以行数来进行分割。<br>PREFIX ：代表前置字元的意思，可作为分割档案的前导文字。<br></code></pre></td></tr></table></figure><h2 id="正则表达式与文件格式化处理">11. 正则表达式与文件格式化处理</h2><h3 id="基础正则表达式">11.1 基础正则表达式</h3><table><thead><tr class="header"><th>特殊符号</th><th>代表意义</th></tr></thead><tbody><tr class="odd"><td>[:alnum:]</td><td>代表英文大小写字元及数字，亦即0-9, A-Z, a-z</td></tr><tr class="even"><td>[:alpha:]</td><td>代表任何英文大小写字元，亦即A-Z, a-z</td></tr><tr class="odd"><td>[:blank:]</td><td>代表空白键与[Tab] 按键两者</td></tr><tr class="even"><td>[:cntrl:]</td><td>代表键盘上面的控制按键，亦即包括CR, LF, Tab, Del 等等</td></tr><tr class="odd"><td>[:digit:]</td><td>代表数字而已，亦即0-9</td></tr><tr class="even"><td>[:graph:]</td><td>除了空白字元(空白键与[Tab] 按键) 外的其他所有按键</td></tr><tr class="odd"><td>[:lower:]</td><td>代表小写字元，亦即a-z</td></tr><tr class="even"><td>[:print:]</td><td>代表任何可以被列印出来的字元</td></tr><tr class="odd"><td>[:punct:]</td><td>代表标点符号(punctuation symbol)，亦即：" ' ? ! ; : # $</td></tr><tr class="even"><td>[:upper:]</td><td>代表大写字元，亦即A-Z</td></tr><tr class="odd"><td>[:space:]</td><td>任何会产生空白的字元，包括空白键, [Tab], CR 等等</td></tr><tr class="even"><td>[:xdigit:]</td><td>代表16 进位的数字类型，因此包括： 0-9, A-F, a-f 的数字与字元</td></tr></tbody></table><ul><li>查找特定字符串</li><li>利用中括号 <code>[]</code> 来查找集合字符</li><li>行首和行尾字符 <code>^$</code></li><li>任意一个字符 <code>.</code> 与重复字符 <code>*</code></li><li>限定连续 RE 字符范围 <code>&#123;&#125;</code>（需使用转义字符<code>\</code>）</li></ul><p>基础的正规表示法特殊字符汇整如下：</p><table><thead><tr class="header"><th>E 字符</th><th>意义与范例</th></tr></thead><tbody><tr class="odd"><td>^word</td><td>意义：待搜寻的字串(word)在行首！ <br/>范例：搜寻行首为#开始的那一行，并列出行号<br/>grep -n '^#' regular_express.txt</td></tr><tr class="even"><td>word$</td><td>意义：待搜寻的字串(word)在行尾！ <br/>范例：将行尾为!的那一行列印出来，并列出行号<br/>grep -n '!$' regular_express.txt</td></tr><tr class="odd"><td>.</td><td>意义：代表『一定有一个任意字元』的字符！<br/>范例：搜寻的字串可以是(eve) (eae) (eee) (ee)， 但不能仅有(ee)！亦即e 与e 中间『一定』仅有一个字元，而空白字元也是字元！<br/>grep -n'ee' regular_express.txt</td></tr><tr class="even"><td>\</td><td>意义：透过shell 的跳脱字符，将特殊符号的特殊意义去除！<br/>范例：搜寻含有单引号' 的那一行！<br/>grep -n 'regular_express.txt</td></tr><tr class="odd"><td>*</td><td>意义：重复零个到无穷多个的前一个RE 字符 <br/>范例：找出含有(es)(ess) (esss) 等等的字串，注意，因为* 可以是0 个，所以es也是符合带搜寻字串。另外，因为* 为重复『前一个RE 字符』的符号，因此，在* 之前必须要紧接着一个RE 字符喔！例如任意字元则为『.*』！<br/>grep -n 'ess*' regular_express.txt</td></tr><tr class="even"><td>[list]</td><td>意义：字元集合的RE 字符，里面列出想要撷取的字元！<br/>范例：搜寻含有(gl) 或(gd) 的那一行，需要特别留意的是，在[]当中『谨代表一个待搜寻的字元』， 例如『 a[afl]y』代表搜寻的字串可以是aay, afy, aly 即[afl] 代表a 或f 或l的意思！<br/>grep -n 'g[ld]' regular_express.txt</td></tr><tr class="odd"><td>[n1-n2]</td><td>意义：字元集合的RE 字符，里面列出想要撷取的字元范围！<br/>范例：搜寻含有任意数字的那一行！需特别留意，在字元集合[] 中的减号-是有特殊意义的，他代表两个字元之间的所有连续字元！但这个连续与否与ASCII编码有关，因此，你的编码需要设定正确(在 bash 当中，需要确定LANG与LANGUAGE 的变数是否正确！) 例如所有大写字元则为[AZ]<br/>grep -n '[AZ]'regular_express.txt</td></tr><tr class="even"><td>[^list]</td><td>意义：字元集合的RE 字符，里面列出不要的字串或范围！<br/>范例：搜寻的字串可以是(oog) (ood) 但不能是(oot) ，那个^ 在[]内时，代表的意义是『反向选择』的意思。例如，我不要大写字元，则为[^AZ]。但是，需要特别注意的是，如果以grep-n [^AZ] regular_express.txt来搜寻，却发现该档案内的所有行都被列出，为什么？因为这个[^AZ]是『非大写字元』的意思， 因为每一行均有非大写字元，例如第一行的"OpenSource" 就有p,e,n,o.... 等等的小写字<br/>grep -n 'oo[^t]'regular_express.txt</td></tr><tr class="odd"><td>{n,m}</td><td>意义：连续n 到m 个的『前一个RE 字符』 <br/>意义：若为{n} 则是连续n个的前一个RE 字符， <br/>意义：若是{n,} 则是连续n 个以上的前一个RE字符！ <br/>范例：在g 与g 之间有2 个到3 个的o存在的字串，亦即(goog)(gooog)<br/>grep -n 'go\{2,3\}g'regular_express.txt</td></tr></tbody></table><h3 id="扩展正则表达式">11.2 扩展正则表达式</h3><table><thead><tr class="header"><th>RE 字符</th><th>意义与范例</th></tr></thead><tbody><tr class="odd"><td>+</td><td>意义：重复『一个或一个以上』的前一个RE 字符 <br/>范例：搜寻(god)(good) (goood)... 等等的字串。那个o+ 代表『一个以上的o』所以，底下的执行成果会将第1, 9, 13 行列出来。<br/>egrep -n 'go+d'regular_express.txt</td></tr><tr class="even"><td>?</td><td>意义：『零个或一个』的前一个RE 字符 <br/>范例：搜寻(gd) (god)这两个字串。那个o? 代表『空的或1 个o 』所以，上面的执行成果会将第13, 14行列出来。有没有发现到，这两个案例( 'go+d' 与'go?d' )的结果集合与'go*d'相同？想想看，这是为什么喔！<br/>egrep -n 'go?d'regular_express.txt</td></tr><tr class="odd"><td>|</td><td>意义：用或( or )的方式找出数个字串 <br/>范例：搜寻gd 或good这两个字串，注意，是『或』！所以，第1,9,14这三行都可以被列印出来喔！那如果还想要找出dog 呢？<br/>egrep -n'gd|good' regular_express.txt egrep -n 'gd|good|dog'regular_express.txt</td></tr><tr class="even"><td>()</td><td>意义：找出『群组』字串 范<br/>例：搜寻(glad) 或(good)这两个字串，因为g 与d 是重复的，所以， 我就可以将la 与oo 列于( )当中，并以| 来分隔开来，就可以啦！<br/>egrep -n 'g(la|oo)d'regular_express.txt</td></tr><tr class="odd"><td>()+</td><td>意义：多个重复群组的判别 <br/>范例：将『AxyzxyzxyzxyzC』用echo叫出，然后再使用如下的方法搜寻一下！<br/>echo 'AxyzxyzxyzxyzC' | egrep'A(xyz)+C'<br/>上面的例子意思是说，我要找开头是A 结尾是C，中间有一个以上的"xyz" 字串的意思</td></tr></tbody></table><h2 id="学习-shell-脚本">12. 学习 shell 脚本</h2><h3 id="什么是-shell-脚本">12.1 什么是 shell 脚本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">This program shows <span class="hljs-string">&quot;Hello World!&quot;</span> <span class="hljs-keyword">in</span> your screen.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/16 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br>echo -e &quot;Hello World! \a \n&quot;<br>exit 0<br></code></pre></td></tr></table></figure><p>良好的script 撰写习惯，在每个script 的档头处记录好：</p><ul><li>script 的功能；</li><li>script 的版本资讯；</li><li>script 的作者与联络方式；</li><li>script 的版权宣告方式；</li><li>script 的History (历史纪录)；</li><li>script 内较特殊的指令，使用『绝对路径』的方式来下达；</li><li>script 运作时需要的环境变量预先声明与设置。</li></ul><h3 id="简单的-shell-脚本练习">12.2 简单的 shell 脚本练习</h3><p>处理用户输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">User inputs his first name and last name. Program shows his full name.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/16 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>read -p &quot;Please input your first name: &quot; firstname       # 提示使用者输入<br>read -p &quot;Please input your last name: &quot; lastname        # 提示使用者输入<br>echo -e &quot;\nYour full name is: $&#123;firstname&#125; $&#123;lastname&#125;&quot; # 结果由屏幕输出<br></code></pre></td></tr></table></figure><p>随日期变化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program creates three files, <span class="hljs-built_in">which</span> named by user<span class="hljs-string">&#x27;s input and date command.</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">History:</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">2015/07/16 VBird First release</span></span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">1. 让使用者输入档案名称，并取得fileuser 这个变数；</span></span> <br>echo -e &quot;I will use &#x27;touch&#x27; command to create 3 files.&quot; # 纯粹显示资讯<br>read -p &quot;Please input your filename: &quot; fileuser          # 提示使用者输入<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">2. 为了避免使用者随意按Enter ，利用变数功能分析档名是否有设定？</span></span><br>filename=$&#123;fileuser:-&quot;filename&quot;&#125;            # 开始判断有否设定档名<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">3. 开始利用date 指令来取得所需要的档名了；</span></span> <br>date1=$(date --date=&#x27;2 days ago&#x27; +%Y%m%d)   # 前两天的日期<br>date2=$(date --date=&#x27;1 days ago&#x27; +%Y%m%d)   # 前一天的日期<br>date3=$(date +%Y%m%d)                       # 今天的日期<br>file1=$&#123;filename&#125;$&#123;date1&#125;                   # 底下三行在设定档名<br>file2=$&#123;filename&#125;$&#123;date2&#125;<br>file3=$&#123;filename&#125;$&#123;date3&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">4. 将档名建立吧！</span></span><br>touch &quot;$&#123;file1&#125;&quot;                            # 底下三行在建立档案<br>touch &quot;$&#123;file2&#125;&quot;<br>touch &quot;$&#123;file3&#125;&quot;<br></code></pre></td></tr></table></figure><p>数值运算：简单的加减乘除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">User inputs 2 <span class="hljs-built_in">integer</span> numbers; program will cross these two numbers.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/16 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br>echo -e &quot;You SHOULD input 2 numbers, I will multiplying them! \n&quot;<br>read -p &quot;first number: &quot; firstnu<br>read -p &quot;second number: &quot; secnu<br>total=$(($&#123;firstnu&#125;*$&#123;secnu&#125;))<br>echo -e &quot;\nThe result of $&#123;firstnu&#125; x $&#123;secnu&#125; is ==&gt; $&#123;total&#125;&quot;<br></code></pre></td></tr></table></figure><p>计算含小数点数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;123.123*55.9&quot;</span> | bc</span><br></code></pre></td></tr></table></figure><p>计算 Pi</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">User input a scale number to calculate pi number.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/16 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br>echo -e &quot;This program will calculate pi value. \n&quot;<br>echo -e &quot;You should input a float number to calculate pi value.\n&quot;<br>read -p &quot;The scale number (10~10000) ? &quot; checking<br>num=$&#123;checking:-&quot;10&quot;&#125;            # 开始判断有否有输入数值<br>echo -e &quot;Starting calculate pi value. Be patient.&quot;<br>time echo &quot;scale=$&#123;num&#125;; 4*a(1)&quot; | bc -lq<br></code></pre></td></tr></table></figure><h3 id="善用判断式">12.3 善用判断式</h3><table><thead><tr class="header"><th>测试的标志</th><th>代表意义</th></tr></thead><tbody><tr class="odd"><td>1. 关于某个文件名的『文件类型』判断，如test -e filename表示存在否</td><td></td></tr><tr class="even"><td>-e</td><td>该『文件名』是否存在？(常用)</td></tr><tr class="odd"><td>-f</td><td>该『文件名』是否存在且为文件(file)？(常用)</td></tr><tr class="even"><td>-d</td><td>该『文件名』是否存在且为目录(directory)？(常用)</td></tr><tr class="odd"><td>-b</td><td>该『文件名』是否存在且为一个block device 设备？</td></tr><tr class="even"><td>-c</td><td>该『文件名』是否存在且为一个character device 设备？</td></tr><tr class="odd"><td>-S</td><td>该『文件名』是否存在且为一个Socket 文件？</td></tr><tr class="even"><td>-p</td><td>该『文件名』是否存在且为一个FIFO (pipe) 文件？</td></tr><tr class="odd"><td>-L</td><td>该『文件名』是否存在且为一个链接文件？</td></tr><tr class="even"><td>2. 关于档案的权限检测，如test -r filename 表示可读否(但root权限常有例外)</td><td></td></tr><tr class="odd"><td>-r</td><td>检测该文件名是否存在且具有『可读』的权限？</td></tr><tr class="even"><td>-w</td><td>检测该文件名是否存在且具有『可写』的权限？</td></tr><tr class="odd"><td>-x</td><td>检测该文件名是否存在且具有『可执行』的权限？</td></tr><tr class="even"><td>-u</td><td>检测该文件名是否存在且具有『SUID』的属性？</td></tr><tr class="odd"><td>-g</td><td>检测该文件名是否存在且具有『SGID』的属性？</td></tr><tr class="even"><td>-k</td><td>检测该文件名是否存在且具有『Sticky bit』的属性？</td></tr><tr class="odd"><td>-s</td><td>检测该文件名是否存在且为『非空白文件』？</td></tr><tr class="even"><td>3. 两个档案之间的比较，如： test file1 -nt file2</td><td></td></tr><tr class="odd"><td>-nt</td><td>(newer than)判断file1 是否比file2 新</td></tr><tr class="even"><td>-ot</td><td>(older than)判断file1 是否比file2 旧</td></tr><tr class="odd"><td>-ef</td><td>判断file1 与file2 是否为同一档案，可用在判断hard link的判定上。主要意义在判定，两个档案是否均指向同一个inode</td></tr><tr class="even"><td>4. 关于两个整数之间的判定，例如test n1 -eq n2</td><td></td></tr><tr class="odd"><td>-eq</td><td>两数值相等(equal)</td></tr><tr class="even"><td>-ne</td><td>两数值不等(not equal)</td></tr><tr class="odd"><td>-gt</td><td>n1 大于n2 (greater than)</td></tr><tr class="even"><td>-lt</td><td>n1 小于n2 (less than)</td></tr><tr class="odd"><td>-ge</td><td>n1 大于等于n2 (greater than or equal)</td></tr><tr class="even"><td>-le</td><td>n1 小于等于n2 (less than or equal)</td></tr><tr class="odd"><td>5. 判定字符串的数据</td><td></td></tr><tr class="even"><td>test -z string</td><td>判定字串是否为0 ？若string 为空字串，则为true</td></tr><tr class="odd"><td>test -n string</td><td>判定字串是否非为0 ？若string 为空字串，则为false。 注： -n亦可省略</td></tr><tr class="even"><td>test str1 == str2</td><td>判定str1 是否等于str2 ，若相等，则回传true</td></tr><tr class="odd"><td>test str1 != str2</td><td>判定str1 是否不等于str2 ，若相等，则回传false</td></tr><tr class="even"><td>6. 多重条件判定，例如： test -r filename -a -x filename</td><td></td></tr><tr class="odd"><td>-a</td><td>(and)两状况同时成立！例如test -r file -a -x file，则file 同时具有r与 x 权限时，才回传true。</td></tr><tr class="even"><td>-o</td><td>(or)两状况任何一个成立！例如test -r file -o -x file，则file 具有r 或x 权限时，就可回传true。</td></tr><tr class="odd"><td>!</td><td>反相状态，如test ! -x file ，当file 不具有x 时，回传true</td></tr></tbody></table><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">User input a filename, program will check the flowing:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1.) exist? 2.) file/directory? 3.) file permissions</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/16 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 让使用者输入档名，并且判断使用者是否真的有输入字串？</span><br>echo -e &quot;Please input a filename, I will check the filename&#x27;s type and permission. \n\n&quot;<br>read -p &quot;Input a filename : &quot; filename<br>test -z $&#123;filename&#125; &amp;&amp; echo &quot;You MUST input a filename.&quot; &amp;&amp; exit 0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 判断档案是否存在？若不存在则显示讯息并结束脚本</span><br>test ! -e $&#123;filename&#125; &amp;&amp; echo &quot;The filename &#x27;$&#123;filename&#125;&#x27; DO NOT exist&quot; &amp;&amp; exit 0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">3. 开始判断档案类型与属性</span><br>test -f $&#123;filename&#125; &amp;&amp; filetype=&quot;regulare file&quot;<br>test -d $&#123;filename&#125; &amp;&amp; filetype=&quot;directory&quot;<br>test -r $&#123;filename&#125; &amp;&amp; perm=&quot;readable&quot;<br>test -w $&#123;filename&#125; &amp;&amp; perm=&quot;$&#123;perm&#125; writable&quot;<br>test -x $&#123;filename&#125; &amp;&amp; perm=&quot;$&#123;perm&#125; executable&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">4. 开始输出资讯！</span><br>echo &quot;The filename: $&#123;filename&#125; is a $&#123;filetype&#125;&quot;<br>echo &quot;And the permissions for you are : $&#123;perm&#125;&quot;<br></code></pre></td></tr></table></figure><p>使用中括号 <code>[]</code> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">This program shows the user<span class="hljs-string">&#x27;s choice</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">History:</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">2015/07/16 VBird First release</span></span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>read -p &quot;Please input (Y/N): &quot; yn<br>[ &quot;$&#123;yn&#125;&quot; == &quot;Y&quot; -o &quot;$&#123;yn&#125;&quot; == &quot;y&quot; ] &amp;&amp; echo &quot;OK, continue&quot; &amp;&amp; exit 0<br>[ &quot;$&#123;yn&#125;&quot; == &quot;N&quot; -o &quot;$&#123;yn&#125;&quot; == &quot;n&quot; ] &amp;&amp; echo &quot;Oh, interrupt!&quot; &amp;&amp; exit 0<br>echo &quot;I don&#x27;t know what your choice is&quot; &amp;&amp; exit 0<br></code></pre></td></tr></table></figure><p>shell 脚本的默认变量（<code>$0</code> <code>$1</code> ...）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program shows the script name, parameters...</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/16 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>echo &quot;The script name is ==&gt; $&#123;0&#125;&quot;<br>echo &quot;Total parameter number is ==&gt; $#&quot;<br>[ &quot;$#&quot; -lt 2 ] &amp;&amp; echo &quot;The number of parameter is less than 2. Stop here.&quot; &amp;&amp; exit 0<br>echo &quot;Your whole parameter is ==&gt; &#x27;$@&#x27;&quot;<br>echo &quot;The 1st parameter ==&gt; $&#123;1&#125;&quot;<br>echo &quot;The 2nd parameter ==&gt; $&#123;2&#125;&quot;<br></code></pre></td></tr></table></figure><h3 id="条件判断式">12.4 条件判断式</h3><h4 id="if...then">12.4.1 if...then</h4><p>单层、简单条件判断式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">if [条件判断式]; then<br>当条件判断式成立时，可以进行的指令工作内容；<br>fi<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">This program shows the user<span class="hljs-string">&#x27;s choice</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">History:</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">2015/07/16 VBird First release</span></span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>read -p &quot;Please input (Y/N): &quot; yn<br><br>if [ &quot;$&#123;yn&#125;&quot; == &quot;Y&quot; ] || [ &quot;$&#123;yn&#125;&quot; == &quot;y&quot; ]; then<br>echo &quot;OK, continue&quot;<br>exit 0<br>fi<br>if [ &quot;$&#123;yn&#125;&quot; == &quot;N&quot; ] || [ &quot;$&#123;yn&#125;&quot; == &quot;n&quot; ]; then<br>echo &quot;Oh, interrupt!&quot;<br>exit 0<br>fi<br>echo &quot;I don&#x27;t know what your choice is&quot; &amp;&amp; exit 0<br></code></pre></td></tr></table></figure><p>多重、复杂条件判断式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">一个条件判断，分成功进行与失败进行(<span class="hljs-keyword">else</span>)</span> <br>if [条件判断式]; then<br>当条件判断式成立时，可以进行的指令工作内容；<br>else<br>当条件判断式不成立时，可以进行的指令工作内容；<br>fi<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">多个条件判断(<span class="hljs-keyword">if</span> ... <span class="hljs-keyword">elif</span> ... <span class="hljs-keyword">elif</span> ... <span class="hljs-keyword">else</span>) 分多种不同情况执行</span><br>if [条件判断式一]; then<br>当条件判断式一成立时，可以进行的指令工作内容；<br>elif [条件判断式二]; then<br>当条件判断式二成立时，可以进行的指令工作内容；<br>else<br>当条件判断式一与二均不成立时，可以进行的指令工作内容；<br>fi<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">This program shows the user<span class="hljs-string">&#x27;s choice</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">History:</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">2015/07/16 VBird First release</span></span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>read -p &quot;Please input (Y/N): &quot; yn<br><br>if [ &quot;$&#123;yn&#125;&quot; == &quot;Y&quot; ] || [ &quot;$&#123;yn&#125;&quot; == &quot;y&quot; ]; then<br>echo &quot;OK, continue&quot;<br>elif [ &quot;$&#123;yn&#125;&quot; == &quot;N&quot; ] || [ &quot;$&#123;yn&#125;&quot; == &quot;n&quot; ]; then<br>echo &quot;Oh, interrupt!&quot;<br>else<br>echo &quot;I don&#x27;t know what your choice is&quot;<br>fi<br></code></pre></td></tr></table></figure><p>从命令行获取用户输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Check <span class="hljs-variable">$1</span> is equal to <span class="hljs-string">&quot;hello&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/16 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>if [ &quot;$&#123;1&#125;&quot; == &quot;hello&quot; ]; then<br>echo &quot;Hello, how are you ?&quot;<br>elif [ &quot;$&#123;1&#125;&quot; == &quot;&quot; ]; then<br>echo &quot;You MUST input parameters, ex&gt; &#123;$&#123;0&#125; someword&#125;&quot;<br>else<br>echo &quot;The only parameter is &#x27;hello&#x27;, ex&gt; &#123;$&#123;0&#125; hello&#125;&quot;<br>fi<br></code></pre></td></tr></table></figure><p>检测服务端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Using netstat and grep to detect WWW,SSH,FTP and Mail services.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/16 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 先作一些告知的动作而已～</span><br>echo &quot;Now, I will detect your Linux server&#x27;s services!&quot;<br>echo -e &quot;The www, ftp, ssh, and mail(smtp) will be detected! \n&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 开始进行一些测试的工作，并且也输出一些资讯啰！</span><br>testfile=/dev/shm/netstat_checking.txt<br>netstat -tuln &gt; $&#123;testfile&#125;           # 先转存资料到记忆体当中！不用一直执行netstat <br>testing=$(grep &quot;:80 &quot; $&#123;testfile&#125;)    # 侦测看port 80 在否？<br>if [ &quot;$&#123;testing&#125;&quot; != &quot;&quot; ]; then<br>echo &quot;WWW is running in your system.&quot;<br>fi<br>testing=$(grep &quot;:22 &quot; $&#123;testfile&#125;)    # 侦测看port 22 在否？<br>if [ &quot;$&#123;testing&#125;&quot; != &quot;&quot; ]; then<br>echo &quot;SSH is running in your system.&quot;<br>fi<br>testing=$(grep &quot;:21 &quot; $&#123;testfile&#125;)    # 侦测看port 21 在否？<br>if [ &quot;$&#123;testing&#125;&quot; != &quot;&quot; ]; then<br>echo &quot;FTP is running in your system.&quot;<br>fi<br>testing=$(grep &quot;:25 &quot; $&#123;testfile&#125;)    # 侦测看port 25 在否？<br>if [ &quot;$&#123;testing&#125;&quot; != &quot;&quot; ]; then<br>echo &quot;Mail is running in your system.&quot;<br>fi<br></code></pre></td></tr></table></figure><p>计算距离指定日期剩余天数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">You input your demobilization <span class="hljs-built_in">date</span>, I calculate how many days before you demobilize.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/16 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 告知使用者这支程式的用途，并且告知应该如何输入日期格式？</span><br>echo &quot;This program will try to calculate :&quot;<br>echo &quot;How many days before your demobilization date...&quot;<br>read -p &quot;Please input your demobilization date (YYYYMMDD ex&gt;20150716): &quot; date2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 测试一下，这个输入的内容是否正确？利用正规表示法啰～</span> <br>date_d=$(echo $&#123;date2&#125; |grep &#x27;[0-9]\&#123;8\&#125;&#x27;)    # 看看是否有八个数字<br>if [ &quot;$&#123;date_d&#125;&quot; == &quot;&quot; ]; then<br>echo &quot;You input the wrong date format....&quot;<br>exit 1<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3. 开始计算日期啰～</span> <br>declare -i date_dem=$(date --date=&quot;$&#123;date2&#125;&quot; +%s)       # 退伍日期秒数<br>declare -i date_now=$(date +%s)                         # 现在日期秒数<br>declare -i date_total_s=$(($&#123;date_dem&#125;-$&#123;date_now&#125;))    # 剩余秒数统计<br>declare -i date_d=$(($&#123;date_total_s&#125;/60/60/24))         # 转为日数<br>if [ &quot;$&#123;date_total_s&#125;&quot; -lt &quot;0&quot; ]; then                  # 判断是否已退伍<br>echo &quot;You had been demobilization before: &quot; $((-1*$&#123;date_d&#125;)) &quot; ago&quot;<br>else<br>declare -i date_h=$(($(($&#123;date_total_s&#125;-$&#123;date_d&#125;*60*60*24))/60/60))<br>echo &quot;You will demobilize after $&#123;date_d&#125; days and $&#123;date_h&#125; hours.&quot;<br>fi<br></code></pre></td></tr></table></figure><h4 id="case...esac">12.4.2 case...esac</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">case $变数名称 in    &lt;==关键字为case ，还有变数前有钱字号<br>  &quot;第一个变数内容&quot; )    &lt;==每个变数内容建议用双引号括起来，关键字则为小括号)<br>程式段<br>;;             &lt;==每个类别结尾使用两个连续的分号来处理！<br>  &quot;第二个变数内容&quot; )<br>程式段<br>;; <br>  * )                   &lt;==最后一个变数内容都会用* 来代表所有其他值<br>不包含第一个变数内容与第二个变数内容的其他程式执行段<br>exit 1<br>;; <br>esac<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Show <span class="hljs-string">&quot;Hello&quot;</span> from <span class="hljs-variable">$1</span>.... by using <span class="hljs-keyword">case</span> .... <span class="hljs-keyword">esac</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/16 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>case $&#123;1&#125; in<br>  &quot;hello&quot;)<br>echo &quot;Hello, how are you ?&quot;<br>;;<br>  &quot;&quot;)<br>echo &quot;You MUST input parameters, ex&gt; &#123;$&#123;0&#125; someword&#125;&quot;<br>;;<br>  *)    # 其实就相当于万用字元，0~无穷多个任意字元之意！<br>echo &quot;Usage $&#123;0&#125; &#123;hello&#125;&quot;<br>;;<br>esac<br></code></pre></td></tr></table></figure><h4 id="function">12.4.3 function</h4><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">function fname () &#123;<br>程序段<br>&#125;<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Use <span class="hljs-keyword">function</span> to repeat information.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/17 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>function printit()&#123;<br>echo -n &quot;Your choice is &quot;      # 加上-n 可以不断行继续在同一行显示<br>&#125;<br><br>echo &quot;This program will print your selection !&quot;<br>case $&#123;1&#125; in<br>  &quot;one&quot;)<br>printit ; echo $&#123;1&#125; | tr &#x27;az&#x27; &#x27;AZ&#x27;   # 将参数做大小写转换！<br>;;<br>  &quot;two&quot;)<br>printit ; echo $&#123;1&#125; | tr &#x27;az&#x27; &#x27;AZ&#x27;<br>;;<br>  &quot;three&quot;)<br>printit ; echo $&#123;1&#125; | tr &#x27;az&#x27; &#x27;AZ&#x27;<br>;;<br>  *)<br>echo &quot;Usage $&#123;0&#125; &#123;one|two|three&#125;&quot;<br>;;<br>esac<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Use <span class="hljs-keyword">function</span> to repeat information.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/17 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>function printit()&#123;<br>echo &quot;Your choice is $&#123;1&#125;&quot;    # 这个$1 必须要参考底下指令的下达<br>&#125;<br><br>echo &quot;This program will print your selection !&quot;<br>case $&#123;1&#125; in<br>  &quot;one&quot;)<br>printit 1   # 请注意， printit 指令后面还有接参数！<br>;;<br>  &quot;two&quot;)<br>printit 2<br>;;<br>  &quot;three&quot;)<br>printit 3<br>;;<br>  *)<br>echo &quot;Usage $&#123;0&#125; &#123;one|two|three&#125;&quot;<br>;;<br>esac<br></code></pre></td></tr></table></figure><h3 id="循环">12.5 循环</h3><h4 id="while-do-doneuntil-do-done不定循环">12.5.1 while do done、untildo done（不定循环）</h4><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">while [ condition ]   &lt;==中括号内的状态就是判断式<br>do             &lt;==do 是循环的开始！<br>程式段落<br>done<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">until [ condition ]<br>do<br>程式段落<br>done<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Repeat question until user input correct answer.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/17 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>while [ &quot;$&#123;yn&#125;&quot; != &quot;yes&quot; -a &quot;$&#123;yn&#125;&quot; != &quot;YES&quot; ]<br>do<br>read -p &quot;Please input yes/YES to stop this program: &quot; yn<br>done<br>echo &quot;OK! you input the correct answer.&quot;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Repeat question until user input correct answer.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/17 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>until [ &quot;$&#123;yn&#125;&quot; == &quot;yes&quot; -o &quot;$&#123;yn&#125;&quot; == &quot;YES&quot; ]<br>do<br>read -p &quot;Please input yes/YES to stop this program: &quot; yn<br>done<br>echo &quot;OK! you input the correct answer.&quot;<br></code></pre></td></tr></table></figure><p>示例：(计算1+2+3+....+100)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Use loop to calculate <span class="hljs-string">&quot;1+2+3+...+100&quot;</span> result.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/17 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>s=0   # 这是加总的数值变数<br>i=0   # 这是累计的数值，亦即是1, 2, 3....<br>while [ &quot;$&#123;i&#125;&quot; != &quot;100&quot; ]<br>do<br>i=$(($i+1))    # 每次i 都会增加1 <br>s=$(($s+$i))   # 每次都会求和一次<br>done<br>echo &quot;The result of &#x27;1+2+3+...+100&#x27; is ==&gt; $s&quot;<br></code></pre></td></tr></table></figure><h4 id="for...do...done固定循环">12.5.2 for...do...done（固定循环）</h4><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for var in con1 con2 con3 ...<br>do<br>程式段<br>done<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Using <span class="hljs-keyword">for</span> .... loop to <span class="hljs-built_in">print</span> 3 animals</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/17 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>for animal in dog cat elephant<br>do<br>echo &quot;There are $&#123;animal&#125;s.... &quot;<br>done<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Use ping <span class="hljs-built_in">command</span> to check the network<span class="hljs-string">&#x27;s PC state.</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">History</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">2015/07/17 VBird first release</span></span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br>network=&quot;192.168.1&quot;               # 先定义一个网域的前面部分！<br>for sitenu in $(seq 1 100)        # seq 为sequence(连续) 的缩写之意<br>do<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">底下的程式在取得ping 的回传值是正确的还是失败的！</span></span><br>        ping -c 1 -w 1 $&#123;network&#125;.$&#123;sitenu&#125; &amp;&gt; /dev/null &amp;&amp; result=0 || result=1<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">开始显示结果是正确的启动(UP) 还是错误的没有连通(DOWN)</span></span><br>        if [ &quot;$&#123;result&#125;&quot; == 0 ]; then<br>                echo &quot;Server $&#123;network&#125;.$&#123;sitenu&#125; is UP.&quot;<br>        else<br>                echo &quot;Server $&#123;network&#125;.$&#123;sitenu&#125; is DOWN.&quot;<br>        fi<br>done<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">User input <span class="hljs-built_in">dir</span> name, I find the permission of files.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/17 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 先看看这个目录是否存在啊？</span><br>read -p &quot;Please input a directory: &quot; dir<br>if [ &quot;$&#123;dir&#125;&quot; == &quot;&quot; -o ! -d &quot;$&#123;dir&#125;&quot; ]; then<br>echo &quot;The $&#123;dir&#125; is NOT exist in your system.&quot;<br>exit 1<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 开始测试档案啰～</span> <br>filelist=$(ls $&#123;dir&#125;)         # 列出所有在该目录下的档案名称<br>for filename in $&#123;filelist&#125;<br>do<br>perm=&quot;&quot;<br>test -r &quot;$&#123;dir&#125;/$&#123;filename&#125;&quot; &amp;&amp; perm=&quot;$&#123;perm&#125; readable&quot;<br>test -w &quot;$&#123;dir&#125;/$&#123;filename&#125;&quot; &amp;&amp; perm=&quot;$&#123;perm&#125; writable&quot;<br>test -x &quot;$&#123;dir&#125;/$&#123;filename&#125;&quot; &amp;&amp; perm=&quot;$&#123;perm&#125; executable&quot;<br>echo &quot;The file $&#123;dir&#125;/$&#123;filename&#125;&#x27;s permission is $&#123;perm&#125; &quot;<br>done<br></code></pre></td></tr></table></figure><h4 id="for...do...done-的数值处理">12.5.3 for...do...done的数值处理</h4><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for ((初始值;限制值;赋值运算))<br>do<br>程式段<br>done<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Try <span class="hljs-keyword">do</span> calculate 1+2+....+<span class="hljs-variable">$&#123;your_input&#125;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/17 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>read -p &quot;Please input a number, I will count for 1+2+...+your_input: &quot; nu<br><br>s=0<br>for (( i=1; i&lt;=$&#123;nu&#125;; i=i+1 ))<br>do<br>s=$(($&#123;s&#125;+$&#123;i&#125;))<br>done<br>echo &quot;The result of &#x27;1+2+3+...+$&#123;nu&#125;&#x27; is ==&gt; $&#123;s&#125;&quot;<br></code></pre></td></tr></table></figure><h4 id="搭配随机数和数组的实验">12.5.4 搭配随机数和数组的实验</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Try <span class="hljs-keyword">do</span> tell you what you may eat.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">History:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2015/07/17 VBird First release</span><br>PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<br>export PATH<br><br>eat[1]=&quot;卖当当汉堡&quot;        # 写下你所收集到的店家！<br>eat[2]=&quot;肯爷爷炸鸡&quot;<br>eat[3]=&quot;彩虹日式便当&quot;<br>eat[4]=&quot;越油越好吃大雅&quot;<br>eat[5]=&quot;想不出吃啥学餐&quot;<br>eat[6]=&quot;太师父便当&quot;<br>eat[7]=&quot;池上便当&quot;<br>eat[8]=&quot;怀念火车便当&quot;<br>eat[9]=&quot;一起吃泡面&quot;<br>eatnum=9                   # 需要输入有几个可用的餐厅数！<br><br>check=$(( $&#123;RANDOM&#125; * $&#123;eatnum&#125; / 32767 + 1 ))<br>echo &quot;your may eat $&#123;eat[$&#123;check&#125;]&#125;&quot;<br></code></pre></td></tr></table></figure><h3 id="shell-脚本的跟踪与调试">12.6 shell 脚本的跟踪与调试</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sh [-nvx] scripts.sh</span><br>选项与参数：<br>-n ：不要执行script，仅查询语法的问题；<br>-v ：再执行script 前，先将scripts 的内容输出到萤幕上；<br>-x ：将使用到的script 内容显示到萤幕上，这是很有用的参数！<br><br>范例一：测试dir_perm.sh 有无语法的问题？<br>[dmtsai@study ~]$ sh -n dir_perm.sh <br><span class="hljs-meta prompt_"># </span><span class="language-bash">若语法没有问题，则不会显示任何资讯！</span><br><br>范例二：将show_animal.sh 的执行过程全部列出来～ <br>[dmtsai@study ~]$ sh -x show_animal.sh <br>+ PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:/root/bin<br>+ export PATH<br>+ for animal in dog cat elephant<br>+ echo &#x27;There are dogs.... &#x27;<br>There are dogs....<br>+ for animal in dog cat elephant<br>+ echo &#x27;There are cats.... &#x27;<br>There are cats....<br>+ for animal in dog cat elephant<br>+ echo &#x27;There are elephants.... &#x27;<br>There are elephants....<br></code></pre></td></tr></table></figure><h2 id="linux-账号管理与-acl-权限设置">13. Linux 账号管理与 ACL权限设置</h2><h3 id="账号管理">13.2 账号管理</h3><p>用户管理：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">useradd [-u UID] [-g 初始群组] [-G 次要群组] [-mM]\ </span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">[-c 说明栏] [-d 家目录绝对路径] [-s shell] 使用者帐号名</span><br>选项与参数：<br>-u ：后面接的是UID ，是一组数字。直接指定一个特定的UID 给这个帐号；<br>-g ：后面接的那个群组名称就是我们上面提到的initial group 啦～<br>      该群组的GID 会被放置到/etc/passwd 的第四个栏位内。<br>-G ：后面接的群组名称则是这个帐号还可以加入的群组。<br>      这个选项与参数会修改/etc/group 内的相关资料喔！<br>-M ：强制！不要建立使用者家目录！(系统帐号预设值)<br>-m ：强制！要建立使用者家目录！(一般帐号预设值)<br>-c ：这个就是/etc/passwd 的第五栏的说明内容啦～可以随便我们设定的啦～<br>-d ：指定某个目录成为家目录，而不要使用预设值。务必使用绝对路径！<br>-r ：建立一个系统的帐号，这个帐号的UID 会有限制(参考/etc/login.defs)<br>-s ：后面接一个shell ，若没有指定则预设是/bin/bash 的啦～<br>-e ：后面接一个日期，格式为『YYYY-MM-DD』此项目可写入shadow 第八栏位，<br>      亦即帐号失效日的设定项目啰；<br>-f ：后面接shadow 的第七栏位项目，指定密码是否会失效。0为立刻失效，<br>      -1 为永远不失效(密码只会过期而强制于登入时重新设定而已。)<br><br>范例一：完全参考预设值建立一个使用者，名称为vbird1 <br>[root@study ~]# useradd vbird1 <br>[root@study ~]# ll -d /home/vbird1<br>drwx------. 3 vbird1 vbird1 74 Jul 20 21:50 /home/vbird1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">预设会建立使用者家目录，且权限为700 ！这是重点！</span><br><br>[root@study ~]# grep vbird1 /etc/passwd /etc/shadow /etc/group<br>/etc/passwd:vbird1:x:1003:1004::/home/vbird1:/bin/bash<br>/etc/shadow:vbird1:!!:16636:0:99999:7:::<br>/etc/group:vbird1:x:1004:      &lt;==预设会建立一个与帐号一模一样的群组名<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">passwd [--stdin] [帐号名称]   &lt;==所有人均可使用来改自己的密码</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">passwd [-l] [-u] [--stdin] [-S] \ </span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">  [-n 日数] [-x 日数] [-w 日数] [-i 日数] 帐号 &lt;==root 功能</span><br>选项与参数：<br>--stdin ：可以透过来自前一个管线的资料，作为密码输入，对shell script 有帮助！<br>-l ：是Lock 的意思，会将/etc/shadow 第二栏最前面加上! 使密码失效；<br>-u ：与-l 相对，是Unlock 的意思！<br>-S ：列出密码相关参数，亦即shadow 档案内的大部分资讯。<br>-n ：后面接天数，shadow 的第4 栏位，多久不可修改密码天数<br>-x ：后面接天数，shadow 的第5 栏位，多久内必须要更动密码<br>-w ：后面接天数，shadow 的第6 栏位，密码过期前的警告天数<br>-i ：后面接天数，shadow 的第7 栏位，密码失效天数<br><br>范例一：请root 给予vbird2 密码<br><span class="hljs-meta prompt_"># </span><span class="language-bash">passwd vbird2</span><br>Changing password for user vbird2.<br>New UNIX password: &lt;==这里直接输入新的密码，萤幕不会有任何反应<br>BAD PASSWORD: The password is shorter than 8 characters &lt;==密码太简单或过短的错误！<br>Retype new UNIX password:   &lt;==再输入一次同样的密码<br>passwd: all authentication tokens updated successfully .   &lt;==竟然还是成功修改了！<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">usermod [-cdegGlsuLU] username</span><br>选项与参数：<br>-c ：后面接帐号的说明，即/etc/passwd 第五栏的说明栏，可以加入一些帐号的说明。<br>-d ：后面接帐号的家目录，即修改/etc/passwd 的第六栏；<br>-e ：后面接日期，格式是YYYY-MM-DD 也就是在/etc/shadow 内的第八个栏位资料啦！<br>-f ：后面接天数，为shadow 的第七栏位。<br>-g ：后面接初始群组，修改/etc/passwd 的第四个栏位，亦即是GID 的栏位！<br>-G ：后面接次要群组，修改这个使用者能够支援的群组，修改的是/etc/group 啰～<br>-a ：与-G 合用，可『增加次要群组的支援』而非『设定』喔！<br>-l ：后面接帐号名称。亦即是修改帐号名称， /etc/passwd 的第一栏！<br>-s ：后面接Shell 的实际档案，例如/bin/bash 或/bin/csh 等等。<br>-u ：后面接UID 数字啦！即/etc/passwd 第三栏的资料；<br>-L ：暂时将使用者的密码冻结，让他无法登入。其实仅改/etc/shadow 的密码栏。<br>-U ：将/etc/shadow 密码栏的! 拿掉，解冻啦！<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">userdel [-r] username</span><br>选项与参数：<br>-r ：连同使用者的家目录也一起删除<br><br>范例一：删除vbird2 ，连同家目录一起删除<br><span class="hljs-meta prompt_"># </span><span class="language-bash">userdel -r vbird2</span><br></code></pre></td></tr></table></figure><p>用户组管理：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">groupadd [-g gid] [-r] 群组名称</span><br>选项与参数：<br>-g ：后面接某个特定的GID ，用来直接给予某个GID ～<br>-r ：建立系统群组啦！与/etc/login.defs 内的GID_MIN 有关。<br><br>范例一：新建一个群组，名称为group1 <br><span class="hljs-meta prompt_"># </span><span class="language-bash">groupadd group1</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">grep group1 /etc/group /etc/gshadow</span> <br>/etc/group:group1:x: 1503 :<br>/etc/gshadow:group1:!::<br><span class="hljs-meta prompt_"># </span><span class="language-bash">群组的GID 也是会由1000 以上最大GID+1 来决定！</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">groupmod [-g gid] [-n group_name] 群组名</span><br>选项与参数：<br>-g ：修改既有的GID 数字；<br>-n ：修改既有的群组名称<br><br>范例一：将刚刚上个指令建立的group1 名称改为mygroup ， GID 为201 <br><span class="hljs-meta prompt_"># </span><span class="language-bash">groupmod -g 201 -n mygroup group1</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">grep mygroup /etc/group /etc/gshadow</span> <br>/etc/group:mygroup:x: 201 :<br>/etc/gshadow:mygroup:!::<br></code></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># groupdel [groupname]</span><br><br>范例一：将刚刚的mygroup 删除！<br><span class="hljs-comment"># groupdel mygroup</span><br><br>范例二：若要删除vbird1 这个群组的话？<br><span class="hljs-comment"># groupdel vbird1</span><br>groupdel: cannot remove the primary <span class="hljs-keyword">group</span> <span class="hljs-title">of</span> <span class="hljs-keyword">user</span> <span class="hljs-title">&#x27;vbird1</span>&#x27;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">关于系统管理员(root)做的动作：</span> <br>[root@study ~]# gpasswd groupname <br>[root@study ~]# gpasswd [-A user1,...] [-M user3,...] groupname <br>[root@study ~]# gpasswd [-rR] groupname<br>选项与参数：<br>    ：若没有任何参数时，表示给予groupname 一个密码(/etc/gshadow)<br>-A ：将groupname 的主控权交由后面的使用者管理(该群组的管理员)<br>-M ：将某些帐号加入这个群组当中！<br>-r ：将groupname 的密码移除<br>-R ：让groupname 的密码栏失效<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">关于群组管理员(Group administrator)做的动作：</span> <br>[someone@study ~]$ gpasswd [-ad] user groupname<br>选项与参数：<br>-a ：将某位使用者加入到groupname 这个群组当中！<br>-d ：将某位使用者移除出groupname 这个群组当中。<br><br>范例一：建立一个新群组，名称为testgroup 且群组交由vbird1 管理： <br>[root@study ~]# groupadd testgroup   &lt;==先建立群组<br>[root@study ~]# gpasswd testgroup   &lt;==给这个群组一个密码吧！<br>Changing the password for group testgroup<br>New Password:<br>Re-enter new password:<br><span class="hljs-meta prompt_"># </span><span class="language-bash">输入两次密码就对了！</span><br>[root@study ~]# gpasswd -A vbird1 testgroup   &lt;==加入群组管理员为vbird1 <br>[root@study ~]# grep testgroup /etc/group /etc/gshadow<br>/etc/group:testgroup:x:1503:<br>/etc/gshadow:testgroup: $6$MnmChP3D$mrUn.Vo.buDjObMm8F2emTkvGSeuWikhRzaKHxpJ...:vbird1: <br><span class="hljs-meta prompt_"># </span><span class="language-bash">很有趣吧！此时vbird1 则拥有testgroup 的主控权喔！身份有点像板主啦！</span><br><br>范例二：以vbird1 登入系统，并且让他加入vbird1, vbird3 成为testgroup 成员<br>[vbird1@study ~]$ id<br>uid=1003(vbird1) gid=1004(vbird1) groups=1004(vbird1) ...<br><span class="hljs-meta prompt_"># </span><span class="language-bash">看得出来，vbird1 尚未加入testgroup 群组喔！</span><br><br>[vbird1@study ~]$ gpasswd -a vbird1 testgroup <br>[vbird1@study ~]$ gpasswd -a vbird3 testgroup <br>[vbird1@study ~]$ grep testgroup /etc/group <br>testgroup:x:1503: vbird1,vbird3<br></code></pre></td></tr></table></figure><h3 id="用户身份切换">13.4 用户身份切换</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">su [-lm] [-c 指令] [username]</span><br>选项与参数：<br>- ：单纯使用- 如『 su - 』代表使用login-shell 的变数档案读取方式来登入系统；<br>      若使用者名称没有加上去，则代表切换为root 的身份。<br>-l ：与- 类似，但后面需要加欲切换的使用者帐号！也是login-shell 的方式。<br>-m ：-m 与-p 是一样的，表示『使用目前的环境设定，而不读取新使用者的设定档』<br>-c ：仅进行一次指令，所以-c 后面可以加上指令<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell">范例一：假设你原本是dmtsai 的身份，想要使用non-login shell 的方式变成root <br>[ dmtsai @study ~]$ su        &lt;==注意提示字元，是dmtsai 的身份喔！<br>Password:                   &lt;==这里输入root 的密码喔！<br>[root@study dmtsai ]# id     &lt;==提示字元的目录是dmtsai 喔！<br>uid=0(root) gid=0(root) groups=0(root) context=unconf....   &lt;==确实是root 的身份！<br>[root@study dmtsai]# env | grep &#x27;dmtsai&#x27; <br>USER=dmtsai                                          &lt;==竟然还是dmtsai 这家伙！<br>PATH=...:/home/dmtsai/.local/bin:/home/dmtsai/bin    &lt;==这个影响最大！ <br>MAIL=/var/spool/mail/dmtsai                          &lt;==收到的mailbox 是vbird1<br>PWD=/home/dmtsai                                     &lt;==并非root 的家目录<br>LOGNAME=dmtsai<br><span class="hljs-meta prompt_"># </span><span class="language-bash">虽然你的UID 已经是具有root 的身份，但是看到上面的输出讯息吗？</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">还是有一堆变数为原本dmtsai 的身份，所以很多资料还是无法直接利用。</span><br>[root@study dmtsai]# exit    &lt;==这样可以离开su 的环境<br><br><br>范例二：使用login shell 的方式切换为root 的身份并观察变数<br>[dmtsai@study ~]$ su - <br>Password:    &lt;==这里输入root 的密码喔！<br>[root@study ~]# env | grep root<br>USER=root<br>MAIL=/var/spool/mail/root<br>PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin<br>PWD=/root<br>HOME=/root<br>LOGNAME=root<br><span class="hljs-meta prompt_"># </span><span class="language-bash">了解差异了吧？下次变换成为root 时，记得最好使用su - 喔！</span><br>[root@study ~]# exit    &lt;==这样可以离开su 的环境<br></code></pre></td></tr></table></figure><p>sudo：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# sudo [-b] [-u 新使用者帐号]<br>选项与参数：<br>-b ：将后续的指令放到背景中让系统自行执行，而不与目前的shell 产生影响<br>-u ：后面可以接欲切换的使用者，若无此项则代表切换身份为root 。<br><br>范例一：你想要以sshd 的身份在/tmp 底下建立一个名为mysshd 的档案<br>[root@study ~]# sudo -u sshd touch /tmp/mysshd <br>[root@study ~]# ll /tmp/mysshd <br>-rw-r--r--. 1 sshd sshd 0 Jul 21 23:37 /tmp/mysshd<br><span class="hljs-meta prompt_"> # </span><span class="language-bash">特别留意，这个档案的权限是由sshd 所建立的情况喔！</span><br><br>范例二：你想要以vbird1 的身份建立~vbird1/www 并于其中建立index.html 档案<br>[root@study ~]# sudo -u vbird1 sh -c &quot;mkdir ~vbird1/www; cd ~vbird1/www; \ <br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">  <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;This is index.html file&#x27;</span> &gt; index.html<span class="hljs-string">&quot;</span></span> <br>[root@study ~]# ll -a ~vbird1/www<br>drwxr-xr-x. 2 vbird1 vbird1 23 Jul 21 23:38 .<br>drwx------. 6 vbird1 vbird1 4096 Jul 21 23:38 ..<br>-rw-r--r--. 1 vbird1 vbird1 24 Jul 21 23:38 index.html<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">要注意，建立者的身份是vbird1 ，且我们使用sh -c &quot;</span>一串指令<span class="hljs-string">&quot; 来执行的！</span></span><br></code></pre></td></tr></table></figure><h2 id="磁盘配额quota与高级文件系统管理">14.磁盘配额（Quota）与高级文件系统管理</h2><p>略</p><h2 id="计划任务crontab">15. 计划任务（crontab）</h2><h3 id="什么是计划任务">15.1 什么是计划任务</h3><ul><li><strong>at</strong>：at是个可以处理仅执行一次就结束排程的指令，不过要执行at 时， 必须要有atd这个服务的支援才行。在某些新版的distributions 中，atd可能预设并没有启动，那么at 这个指令就会失效</li><li><strong>crontab</strong>：crontab这个指令所设定的工作将会循环的一直进行下去！可循环的时间为分钟、小时、每周、每月或每年等。crontab除了可以使用指令执行外，亦可编辑/etc/crontab 来支援。至于让crontab可以生效的服务则是crond 这个服务</li></ul><h3 id="仅执行一次的计划任务">15.2 仅执行一次的计划任务</h3><p>需先启动 atd 服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# systemctl restart atd   # 重新启动atd 这个服务<br>[root@study ~]# systemctl enable atd   # 让这个服务开机就自动启动<br>[root@study ~]# systemctl status atd   # 查阅一下atd 目前的状态<br>atd.service - Job spooling tools<br>   Loaded: loaded (/usr/lib/systemd/system/atd.service; enabled )        # 是否开机启动<br>   Active: active (running) since Thu 2015-07-30 19:21:21 CST; 23s ago # 是否正在运作中<br> Main PID: 26503 (atd)<br>   CGroup: /system.slice/atd.service<br>           └─26503 /usr/sbin/atd -f<br><br>Jul 30 19:21:21 study.centos.vbird systemd[1]: Starting Job spooling tools...<br>Jul 30 19:21:21 study.centos.vbird systemd[1]: Started Job spooling tools.<br></code></pre></td></tr></table></figure><p>使用 at这个指令来产生所要运作的工作，并将这个工作以文本文件的方式写入/var/spool/at/ 目录内，该工作便能等待atd 这个服务的取用与执行了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# at [-mldv] TIME <br>[root@study ~]# at -c 任务号码<br>选项与参数：<br>-m ：当at 的工作完成后，即使没有输出讯息，亦以email 通知使用者该工作已完成。<br>-l ：at -l 相当于atq，列出目前系统上面的所有该使用者的at 计划；<br>-d ：at -d 相当于atrm ，可以取消一个在at 计划中的工作；<br>-v ：可以使用较明显的时间格式列出at 计划中的工作列表；<br>-c ：可以列出后面接的该项工作的实际指令内容。<br><br>TIME：时间格式，这里可以定义出『什么时候要进行at 这项计划』的时间，格式有：<br>  HH:MM ex&gt; 04:00<br>在今日的HH:MM 时刻进行，若该时刻已超过，则明天的HH:MM 进行此工作。<br>  HH:MM YYYY-MM-DD ex&gt; 04:00 2015-07-30<br>强制规定在某年某月的某一天的特殊时刻进行该工作！<br>  HH:MM[am|pm] [Month] [Date] ex&gt; 04pm July 30<br>也是一样，强制在某年某月某日的某时刻进行！<br>  HH:MM[am|pm] + number [minutes|hours|days|weeks]<br><span class="hljs-meta prompt_">ex&gt; </span><span class="language-bash">now + 5 minutes ex&gt; 04pm + 3 days</span><br>就是说，在某个时间点『再加几个时间后』才进行。<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell">范例一：再过五分钟后，将/root/.bashrc 寄给root 自己<br>[root@study ~]# at now + 5 minutes   &lt;==记得单位要加s 喔！<br><span class="hljs-meta prompt_">at&gt; </span><span class="language-bash">/bin/mail -s <span class="hljs-string">&quot;testing at job&quot;</span> root &lt; /root/.bashrc</span> <br><span class="hljs-meta prompt_">at&gt; </span><span class="language-bash">&lt;EOT&gt;    &lt;==这里输入[ctrl] + d 就会出现&lt;EOF&gt; 的字样！代表结束！</span><br>job 2 at Thu Jul 30 19:35:00 2015<br><span class="hljs-meta prompt_"># </span><span class="language-bash">上面这行资讯在说明，第2 个at 工作将在2015/07/30 的19:35 进行！</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">而执行at 会进入所谓的at shell 环境，让你下达多重指令等待运作！</span><br><br>范例二：将上述的第2 项工作内容列出来查阅<br>[root@study ~]# at -c 2 <br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/sh                &lt;==就是透过bash shell 的啦！</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">atrun uid=0 gid=0</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">mail root 0</span><br>umask 22<br>....(中间省略许多的环境变数项目)....<br>cd /etc/cron\.d || &#123;<br>         echo &#x27;Execution directory inaccessible&#x27; &gt;&amp;2<br>         exit 1<br>&#125;<br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;SHELL:-/bin/sh&#125; &lt;&lt; <span class="hljs-string">&#x27;marcinDELIMITER410efc26&#x27;</span></span><br>/bin/mail -s &quot;testing at job&quot; root &lt; /root/.bashrc     # 这一行最重要！<br>marcinDELIMITER410efc26 <br><span class="hljs-meta prompt_"># </span><span class="language-bash">你可以看到指令执行的目录(/root)，还有多个环境变数与实际的指令内容啦！</span><br><br>范例三：由于机房预计于2015/08/05 停电，我想要在2015/08/04 23:00 关机？<br>[root@study ~]# at 23:00 2015-08-04 <br><span class="hljs-meta prompt_">at&gt; </span><span class="language-bash">/bin/sync</span> <br><span class="hljs-meta prompt_">at&gt; </span><span class="language-bash">/bin/sync</span> <br><span class="hljs-meta prompt_">at&gt; </span><span class="language-bash">/sbin/shutdown -h now</span><br><span class="hljs-meta prompt_">at&gt; </span><span class="language-bash">&lt;EOT&gt;</span><br>job 3 at Tue Aug 4 23:00:00 2015<br><span class="hljs-meta prompt_"># </span><span class="language-bash">您瞧瞧！at 还可以在一个工作内输入多个指令呢！不错吧！</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# atq <br>[root@study ~]# atrm (jobnumber)<br><br>范例一：查询目前主机上面有多少的at 工作排程？<br>[root@study ~]# atq<br>3 Tue Aug 4 23:00:00 2015 a root<br><span class="hljs-meta prompt_"># </span><span class="language-bash">上面说的是：『在2015/08/04 的23:00 有一项工作，该项工作指令下达者为</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">root』而且，该项工作的工作号码(jobnumber) 为3 号喔！</span><br><br>范例二：将上述的第3 个工作移除！<br>[root@study ~]# atrm 3 <br>[root@study ~]# atq <br><span class="hljs-meta prompt_"># </span><span class="language-bash">没有任何资讯，表示该工作被移除了！</span><br></code></pre></td></tr></table></figure><h3 id="循环执行的计划任务">15.3 循环执行的计划任务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# crontab [-u username] [-l|-e|-r]<br>选项与参数：<br>-u ：只有root 才能进行这个任务，亦即帮其他使用者建立/移除crontab 工作排程；<br>-e ：编辑crontab 的工作内容<br>-l ：查阅crontab 的工作内容<br>-r ：移除所有的crontab 的工作内容，若仅要移除一项，请用-e 去编辑。<br><br>范例一：用dmtsai 的身份在每天的12:00 发信给自己<br>[dmtsai@study ~]$ crontab -e <br><span class="hljs-meta prompt_"># </span><span class="language-bash">此时会进入vi 的编辑画面让您编辑工作！注意到，每项工作都是一行。</span><br>0 12 * * * mail -s &quot;at 12:00&quot; dmtsai &lt; /home/dmtsai/.bashrc <br><span class="hljs-meta prompt_">#</span><span class="language-bash">分时日月周|&lt;==============指令串========================&gt;|</span><br></code></pre></td></tr></table></figure><p>每项工作(每行) 的格式都是具有六个栏位，这六个栏位的意义为：</p><table><thead><tr class="header"><th style="text-align: center;">代表意义</th><th style="text-align: center;">分钟</th><th style="text-align: center;">小时</th><th style="text-align: center;">日期</th><th style="text-align: center;">月份</th><th style="text-align: center;">周</th><th style="text-align: center;">命令</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">数字范围</td><td style="text-align: center;">0-59</td><td style="text-align: center;">0-23</td><td style="text-align: center;">1-31</td><td style="text-align: center;">1-12</td><td style="text-align: center;">0-7</td><td style="text-align: center;">需要执行的命令</td></tr></tbody></table><p>特殊字符：</p><table><thead><tr class="header"><th>特殊字符</th><th>代表意义</th></tr></thead><tbody><tr class="odd"><td>*(星号)</td><td>代表任何时刻都接受的意思！举例来说，范例一内那个日、月、周都是* ，就代表着『不论何月、何日的礼拜几的12:00 都执行后续指令』的意思！</td></tr><tr class="even"><td>,(逗号)</td><td>代表分隔时段的意思。举例来说，如果要下达的工作是3:00 与6:00时，就会是：0 3,6 * * * command时间参数还是有五栏，不过第二栏是3,6，代表3 与6 都适用！</td></tr><tr class="odd"><td>-(减号)</td><td>代表一段时间范围内，举例来说， 8 点到12 点之间的每小时的20分都进行一项工作：20 8-12 * * * command仔细看到第二栏变成8-12喔！代表8,9,10,11,12 都适用的意思！</td></tr><tr class="even"><td>/n(斜线)</td><td>那个n 代表数字，亦即是『每隔n单位间隔』的意思，例如每五分钟进行一次，则： <em>/5 </em> * * *command很简单吧！用* 与/5 来搭配，也可以写成0-59/5 ，相同意思！</td></tr></tbody></table><p>注意：『如果只是要删除某个crontab 的工作项目，那么请使用crontab -e来重新编辑即可！』如果使用-r 的参数，是会将所有的 crontab资料内容都删掉的！</p><h3 id="可唤醒停机期间的工作任务">15.4 可唤醒停机期间的工作任务</h3><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# anacron [-sfn] [job].. <br>[root@study ~]# anacron -u [job]..<br>选项与参数：<br>-s ：开始一连续的执行各项工作(job)，会依据时间记录档的资料判断是否进行；<br>-f ：强制进行，而不去判断时间记录档的时间戳记；<br>-n ：立刻进行未进行的任务，而不延迟(delay) 等待时间；<br>-u ：仅更新时间记录档的时间戳记，不进行任何工作。<br>job ：由/etc/anacrontab 定义的各项工作名称。<br></code></pre></td></tr></table></figure><h2 id="进程管理与-selinux-初探">16. 进程管理与 SELinux 初探</h2><p>kill：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# kill -signal %jobnumber <br>[root@study ~]# kill -l<br>选项与参数：<br>-l ：这个是L 的小写，列出目前kill 能够使用的讯号(signal) 有哪些？<br>signal ：代表给予后面接的那个工作什么样的指示啰！用man 7 signal 可知：<br>  -1 ：重新读取一次参数的设定档(类似reload)；<br>  -2 ：代表与由键盘输入[ctrl]-c 同样的动作；<br>  -9 ：立刻强制删除一个工作；<br>  -15：以正常的程序方式终止一项工作。与-9 是不一样的。<br><br>范例一：找出目前的bash 环境下的背景工作，并将该工作『强制删除』。<br>[root@study ~]# jobs<br>[1]+ Stopped vim ~/.bashrc<br>[2] Stopped find / -print<br>[root@study ~]# kill -9 %2; jobs<br>[1]+ Stopped vim ~/.bashrc<br>[2]    Killed                   find / -print<br><span class="hljs-meta prompt_"> # </span><span class="language-bash">再过几秒你再下达<span class="hljs-built_in">jobs</span> 一次，就会发现2 号工作不见了！因为被移除了！</span><br><br>范例二：找出目前的bash 环境下的背景工作，并将该工作『正常终止』掉。<br>[root@study ~]# jobs<br>[1]+ Stopped vim ~/.bashrc<br>[root@study ~]# kill -SIGTERM %1 <br><span class="hljs-meta prompt_"># </span><span class="language-bash">-SIGTERM 与-15 是一样的！您可以使用<span class="hljs-built_in">kill</span> -l 来查阅！</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">不过在这个案例中， vim 的工作无法被结束喔！因为他无法透过<span class="hljs-built_in">kill</span> 正常终止的意思！</span><br></code></pre></td></tr></table></figure><table><thead><tr class="header"><th>代号</th><th>名称</th><th>内容</th></tr></thead><tbody><tr class="odd"><td>1</td><td>SIGHUP</td><td>启动被终止的程序，可让该PID 重新读取自己的设定档，类似重新启动</td></tr><tr class="even"><td>2</td><td>SIGINT</td><td>相当于用键盘输入[ctrl]-c 来中断一个程序的进行</td></tr><tr class="odd"><td>9</td><td>SIGKILL</td><td>代表强制中断一个程序的进行，如果该程序进行到一半，那么尚未完成的部分可能会有『半产品』产生，类似vim会有.filename.swp保留下来。</td></tr><tr class="even"><td>15</td><td>SIGTERM</td><td>以正常的结束程序来终止该程序。由于是正常的终止，所以后续的动作会将他完成。不过，如果该程序已经发生问题，就是无法使用正常的方法终止时，输入这个signal 也是没有用的。</td></tr><tr class="odd"><td>19</td><td>SIGSTOP</td><td>相当于用键盘输入[ctrl]-z 来暂停一个程序的进行</td></tr></tbody></table><p>killall：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">root@study ~</span>]<span class="hljs-meta"># killall [-iIe] [command name]</span><br>选项与参数：<br>-i ：interactive 的意思，互动式的，若需要删除时，会出现提示字元给使用者；<br>-e ：exact 的意思，表示『后面接的command name 要一致』，但整个完整的指令<br>      不能超过<span class="hljs-number">15</span> 个字元。<br>-I ：指令名称(可能含参数)忽略大小写。<br><br>范例一：给予rsyslogd 这个指令启动的PID 一个SIGHUP 的讯号<br>[<span class="hljs-meta">root@study ~</span>]<span class="hljs-meta"># killall -1 rsyslogd </span><br><span class="hljs-meta"># 如果用ps aux 仔细看一下，若包含所有参数，则/usr/sbin/rsyslogd -n 才是最完整的！</span><br><br>范例二：强制终止所有以httpd 启动的程序(其实并没有此程序在系统内) <br>[<span class="hljs-meta">root@study ~</span>]<span class="hljs-meta"># killall -9 httpd</span><br><br>范例三：依次询问每个bash 程式是否需要被终止运作！<br>[<span class="hljs-meta">root@study ~</span>]<span class="hljs-meta"># killall -i -9 bash </span><br><span class="hljs-function">Signal <span class="hljs-title">bash</span>(<span class="hljs-params"><span class="hljs-number">13888</span></span>) ? (<span class="hljs-params">y/N</span>) n  &lt;</span>==这个不杀！<br><span class="hljs-function">Signal <span class="hljs-title">bash</span>(<span class="hljs-params"><span class="hljs-number">13928</span></span>) ? (<span class="hljs-params">y/N</span>) n  &lt;</span>==这个不杀！<br><span class="hljs-function">Signal <span class="hljs-title">bash</span>(<span class="hljs-params"><span class="hljs-number">13970</span></span>) ? (<span class="hljs-params">y/N</span>) n  &lt;</span>==这个不杀！<br><span class="hljs-function">Signal <span class="hljs-title">bash</span>(<span class="hljs-params"><span class="hljs-number">14836</span></span>) ? (<span class="hljs-params">y/N</span>) y  &lt;</span>==这个杀掉！<br><span class="hljs-meta"># 具有互动的功能！可以询问你是否要删除bash 这个程式。要注意，若没有-i 的参数，</span><br><span class="hljs-meta"># 所有的bash 都会被这个root 给杀掉！包括root 自己的bash 喔！^_^</span><br></code></pre></td></tr></table></figure><p>ps 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# ps aux  &lt;==观察系统所有的程序资料<br>[root@study ~]# ps -lA  &lt;==也是能够观察所有系统的资料<br>[root@study ~]# ps axjf  &lt;==连同部分程序树状态<br>选项与参数：<br>-A ：所有的process 均显示出来，与-e 具有同样的效用；<br>-a ：不与terminal 有关的所有process ；<br>-u ：有效使用者(effective user) 相关的process ；<br>x ：通常与a 这个参数一起使用，可列出较完整资讯。<br>输出格式规划：<br>l ：较长、较详细的将该PID 的的资讯列出；<br>j ：工作的格式(jobs format)<br>-f ：做一个更为完整的输出。<br></code></pre></td></tr></table></figure><p>top 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# top [-d 数字] | top [-bnp]<br>选项与参数：<br>-d ：后面可以接秒数，就是整个程序画面更新的秒数。预设是5 秒；<br>-b ：以批次的方式执行top ，还有更多的参数可以使用喔！<br>      通常会搭配资料流重导向来将批次的结果输出成为档案。<br>-n ：与-b 搭配，意义是，需要进行几次top 的输出结果。<br>-p ：指定某些个PID 来进行观察监测而已。<br>在top 执行过程当中可以使用的按键指令：<br>? ：显示在top 当中可以输入的按键指令；<br>P ：以CPU 的使用资源排序显示；<br>M ：以Memory 的使用资源排序显示；<br>N ：以PID 来排序喔！<br>T ：由该Process 使用的CPU 时间累积(TIME+) 排序。<br>k ：给予某个PID 一个讯号(signal)<br>r ：给予某个PID 重新制订一个nice 值。<br>q ：离开top 软体的按键。<br></code></pre></td></tr></table></figure><p>pstree 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# pstree [-A|U] [-up]<br>选项与参数：<br>-A ：各程序树之间的连接以ASCII 字元来连接；<br>-U ：各程序树之间的连接以万国码的字元来连接。在某些终端介面下可能会有错误；<br>-p ：并同时列出每个process 的PID；<br>-u ：并同时列出每个process 的所属帐号名称。<br><br>范例一：列出目前系统上面所有的程序树的相关性： <br>[root@study ~]# pstree -A <br>systemd-+-ModemManager---2*[&#123;ModemManager&#125;]        # 这行是ModenManager 与其子程序<br>        |-NetworkManager---3*[&#123;NetworkManager&#125;]    # 前面有数字，代表子程序的数量！<br>....(中间省略).... <br>        |-sshd---sshd---sshd---bash---bash---sudo---su---bash---pstree &lt;==我们指令执行的相依性<br>....(底下省略).... <br><span class="hljs-meta prompt_"># </span><span class="language-bash">注意一下，为了节省版面，所以鸟哥已经删去很多程序了！</span><br><br>范例二：承上题，同时秀出PID 与users <br>[root@study ~]# pstree -Aup<br>systemd(1)-+-ModemManager(745)-+-&#123;ModemManager&#125;(785)<br>           | `-&#123;ModemManager&#125;(790)<br>           |-NetworkManager(870)-+-&#123;NetworkManager&#125;(907)<br>           | |-&#123;NetworkManager&#125;(911)<br>           | `-&#123;NetworkManager&#125;(914)<br>....(中间省略).... <br>           |-sshd(1326)---sshd(13923)---sshd(13927, dmtsai )---bash(13928)---bash(13970)---<br> ....(底下省略).... <br><span class="hljs-meta prompt_"># </span><span class="language-bash">在括号() 内的即是PID 以及该程序的owner 喔！一般来说，如果该程序的所有人与父程序同，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">就不会列出，但是如果与父程序不一样，那就会列出该程序的拥有者！看上面13927 就转变成dmtsai 了</span><br></code></pre></td></tr></table></figure><p>free 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">free [-b|-k|-m|-g|-h] [-t] [-s N -c N]</span><br>选项与参数：<br>-b ：直接输入free 时，显示的单位是Kbytes，我们可以使用b(bytes), m(Mbytes)<br>      k(Kbytes), 及g(Gbytes) 来显示单位喔！也可以直接让系统自己指定单位(-h)<br>-t ：在输出的最终结果，显示实体记忆体与swap 的总量。<br>-s ：可以让系统每几秒钟输出一次，不间断的一直输出的意思！对于系统观察挺有效！<br>-c ：与-s 同时处理～让free 列出几次的意思～<br><br>范例一：显示目前系统的记忆体容量<br>[root@study ~]# free -m<br>              total used free shared buff/cache available<br>Mem: 2848 346 1794 8 706 2263<br>Swap: 1023 0 1023<br></code></pre></td></tr></table></figure><p>netstat 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# netstat -[atunlp]<br>选项与参数：<br>-a ：将目前系统上所有的连线、监听、Socket 资料都列出来<br>-t ：列出tcp 网路封包的资料<br>-u ：列出udp 网路封包的资料<br>-n ：不以程序的服务名称，以埠号(port number) 来显示；<br>-l ：列出目前正在网路监听(listen) 的服务；<br>-p ：列出该网路服务的程序PID<br><br>范例一：列出目前系统已经建立的网路连线与unix socket 状态<br>[root@study ~]# netstat <br>Active Internet connections (w/o servers)  &lt;==与网路较相关的部分<br>Proto Recv-Q Send-Q Local Address Foreign Address State<br>tcp 0 0 172.16.15.100:ssh 172.16.220.234:48300 ESTABLISHED<br>Active UNIX domain sockets (w/o servers)   &lt;==与本机的程序自己的相关性(非网路)<br>Proto RefCnt Flags Type State I-Node Path<br>unix 2 [ ] DGRAM 1902 @/org/freedesktop/systemd1/notify<br>unix 2 [ ] DGRAM 1944 /run/systemd/shutdownd<br>....(中间省略)....<br>unix 3 [ ] STREAM CONNECTED 25425 @/tmp/.X11-unix/X0<br>unix 3 [ ] STREAM CONNECTED 28893<br>unix 3 [ ] STREAM CONNECTED 21262<br><br>范例二：找出目前系统上已在监听的网路连线及其PID <br>[root@study ~]# netstat -tulnp<br>Active Internet connections (only servers)<br>Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name<br>tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 1326/sshd<br>tcp 0 0 127.0.0.1:25 0.0.0.0:* LISTEN 2349/master<br>tcp6 0 0 :::22 :::* LISTEN       1326/sshd<br>tcp6 0 0 ::1:25 :::* LISTEN 2349/master<br>udp 0 0 0.0.0.0:123 0.0.0.0:* 751/chronyd<br>udp 0 0 127.0.0.1:323 0.0.0.0:* 751/chronyd<br>udp 0 0 0.0.0.0:57808 0.0.0.0:* 743/avahi-daemon: r<br>udp 0 0 0.0.0.0:5353 0.0.0.0:* 743/avahi-daemon: r<br>udp6 0 0 :::123 :::* 751/chronyd<br>udp6 0 0 ::1:323 :::* 751/chronyd<br><span class="hljs-meta prompt_"># </span><span class="language-bash">除了可以列出监听网路的介面与状态之外，最后一个栏位还能够显示此服务的</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">PID 号码以及程序的指令名称喔！例如上头的1326 就是该PID</span><br><br>范例三：将上述的0.0.0.0:57808 那个网路服务关闭的话？<br>[root@study ~]# kill -9 743 <br>[root@study ~]# killall -9 avahi-daemon<br></code></pre></td></tr></table></figure><p>dmesg 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">范例一：输出所有的核心开机时的资讯<br>[root@study ~]# dmesg | more<br><br>范例二：搜寻开机的时候，硬碟的相关资讯为何？<br>[root@study ~]# dmesg | grep -i vda<br>[ 0.758551] vda: vda1 vda2 vda3 vda4 vda5 vda6 vda7 vda8 vda9<br>[ 3.964134] XFS (vda2): Mounting V4 Filesystem<br>....(底下省略)....<br></code></pre></td></tr></table></figure><p>vmstat 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# vmstat [-a] [延迟[总计侦测次数]]  &lt;==CPU/记忆体等资讯<br>[root@study ~]# vmstat [-fs]                       &lt;==记忆体相关<br>[root@study ~]# vmstat [-S 单位]                   &lt;==设定显示数据的单位<br>[root@study ~]# vmstat [-d]                        &lt;==与磁碟有关<br>[root@study ~]# vmstat [-p 分割槽]                 &lt;==与磁碟有关<br>选项与参数：<br>-a ：使用inactive/active(活跃与否) 取代buffer/cache 的记忆体输出资讯；<br>-f ：开机到目前为止，系统复制(fork) 的程序数；<br>-s ：将一些事件(开机至目前为止) 导致的记忆体变化情况列表说明；<br>-S ：后面可以接单位，让显示的资料有单位。例如K/M 取代bytes 的容量；<br>-d ：列出磁碟的读写总量统计表<br>-p ：后面列出分割槽，可显示该分割槽的读写总量统计表<br><br>范例一：统计目前主机CPU 状态，每秒一次，共计三次！<br>[root@study ~]# vmstat 1 3<br>procs ------------memory---------- ---swap-- -----io---- -system-- ------cpu-----<br> rb swpd free buff cache si so bi bo in cs us sy id wa st<br> 1 0 0 1838092 1504 722216 0 0 4 1 6 9 0 0 100 0 0<br> 0 0 0 1838092 1504 722200 0 0 0 0 13 23 0 0 100 0 0<br> 0 0 0 1838092 1504 722200 0 0 0 0 25 46 0 0 100 0 0<br></code></pre></td></tr></table></figure><p>fuser：借由文件（或唔见系统）找出正在使用该文件的进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# fuser [-umv] [-k [i] [-signal]] file/dir<br>选项与参数：<br>-u ：除了程序的PID 之外，同时列出该程序的拥有者；<br>-m ：后面接的那个档名会主动的上提到该档案系统的最顶层，对umount 不成功很有效！<br>-v ：可以列出每个档案与程序还有指令的完整相关性！<br>-k ：找出使用该档案/目录的PID ，并试图以SIGKILL 这个讯号给予该PID；<br>-i ：必须与-k 配合，在删除PID 之前会先询问使用者意愿！<br>-signal：例如-1 -15 等等，若不加的话，预设是SIGKILL (-9) 啰！<br><br>范例一：找出目前所在目录的使用PID/所属帐号/权限为何？<br>[root@study ~]# fuser -uv .<br>                     USER PID ACCESS COMMAND<br>/root: root 13888 ..c.. (root)bash<br>                     root 31743 ..c.. (root)bash<br>                     <br><br>范例二：找到所有使用到/proc 这个档案系统的程序吧！<br>[root@study ~]# fuser -uv /proc<br>/proc: root kernel mount (root)/proc<br>                     rtkit 768 .rc.. (rtkit)rtkit-daemon<br><span class="hljs-meta prompt_"># </span><span class="language-bash">资料量还不会很多，虽然这个目录很繁忙～没关系！我们可以继续这样作，看看其他的程序！</span><br><br>[root@study ~]# fuser -mvu /proc<br>                     USER PID ACCESS COMMAND<br>/proc: root kernel mount (root)/proc<br>                     root 1 f.... (root)systemd<br>                     root 2 ...e. (root)kthreadd<br>.....(底下省略)..... <br><span class="hljs-meta prompt_"># </span><span class="language-bash">有这几支程序在进行/proc 档案系统的存取喔！这样清楚了吗？</span><br><br>范例三：找到所有使用到/home 这个档案系统的程序吧！<br>[root@study ~]# echo $$ <br>31743   # 先确认一下，自己的bash PID 号码吧！<br>[root@study ~]# cd /home <br>[root@study home]# fuser -muv .<br>                     USER PID ACCESS COMMAND<br>/home: root kernel mount (root)/home<br>                     dmtsai 31535 ..c.. (dmtsai)bash<br>                     root 31571 ..c.. (root)passwd<br>                     root 31737 ..c.. (root)sudo<br>                     root       31743 ..c.. (root)bash     # 果然，自己的PID 在啊！<br>[root@study home]# cd ~ <br>[root@study ~]# umount /home<br>umount: /home: target is busy.<br>        (In some cases useful info about processes that use<br>         the device is found by lsof(8) or fuser(1))<br><span class="hljs-meta prompt_"># </span><span class="language-bash">从fuser 的结果可以知道，总共有五只process 在该目录下运作，那即使root 离开了/home，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">当然还是无法umount 的！那要怎办？哈哈！可以透过如下方法一个一个删除～</span> <br>[root@study ~]# fuser -mki /home <br>/home: 31535c 31571c 31737c   # 你会发现， PID 跟上面查到的相同！<br>Kill process 31535 ? (y/N) # 这里会问你要不要删除！当然不要乱删除啦！通通取消！<br></code></pre></td></tr></table></figure><p>lsof：列出被进程所使用的文件名称</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# lsof [-aUu] [+d]<br>选项与参数：<br>-a ：多项资料需要『同时成立』才显示出结果时！<br>-U ：仅列出Unix like 系统的socket 档案类型；<br>-u ：后面接username，列出该使用者相关程序所开启的档案；<br>+d ：后面接目录，亦即找出某个目录底下已经被开启的档案！<br><br>范例一：列出目前系统上面所有已经被开启的档案与装置： <br>[root@study ~]# lsof<br>COMMAND PID TID USER FD TYPE DEVICE SIZE/OFF NODE NAME<br>systemd 1 root cwd DIR 253,0 4096 128 /<br>systemd 1 root rtd DIR 253,0 4096 128 /<br>systemd 1 root txt REG 253,0 1230920 967763 /usr/lib/systemd/systemd<br>....(底下省略).... <br><span class="hljs-meta prompt_"># </span><span class="language-bash">注意到了吗？是的，在预设的情况下， lsof 会将目前系统上面已经开启的</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">档案全部列出来～所以，画面多的吓人啊！您可以注意到，第一个档案systemd 执行的</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">地方就在根目录，而根目录，嘿嘿！所在的inode 也有显示出来喔！</span><br><br>范例二：仅列出关于root 的所有程序开启的socket 档案<br>[root@study ~]# lsof -u root -a -U<br>COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME<br>systemd 1 root 3u unix 0xffff8800b7756580 0t0 13715 socket<br>systemd 1 root 7u unix 0xffff8800b7755a40 0t0 1902 @/org/freedesktop/systemd1/notify<br>systemd 1 root 9u unix 0xffff8800b7756d00 0t0 1903 /run/systemd/private<br>.....(中间省略).....<br>Xorg 4496 root 1u unix 0xffff8800ab107480 0t0 25981 @/tmp/.X11-unix/X0<br>Xorg 4496 root 3u unix 0xffff8800ab107840 0t0 25982 /tmp/.X11-unix/X0<br>Xorg 4496 root 16u unix 0xffff8800b7754f00 0t0 25174 @/tmp/.X11-unix/X0<br>.....(底下省略)..... <br><span class="hljs-meta prompt_"># </span><span class="language-bash">注意到那个-a 吧！如果你分别输入lsof -u root 及lsof -U ，会有啥资讯？</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用lsof -u root -U 及lsof -u root -a -U ，呵呵！都不同啦！</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-a 的用途就是在解决同时需要两个项目都成立时啊！^_^</span><br><br>范例三：请列出目前系统上面所有的被启动的周边装置<br>[root@study ~]# lsof +d /dev<br>COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME<br>systemd 1 root 0u CHR 1,3 0t0 1028 /dev/null<br>systemd 1 root 1u CHR 1,3 0t0 1028 /dev/null<br><span class="hljs-meta prompt_"># </span><span class="language-bash">看吧！因为装置都在/dev 里面嘛！所以啰，使用搜寻目录即可啊！</span><br><br>范例四：秀出属于root 的bash 这支程式所开启的档案<br>[root@study ~]# lsof -u root | grep bash<br>ksmtuned 781 root txt REG 253,0 960384 33867220 /usr/bin/bash<br>bash 13888 root cwd DIR 253,0 4096 50331777 /root<br>bash 13888 root rtd DIR 253,0 4096 128 /<br>bash 13888 root txt REG 253,0 960384 33867220 /usr/bin/bash<br>bash 13888 root mem REG 253,0 106065056 17331169 /usr/lib/locale/locale-archive<br>....(底下省略)....<br></code></pre></td></tr></table></figure><h2 id="认识系统服务daemon">17. 认识系统服务（daemon）</h2><h3 id="什么是-daemon-与服务service">17.1 什么是 daemon与服务（service）</h3><p>完成 service 的程序称为 daemon。</p><ul><li>/usr/lib/systemd/system/：每个服务最主要的启动脚本设定，有点类似以前的/etc/init.d底下的档案；</li><li>/run/systemd/system/：系统执行过程中所产生的服务脚本，这些脚本的优先序要比/usr/lib/systemd/system/高！</li><li>/etc/systemd/system/：管理员依据主机系统的需求所建立的执行脚本，其实这个目录有点像以前/etc/rc.d/rc5.d/Sxx之类的功能！执行优先序又比/run/systemd/system/ 高喔！</li></ul><p>常见的 systemd 服务类型：</p><table><thead><tr class="header"><th>扩展名</th><th>主要服务功能</th></tr></thead><tbody><tr class="odd"><td>.service</td><td>一般服务类型(serviceunit)：主要是系统服务，包括服务器本身所需要的本机服务以及网路服务等，比较经常被使用到的服务大多是这种类型！所以，这也是最常见的类型了！</td></tr><tr class="even"><td>.socket</td><td>内部程序资料交换的插槽服务(socket unit)：主要是IPC (Inter-processcommunication) 的传输讯息插槽档(socket file)功能。这种类型的服务通常在监控讯息传递的插槽档，当有透过此插槽档传递讯息来说要连结服务时，就依据当时的状态将该用户的要求传送到对应的daemon，若daemon 尚未启动，则启动该daemon 后再传送用户的要求。使用socket类型的服务一般是比较不会被用到的服务，因此在开机时通常会稍微延迟启动的时间(因为比较没有这么常用嘛！)。一般用于本机服务比较多，例如我们的图形界面很多的软体都是透过socket来进行本机程序资料交换的行为。(这与早期的xinetd 这个super daemon有部份的相似喔！)</td></tr><tr class="odd"><td>.target</td><td>执行环境类型(target unit)：其实是一群unit的集合，例如上面表格中谈到的multi-user.target其实就是一堆服务的集合～也就是说， 选择执行multi-user.target就是执行一堆其他.service 或/及.socket 之类的服务就是了！</td></tr><tr class="even"><td>.mount .automount</td><td>档案系统挂载相关的服务(automount unit / mountunit)：例如来自网路的自动挂载、NFS档案系统挂载等与档案系统相关性较高的程序管理。</td></tr><tr class="odd"><td>.path</td><td>侦测特定档案或目录类型(pathunit)：某些服务需要侦测某些特定的目录来提供伫列服务，例如最常见的列印服务，就是透过侦测列印伫列目录来启动列印功能！这时就得要.path的服务类型支援了！</td></tr><tr class="even"><td>.timer</td><td>循环执行的服务(timer unit)：这个东西有点类似anacrontab喔！不过是由systemd 主动提供的，比anacrontab 更加有弹性！</td></tr></tbody></table><h3 id="通过-systemctl-管理服务">17.2 通过 systemctl 管理服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# systemctl [command] [unit] <br>command 主要有：<br>start ：立刻启动后面接的unit<br>stop ：立刻关闭后面接的unit<br>restart ：立刻关闭后启动后面接的unit，亦即执行stop 再start 的意思<br>reload ：不关闭后面接的unit 的情况下，重新载入设定档，让设定生效<br>enable ：设定下次开机时，后面接的unit 会被启动<br>disable ：设定下次开机时，后面接的unit 不会被启动<br>status ：目前后面接的这个unit 的状态，会列出有没有正在执行、开机预设执行否、登录等资讯等！<br>is-active ：目前有没有正在运作中<br>is-enabled：开机时有没有预设要启用这个unit<br><br>范例一：看看目前atd 这个服务的状态为何？<br>[root@study ~]# systemctl status atd.service<br>atd.service - Job spooling tools<br>   Loaded: loaded (/usr/lib/systemd/system/atd.service; enabled)<br>   Active: active (running) since Mon 2015-08-10 19:17:09 CST; 5h 42min ago<br> Main PID: 1350 (atd)<br>   CGroup: /system.slice/atd.service<br>           └─1350 /usr/sbin/atd -f<br><br>Aug 10 19:17:09 study.centos.vbird systemd[1]: Started Job spooling tools.<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重点在第二、三行喔～</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Loaded：这行在说明，开机的时候这个unit 会不会启动，enabled 为开机启动，disabled 开机不会启动</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Active：现在这个unit 的状态是正在执行(running) 或没有执行(dead)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">后面几行则是说明这个unit 程序的PID 状态以及最后一行显示这个服务的登录档资讯！</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">登录档资讯格式为：『时间』 『讯息发送主机』 『哪一个服务的讯息』 『实际讯息内容』</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">所以上面的显示讯息是：这个atd 预设开机就启动，而且现在正在运作的意思！</span><br><br>范例二：正常关闭这个atd 服务<br>[root@study ~]# systemctl stop atd.service <br>[root@study ~]# systemctl status atd.service<br>atd.service - Job spooling tools<br>   Loaded: loaded (/usr/lib/systemd/system/atd.service; enabled )<br>    Active: inactive (dead) since Tue 2015-08-11 01:04:55 CST; 4s ago<br>  Process: 1350 ExecStart=/usr/sbin/atd -f $OPTS (code=exited, status=0/SUCCESS)<br> Main PID: 1350 (code=exited, status=0/SUCCESS)<br><br>Aug 10 19:17:09 study.centos.vbird systemd[1]: Started Job spooling tools.<br>Aug 11 01:04:55 study.centos.vbird systemd[1]: Stopping Job spooling tools...<br>Aug 11 01:04:55 study.centos.vbird systemd[1]: Stopped Job spooling tools. <br><span class="hljs-meta prompt_"># </span><span class="language-bash">目前这个unit 下次开机还是会启动，但是现在是没在运作的状态中！同时，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">最后两行为新增加的登录讯息，告诉我们目前的系统状态喔！</span><br></code></pre></td></tr></table></figure><p>查看系统上所有服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# systemctl [command] [--type=TYPE] [--all] <br>command:<br>    list-units ：依据unit 列出目前有启动的unit。若加上--all 才会列出没启动的。<br>    list-unit-files ：依据/usr/lib/systemd/system/ 内的档案，将所有档案列表说明。<br>--type=TYPE：就是之前提到的unit type，主要有service, socket, target 等<br><br>范例一：列出系统上面有启动的unit <br>[root@study ~]# systemctl<br>UNIT LOAD ACTIVE SUB DESCRIPTION<br>proc-sys-fs-binfmt_mis... loaded active waiting Arbitrary Executable File Formats File System<br>sys-devices-pc...:0:1:... loaded active plugged QEMU_HARDDISK<br>sys-devices-pc...0:1-0... loaded active plugged QEMU_HARDDISK<br>sys-devices-pc...0:0-1... loaded active plugged QEMU_DVD-ROM<br>.....(中间省略).....<br>vsftpd.service loaded active running Vsftpd ftp daemon<br>.....(中间省略).....<br>cups.socket loaded failed failed CUPS Printing Service Sockets<br>.....(中间省略).....<br>LOAD = Reflects whether the unit definition was properly loaded.<br>ACTIVE = The high-level unit activation state, ie generalization of SUB.<br>SUB = The low-level unit activation state, values depend on unit type.<br><br>141 loaded units listed. Pass --all to see loaded but inactive units, too.<br>To show all installed unit files use &#x27;systemctl list-unit-files&#x27;. <br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出的项目中，主要的意义是：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">UNIT ：项目的名称，包括各个unit 的类别(看副档名)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">LOAD ：开机时是否会被载入，预设systemctl 显示的是有载入的项目而已喔！</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">ACTIVE ：目前的状态，须与后续的SUB 搭配！就是我们用systemctl status 观察时，active 的项目！</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">DESCRIPTION ：详细描述啰</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">cups 比较有趣，因为刚刚被我们玩过，所以ACTIVE 竟然是failed 的喔！被玩死了！^_^</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">另外，systemctl 都不加参数，其实预设就是list-units 的意思！</span><br><br>范例二：列出所有已经安装的unit 有哪些？<br>[root@study ~]# systemctl list-unit-files<br>UNIT FILE STATE<br>proc-sys-fs-binfmt_misc.automount static<br>dev-hugepages.mount static<br>dev-mqueue.mount static<br>proc-fs-nfsd.mount static<br>.....(中间省略).....<br>systemd-tmpfiles-clean.timer static<br><br>336 unit files listed.<br></code></pre></td></tr></table></figure><p>查看网络端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# netstat -tlunp<br>Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name<br>tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 1340/sshd<br>tcp 0 0 127.0.0.1:25 0.0.0.0:* LISTEN 2387/master<br>tcp6 0 0 :::555 :::* LISTEN 29113/vsftpd<br>tcp6 0 0 :::22 :::* LISTEN 1340/sshd<br>tcp6 0 0 ::1:25 :::* LISTEN 2387/master<br>udp 0 0 0.0.0.0:5353 0.0.0.0:* 750/avahi-daemon: r<br>udp 0 0 0.0.0.0:36540 0.0.0.0:* 750/avahi-daemon: r<br></code></pre></td></tr></table></figure><h3 id="systemctl-针对-service-类型的配置文件">17.3 systemctl 针对service 类型的配置文件</h3><p>systemctl 配置文件设置项目简介：（以 <code>sshd.service</code>文件为例）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# cat /usr/lib/systemd/system/sshd.service <br>[Unit]            # 这个项目与此unit 的解释、执行服务相依性有关<br>Description=OpenSSH server daemon<br>After=network.target sshd-keygen.service<br>Wants=sshd-keygen.service<br><br>[Service]         # 这个项目与实际执行的指令参数有关<br>EnvironmentFile=/etc/sysconfig/sshd<br>ExecStart=/usr/sbin/sshd -D $OPTIONS<br>ExecReload=/bin/kill -HUP $MAINPID<br>KillMode=process<br>Restart=on-failure<br>RestartSec=42s<br><br>[Install]         # 这个项目说明此unit 要挂载哪个target 底下<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><p>可分为三个部分：</p><ul><li>[Unit]： unit 本身的说明，以及与其他相依daemon的设定，包括在什么服务之后才启动此unit 之类的设定值；</li><li>[Service], [Socket], [Timer], [Mount], [Path]..：不同的unit type就得要使用相对应的设定项目。我们拿的是sshd.service来当范本，所以这边就使用[Service]来设定。这个项目内主要在规范服务启动的脚本、环境设定档档名、重新启动的方式等等。</li><li>[Install]：这个项目就是将此unit 安装到哪个target 里面去的意思！</li></ul><p>具体设置参数含义：</p><table><thead><tr class="header"><th style="text-align: center;">[Unit] 部分</th><th></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">设定参数</td><td>参数意义说明</td></tr><tr class="even"><td style="text-align: center;">Description</td><td>就是当我们使用systemctl list-units时，会输出给管理员看的简易说明！当然，使用systemctl status输出的此服务的说明，也是这个项目！</td></tr><tr class="odd"><td style="text-align: center;">Documentation</td><td>这个项目在提供管理员能够进行进一步的文件查询的功能！提供的文件可以是如下的资料：<br/>Documentation=http://www...<br/>Documentation=man:sshd(8)<br/>Documentation=file:/etc/ssh/sshd_config</td></tr><tr class="even"><td style="text-align: center;">After</td><td>说明此unit 是在哪个daemon启动之后才启动的意思！基本上仅是说明服务启动的顺序而已，并没有强制要求里头的服务一定要启动后此unit才能启动。以sshd.service 的内容为例，该档案提到After后面有network.target 以及sshd-keygen.service，但是若这两个unit没有启动而强制启动sshd.service 的话， 那么sshd.service应该还是能够启动的！这与Requires 的设定是有差异的喔！</td></tr><tr class="odd"><td style="text-align: center;">Before</td><td>与After的意义相反，是在什么服务启动前最好启动这个服务的意思。不过这仅是规范服务启动的顺序，并非强制要求的意思。</td></tr><tr class="even"><td style="text-align: center;">Requires</td><td>明确的定义此unit 需要在哪个daemon启动后才能够启动！就是设定相依服务啦！如果在此项设定的前导服务没有启动，那么此unit就不会被启动！</td></tr><tr class="odd"><td style="text-align: center;">Wants</td><td>与Requires 刚好相反，规范的是这个unit之后最好还要启动什么服务比较好的意思！不过，并没有明确的规范就是了！主要的目的是希望建立让使用者比较好操作的环境。因此，这个Wants后面接的服务如果没有启动，其实不会影响到这个unit 本身！</td></tr><tr class="even"><td style="text-align: center;">Conflicts</td><td>代表冲突的服务！亦即这个项目后面接的服务如果有启动，那么我们这个unit本身就不能启动！我们unit有启动，则此项目后的服务就不能启动！反正就是冲突性的检查啦！</td></tr></tbody></table><table><thead><tr class="header"><th style="text-align: center;">[Service] 部分</th><th></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">设定参数</td><td>参数意义说明</td></tr><tr class="even"><td style="text-align: center;">Type</td><td>说明这个daemon 启动的方式，会影响到ExecStart喔！一般来说，有底下几种类型<br/>simple：预设值，这个daemon主要由ExecStart接的指令串来启动，启动后常驻于记忆体中。<br/>forking：由ExecStart启动的程序透过spawns 延伸出其他子程序来作为此daemon的主要服务。原生的父程序在启动结束后就会终止运作。传统的unit服务大多属于这种项目，例如httpd 这个WWW 服务，当httpd的程序因为运作过久因此即将终结了，则systemd会再重新生出另一个子程序持续运作后，再将父程序删除。据说这样的效能比较好！！<br/>oneshot：与simple类似，不过这个程序在工作完毕后就结束了，不会常驻在记忆体中。<br/>dbus：与simple类似，但这个daemon 必须要在取得一个D-Bus的名称后，才会继续运作！因此设定这个项目时，通常也要设定BusName=才行！<br/>idle：与simple 类似，意思是，要执行这个daemon必须要所有的工作都顺利执行完毕后才会执行。这类的daemon通常是开机到最后才执行即可的服务！比较重要的项目大概是simple, forking与oneshot了！毕竟很多服务需要子程序(forking)，而有更多的动作只需要在开机的时候执行一次(oneshot)，例如档案系统的检查与挂载啊等等的。</td></tr><tr class="odd"><td style="text-align: center;">EnvironmentFile</td><td>可以指定启动脚本的环境设定档！例如sshd.service的设定档写入到/etc/sysconfig/sshd 当中！你也可以使用Environment=后面接多个不同的Shell 变数来给予设定！</td></tr><tr class="even"><td style="text-align: center;">ExecStart</td><td>就是实际执行此daemon 的指令或脚本程式。你也可以使用ExecStartPre(之前) 以及ExecStartPost (之后)两个设定项目来在实际启动服务前，进行额外的指令行为。但是你得要特别注意的是，指令串仅接受『指令参数参数...』的格式，不能接受&lt;,&gt;, &gt;&gt;, |, &amp; 等特殊字符，很多的bash语法也不支援喔！所以，要使用这些特殊的字符时，最好直接写入到指令脚本里面去！不过，上述的语法也不是完全不能用，亦即，若要支援比较完整的bash语法，那你得要使用Type=oneshot 才行喔！其他的Type才不能支援这些字符。</td></tr><tr class="odd"><td style="text-align: center;">ExecStop</td><td>与systemctl stop 的执行有关，关闭此服务时所进行的指令。</td></tr><tr class="even"><td style="text-align: center;">ExecReload</td><td>与systemctl reload 有关的指令行为</td></tr><tr class="odd"><td style="text-align: center;">Restart</td><td>当设定Restart=1 时，则当此daemon服务终止后，会再次的启动此服务。举例来说，如果你在tty2使用文字界面登入，操作完毕后登出，基本上，这个时候tty2就已经结束服务了。但是你会看到萤幕又立刻产生一个新的tty2的登入画面等待你的登入！那就是Restart 的功能！除非使用systemctl强制将此服务关闭，否则这个服务会源源不绝的一直重复产生！</td></tr><tr class="even"><td style="text-align: center;">RemainAfterExit</td><td>当设定为RemainAfterExit=1 时，则当这个daemon所属的所有程序都终止之后，此服务会再尝试启动。这对于Type=oneshot的服务很有帮助！</td></tr><tr class="odd"><td style="text-align: center;">TimeoutSec</td><td>若这个服务在启动或者是关闭时，因为某些缘故导致无法顺利『正常启动或正常结束』的情况下，则我们要等多久才进入『强制结束』的状态！</td></tr><tr class="even"><td style="text-align: center;">KillMode</td><td>可以是process, control-group, none 的其中一种，如果是process则daemon 终止时，只会终止主要的程序(ExecStart接的后面那串指令)，如果是control-group 时， 则由此daemon所产生的其他control-group 的程序，也都会被关闭。如果是none的话，则没有程序会被关闭喔！</td></tr><tr class="odd"><td style="text-align: center;">RestartSec</td><td>与Restart有点相关性，如果这个服务被关闭，然后需要重新启动时，大概要sleep多少时间再重新启动的意思。预设是100ms (毫秒)。</td></tr></tbody></table><table><thead><tr class="header"><th style="text-align: center;">[Install] 部分</th><th></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">设定参数</td><td>参数意义说明</td></tr><tr class="even"><td style="text-align: center;">WantedBy</td><td>这个设定后面接的大部分是*.target unit ！意思是，这个unit本身是附挂在哪一个target unit 底下的！一般来说，大多的服务性质的unit都是附挂在multi-user.target 底下！</td></tr><tr class="odd"><td style="text-align: center;">Also</td><td>当目前这个unit 本身被enable 时，Also 后面接的unit 也请enable的意思！也就是具有相依性的服务可以写在这里呢！</td></tr><tr class="even"><td style="text-align: center;">Alias</td><td>进行一个连结的别名的意思！当systemctl enable相关的服务时，则此服务会进行连结档的建立！以multi-user.target为例，这个家伙是用来作为预设操作环境default.target 的规划，因此当你设定用成default.target时，这个/etc/systemd/system/default.target就会连结到/usr/lib/systemd/system/multi-user.target 啰！</td></tr></tbody></table><p>示例：建立自己的备份服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# vim /backups/backup.sh <br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>source=&quot;/etc /home /root /var/lib /var/spool/&#123;cron,at,mail&#125;&quot;<br>target=&quot;/backups/backup-system-$(date +%Y-%m-%d).tar.gz&quot;<br>[ ! -d /backups ] &amp;&amp; mkdir /backups<br>tar -zcvf $&#123;target&#125; $&#123;source&#125; &amp;&gt; /backups/backup.log<br><br>[root@study ~]# chmod a+x /backups/backup.sh <br>[root@study ~]# ll /backups/backup.sh <br>-rwxr-xr-x . 1 root root 220 Aug 13 01:57 /backups/backup.sh<br><span class="hljs-meta prompt_"> # </span><span class="language-bash">记得要有可执行的权限才可以喔！</span><br> <br> <br>[root@study ~]# vim /etc/systemd/system/backup.service <br>[Unit]<br>Description=backup my server<br>Requires=atd.service<br><br>[Service]<br>Type=simple<br>ExecStart=/bin/bash -c &quot; echo /backups/backup.sh | at now&quot;<br><br>[Install]<br>WantedBy=multi-user.target <br><span class="hljs-meta prompt_"># </span><span class="language-bash">因为ExecStart 里面有用到at 这个指令，因此， atd.service 就是一定要的服务！</span><br><br>[root@study ~]# systemctl daemon-reload <br>[root@study ~]# systemctl start backup.service <br>[root@study ~]# systemctl status backup.service<br>backup.service - backup my server<br>   Loaded: loaded (/etc/systemd/system/backup.service; disabled)<br>   Active: inactive (dead)<br><br>Aug 13 07:50:31 study.centos.vbird systemd[1]: Starting backup my server...<br>Aug 13 07:50:31 study.centos.vbird bash[20490]: job 8 at Thu Aug 13 07:50:00 2015<br>Aug 13 07:50:31 study.centos.vbird systemd[1]: Started backup my server.<br><span class="hljs-meta prompt_"># </span><span class="language-bash">为什么Active 是inactive 呢？这是因为我们的服务仅是一个简单的script 啊！</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">因此执行完毕就完毕了，不会继续存在记忆体中喔！</span><br></code></pre></td></tr></table></figure><h2 id="认识与分析日志文件">18. 认识与分析日志文件</h2><p>略</p><h2 id="启动流程模块管理与-loader">19. 启动流程、模块管理与 Loader</h2><h3 id="linux-启动流程分析">19.1 Linux 启动流程分析</h3><ol type="1"><li><p>载入BIOS的硬体信息与进行自我检测（自检），并根据设置取得第一个可启动的设备；</p></li><li><p>读取并执行第一个启动设备内MBR 的启动引导程序(bootLoader，亦即是grub2, spfdisk 等程序)；</p></li><li><p>依据boot loader 的设置载入Kernel ，Kernel会开始检测硬体与加载驱动程序；</p></li><li><p>在硬体驱动成功后，Kernel 会主动调用systemd程序，并以default.target 流程启动；</p><ul><li><p>systemd 执行sysinit.target 初始化系统及basic.target准备操作系统；</p></li><li><p>systemd 启动multi-user.target 下的本机与服务器服务；</p></li><li><p>systemd 执行multi-user.target 下的/etc/rc.d/rc.local文件；</p></li><li><p>systemd 执行multi-user.target 下的getty.target及登录服务；</p></li><li><p>systemd 执行graphical 需要的服务</p></li></ul></li></ol><h2 id="基础系统设置与备份策略">20. 基础系统设置与备份策略</h2><p>略</p><h2 id="软件安装源代码与-tarball">21. 软件安装：源代码与 Tarball</h2><h3 id="开放源代码的软件安装与升级简介">21.1开放源代码的软件安装与升级简介</h3><p>通过 configure 与 make 进行编译示意图：</p><p><imgsrc="https://linux.vbird.org/linux_basic/centos7/0520source//make_configure.gif" /></p><h3 id="使用传统程序语言进行编译的简单示例">21.2使用传统程序语言进行编译的简单示例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 编辑主程式：</span> <br>[root@study ~]# vim thanks.c <br><span class="hljs-meta prompt_">#</span><span class="language-bash">include &lt;stdio.h&gt;</span><br>int main(void)<br>&#123;<br>        printf(&quot;Hello World\n&quot;);<br>        thanks_2();<br>&#125; <br><span class="hljs-meta prompt_"># </span><span class="language-bash">上面的thanks_2(); 那一行就是呼叫副程式啦！</span><br><br>[root@study ~]# vim thanks_2.c <br><span class="hljs-meta prompt_">#</span><span class="language-bash">include &lt;stdio.h&gt;</span><br>void thanks_2(void)<br>&#123;<br>        printf(&quot;Thank you!\n&quot;);<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 开始将原始码编译成为可执行的binary file ：</span> <br>[root@study ~]# gcc -c thanks.c thanks_2.c <br>[root@study ~]# ll thanks*<br>-rw-r--r--. 1 root root 75 Sep 4 11:43 thanks_2.c<br>-rw-r--r--. 1 root root 1496 Sep 4 11:43 thanks_2.o   &lt;==编译产生的！<br>-rw-r--r--. 1 root root 91 Sep 4 11:42 thanks.c<br>-rw-r--r--. 1 root root 1560 Sep 4 11:43 thanks.o     &lt;==编译产生的！<br><br>[root@study ~]# gcc -o thanks thanks.o thanks_2.o <br>[root@study ~]# ll thanks* <br>-rwxr-xr-x. 1 root root 8572 Sep 4 11:44 thanks     &lt;==最终结果会产生这玩意儿<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3. 执行一下这个档案：</span> <br>[root@study ~]# ./thanks<br>Hello World<br>Thank you!<br></code></pre></td></tr></table></figure><p>加入链接选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# vim sin.c <br><span class="hljs-meta prompt_">#</span><span class="language-bash">include &lt;stdio.h&gt;</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">include &lt;math.h&gt;</span><br>int main(void)<br>&#123;<br>        float value;<br>        value = sin ( 3.14 / 2 );<br>        printf(&quot;%f\n&quot;,value);<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">编译</span><br>[root@study ~]# gcc sin.c <br><span class="hljs-meta prompt_"># </span><span class="language-bash">新的GCC 会主动将函数抓进来给你用，所以只要加上include &lt;math.h&gt; 就好了！</span><br><br>[root@study ~]# gcc sin.c -lm -L/lib -L/lib64   &lt;==重点在-lm <br>[root@study ~]# ./a.out                          &lt;==尝试执行新档案！<br>1.000000<br></code></pre></td></tr></table></figure><p>特别注意，使用gcc 编译时所加入的那个-lm是有意义的，他可以拆开成两部份来看：</p><ul><li>-l ：是『加入某个函式库(library)』的意思，</li><li>m ：则是libm.so 这个函式库，其中， lib 与副档名(.a或.so)不需要写</li></ul><p>所以-lm 表示使用libm.so (或libm.a) 这个函式库的意思～至于那个-L后面接的路径呢？这表示： 『我要的函式库libm.so 请到/lib 或/lib64里面搜寻！』</p><p>gcc 简易用法（编译、参数和链接）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">仅将原始码编译成为目标档，并不制作连结等功能：</span> <br>[root@study ~]# gcc -c hello.c <br><span class="hljs-meta prompt_"># </span><span class="language-bash">会自动的产生hello.o 这个档案，但是并不会产生binary 执行档。</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在编译的时候，依据作业环境给予最佳化执行速度</span><br>[root@study ~]# gcc -O hello.c -c <br><span class="hljs-meta prompt_"># </span><span class="language-bash">会自动的产生hello.o 这个档案，并且进行最佳化喔！</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在进行binary file 制作时，将连结的函式库与相关的路径填入</span><br>[root@study ~]# gcc sin.c -lm -L/lib -I/usr/include <br><span class="hljs-meta prompt_"># </span><span class="language-bash">这个指令较常下达在最终连结成binary file 的时候，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-lm 指的是libm.so 或libm.a 这个函式库档案；</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-L 后面接的路径是刚刚上面那个函式库的搜寻目录；</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-I 后面接的是原始码内的include 档案之所在目录。</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将编译的结果输出成某个特定档名</span><br>[root@study ~]# gcc -o hello hello.c <br><span class="hljs-meta prompt_"># </span><span class="language-bash">-o 后面接的是要输出的binary file 档名</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在编译的时候，输出较多的讯息说明</span><br>[root@study ~]# gcc -o hello hello.c -Wall <br><span class="hljs-meta prompt_"># </span><span class="language-bash">加入-Wall 之后，程式的编译会变的较为严谨一点，所以警告讯息也会显示出来！</span><br></code></pre></td></tr></table></figure><p>我们通常称 -Wall 或者-O这些非必要的参数为旗标(FLAGS)，因为我们使用的是C程式语言，所以有时候也会简称这些旗标为 CFLAGS</p><h3 id="用-make-进行宏编译">21.3 用 make 进行宏编译</h3><p>有以下源文件：</p><ul><li>main.c ：主要的目的是让使用者输入角度资料与呼叫其他三支副程式；</li><li>haha.c ：输出一堆有的没有的讯息而已；</li><li>sin_value.c ：计算使用者输入的角度(360) sin 数值；</li><li>cos_value.c ：计算使用者输入的角度(360) cos 数值。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 先进行目标档的编译，最终会有四个*.o 的档名出现：</span> <br>[root@study ~]# gcc -c main.c <br>[root@study ~]# gcc -c haha.c <br>[root@study ~]# gcc -c sin_value.c <br>[root@study ~]# gcc -c cos_value.c<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 再进行连结成为执行档，并加入libm 的数学函式，以产生main 执行档：</span> <br>[root@study ~]# gcc -o main main.o haha.o sin_value.o cos_value.o -lm<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3. 本程式的执行结果，必须输入姓名、360 度角的角度值来计算：</span> <br>[root@study ~]# ./main <br>Please input your name: VBird   &lt;==这里先输入名字<br>Please enter the degree angle (ex&gt; 90): 30    &lt;==输入以360 度角为主的角度<br>Hi, Dear VBird, nice to meet you.     &lt;==这三行为输出的结果喔！<br>The Sin is: 0.50<br>The Cos is: 0.87<br></code></pre></td></tr></table></figure><p>使用 make 编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 先编辑makefile 这个规则档，内容只要作出main 这个执行档</span><br>[root@study ~]# vim makefile <br>main: main.o haha.o sin_value.o cos_value.o<br>gcc -o main main.o haha.o sin_value.o cos_value.o -lm <br><span class="hljs-meta prompt_"># </span><span class="language-bash">注意：第二行的gcc 之前是&lt;tab&gt; 按键产生的空格喔！</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 尝试使用makefile 制订的规则进行编译的行为：</span> <br>[root@study ~]# rm -f main *.o    &lt;==先将之前的目标档去除<br>[root@study ~]# make<br>cc -c -o main.o main.c<br>cc -c -o haha.o haha.c<br>cc -c -o sin_value.o sin_value.c<br>cc -c -o cos_value.o cos_value.c<br>gcc -o main main.o haha.o sin_value.o cos_value.o -lm<br><span class="hljs-meta prompt_"># </span><span class="language-bash">此时make 会去读取makefile 的内容，并根据内容直接去给他编译相关的档案啰！</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3. 在不删除任何档案的情况下，重新执行一次编译的动作：</span> <br>[root@study ~]# make<br>make: `main&#x27; is up to date.<br><span class="hljs-meta prompt_"># </span><span class="language-bash">看到了吧！是否很方便呢！只会进行更新(update) 的动作而已。</span><br></code></pre></td></tr></table></figure><p>make 优点：</p><ul><li>简化编译时所需要下达的指令；</li><li>若在编译完成之后，修改了某个原始码档案，则make仅会针对被修改了的档案进行编译，其他的 object file 不会被更动；</li><li>最后可以依照相依性来更新(update) 执行档。</li></ul><p>基本的 makefile 规则：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">目标(target): 目标文件1 目标文件2</span><br>&lt;tab&gt; gcc -o 欲建立的执行文件 目标文件1 目标文件2<br></code></pre></td></tr></table></figure><p><strong>命令行必须要以tab 按键作为开头</strong>，他的规则基本上是这样的：</p><ul><li>在makefile 当中的# 代表注解；</li><li>&lt;tab&gt; 需要在命令行(例如gcc 这个编译器指令) 的第一个字符；</li><li>目标(target) 与依赖文件(就是目标文件)之间需以『:』隔开。</li></ul><p>示例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 1. 先编辑makefile 来建立新的规则，此规则的标的名称为clean ： </span><br>[root@study ~]<span class="hljs-comment"># vi makefile</span><br><span class="hljs-section">main: main.o haha.o sin_value.o cos_value.o</span><br>gcc -o main main.o haha.o sin_value.o cos_value.o -lm<br><span class="hljs-section">clean:</span><br>rm -f main main.o haha.o sin_value.o cos_value.o<br><br><span class="hljs-comment"># 2. 以新的目标(clean) 测试看看执行make 的结果： </span><br>[root@study ~]<span class="hljs-comment"># make clean   &lt;==就是这里！透过make 以clean 为标的</span><br>rm -rf main main.o haha.o sin_value.o cos_value.o<br></code></pre></td></tr></table></figure><p>如此一来，我们的makefile 里面就具有至少两个标的，分别是main 与clean，如果我们想要建立main 的话，输入『makemain』，如果想要清除有的没的，输入『make clean』即可。</p><p>使用变量：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile">[root@study ~]<span class="hljs-comment"># vi makefile </span><br>LIBS = -lm<br>OBJS = main.o haha.o sin_value.o cos_value.o<br><span class="hljs-section">main: $&#123;OBJS&#125;</span><br>        gcc -o main $&#123;OBJS&#125; $&#123;LIBS&#125;<br><span class="hljs-section">clean:</span><br>        rm -f main $&#123;OBJS&#125;<br></code></pre></td></tr></table></figure><p>与 bash shell 脚本的语法有点不同，变量的基本语法为：</p><ol type="1"><li>变量与变量内容以『=』隔开，同时两边可以具有空格；</li><li>变量左边不可以有&lt;tab&gt; ，例如上面范例的第一行LIBS左边不可以是&lt;tab&gt;；</li><li>变量与变量内容在『=』两边不能具有『:』；</li><li>在习惯上，变量最好是以『大写字母』为主；</li><li>运用变量时，以${变量} 或$(变量) 使用；</li><li>在该shell 的环境变量是可以被套用的，例如提到的CFLAGS 这个变数！</li><li>在命令行模式也可以设置变量。</li></ol><p>设置 <code>CFLAGS</code> 环境变量两种方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">方式 1</span><br>[root@study ~]# CFLAGS=&quot;-Wall&quot; make clean main <br><span class="hljs-meta prompt_"># </span><span class="language-bash">这个动作在上make 进行编译时，会去取用CFLAGS 的变数内容！</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">方式 2</span><br>[root@study ~]# vi makefile<br>LIBS = -lm<br>OBJS = main.o haha.o sin_value.o cos_value.o<br>CFLAGS = -Wall<br>main: $&#123;OBJS&#125;<br>gcc -o main $&#123;OBJS&#125; $&#123;LIBS&#125;<br>clean:<br>rm -f main $&#123;OBJS&#125;<br></code></pre></td></tr></table></figure><p>环境变量使用规则（优先级）：</p><ol type="1"><li>make 命令行后面加上的环境变量为优先；</li><li>makefile 里面指定的环境变量第二；</li><li>shell 原本具有的环境变量第三。</li></ol><p><code>$@</code>：代表目前的目标(target) ，故 makefile 也可写成</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile">[root@study ~]<span class="hljs-comment"># vi makefile</span><br>LIBS = -lm<br>OBJS = main.o haha.o sin_value.o cos_value.o<br>CFLAGS = -Wall<br><span class="hljs-section">main: $&#123;OBJS&#125;</span><br>gcc -o <span class="hljs-variable">$@</span> $&#123;OBJS&#125; $&#123;LIBS&#125;    &lt;==那个<span class="hljs-variable">$@</span> 就是main ！<br><span class="hljs-section">clean:</span><br>rm -f main $&#123;OBJS&#125;<br></code></pre></td></tr></table></figure><h2 id="软件安装-rpmsrpm-与-yum">22. 软件安装 RPM、SRPM 与 YUM</h2><h3 id="rpm-软件管理程序rpm">22.1 RPM 软件管理程序：rpm</h3><p>rpm 安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# rpm -ivh package_name<br>选项与参数：<br>-i ：install 的意思<br>-v ：察看更细部的安装资讯画面<br>-h ：以安装资讯列显示安装进度<br><br>范例一：安装原版光碟上的rp-pppoe 软体<br>[root@study ~]# rpm -ivh /mnt/Packages/rp-pppoe-3.11-5.el7.x86_64.rpm<br>Preparing... ################################# [100%]<br>Updating / installing...<br>   1:rp-pppoe-3.11-5.el7 ################################# [100%]<br><br>范例二、一口气安装两个以上的软体时： <br>[root@study ~]# rpm -ivh a.i386.rpm b.i386.rpm *.rpm <br><span class="hljs-meta prompt_"># </span><span class="language-bash">后面直接接上许多的软体档案！</span><br><br>范例三、直接由网路上面的某个档案安装，以网址来安装： <br>[root@study ~]# rpm -ivh http://website.name/path/pkgname.rpm<br></code></pre></td></tr></table></figure><p>强制安装选项：</p><table><thead><tr class="header"><th>可下达的选项</th><th>代表意义</th></tr></thead><tbody><tr class="odd"><td>--nodeps</td><td>使用时机：当发生软体属性相依问题而无法安装，但你执意安装时 危险性：软体会有相依性的原因是因为彼此会使用到对方的机制或功能，如果强制安装而不考虑软体的属性相依，则可能会造成该软体的无法正常使用！</td></tr><tr class="even"><td>--replacefiles</td><td>使用时机：如果在安装的过程当中出现了『某个档案已经被安装在你的系统上面』的资讯，又或许出现版本不合的讯息(confilctingfiles) 时，可以使用这个参数来直接覆盖档案。 危险性：覆盖的动作是无法复原的！所以，你必须要很清楚的知道被覆盖的档案是真的可以被覆盖喔！否则会欲哭无泪！</td></tr><tr class="odd"><td>--replacepkgs</td><td>使用时机： 重新安装某个已经安装过的软体！如果你要安装一堆RPM软体档案时，可以使用rpm -ivh *.rpm ，但若某些软体已经安装过了，此时系统会出现『某软体已安装』的资讯，导致无法继续安装。此时可使用这个选项来重复安装喔！</td></tr><tr class="even"><td>--force</td><td>使用时机：这个参数其实就是--replacefiles 与--replacepkgs的综合体！</td></tr><tr class="odd"><td>--test</td><td>使用时机： 想要测试一下该软体是否可以被安装到使用者的Linux环境当中，可找出是否有属性相依的问题。范例为： rpm -ivh pkgname.i386.rpm--test</td></tr><tr class="even"><td>--justdb</td><td>使用时机： 由于RPM资料库破损或者是某些缘故产生错误时，可使用这个选项来更新软体在资料库内的相关资讯。</td></tr><tr class="odd"><td>--nosignature</td><td>使用时机： 想要略过数位签章的检查时，可以使用这个选项。</td></tr><tr class="even"><td>--prefix 新路径</td><td>使用时机：要将软体安装到其他非正规目录时。举例来说，你想要将某软体安装到/usr/local而非正规的/bin, /etc 等目录， 就可以使用『 --prefix /usr/local』来处理了。</td></tr><tr class="odd"><td>--noscripts</td><td>使用时机：不想让该软体在安装过程中自行执行某些系统指令。 说明： RPM的优点除了可以将档案放置到定位之外，还可以自动执行一些前置作业的指令，例如资料库的初始化。如果你不想要让RPM帮你自动执行这一类型的指令，就加上他吧！</td></tr></tbody></table><p>rpm 升级与更新：</p><table><thead><tr class="header"><th>-Uvh</th><th>后面接的软体即使没有安装过，则系统将予以直接安装；若后面接的软体有安装过旧版，则系统自动更新至新版；</th></tr></thead><tbody><tr class="odd"><td>-Fvh</td><td>如果后面接的软体并未安装到你的Linux系统上，则该软体不会被安装；亦即只有已安装至你 Linux系统内的软体会被『升级』！</td></tr></tbody></table><p>rpm 查询：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# rpm -qa                               &lt;==已安装软体<br>[root@study ~]# rpm -q[licdR] 已安装的软体名称       &lt;==已安装软体<br>[root@study ~]# rpm -qf 存在于系统上面的某个档名     &lt;==已安装软体<br>[root@study ~]# rpm -qp[licdR] 未安装的某个档案名称  &lt;==查阅RPM档案<br>选项与参数：<br>查询已安装软体的资讯：<br>-q ：仅查询，后面接的软体名称是否有安装；<br>-qa ：列出所有的，已经安装在本机Linux 系统上面的所有软体名称；<br>-qi ：列出该软体的详细资讯(information)，包含开发商、版本与说明等；<br>-ql ：列出该软体所有的档案与目录所在完整档名(list)；<br>-qc ：列出该软体的所有设定档(找出在/etc/ 底下的档名而已)<br>-qd ：列出该软体的所有说明档(找出与man 有关的档案而已)<br>-qR ：列出与该软体有关的相依软体所含的档案(Required 的意思)<br>-qf ：由后面接的档案名称，找出该档案属于哪一个已安装的软体；<br>-q --scripts：列出是否含有安装后需要执行的脚本档，可用以debug 喔！<br>查询某个RPM 档案内含有的资讯：<br>-qp[icdlR]：注意-qp 后面接的所有参数以上面的说明一致。但用途仅在于找出<br>    某个RPM 档案内的资讯，而非已安装的软体资讯！注意！<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs shell">范例一：找出你的Linux 是否有安装logrotate 这个软体？<br>[root@study ~]# rpm -q logrotate<br>logrotate-3.8.6-4.el7.x86_64<br>[root@study ~]# rpm -q logrotating<br>package logrotating is not installed<br><span class="hljs-meta prompt_"># </span><span class="language-bash">注意到，系统会去找是否有安装后面接的软体名称。注意，不必要加上版本喔！</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">至于显示的结果，一看就知道有没有安装啦！</span><br><br>范例二：列出上题当中，属于该软体所提供的所有目录与档案： <br>[root@study ~]# rpm -ql logrotate<br>/etc/cron.daily/logrotate<br>/etc/logrotate.conf<br>....(以下省略).... <br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以看出该软体到底提供了多少的档案与目录，也可以追踪软体的资料。</span><br><br>范例三：列出logrotate 这个软体的相关说明资料： <br>[root@study ~]# rpm -qi logrotate <br>Name : logrotate                           # 软体名称<br>Version : 3.8.6                               # 软体的版本<br>Release : 4.el7                               # 释出的版本<br>Architecture: x86_64                              # 编译时所针对的硬体等级<br>Install Date: Mon 04 May 2015 05:52:36 PM CST     # 这个软体安装到本系统的时间<br>Group : System Environment/Base             # 软体是放再哪一个软体群组中<br>Size : 102451                              # 软体的大小<br>License : GPL+                                # 释出的授权方式<br>Signature : RSA/SHA256, Fri 04 Jul 2014 11:34:56 AM CST, Key ID 24c6a8a7f4a80eb5<br>Source RPM : logrotate-3.8.6-4.el7.src.rpm       # 这就是SRPM 的档名<br>Build Date : Tue 10 Jun 2014 05:58:02 AM CST     # 软体编译打包的时间<br>Build Host : worker1.bsys.centos.org             # 在哪一部主机上面编译的<br>Relocations : (not relocatable)   <br>Packager : CentOS BuildSystem &lt;http://bugs.centos.org&gt;<br>Vendor : CentOS<br>URL : https://fedorahosted.org/logrotate/<br>Summary : Rotates, compresses, removes and mails system log files<br>Description :                                     # 这个是详细的描述！<br>The logrotate utility is designed to simplify the administration of<br>log files on a system which generates a lot of log files. Logrotate<br>allows for the automatic rotation compression, removal and mailing of<br>log files. Logrotate can be set to handle a log file daily, weekly,<br>monthly or when the log file gets to a certain size. Normally,<br>logrotate runs as a daily cron job.<br><br>Install the logrotate package if you need a utility to deal with the<br>log files on your system.<br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出该软体的information (资讯)，里面的资讯可多著呢，包括了软体名称、</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">版本、开发商、SRPM档案名称、打包次数、简单说明资讯、软体打包者、</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装日期等等！如果想要详细的知道该软体的资料，用这个参数来了解一下</span><br><br>范例四：分别仅找出logrotate 的设定档与说明档<br>[root@study ~]# rpm -qc logrotate <br>[root@study ~]# rpm -qd logrotate<br><br>范例五：若要成功安装logrotate ，他还需要什么档案的帮忙？<br>[root@study ~]# rpm -qR logrotate<br>/bin/sh<br>config(logrotate) = 3.8.6-4.el7<br>coreutils &gt;= 5.92<br>....(以下省略)....<br><span class="hljs-meta prompt_"># </span><span class="language-bash">由这里看起来，呵呵～还需要很多档案的支援才行喔！</span><br><br>范例六：由上面的范例五，找出/bin/sh 是那个软体提供的？<br>[root@study ~]# rpm -qf /bin/sh<br>bash-4.2.46-12.el7.x86_64<br><span class="hljs-meta prompt_"># </span><span class="language-bash">这个参数后面接的可是『档案』呐！不像前面都是接软体喔！</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这个功能在查询系统的某个档案属于哪一个软体所有的。</span><br><br>范例七：假设我有下载一个RPM 档案，想要知道该档案的需求档案，该如何？<br>[root@study ~]# rpm -qpR filename.i386.rpm <br><span class="hljs-meta prompt_"># </span><span class="language-bash">加上-qpR ，找出该档案需求的资料！</span><br></code></pre></td></tr></table></figure><p>rpm 卸载与重建数据库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 找出与pam 有关的软体名称，并尝试移除pam 这个软体：</span> <br>[root@study ~]# rpm -qa | grep pam<br>fprintd-pam-0.5.0-4.0.el7_0.x86_64<br>pam-1.1.8-12.el7.x86_64<br>gnome-keyring-pam-3.8.2-10.el7.x86_64<br>pam-devel-1.1.8-12.el7.x86_64<br>pam_krb5-2.4.8-4.el7.x86_64<br>[root@study ~]# rpm -e pam <br>error: Failed dependencies:   &lt;==这里提到的是相依性的问题<br>        libpam.so.0()(64bit) is needed by (installed) systemd-libs-208-20.el7.x86_64<br>        libpam.so.0()(64bit) is needed by (installed) libpwquality-1.2.3-4.el7.x86_64<br>....(以下省略)....<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 若仅移除pam-devel 这个之前范例安装上的软体呢？</span><br>[root@study ~]# rpm -e pam-devel   &lt;==不会出现任何讯息！<br>[root@study ~]# rpm -q pam-devel<br>package pam-devel is not installed<br><br>[root@study ~]# rpm --rebuilddb    &lt;==重建数据库<br></code></pre></td></tr></table></figure><h3 id="yum-在线升级功能">22.2 YUM 在线升级功能</h3><p>查询：yum [list|info|search|provides|whatprovides] 参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# yum [option] [查询工作项目] [相关参数]<br>选项与参数：<br>[option]：主要的选项，包括有：<br>  -y ：当yum 要等待使用者输入时，这个选项可以自动提供yes 的回应；<br>  --installroot=/some/path ：将该软体安装在/some/path 而不使用预设路径<br>[查询工作项目] [相关参数]：这方面的参数有：<br>  search ：搜寻某个软体名称或者是描述(description) 的重要关键字；<br>  list ：列出目前yum 所管理的所有的软体名称与版本，有点类似rpm -qa；<br>  info ：同上，不过有点类似rpm -qai 的执行结果；<br>  provides：从档案去搜寻软体！类似rpm -qf 的功能！<br><br>范例一：搜寻磁碟阵列(raid) 相关的软体有哪些？<br>[root@study ~]# yum search raid <br>Loaded plugins: fastestmirror, langpacks       # yum 系统自己找出最近的yum server <br>Loading mirror speeds from cached hostfile     # 找出速度最快的那一部yum server <br> * base: ftp.twaren.net                        # 底下三个软体库，且来源为该伺服器！<br> * extras: ftp.twaren.net<br> * updates: ftp.twaren.net<br>....(前面省略)....<br>dmraid-events-logwatch.x86_64 : dmraid logwatch-based email reporting<br>dmraid-events.x86_64 : dmevent_tool (Device-mapper event tool) and DSO<br>iprutils.x86_64 : Utilities for the IBM Power Linux RAID adapters<br>mdadm.x86_64 : The mdadm program controls Linux md devices (software RAID arrays)<br>....(后面省略)....<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在冒号(:) 左边的是软体名称，右边的则是在RPM 内的name 设定(软体名)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">瞧！上面的结果，这不就是与RAID 有关的软体吗？如果想了解mdadm 的软体内容呢？</span><br><br>范例二：找出mdadm 这个软体的功能为何<br>[root@study ~]# yum info mdadm <br>Installed Packages        &lt;==这说明该软体是已经安装的了<br>Name : mdadm       &lt;==这个软体的名称<br>Arch : x86_64      &lt;==这个软体的编译架构<br>Version : 3.3.2       &lt;==此软体的版本<br>Release : 2.el7       &lt;==释出的版本<br>Size : 920 k       &lt;==此软体的档案总容量<br>Repo : installed   &lt;==软体库回报说已安装的<br>From repo : anaconda<br>Summary : The mdadm program controls Linux md devices (software RAID arrays)<br>URL : http://www.kernel.org/pub/linux/utils/raid/mdadm/<br>License : GPLv2+<br>Description : The mdadm program is used to create, manage, and monitor Linux MD (software<br>            : RAID) devices. As such, it provides similar functionality to the raidtools<br>            : package. However, mdadm is a single program, and it can perform<br>            : almost all functions without a configuration file, though a configuration<br>            : file can be used to help with some common tasks.<br><span class="hljs-meta prompt_"># </span><span class="language-bash">不要跟我说，上面说些啥？自己找字典翻一翻吧！拜托拜托！</span><br><br>范例三：列出yum 伺服器上面提供的所有软体名称<br>[root@study ~]# yum list <br>Installed Packages    &lt;==已安装软体<br>GConf2.x86_64 3.2.6-8.el7 @anaconda<br>LibRaw.x86_64 0.14.8-5.el7.20120830git98d925 @base<br>ModemManager.x86_64 1.1.0-6.git20130913.el7 @anaconda<br>....(中间省略).... <br>Available Packages    &lt;==还可以安装的其他软体<br>389-ds-base.x86_64 1.3.3.1-20.el7_1 updates<br>389-ds-base-devel.x86_64 1.3.3.1-20.el7_1 updates<br>389-ds-base-libs.x86_64 1.3.3.1-20.el7_1 updates<br>....(底下省略)....<br><span class="hljs-meta prompt_"># </span><span class="language-bash">上面提供的意义为：『 软体名称版本在那个软体库内』</span><br><br>范例四：列出目前伺服器上可供本机进行升级的软体有哪些？<br>[root@study ~]# yum list updates   &lt;==一定要是update s喔！<br>Updated Packages<br>NetworkManager.x86_64 1:1.0.0-16.git20150121.b4ea599c.el7_1 updates<br>NetworkManager-adsl.x86_64 1:1.0.0-16.git20150121.b4ea599c.el7_1 updates<br>....(底下省略)....<br><span class="hljs-meta prompt_"># </span><span class="language-bash">上面就列出在那个软体库内可以提供升级的软体与版本！</span><br><br>范例五：列出提供passwd 这个档案的软体有哪些<br>[root@study ~]# yum provides passwd<br>passwd-0.79-4.el7.x86_64 : An utility for setting or changing passwords using PAM<br>Repo : base<br><br>passwd-0.79-4.el7.x86_64 : An utility for setting or changing passwords using PAM<br>Repo : @anaconda<br><span class="hljs-meta prompt_"># </span><span class="language-bash">找到啦！就是上面的这个软体提供了passwd 这个程式！</span><br></code></pre></td></tr></table></figure><p>安装/升级：yum [install|update] 软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# yum [option] [安装与升级的工作项目] [相关参数]<br>选项与参数：<br>  install ：后面接要安装的软体！<br>  update ：后面接要升级的软体，若要整个系统都升级，就直接update 即可<br><br>范例一：将前一个练习找到的未安装的pam-devel 安装起来<br>[root@study ~]# yum install pam-devel <br>Loaded plugins: fastestmirror, langpacks     # 首先的5 行在找出最快的yum server<br>Loading mirror speeds from cached hostfile<br> * base: ftp.twaren.net<br> * extras: ftp.twaren.net<br> * updates: ftp.twaren.net<br>Resolving Dependencies                       # 接下来先处理『属性相依』的软体问题<br><span class="hljs-meta prompt_">--&gt; </span><span class="language-bash">Running transaction check</span><br><span class="hljs-meta prompt_">---&gt; </span><span class="language-bash">Package pam-devel.x86_64 0:1.1.8-12.el7_1.1 will be installed</span><br><span class="hljs-meta prompt_">--&gt; </span><span class="language-bash">Processing Dependency: pam(x86-64) = 1.1.8-12.el7_1.1 <span class="hljs-keyword">for</span> package: pam-devel-</span><br>       1.1.8-12.el7_1.1.x86_64<br><span class="hljs-meta prompt_">--&gt; </span><span class="language-bash">Running transaction check</span><br><span class="hljs-meta prompt_">---&gt; </span><span class="language-bash">Package pam.x86_64 0:1.1.8-12.el7 will be updated</span><br><span class="hljs-meta prompt_">---&gt; </span><span class="language-bash">Package pam.x86_64 0:1.1.8-12.el7_1.1 will be an update</span><br><span class="hljs-meta prompt_">--&gt; </span><span class="language-bash">Finished Dependency Resolution</span><br>Dependencies Resolved<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">由上面的检查发现到pam 这个软体也需要同步升级，这样才能够安装新版pam-devel 喔！</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">至于底下则是一个总结的表格显示！</span><br>==========================================================================================<br> Package Arch Version Repository Size<br>==========================================================================================<br>Installing:<br> pam-devel x86_64 1.1.8-12.el7_1.1 updates 183 k<br>Updating for dependencies:<br> pam x86_64 1.1.8-12.el7_1.1 updates 714 k<br><br>Transaction Summary<br>==========================================================================================<br>Install 1 Package                           # 要安装的是一个软体<br>Upgrade ( 1 Dependent package)   # 因为相依属性问题，需要额外加装一个软体！<br><br>Total size: 897 k<br>Total download size: 183 k                   # 总共需要下载的容量！<br>Is this ok [y/d/N]: y    # 你得要自己决定是否要下载与安装！当然是y 啊！<br>Downloading packages:                        # 开始下载啰！<br>warning: /var/cache/yum/x86_64/7/updates/packages/pam-devel-1.1.8-12.el7_1.1.x86_64.rpm:<br>         Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEY<br>Public key for pam-devel-1.1.8-12.el7_1.1.x86_64.rpm is not installed<br>pam-devel-1.1.8-12.el7_1.1.x86_64.rpm | 183 kB 00:00:00<br>Retrieving key from file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7<br>Importing GPG key 0xF4A80EB5:<br> Userid : &quot;CentOS-7 Key (CentOS 7 Official Signing Key) &lt;security@centos.org&gt;&quot;<br> Fingerprint: 6341 ab27 53d7 8a78 a7c2 7bb1 24c6 a8a7 f4a8 0eb5<br> Package : centos-release-7-1.1503.el7.centos.2.8.x86_64 (@anaconda)<br> From : /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7<br>Is this ok [y/N]: y   # 只有在第一次安装才会出现这个项目『确定要安装数位签章』才能继续！<br>Running transaction check<br>Running transaction test<br>Transaction test succeeded<br>Running transaction<br>Warning: RPMDB altered outside of yum.<br>  Updating : pam-1.1.8-12.el7_1.1.x86_64 1/3<br>  Installing : pam-devel-1.1.8-12.el7_1.1.x86_64 2/3<br>  Cleanup : pam-1.1.8-12.el7.x86_64 3/3<br>  Verifying : pam-1.1.8-12.el7_1.1.x86_64 1/3<br>  Verifying : pam-devel-1.1.8-12.el7_1.1.x86_64 2/3<br>  Verifying : pam-1.1.8-12.el7.x86_64 3/3<br><br>Installed:<br>  pam-devel.x86_64 0:1.1.8-12.el7_1.1<br><br>Dependency Updated:<br>  pam.x86_64 0:1.1.8-12.el7_1.1<br><br>Complete!<br></code></pre></td></tr></table></figure><p>删除：yum [remove] 软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@study ~]# yum remove pam-devel<br>Loaded plugins: fastestmirror, langpacks<br>Resolving Dependencies    &lt;==同样的，先解决属性相依的问题<br><span class="hljs-meta prompt_">--&gt; </span><span class="language-bash">Running transaction check</span><br><span class="hljs-meta prompt_">---&gt; </span><span class="language-bash">Package pam-devel.x86_64 0:1.1.8-12.el7_1.1 will be erased</span><br><span class="hljs-meta prompt_">--&gt; </span><span class="language-bash">Finished Dependency Resolution</span><br><br>Dependencies Resolved<br><br>==========================================================================================<br> Package Arch Version Repository Size<br>==========================================================================================<br>Removing:<br> pam-devel x86_64 1.1.8-12.el7_1.1 @updates 528 k<br><br>Transaction Summary<br>==========================================================================================<br>Remove 1 Package        # 还好！没有相依属性的问题，仅移除一个软体！<br><br>Installed size: 528 k<br>Is this ok [y/N]: y<br>Downloading packages:<br>Running transaction check<br>Running transaction test<br>Transaction test succeeded<br>Running transaction<br>  Erasing : pam-devel-1.1.8-12.el7_1.1.x86_64 1/1<br>  Verifying : pam-devel-1.1.8-12.el7_1.1.x86_64 1/1<br><br>Removed:<br>  pam-devel.x86_64 0:1.1.8-12.el7_1.1<br><br>Complete!<br></code></pre></td></tr></table></figure><h2 id="x-window-设置介绍">23. X Window 设置介绍</h2><p>略</p><h2 id="linux-内核编译与管理">24. Linux 内核编译与管理</h2><p>略</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>命令行</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux 命令行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一文读懂 C++ 运算符重载</title>
    <link href="/2023/02/19/%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82-C-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    <url>/2023/02/19/%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82-C-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<p>运算符重载是 C++语言的一个特性，利用运算符重载能够写出更加简洁的代码，对外封装类的实现细节。本文介绍运算符重载相关知识点。</p><p>谈到运算符重载，还需要从 “<strong>函数重载</strong>”说起。函数重载是指函数名相同，但函数参数类型、参数数量不同（返回类型相同）的函数。比如实现某种数据类型向string 类型运算的函数： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 函数重载示例</span><br><span class="hljs-function">string <span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-type">double</span> d)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-type">float</span> d)</span></span>;<br><span class="hljs-comment">// 等等</span><br></code></pre></td></tr></table></figure> 这就是典型的函数重载。</p><p>运算符重载本质上也是函数重载，它们可以看做函数名为<code>operator+</code>、<code>operator-</code>、<code>operator*</code>、<code>operator++</code>、<code>operator&lt;&lt;</code>等等的函数。重载即体现在函数名相同，但函数参数类型不同。当然，一些运算符也允许参数数量不同的重载，典型的就是函数调用运算符<code>operator()</code>的重载。</p><p>利用函数重载可以实现更好的封装，同时提高代码的简洁度。例如，我们要实现一个大整数类，用于支持高精度运算，如果没有运算符重载，我们只能按照如下方式实现：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BigNum</span>&#123;<br>    <span class="hljs-comment">// 相关数据成员声明</span><br>&#125;；<br><span class="hljs-function">BigNum <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">const</span> BigNum &amp;,<span class="hljs-type">const</span> BigNum &amp;)</span></span>;  <span class="hljs-comment">// 加法   </span><br><span class="hljs-function">BigNum <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-type">const</span> BigNum &amp;,<span class="hljs-type">const</span> BigNum &amp;)</span></span>;  <span class="hljs-comment">// 减法   </span><br><span class="hljs-function">BigNum <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-type">const</span> BigNum &amp;,<span class="hljs-type">const</span> BigNum &amp;)</span></span>;  <span class="hljs-comment">// 乘法   </span><br><span class="hljs-function">BigNum <span class="hljs-title">div</span><span class="hljs-params">(<span class="hljs-type">const</span> BigNum &amp;,<span class="hljs-type">const</span> BigNum &amp;)</span></span>;  <span class="hljs-comment">// 除法   </span><br><span class="hljs-function">BigNum <span class="hljs-title">mod</span><span class="hljs-params">(<span class="hljs-type">const</span> BigNum &amp;,<span class="hljs-type">const</span> BigNum &amp;)</span></span>;  <span class="hljs-comment">// 取模   </span><br></code></pre></td></tr></table></figure> 进行函数调用时，则是以下形式： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">BigNum n1, n2, n3;<br>n3 = <span class="hljs-built_in">add</span>(n1, n2);  <span class="hljs-comment">// 显式函数调用</span><br></code></pre></td></tr></table></figure>利用运算符重载，则实现方式如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BigNum</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 相关数据成员</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">friend</span> BigNum <span class="hljs-keyword">operator</span>+ (<span class="hljs-type">const</span> BigNum&amp;, <span class="hljs-type">const</span> BigNum &amp;);    <span class="hljs-comment">// 加法  </span><br>    <span class="hljs-keyword">friend</span> BigNum <span class="hljs-keyword">operator</span>- (<span class="hljs-type">const</span> BigNum&amp;, <span class="hljs-type">const</span> BigNum &amp;);    <span class="hljs-comment">// 减法  </span><br>    <span class="hljs-keyword">friend</span> BigNum <span class="hljs-keyword">operator</span>* (<span class="hljs-type">const</span> BigNum&amp;, <span class="hljs-type">const</span> BigNum &amp;);    <span class="hljs-comment">// 乘法  </span><br>    <span class="hljs-comment">// 略</span><br>&#125;;<br><span class="hljs-comment">// 进行加法运算</span><br>BigNum n1, n2, n3;<br>n3 = n1 + n2;  <span class="hljs-comment">// 直接使用 + 运算符即可，相当于调用 operator+ 函数</span><br></code></pre></td></tr></table></figure>由上面两种实现方式和调用方式，不难看出运算符重载的优点：封装与简洁（对使用者而言的简洁，对类的设计者而言工作量增加）。</p><p>知道了上面的基础知识，我们正式进入 C++运算符重载的主题，重点介绍运算符重载的语法特点和一些需要注意的问题。（下文以<em>TypeName</em> 代表自定义类型名，如上面的 <em>BigNum</em> ）</p><h2 id="重载输出运算符">1. 重载输出运算符 &lt;&lt;</h2><p>输入输出运算符的重载是为了更加方便的输入/输出数据。其语法规则如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 类内声明友元</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 相关成员定义 略</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt; (ostream &amp;, <span class="hljs-type">const</span> TypeName &amp;);    <br>&#125;;<br><span class="hljs-comment">// 类外定义函数</span><br>ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt; (ostream &amp;os, <span class="hljs-type">const</span> TypeName &amp;temp)<br>&#123;<br>    <span class="hljs-comment">// 具体实现 略</span><br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>注意点如下：</p><ol type="1"><li>形参 1 ：<strong>ostream &amp;类型</strong>，非 const 引用</li><li>形参 2 ：<strong>const 引用类型</strong>。const是因为输出运算符一般不应该改变对象的的状态；使用引用类型是处于性能与效率的考虑，减少调用时对象的拷贝，从而提高程序运行效率</li><li>返回类型： <strong>ostream 引用</strong>，这是为了能够连续输出</li><li>一般定义为友元</li></ol><h2 id="重载输入运算符">2. 重载输入运算符 &gt;&gt;</h2><p>输入运算符与输出运算符比较相似，其语法规则如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 类内声明友元与上面输出运算符类似 此处略</span><br><span class="hljs-comment">// 类外实现如下</span><br>istream &amp; <span class="hljs-keyword">operator</span>&gt;&gt; (istream &amp;is, TypeName &amp;temp) <br>&#123;<br>    <span class="hljs-comment">// 具体实现 略</span><br>    <span class="hljs-keyword">return</span> is;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>注意点如下：</p><ol type="1"><li>形参 1 ：<strong>istream &amp;类型</strong>, 同样是非 const引用类型</li><li>形参 2 ：<strong>非 const 引用</strong>，之所以是非 const是因为输入一般要改变对象内部状态；之所以是引用类型是因为要改变形参对象本身</li><li>返回类型：与输出运算符重载类型，返回引用，目的是能够连续输入</li><li>一般定义为友元</li></ol><h2 id="重载算术和关系运算符">3. 重载算术和关系运算符</h2><p>实际上，算术和关系运算符重载有两种实现方法，即重载是定义为成员函数还是定义为非成员函数（友元）。以加法为例说明如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 方法 1 ：非成员函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 类内声明</span><br>    <span class="hljs-keyword">friend</span> TypeName <span class="hljs-keyword">operator</span>+ (<span class="hljs-type">const</span> TypeName &amp;, <span class="hljs-type">const</span> TypeName &amp;);   <br>&#125;;<br><span class="hljs-comment">// 类外定义</span><br>TypeName <span class="hljs-keyword">operator</span>+ (<span class="hljs-type">const</span> TypeName &amp;lop, <span class="hljs-type">const</span> TypeName &amp;rop)<br>&#123;<br>    <span class="hljs-comment">// 略</span><br>&#125;<br><br><span class="hljs-comment">// 方法 2： 成员函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    TypeName <span class="hljs-keyword">operator</span>+ (<span class="hljs-type">const</span> TypeName &amp;rop)<br>    &#123;<br>        <span class="hljs-comment">// 略</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>一般情况下，这两种方式差别不大，但是当类含有一个接收普通类型的构造函数时，第一种实现方法更好，这是因为非成员函数允许对左侧或者右侧的运算对象进行类型转换（即调用构造函数由普通类型构造类的对象）；而成员函数方式只允许对右侧运算对象进行类型转换。按照《C++Primer 第五版》一书的说法，推荐以非成员函数方式实现。</p><h3 id="算术运算符">3.1 算术运算符</h3><p>我们以加法为例介绍算术运算符重载。语法规则如下：(实际上这段代码和上面方法1 代码相同) <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 类内声明</span><br>    <span class="hljs-keyword">friend</span> TypeName <span class="hljs-keyword">operator</span>+ (<span class="hljs-type">const</span> TypeName &amp;, <span class="hljs-type">const</span> TypeName &amp;);   <br>&#125;;<br><span class="hljs-comment">// 类外定义</span><br>TypeName <span class="hljs-keyword">operator</span>+ (<span class="hljs-type">const</span> TypeName &amp;lop, <span class="hljs-type">const</span> TypeName &amp;rop)<br>&#123;<br>    <span class="hljs-comment">// 略</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p>注意点如下：</p><ol type="1"><li>参数类型：两个形参都为 <strong>const &amp;类型</strong>,这是因为算术运算符不改变运算对象本身；同时引用减少拷贝提高效率</li><li>返回值类型：返回一个经算术运算后生成的临时对象</li></ol><h3 id="关系运算符">3.2 关系运算符</h3><p>关系运算符很多，包括：<code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code>共6 种。它们的实现方式同样推荐方法 1，即以非成员函数方式实现。它们的参数类型都是 <strong>const引用类型</strong> ，返回值都是 <strong>bool 类型</strong>。</p><p>这 6种关系运算符实际上存在逻辑上的转换关系，因此在实际编程中，往往采用如下方式实现这些运算符重载：</p><ul><li>首先实现 <code>==</code> 运算符</li><li>利用 <code>==</code> 实现 <code>!=</code> 运算符，即<code>a != b</code> 相当于 <code>!(a == b)</code></li><li>实现 <code>&lt;</code> 运算符</li><li>实现 <code>&gt;</code> 运算符</li><li>利用 <code>&lt;</code> 和 <code>==</code> 实现 <code>&lt;=</code>运算符，即 <code>a &lt;= b</code> 相当于<code>(a &lt; b || a == b)</code> (当然，也可以用<code>!(a &gt; b)</code> 实现)</li><li>利用 <code>&gt;</code> 和 <code>==</code> 实现 <code>&gt;=</code>运算符，即 <code>a &gt;= b</code> 相当于<code>(a &gt; b || a == b)</code> (当然，也可以用<code>!(a &lt; b)</code> 实现)</li></ul><p>实际上，除了上述实现方式也有其他方法，如 <code>a == b</code> 相当于<code>!( (a&gt;b) || (a&lt;b) )</code>，其他运算符也有另外实现方式，只须符合逻辑规则即可，这里不赘述。</p><p>下面以 <code>==</code> 为例给出语法规则： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 类内声明</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>== (<span class="hljs-type">const</span> TypeName &amp;, <span class="hljs-type">const</span> TypeName &amp;);   <br>&#125;;<br><span class="hljs-comment">// 类外定义</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>== (<span class="hljs-type">const</span> TypeName &amp;lop, <span class="hljs-type">const</span> TypeName &amp;rop)<br>&#123;<br>    <span class="hljs-comment">// 略</span><br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="重载赋值运算符">4. 重载赋值运算符</h2><p>赋值运算符分为两种，一为普通的赋值运算符<code>=</code>；二为复合赋值运算符，如<code>+=</code>、<code>-=</code>等。其中，普通赋值运算符又分为拷贝赋值和移动赋值，它们实际上更应该归类与类的拷贝控制。公众号此前写过文章介绍类的拷贝控制，其中包括拷贝赋值和移动赋值运算符介绍：<ahref="https://mp.weixin.qq.com/s/Q80xH9ZlLbgXCpXTmrNUYQ">《浅谈 C++类的拷贝控制》</a>。普通赋值运算符的重载必须为类的成员函数。此外，赋值运算符的也可以重载其它参数类型，如C++ 标准库提供的初始化列表类型<code>initializer_list&lt;TypeName&gt;</code>，不过其不是本文重点，相关资料请自行查阅。</p><p>下面重点介绍复合赋值运算符的重载。复合赋值运算符不是必须定义为类的成员，但是绝大多数情况下，最好定义为类的成员函数。其语法规则如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">TypeName &amp; <span class="hljs-keyword">operator</span>+= (<span class="hljs-type">const</span> TypeName &amp;rop)<br>&#123;<br>    <span class="hljs-comment">// 具体实现 略</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>注意点如下：</p><ol type="1"><li>形参类型：<strong>const 引用类型</strong></li><li>返回值类型：<strong>引用类型</strong>，这是为了与 C++内置与普通数据成员的复合赋值运算符保持一致的特性，即返回引用类型，在代码中体现为<code>return *this</code></li><li>所有复合赋值运算符都应该定义在类内部，作为成员函数</li></ol><h2 id="重载下标运算符">5. 重载下标运算符 [ ]</h2><p>下标运算符必须是成员函数。其语法规则如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 不完全正确版本</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 略</span><br><span class="hljs-keyword">public</span>:<br>    ReturnType &amp; <span class="hljs-keyword">operator</span>[] (<span class="hljs-type">int</span> i)<br>    &#123;<br>        <span class="hljs-comment">// 略</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 代码中<code>ReturnType</code> 代表返回类型，一般取决于类内部数据成员类型。以C++ 提供的 <code>vector</code> 为例，<code>vector&lt;T&gt;</code>类型的下标运算符返回类型为<code>T &amp;</code>。这样我们就可以通过下标运算符修改数据成员。</p><p>注意点如下：</p><ol type="1"><li>参数类型：一般为整型，代表下标</li><li>返回值类型：一般返回<strong>引用类型</strong></li><li>对于 const 类型数据，其下标运算符应该返回 <strong>const引用类型</strong>。因此，在类中应该定义下标运算符的 const 和非 const两个版本重载函数，代码如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 正确版本</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 略</span><br><span class="hljs-keyword">public</span>:<br>    ReturnType &amp; <span class="hljs-keyword">operator</span>[] (<span class="hljs-type">int</span> i)  <span class="hljs-comment">// 非 const  </span><br>    &#123;<br>        <span class="hljs-comment">// 略</span><br>    &#125;<br>    <span class="hljs-comment">// const 类型重载</span><br>    <span class="hljs-type">const</span> ReturnType &amp; <span class="hljs-keyword">operator</span>[] (<span class="hljs-type">int</span> i) <span class="hljs-type">const</span>  <br>    &#123;<br>        <span class="hljs-comment">// 略</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="重载递增和递减运算符---">6. 重载递增和递减运算符 ++ --</h2><p>递增递减运算符分前置和后置两个版本，它们一般应该定义为类的成员。前置与后置版本二者差别较大，下面以<code>++</code> 运算符为例分别介绍。</p><h3 id="前置版本递增递减运算符">6.1 前置版本递增/递减运算符</h3><p>前置版本递增运算符重载语法规则如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    TypeName &amp; <span class="hljs-keyword">operator</span>++ ()<br>    &#123;<br>        <span class="hljs-comment">// 具体实现</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><p>注意点如下：</p><ol type="1"><li>无参函数</li><li>返回值类型：<strong>引用类型</strong>，代码中<code>return *this</code> 体现</li></ol><h3 id="后置版本递增递减运算符">6.2 后置版本递增/递减运算符</h3><p>后置版本递增运算符重载语法规则如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    TypeName <span class="hljs-keyword">operator</span>++ (<span class="hljs-type">int</span>)<br>    &#123;<br>        <span class="hljs-comment">// 具体实现</span><br>        <span class="hljs-keyword">return</span> 自增前的对象;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><p>注意点如下：</p><ol type="1"><li>参数类型： <code>int</code> ，不过，这个 <code>int</code>放在函数形参列表只是为了区分前置与后置， <code>int</code>形参在函数内部不需要用到，因此也不必给出标识符</li><li>返回值类型：<strong>普通类型</strong>，返回递增/递减前保存的临时对象</li><li><strong>后置版本一般利用前置版本实现</strong>，示例代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    TypeName &amp; <span class="hljs-keyword">operator</span>++ ()<br>    &#123;<br>        <span class="hljs-comment">// 具体实现</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <br>    TypeName <span class="hljs-keyword">operator</span>++ (<span class="hljs-type">int</span>)<br>    &#123;<br>        TypeName temp = *<span class="hljs-keyword">this</span>;<br>        ++*<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 调用前置版本++</span><br>        <span class="hljs-keyword">return</span> temp;  <span class="hljs-comment">// 返回递增前保存的临时对象</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h2 id="重载成员访问运算符--">7. 重载成员访问运算符 -&gt; *</h2><p>成员访问运算符包括两个：对于指针的 <code>-&gt;</code> 以及对于对象的<code>*</code> 。<code>-&gt;</code> 必须是类的成员；<code>*</code>通常是类的成员，但并非必须如此。它们的重载函数通常定义为 const的，语法规则如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ReturnType1 <span class="hljs-keyword">operator</span>* () <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-comment">// 具体实现</span><br>        <span class="hljs-comment">// 可返回任意类型</span><br>    &#125;<br>    <br>    ReturnType2 <span class="hljs-keyword">operator</span>-&gt; () <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-comment">// 具体实现</span><br>        <span class="hljs-comment">// 必须返回类的指针或者自定义了箭头运算符的某个类的对象  </span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>成员访问运算符重载一般用的比较少，这里仅做简要介绍。实际中需要用到时，可进一步参考相关资料，并根据类的需求和操作，定义合适的重载方法。</p><h2 id="重载函数调用运算符">8. 重载函数调用运算符 ( )</h2><p>函数调用运算符的重载相对比较特殊。理论上，我们可以重载任意多个函数调用运算符，只要保证这些重载之间不发生冲突即可。函数调用运算符必须是成员函数。定义了函数调用运算符的类的对象称为<strong>函数对象</strong>。举一个例子如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeName</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> a &gt; b;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure> 定义了上面的类后，我们可以显式地调用函数： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TypeName obj;<br><span class="hljs-type">bool</span> b = <span class="hljs-built_in">obj</span>(<span class="hljs-number">12</span>, <span class="hljs-number">15</span>);<br></code></pre></td></tr></table></figure>12 比 15 小，因此上述代码中 b 应该为 false。</p><p>不过，函数对象更为常用的是作为函数参数提供给标准库函数，典型的如 sort函数： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">22</span>,<span class="hljs-number">343</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-232</span>,<span class="hljs-number">-23423</span>&#125;;<br><span class="hljs-type">int</span> n = <span class="hljs-built_in">sizeof</span>(a)/<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>);<br><span class="hljs-built_in">sort</span>(a, a+n, <span class="hljs-built_in">TypeName</span>());<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n; ++i)<br>    cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span>;<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure> 将 <code>TypeName()</code>临时对象作为函数参数传递给 <code>sort</code>函数，就能够实现自定义规则排序。上面代码将数组降序排序，而<code>sort</code> 函数默认为升序排序。</p><p>值得一提的是，C++ 中提供的 lambda表达式，实际上都转换为类，这个类重载了函数调用运算符，参数类型即为lambda 表达式的参数类型。这样，调用 lambda表达式就转换为调用函数对象的函数调用运算符。</p><h2 id="重载类型转换运算符">9. 重载类型转换运算符</h2><p>类型转换运算符的重载更为特殊，是类的一种特殊成员函数，其语法规则如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">type</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 具体实现</span><br>&#125;<br></code></pre></td></tr></table></figure> 其中， <code>type</code> 表示目标转换类型。</p><p>类型转换运算符一般很少使用，在实际编程中也应该谨慎使用。若定义不当，可能产生错误或者意料之外的结果。一般而言，类定义向<code>bool</code> 类型的转换规则就足够了，而且该转换函数最好定义为<code>explicit</code> 的。</p><hr /><p>以上就是本文全部内容。不过这些并不是对运算符重载的全面介绍，想了解更深入详细的知识，仍需阅读相关书籍。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>运算符重载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Nginx(GitHub Pages) 与 Hexo 搭建个人博客</title>
    <link href="/2023/02/18/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/02/18/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>本文介绍使用 Nginx（或者 GitHub Pages） 与 Hexo搭建个人博客的主要步骤。</p><p>在正文开始之前，先介绍上面提到的几个工具的功能：</p><ul><li><a href="https://nginx.org/en/">Nginx</a>：充当 Web服务器的角色，在个人博客中，其主要功能是在公网服务器上提供 HTTP 或 HTTPS服务，让用户能够访问你的博客网站。</li><li><a href="https://pages.github.com/">GitHubPages</a>：在没有个人公网服务器时，使用 GitHub Pages同样可以达到搭建个人博客的目的。具体而言，GitHub Pages 就是一个特殊的GitHub 仓库，你可以在这个仓库内放一些 HTML、CSS 和 JS文件等，从而搭建个人网站。</li><li><a href="https://hexo.io/zh-cn/">Hexo</a>：Hexo是一个静态博客框架，使用它可以搭建博客网站，让用户专注于博客内容，而不需要熟悉CSS 和 Javascript等前端内容。使用官方以及许多开源作者提供的主题，即可快速的构建美观的网页，而博客内容使用Markdown 编写即可。</li></ul><p>下面，介绍具体步骤。</p><h2 id="本地安装-node.js">1. 本地安装 Node.js</h2><p>Node.js 官网为：https://nodejs.org/en/download/，打开链接，根据本地环境，选择合适的安装文件下载。Windows 平台与 Mac平台选择二进制 installer 文件，安装时只需要点下一步即可。</p><p>Linux 平台安装稍微复杂些，推荐以下两种安装方式，可任选其一：</p><ul><li>源代码编译安装，无需配置 bash，但是编译耗时，<ahref="https://cloud.tencent.com/developer/article/1938607">参考</a></li><li>二进制文件下载安装，需要配置 bash 环境，<ahref="https://cloud.tencent.com/developer/article/1772306">参考</a></li></ul><p>安装完成后，在命令行输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm -v<br>$ node -v<br></code></pre></td></tr></table></figure><p>若都有输出，说明安装成功。</p><h2 id="本地安装-hexo-并初始化博客环境">2. 本地安装 Hexo并初始化博客环境</h2><p>Hexo 安装命令参考<ahref="https://hexo.io/zh-cn/">官网</a>即可，具体如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install hexo-cli -g<br>$ hexo init blog<br>$ <span class="hljs-built_in">cd</span> blog<br>$ npm install<br>$ hexo server<br></code></pre></td></tr></table></figure><p>关于 Hexo 的更多信息，可参考官方文档：<ahref="https://hexo.io/zh-cn/docs/">文档 | Hexo</a> 。</p><p>为了让你的博客网站更加符合你的审美，可以选择一个合适的主题 <ahref="https://hexo.io/themes/">Themes | Hexo</a> 。本博客网站使用的是Fluid，其 GitHub 仓库地址为：<ahref="https://github.com/fluid-dev/hexo-theme-fluid">fluid-dev/hexo-theme-fluid:一款 Material Design 风格的 Hexo 主题 / An elegant Material-Design themefor Hexo (github.com)</a> ，官方文档地址为：<ahref="https://hexo.fluid-dev.com/docs/guide/">配置指南 | Hexo Fluid用户手册 (fluid-dev.com)</a>。</p><p>仔细阅读 Hexo 官方文档与你选择的主题的官方文档，根据自己的喜好配置好yml 文件，搭建个人博客的路途就走完了一半。</p><p>下面，我们要解决的问题是：如何让互联网上的广大用户能够访问你的博客网站？</p><p>3、4 小节提供了两种方式，可根据自己的具体情况选择。</p><h2 id="建立-github-pages-仓库">3. 建立 GitHub Pages 仓库</h2><p>首先，在 GitHub上建立一个仓库。这个仓库的命名有点讲究，举例说明如下：</p><p>我的 GitHub 个人主页地址为：https://github.com/UnpureRationalist，其中，<code>UnpureRationalist</code> 表示我的用户名。</p><p>打开 GitHub 并选择创建仓库选项，将仓库命名为<code>用户名.github.io</code>，比如我的仓库命名则是：<code>UnpureRationalist.github.io</code>，并设置仓库为公开可见。</p><p>然后，在该仓库上传一个名为 <code>index.html</code>的文件，参考文件内容如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Example<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello World.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在浏览器输入链接 <code>用户名.github.io</code>，如我的博客地址为：<code>UnpureRationalist.github.io</code>，然后，浏览器即可显示 <code>index.html</code>文件的内容（可能需要等待一会）。</p><p>利用此仓库，我们就可以让其他用户访问自己的博客网站。</p><h2 id="服务器安装-nginx">4. 服务器安装 Nginx</h2><p>对于拥有个人云服务器的用户来说，可以直接在个人服务器上安装 Nginx服务，将个人博客搭建在自己的服务器上。</p><p>首先，我们需要在服务器上安装 Nginx，这里以 Ubuntu系统为例，步骤如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo apt update<br>$ sudo apt install nginx<br>$ sudo systemectl <span class="hljs-built_in">enable</span> nginx<span class="hljs-comment"># 设置 nginx 开机启动</span><br>$ sudo systemctl start nginx<span class="hljs-comment"># 启动 nginx 服务</span><br></code></pre></td></tr></table></figure><p>注意，为了让 Nginx 正常工作，需要在服务器的安全组设置中开放 80 or/and443 端口，以让 HTTP or/and HTTPS服务正常工作，具体参考自己使用的服务器提供商。</p><p>如果要使用 HTTPS 服务，则需要对 Nginx进行一定的配置，具体参考链接：https://cloud.tencent.com/document/product/400/35244。</p><h2 id="配置-hexo-实现自动部署">5. 配置 Hexo 实现自动部署</h2><p>经过上面的步骤，我们在本地有了一个存放个人博客的目录；在云端有了公网用户能够访问的目录。因此，我们只需要使用Git 或 scp 等工具，将 Hexo 生成的 public 目录下的所有文件和文件夹上传到GitHub 仓库或者服务器 Web服务根目录下即可。但是，手动进行这些操作有些麻烦，我们可以使用 Hexo提供的功能实现一条命令部署。详情参考链接：<ahref="https://hexo.io/zh-cn/docs/one-command-deployment">部署 | Hexo</a>。</p><p>具体而言，就是在 <code>_config.yml</code>配置文件中进行适当的配置，然后运行如下命令即可将个人博客部署到云端：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo deploy<br></code></pre></td></tr></table></figure><p>不过，在本人实际使用过程中，发现一键部署功能不太好用，GitHub Pages有时由于网络原因无法部署成功；部署到云服务器上则会报错。因此，本人使用Hexo 提供的功能部署到 GitHub Pages；对于服务器，则使用朴实无华的<code>scp</code>命令进行手动同步。如果读者有更好的自动部署方式，欢迎交流讨论。</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/02/18/hello-world/"/>
    <url>/2023/02/18/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h2 id="测试公式">测试公式</h2><p><span class="math display">\[E=mc^2\]</span></p><p><span class="math display">\[\sigma(z_i) = \frac{e^{z_{i}}}{\sum_{j=1}^K e^{z_{j}}} \ \ \ for\i=1,2,\dots,K\]</span></p><p><span class="math display">\[L_{\delta}=    \left\{\begin{matrix}        \frac{1}{2}(y - \hat{y})^{2} &amp; if \left | (y -\hat{y})  \right | &lt; \delta\\        \delta ((y - \hat{y}) - \frac1 2 \delta) &amp; otherwise    \end{matrix}\right.\]</span></p><p><span class="math display">\[\epsilon \sim \mathcal{N}(0, \textbf{I})\]</span></p><p><span class="math display">\[\vec{z} \sim \mathcal{N}(\vec{\mu}, \sigma^2 \textbf{I})\]</span></p><p><span class="math display">\[\sum_{i=1}^{D}|x_i-y_i|\]</span></p><p><span class="math display">\[Accuracy = \frac{TP+TN}{TP+TN+FP+FN}\]</span></p><p><span class="math display">\[Precision = \frac{TP}{TP+FP}\]</span></p><p><span class="math display">\[Recall = \frac{TP}{TP+FN}\]</span></p><p><span class="math display">\[F1 = \frac{2*Precision*Recall}{Precision+Recall} =\frac{2*TP}{2*TP+FP+FN}\]</span></p><h2 id="测试代码">测试代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> net<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> face_alignment <span class="hljs-keyword">import</span> align<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><br>adaface_models = &#123;<br>    <span class="hljs-string">&#x27;ir_50&#x27;</span>:<span class="hljs-string">&quot;pretrained/adaface_ir50_ms1mv2.ckpt&quot;</span>,<br>&#125;<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_pretrained_model</span>(<span class="hljs-params">architecture=<span class="hljs-string">&#x27;ir_50&#x27;</span></span>):<br>    <span class="hljs-comment"># load model and pretrained statedict</span><br>    <span class="hljs-keyword">assert</span> architecture <span class="hljs-keyword">in</span> adaface_models.keys()<br>    model = net.build_model(architecture)<br>    statedict = torch.load(adaface_models[architecture])[<span class="hljs-string">&#x27;state_dict&#x27;</span>]<br>    model_statedict = &#123;key[<span class="hljs-number">6</span>:]:val <span class="hljs-keyword">for</span> key, val <span class="hljs-keyword">in</span> statedict.items() <span class="hljs-keyword">if</span> key.startswith(<span class="hljs-string">&#x27;model.&#x27;</span>)&#125;<br>    model.load_state_dict(model_statedict)<br>    model.<span class="hljs-built_in">eval</span>()<br>    <span class="hljs-keyword">return</span> model<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">to_input</span>(<span class="hljs-params">pil_rgb_image</span>):<br>    np_img = np.array(pil_rgb_image)<br>    brg_img = ((np_img[:,:,::-<span class="hljs-number">1</span>] / <span class="hljs-number">255.</span>) - <span class="hljs-number">0.5</span>) / <span class="hljs-number">0.5</span><br>    tensor = torch.tensor([brg_img.transpose(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)]).<span class="hljs-built_in">float</span>()<br>    <span class="hljs-keyword">return</span> tensor<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br><br>    model = load_pretrained_model(<span class="hljs-string">&#x27;ir_50&#x27;</span>)<br>    feature, norm = model(torch.randn(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">112</span>,<span class="hljs-number">112</span>))<br><br>    test_image_path = <span class="hljs-string">&#x27;face_alignment/test_images&#x27;</span><br>    features = []<br>    <span class="hljs-keyword">for</span> fname <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(os.listdir(test_image_path)):<br>        path = os.path.join(test_image_path, fname)<br>        aligned_rgb_img = align.get_aligned_face(path)<br>        bgr_tensor_input = to_input(aligned_rgb_img)<br>        feature, _ = model(bgr_tensor_input)<br>        features.append(feature)<br><br>    similarity_scores = torch.cat(features) @ torch.cat(features).T<br>    <span class="hljs-built_in">print</span>(similarity_scores)<br>    <br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span><br>&#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode *left;<br>    TreeNode *right;<br>    <span class="hljs-built_in">TreeNode</span>() : <span class="hljs-built_in">val</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x, TreeNode *left, TreeNode *right) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(left), <span class="hljs-built_in">right</span>(right) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode *root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;TreeNode *&gt; s;<br>        TreeNode *p = root;<br>        <span class="hljs-keyword">while</span> (p || !s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span> (p)<br>            &#123;<br>                s.<span class="hljs-built_in">push</span>(p);<br>                p = p-&gt;left;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                TreeNode *temp = s.<span class="hljs-built_in">top</span>();<br>                s.<span class="hljs-built_in">pop</span>();<br>                res.<span class="hljs-built_in">push_back</span>(temp-&gt;val);<br>                p = temp-&gt;right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode *root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;TreeNode *&gt; s;<br>        TreeNode *p = root;<br>        <span class="hljs-keyword">while</span> (p || !s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">while</span> (p)<br>            &#123;<br>                s.<span class="hljs-built_in">push</span>(p);<br>                p = p-&gt;left;<br>            &#125;<br>            TreeNode *temp = s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            res.<span class="hljs-built_in">push_back</span>(temp-&gt;val);<br>            p = temp-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
